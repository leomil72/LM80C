# file opened: LM80C_64K-firmware-r1.04.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C 64K - FIRMWARE - R1.04
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.0
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; set name for binary output file
  55  0000                  OUTPUT "LM80C-64K-firmware-r1.04.bin"
  56  0000
  57  0000              ; set computer model
  58  0000                  DEFINE LM80C64K
  59  0000
  60  0000              ; set firmware version
  61  0000                  DEFINE VERSION "1.04"
  62  0000
  63  0000              ; define shorter VDP_DAT load instruction
  64  0000                  DEFINE LD_VDP_DAT dec     C
  65  0000
  66  0000              ; ------------------------------------------------------------------------------
  67  0000              ; include the latest version of the bootloader: this sets up the address aliases
  68  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  69  0000                  INCLUDE "../include/bootloader/bootloader-1.05.asm"
# file opened: ../include/bootloader/bootloader-1.05.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.04
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000                  IFDEF LM8064K
  54+ 0000 ~            VDP_SET         equ %00110001
  55+ 0000                  ELSE
  56+ 0000              VDP_SET         equ %00110010
  57+ 0000                  ENDIF
  58+ 0000
  59+ 0000              ; label defining for PSG (Programmable Sound Generator)
  60+ 0000              PSG_REG         equ %01000000
  61+ 0000              PSG_DAT         equ %01000001
  62+ 0000
  63+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  64+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  65+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  66+ 0000              SER_BUFSIZE     equ     $58
  67+ 0000              SER_FULLSIZE    equ     $50
  68+ 0000              SER_EMPTYSIZE   equ     $05
  69+ 0000
  70+ 0000
  71+ 0000              ;------------------------------------------------------------------------------
  72+ 0000              ;                                F I R M W A R E
  73+ 0000              ;------------------------------------------------------------------------------
  74+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  75+ 0000                              org     $0000
  76+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  77+ 0001                  IFDEF LM80C64K
  78+ 0001 C3 F0 50                     jp      ROM2RAM         ; jump to ROM/RAM switcher
  79+ 0004                  ELSE
  80+ 0004 ~                            jp      INIT_HW         ; jump to system initialization
  81+ 0004                  ENDIF
  82+ 0004
  83+ 0004              ;------------------------------------------------------------------------------
  84+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  85+ 0004                              ;$0004
  86+ 0004 64 01                        defw    RX_CHB_AVAIL
  87+ 0006
  88+ 0006              ;------------------------------------------------------------------------------
  89+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  90+ 0006                              ;$0006
  91+ 0006 67 01                        defw    SPEC_RXB_CNDT
  92+ 0008
  93+ 0008              ;------------------------------------------------------------------------------
  94+ 0008              ; send a character over serial ch. A
  95+ 0008                              ;$0008
  96+ 0008 C3 4D 02     RST08:          jp      TXA
  97+ 000B FF                           BLOCK   1,$FF   ; filler
  98+ 000C
  99+ 000C              ;------------------------------------------------------------------------------
 100+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
 101+ 000C                              ;$000C
 102+ 000C 00 01                        defw    RX_CHA_AVAIL
 103+ 000E
 104+ 000E              ;------------------------------------------------------------------------------
 105+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
 106+ 000E                              ;$000E
 107+ 000E 35 01                        defw    SPEC_RXA_CNDT
 108+ 0010
 109+ 0010              ;------------------------------------------------------------------------------
 110+ 0010              ; receive a character over serial ch. A
 111+ 0010                              ;$0010
 112+ 0010 C3 23 02     RST10:          jp      RXA
 113+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 114+ 0018              ;------------------------------------------------------------------------------
 115+ 0018              ; check serial status
 116+ 0018
 117+ 0018                              ;$0018
 118+ 0018 C3 7A 02     RST18:          jp      CKINCHAR
 119+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 120+ 0040              ;------------------------------------------------------------------------------
 121+ 0040              ; interrupt vectors for CTC
 122+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 123+ 0040 E0 52                        defw    CTC0IV
 124+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 125+ 0042 E3 52                        defw    CTC1IV
 126+ 0044                              ;$0044               ; for CH2 timer - unused
 127+ 0044 E6 52                        defw    CTC2IV
 128+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 129+ 0046 E9 52                        defw    CTC3IV
 130+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 131+ 0066              ;------------------------------------------------------------------------------
 132+ 0066              ; interrupt routine for NMI
 133+ 0066                              ;$0066
 134+ 0066 C3 80 51                     jp      NMIUSR              ; jump to execute NMI service routine
 135+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 136+ 0090              ;------------------------------------------------------------------------------
 137+ 0090
 138+ 0090                              ;$0090
 139+ 0090                  IFDEF LM80C
 140+ 0090 ~                            defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
 141+ 0090 ~                            defb    $4C,$4F,$52,$00,$00,$00,$00,$00
 142+ 0090                  ELSE
 143+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 143+ 0094 43 20 36 34
 144+ 0098 4B 20 43 4F                  defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 144+ 009C 4C 4F 52 00
 145+ 00A0                  ENDIF
 146+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 146+ 00A4 55 54 45 52
 147+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$30,$29,$00
 147+ 00AC 32 30 29 00
 148+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 148+ 00B4 67 6E 65 64
 149+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 149+ 00BC 00 00 00 00
 150+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 150+ 00C4 61 72 64 6F
 151+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 151+ 00CC 69 61 6E 69
 152+ 00D0 46 57 20 31  FWVER:          defm    "FW ","1.04",$20,"2021-01-05",$20,"18:23:20",$00
 152+ 00D4 2E 30 34 20
 152+ 00D8 32 30 32 31
 152+ 00DC 2D 30 31 2D
 152+ 00E0 30 35 20 31
 152+ 00E4 38 3A 32 33
 152+ 00E8 3A 32 30 00
 153+ 00EC              FMVEREND:       equ     $
 154+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 155+ 0100              ;------------------------------------------------------------------------------
 156+ 0100
 157+ 0100              ;-------------------------------------------------------------------------------
 158+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 159+ 0100              ;-------------------------------------------------------------------------------
 160+ 0100
 161+ 0100              ;-------------------------------------------------------------------------------
 162+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 163+ 0100              ; this is the only channel that can print received chars onto the screen
 164+ 0100                              ;$0100
 165+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 166+ 0101 E5                           push    HL              ; and HL
 167+ 0102 CD 8E 01                     call    A_RTS_OFF       ; disable RTS line
 168+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 169+ 0107 32 39 53                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 170+ 010A CD F4 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 171+ 010D D2 30 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 172+ 0110 3A 39 53                     ld      A,(TMPKEYBFR)   ; retrieve char
 173+ 0113 32 FA 52                     ld      (CHR4VID),A     ; write into buffer for video printing
 174+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 175+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 176+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 177+ 011D DA 30 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 178+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 179+ 0121 AF                           xor     A
 180+ 0122 32 37 53                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 181+ 0125 3A F7 52                     ld      A,(CRSR_STATE)  ; check cursor state
 182+ 0128 B7                           or      A               ; is it on?
 183+ 0129 C4 4E 07                     call    NZ,CHAR2VID     ; yes, print on screen
 184+ 012C F1                           pop     AF              ; retrieve char
 185+ 012D CD 4D 02                     call    TXA             ; send back to serial
 186+ 0130 E1           LVRXCHA:        pop     HL              ; retrieve HL
 187+ 0131 F1                           pop     AF              ; and A
 188+ 0132 FB                           ei                      ; re-enable interrupts
 189+ 0133 ED 4D                        reti                    ; and exit
 190+ 0135
 191+ 0135              ;-------------------------------------------------------------------------------
 192+ 0135              ; special SIO ch.A condition (i.e., buffer overrun)
 193+ 0135              ; if buffer overruns then show an error, empty the RX buffer and send
 194+ 0135              ; a break char
 195+ 0135 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 196+ 0136 CD 8E 01                     call    A_RTS_OFF       ; disable RTS
 197+ 0139 CD C2 01                     call    SIO_A_DI        ; disable RX on ch. A
 198+ 013C 3A 3F 53                     ld      A,(SERIALS_EN)  ; load serial status
 199+ 013F CB 97                        res     2,A             ; disable RX on port 1
 200+ 0141 32 3F 53                     ld      (SERIALS_EN),A  ; store new serial status
 201+ 0144 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 202+ 0146 CB E7                        set     4,A             ; set 5th pin ON
 203+ 0148 D3 01                        out     (PIO_DB),A      ; send new setting
 204+ 014A 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 205+ 014C D3 22                        out     (SIO_CA),A      ; send command to SIO
 206+ 014E AF           EMPTYCHABFR:    xor     A
 207+ 014F D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 208+ 0151 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 209+ 0153 E6 01                        and     $01             ; check if input buffer if empty
 210+ 0155 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 211+ 0158 DB 20                        in      A,(SIO_DA)      ; read chars
 212+ 015A 18 F2                        jr      EMPTYCHABFR     ; repeat
 213+ 015C F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 214+ 015D 21 FE 3C                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 215+ 0160 E3                           ex      (SP),HL         ; store onto stack
 216+ 0161 FB                           ei                      ; re-enable interrupts
 217+ 0162 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 218+ 0164
 219+ 0164              ;-------------------------------------------------------------------------------
 220+ 0164              ;               Z80 SIO CH. A MANAGEMENT
 221+ 0164              ;-------------------------------------------------------------------------------
 222+ 0164
 223+ 0164              ;-------------------------------------------------------------------------------
 224+ 0164              ; interrupt driven routine to get chars from Z80 SIO ch.B
 225+ 0164 FB           RX_CHB_AVAIL:   ei
 226+ 0165 ED 4D                        reti
 227+ 0167
 228+ 0167              ;-------------------------------------------------------------------------------
 229+ 0167              ; special SIO ch.A condition (i.e., buffer overrun)
 230+ 0167              ; if buffer overruns then show an error, empty the RX buffer and send
 231+ 0167              ; a break char
 232+ 0167 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 233+ 0168 CD 96 01                     call    B_RTS_OFF       ; disable RTS
 234+ 016B CD CA 01                     call    SIO_B_DI        ; disable RX on ch.B
 235+ 016E 3A 3F 53                     ld      A,(SERIALS_EN)  ; load serial status
 236+ 0171 CB 9F                        res     3,A             ; disable RX on port 2
 237+ 0173 32 3F 53                     ld      (SERIALS_EN),A  ; store new serial status
 238+ 0176 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 239+ 0178 CB EF                        set     5,A             ; set 5th pin ON
 240+ 017A D3 01                        out     (PIO_DB),A      ; send new setting
 241+ 017C 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 242+ 017E D3 23                        out     (SIO_CB),A      ; send command to SIO
 243+ 0180 AF           EMPTYCHBBFR:    xor     A
 244+ 0181 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 245+ 0183 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 246+ 0185 E6 01                        and     $01             ; check if input buffer if empty
 247+ 0187 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 248+ 018A DB 21                        in      A,(SIO_DB)      ; read chars
 249+ 018C 18 F2                        jr      EMPTYCHBBFR     ; repeat
 250+ 018E
 251+ 018E
 252+ 018E              ;-------------------------------------------------------------------------------
 253+ 018E              ;               Z80 SIO MANAGEMENT
 254+ 018E              ;-------------------------------------------------------------------------------
 255+ 018E              ; disable RTS:
 256+ 018E              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 257+ 018E C5           A_RTS_OFF:      push    BC              ; store BC
 258+ 018F 0E 22                        ld      C,SIO_CA        ; select channel A
 259+ 0191 3A 40 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 260+ 0194 18 06                        jr      SIO_RTS_OFF
 261+ 0196 C5           B_RTS_OFF:      push    BC              ; store BC
 262+ 0197 0E 23                        ld      C,SIO_CB        ; select channel B
 263+ 0199 3A 41 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 264+ 019C 47           SIO_RTS_OFF:    ld      B,A             ; store data bits
 265+ 019D 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 266+ 019F ED 79                        out     (C),A
 267+ 01A1 78                           ld      A,B             ; retrieve data bits
 268+ 01A2 F6 28                        or      %00101000       ; TX enable; RTS disable
 269+ 01A4 ED 79                        out     (C),A           ; send setting
 270+ 01A6 C1                           pop     BC              ; retrieve BC
 271+ 01A7 C9                           ret                     ; exit
 272+ 01A8
 273+ 01A8              ;-------------------------------------------------------------------------------
 274+ 01A8              ; enable RTS
 275+ 01A8              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 276+ 01A8 C5           A_RTS_ON:       push    BC              ; store BC
 277+ 01A9 0E 22                        ld      C,SIO_CA        ; select channel A
 278+ 01AB 3A 40 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 279+ 01AE 18 06                        jr      SIO_RTS_ON
 280+ 01B0 C5           B_RTS_ON:       push    BC              ; store BC
 281+ 01B1 0E 23                        ld      C,SIO_CB        ; select channel B
 282+ 01B3 3A 41 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 283+ 01B6 47           SIO_RTS_ON:     ld      B,A             ; store data bits
 284+ 01B7 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 285+ 01B9 ED 79                        out     (C),A
 286+ 01BB 78                           ld      A,B             ; retrieve data bits
 287+ 01BC F6 2A                        or      %00101010       ; TX enable; RTS enable
 288+ 01BE ED 79                        out     (C),A           ; send setting
 289+ 01C0 C1                           pop     BC              ; retrieve BC
 290+ 01C1 C9                           ret                     ; return
 291+ 01C2
 292+ 01C2              ;-------------------------------------------------------------------------------
 293+ 01C2              ; disable SIO RX channel
 294+ 01C2 C5           SIO_A_DI:       push    BC              ; store BC
 295+ 01C3 0E 22                        ld      C,SIO_CA        ; SIO channel A
 296+ 01C5 3A 40 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 297+ 01C8 18 06                        jr      SIO_RXDI        ; jump to disable RX
 298+ 01CA C5           SIO_B_DI:       push    BC              ; store BC
 299+ 01CB 0E 23                        ld      C,SIO_CB        ; SIO channel B
 300+ 01CD 3A 41 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 301+ 01D0 47           SIO_RXDI:       ld      B,A             ; store data bits
 302+ 01D1 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 303+ 01D3 ED 79                        out     (C),A
 304+ 01D5 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 305+ 01D6 ED 79                        out     (C),A
 306+ 01D8 C1                           pop     BC              ; retrieve BC
 307+ 01D9 C9                           ret                     ; return
 308+ 01DA
 309+ 01DA              ;-------------------------------------------------------------------------------
 310+ 01DA              ; enable SIO RX channel
 311+ 01DA C5           SIO_A_EI:       push    BC              ; store BC
 312+ 01DB 0E 22                        ld      C,SIO_CA
 313+ 01DD 3A 40 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 314+ 01E0 18 06                        jr      SIO_RXEN
 315+ 01E2 C5           SIO_B_EI:       push    BC              ; store BC
 316+ 01E3 0E 23                        ld      C,SIO_CB
 317+ 01E5 3A 41 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 318+ 01E8 47           SIO_RXEN:       ld      B,A             ; store data bits
 319+ 01E9 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 320+ 01EB ED 79                        out     (C),A           ; select register
 321+ 01ED 78                           ld      A,B             ; retrieve data bits
 322+ 01EE CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 323+ 01F0 ED 79                        out     (C),A           ; send settings to SIO
 324+ 01F2 C1                           pop     BC              ; retrieve BC
 325+ 01F3 C9                           ret
 326+ 01F4
 327+ 01F4              ;------------------------------------------------------------------------------
 328+ 01F4              ; put a char into the input buffer, char is into A
 329+ 01F4              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 330+ 01F4              ; the RETURN key is pressed on the keyboard
 331+ 01F4 F5           CHARINTOBFR:    push    AF              ; store it
 332+ 01F5 3A 7B 51                     ld      A,(serBufUsed)  ; load buffer size
 333+ 01F8 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 334+ 01FA DA FF 01                     jp      C,NOTFULL       ; then store the char
 335+ 01FD F1                           pop     AF              ; else drop it
 336+ 01FE C9                           ret                     ; and exit
 337+ 01FF 2A 77 51     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 338+ 0202 23                           inc     HL              ; load pointer to find first free cell
 339+ 0203 7D                           ld      A,L             ; only check low byte because buffer<256
 340+ 0204 FE 77                        cp      bufWrap         ; check if the pointer is at the last cell
 341+ 0206 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 342+ 0208 21 1F 51                     ld      HL,SERBUF_START ; else load the address of the first cell
 343+ 020B 22 77 51     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 344+ 020E F1                           pop     AF              ; then recover the char
 345+ 020F 77                           ld      (HL),A          ; and store it in the appropriate cell
 346+ 0210 3A 7B 51                     ld      A,(serBufUsed)  ; load the size of the input buffer
 347+ 0213 3C                           inc     A               ; increment it
 348+ 0214 32 7B 51                     ld      (serBufUsed),A  ; and store the new size
 349+ 0217 FE 50                        cp      SER_FULLSIZE    ; check if input buffer is full
 350+ 0219 D8                           ret     C               ; exit if buffer is not full
 351+ 021A 3A 3F 53                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 352+ 021D 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 353+ 021E DC 8E 01                     call    C,A_RTS_OFF     ; ...stop receiving further chars
 354+ 0221 AF                           xor     A               ; clear Carry to set a buffer full condition
 355+ 0222 C9                           ret
 356+ 0223
 357+ 0223
 358+ 0223              ;-------------------------------------------------------------------------------
 359+ 0223              ; retrieve a char from the input buffer
 360+ 0223 3A 7B 51     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 361+ 0226 A7                           and     A               ; check if it's 0 (empty)
 362+ 0227 CA 23 02                     jp      Z,RXA           ; if it's empty, wait for a char
 363+ 022A F3                           di                      ; disable interrupts
 364+ 022B E5                           push    HL              ; store HL
 365+ 022C 2A 79 51                     ld      HL,(serRdPtr)   ; load pointer to first available char
 366+ 022F 23                           inc     HL              ; increment it (go to the next char)
 367+ 0230 7D                           ld      A,L             ; check if the end of the buffer has been reached
 368+ 0231 FE 77                        cp      bufWrap         ; (only check low byte because buffer<256)
 369+ 0233 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 370+ 0235 21 1F 51                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 371+ 0238 22 79 51     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 372+ 023B 3A 7B 51                     ld      A,(serBufUsed)  ; load buffer size
 373+ 023E 3D                           dec     A               ; decrement it
 374+ 023F 32 7B 51                     ld      (serBufUsed),A  ; and store the new size
 375+ 0242 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 376+ 0244 30 03                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 377+ 0246 CD A8 01                     call    A_RTS_ON        ; else re-enable receiving chars
 378+ 0249 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 379+ 024A E1                           pop     HL              ; retrieve HL
 380+ 024B FB                           ei                      ; re-enable interrupts
 381+ 024C C9                           ret                     ; return
 382+ 024D
 383+ 024D              ;------------------------------------------------------------------------------
 384+ 024D              ; sends a char over the serial (trick for INTs from WikiTI)
 385+ 024D              ; char is into A
 386+ 024D F5           TXA:            push    AF              ; store AF
 387+ 024E C5                           push    BC              ; store BC
 388+ 024F 47                           ld      B,A             ; store char
 389+ 0250 ED 57                        ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
 390+ 0252 EA 57 02                     jp      PE,CNTTXA       ; if set, jump over
 391+ 0255 ED 57                        ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
 392+ 0257 F5           CNTTXA:         push    AF              ; store current P/V flag
 393+ 0258 F3                           di                      ; disable INTs
 394+ 0259 3A 3F 53                     ld      A,(SERIALS_EN)  ; load serial status
 395+ 025C FE 05                        cp      %00000101       ; check if serial 1 is open and RX/TX is enabled
 396+ 025E 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 397+ 0260 78                           ld      A,B             ; retrieve char
 398+ 0261 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 399+ 0263 CD 6E 02                     call    TX_EMP          ; wait for outgoing char to be sent
 400+ 0266 F1           TXA_EXIT:       pop     AF              ; retrieve P/V flag
 401+ 0267 E2 6B 02                     jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
 402+ 026A FB                           ei                      ; INTs were enabled, so re-enable interrupts
 403+ 026B C1           EXTXA:          pop     BC              ; retrieve BC
 404+ 026C F1                           pop     AF              ; retrieve AF
 405+ 026D C9                           ret                     ; return
 406+ 026E
 407+ 026E              ;------------------------------------------------------------------------------
 408+ 026E              ; wait until outgoing serial has been sent
 409+ 026E 97           TX_EMP:         sub     A               ; set A to 0
 410+ 026F 3C                           inc     A               ; set A to 1
 411+ 0270 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 412+ 0272 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 413+ 0274 CB 47                        bit     0,A             ; check if all chars have been sent
 414+ 0276 CA 6E 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 415+ 0279 C9                           ret                     ; else exit
 416+ 027A
 417+ 027A
 418+ 027A              ;------------------------------------------------------------------------------
 419+ 027A              ; check if there is some chars into the buffer
 420+ 027A 3A 7B 51     CKINCHAR:       ld      A,(serBufUsed)  ; load char in buffer
 421+ 027D A7                           and     A               ; compare to 0
 422+ 027E C9                           ret                     ; return
 423+ 027F
 424+ 027F              ;------------------------------------------------------------------------------
 425+ 027F              ; print a text from memory, and terminate when $00 is found
 426+ 027F 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 427+ 0280 B7                           or      A               ; is it $00 (end string)?
 428+ 0281 C8                           ret     Z               ; Yes, then return
 429+ 0282 32 FA 52                     ld      (CHR4VID),A     ; store char
 430+ 0285 F3                           di
 431+ 0286 CD 4E 07                     call    CHAR2VID        ; and send it to screen
 432+ 0289 FB                           ei
 433+ 028A 23                           inc     HL              ; and select the next one
 434+ 028B 18 F2                        jr      RAWPRINT        ; repeat
 435+ 028D
 436+ 028D              ;-------------------------------------------------
 437+ 028D              ; Interrupt service routine (ISR) for CH3 timer
 438+ 028D              ; this is used to increment the 100ths of a second counter and for cursor flashing
 439+ 028D F5           CH3_TIMER:      push    AF              ; save regs. A,
 440+ 028E C5                           push    BC              ; BC,
 441+ 028F D5                           push    DE              ; DE,
 442+ 0290 E5                           push    HL              ; HL
 443+ 0291 21 DC 52                     ld      HL,TMRCNT       ; load starting address of the timer
 444+ 0294 06 04                        ld      B,$04           ; 4 bytes to check
 445+ 0296 34           INCTMR3:        inc     (HL)            ; increment timer
 446+ 0297 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 447+ 0299 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 448+ 029A 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 449+ 029C CD B8 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 450+ 029F CD DF 0C                     call    MNGSNDS         ; call the tone managemenet
 451+ 02A2 3A DC 52                     ld      A,(TMRCNT)      ; check for keyboard management
 452+ 02A5 1F                           rra                     ; bit 0 = 1 ?
 453+ 02A6 D4 44 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 454+ 02A9 E1                           pop     HL              ; retrieve HL,
 455+ 02AA D1                           pop     DE              ; DE,
 456+ 02AB C1                           pop     BC              ; BC,
 457+ 02AC F1                           pop     AF              ; and A
 458+ 02AD FB                           ei                      ; re-enable interrupts
 459+ 02AE ED 4D                        reti                    ; exit from ISR
 460+ 02B0
 461+ 02B0              ;------------------------------------------------------------------------------
 462+ 02B0              ;               HARDWARE INITIALISATION
 463+ 02B0              ;------------------------------------------------------------------------------
 464+ 02B0              ; first run - setup HW & SW
 465+ 02B0              ; (on LN80C 64K runs from RAM)
 466+ 02B0 21 AE 52     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 467+ 02B3 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 468+ 02B4 21 1F 51                     ld      HL,SERBUF_START ; set beginning of input buffer
 469+ 02B7 22 77 51                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 470+ 02BA 22 79 51                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 471+ 02BD AF                           xor     A               ; reset A
 472+ 02BE 32 7B 51                     ld      (serBufUsed),A  ; actual buffer size is 0
 473+ 02C1 32 3F 53                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 474+ 02C4                  IFDEF LM80C
 475+ 02C4 ~                            call    HELLOWRLD       ; little serial blink with LEDs
 476+ 02C4                  ENDIF
 477+ 02C4 CD 42 03                     call    initCTC         ; configure CTC, then...
 478+ 02C7 CD 7D 0C                     call    initPSG         ; ...configure PSG
 479+ 02CA CD F4 04                     call    SHOW_LOGO       ; show computer logo
 480+ 02CD 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 481+ 02CF CD D3 03                     call    initVDP         ; set video display
 482+ 02D2 AF                           xor     A
 483+ 02D3 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 484+ 02D5 ED 5E                        im      2               ; interrupt mode 2
 485+ 02D7 FB                           ei                      ; enable interrupts
 486+ 02D8                              ; print system messages
 487+ 02D8 AF                           xor     A               ; A=0 so...
 488+ 02D9 32 37 53                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 489+ 02DC 3C                           inc     A               ; A=1...
 490+ 02DD 32 F9 52                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 491+ 02E0 21 78 03                     ld      HL,MSGTXT1      ; sign-on message
 492+ 02E3 CD 7F 02                     call    RAWPRINT        ; print message
 493+ 02E6 3A 7C 51                     ld      A,(basicStarted); check if BASIC is already started
 494+ 02E9 FE 59                        cp      'Y'             ; to see if this is a power-up
 495+ 02EB 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 496+ 02ED 21 B6 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 497+ 02F0 CD 7F 02                     call    RAWPRINT        ; print message
 498+ 02F3 CD 1A 09                     call    CURSOR_ON       ; enable cursor
 499+ 02F6 AF                           xor     A
 500+ 02F7 32 F9 52                     ld      (PRNTVIDEO),A   ; disable print-on-video
 501+ 02FA CD 23 02     CORW:           call    RXA             ; look for a pressed key
 502+ 02FD E6 DF                        and     %11011111       ; only UPPERCASE char
 503+ 02FF FE 43                        cp      'C'             ; cold start?
 504+ 0301 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 505+ 0303 CD 1E 03                     call    ECHO_CHAR       ; echoes the char
 506+ 0306 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 507+ 0308 32 7C 51                     ld      (basicStarted),A
 508+ 030B CD 2F 09                     call    CURSOR_OFF      ; disable cursor
 509+ 030E C3 E3 11                     jp      COLD            ; start BASIC COLD
 510+ 0311 FE 57        CHECKWARM:      cp      'W'
 511+ 0313 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 512+ 0315 CD 1E 03                     call    ECHO_CHAR       ; echoes the char
 513+ 0318 CD 2F 09                     call    CURSOR_OFF      ; disable cursor
 514+ 031B C3 E6 11                     jp      WARM            ; start BASIC WARM
 515+ 031E
 516+ 031E              ;-------------------------------------------------------------------------------
 517+ 031E              ; send back char received through ch. A
 518+ 031E 32 FA 52     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 519+ 0321 AF                           xor     A
 520+ 0322 32 37 53                     ld      (KBDNPT),A      ; input is not from keyboard
 521+ 0325 F3                           di                      ; disable INTs
 522+ 0326 CD 4E 07                     call    CHAR2VID        ; echoes back the pressed key,
 523+ 0329 3E 0D                        ld      A,CR            ; then set a CR
 524+ 032B 32 FA 52                     ld      (CHR4VID),A     ; set char for video printing
 525+ 032E CD 4E 07                     call    CHAR2VID        ; and send it to screen
 526+ 0331 FB                           ei                      ; re-enable INTs
 527+ 0332 3E 01                        ld      A,$01
 528+ 0334 32 F9 52                     ld      (PRNTVIDEO),A   ; re-enable video printing
 529+ 0337 C9                           ret                     ; return to caller
 530+ 0338
 531+ 0338                  IFDEF LM80C
 532+ 0338 ~            ;-------------------------------------------------------------------------------
 533+ 0338 ~            ; little serial blink with LEDs
 534+ 0338 ~            HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
 535+ 0338 ~                            ld      A,%11001111     ; set mode 3 (mode control)
 536+ 0338 ~                            out     (PIO_CB),A      ; for PIO port B
 537+ 0338 ~                            xor     A               ; set pins to OUTPUT
 538+ 0338 ~                            out     (PIO_CB),A      ; for port B
 539+ 0338 ~                            inc     A               ; LSB on
 540+ 0338 ~            LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
 541+ 0338 ~                            ld      E,$20           ; little delay
 542+ 0338 ~            DEC_E:          ld      B,$00           ; count to 256
 543+ 0338 ~            COUNTER:        djnz    COUNTER         ; decrement inner counter
 544+ 0338 ~                            dec     E               ; decrement outer counter
 545+ 0338 ~                            jr      NZ,DEC_E        ; finish delay
 546+ 0338 ~                            sla     A               ; shift reg.A to left 1 bit
 547+ 0338 ~                            dec     C               ; next LED
 548+ 0338 ~                            jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
 549+ 0338 ~                            ret                     ; return to caller
 550+ 0338                  ENDIF
 551+ 0338              ;-------------------------------------------------------------------------------
 552+ 0338              ; Z80 SIO default settings for serial channels
 553+ 0338 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 554+ 0339 18                           defb    %00011000       ; write into WR0: channel reset
 555+ 033A 04                           defb    %00000100       ; write into WR0: select WR4
 556+ 033B 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 557+ 033C 05                           defb    %00000101       ; write into WR0: select WR5
 558+ 033D E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 559+ 033E 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 560+ 033F 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 561+ 0340 02                           defb    %00000010       ; write into WR0: select WR2
 562+ 0341 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 563+ 0342                                                      ; will be affected by the channel & condition that raised the interrupt
 564+ 0342                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 565+ 0342                                                      ; for special conditions
 566+ 0342              ;------------------------------------------------------------------------------
 567+ 0342              ;               Z80 CTC SETTING UP
 568+ 0342              ;------------------------------------------------------------------------------
 569+ 0342              initCTC:
 570+ 0342 21 6C 03                     ld      HL,CTCCONF      ; CTC configuration
 571+ 0345 11 E0 52                     ld      DE,CTC0IV       ; CTC interrupt vector table
 572+ 0348 01 0C 00                     ld      BC,$000C        ; 12 bytes
 573+ 034B ED B0                        ldir                    ; copy data
 574+ 034D              ;CH0, CH1, & CH2 disabled
 575+ 034D 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 576+ 034F                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 577+ 034F D3 10                        out     (CTC_CH0),A     ; set CH0
 578+ 0351 D3 11                        out     (CTC_CH1),A     ; set CH1
 579+ 0353 D3 12                        out     (CTC_CH2),A     ; set CH2
 580+ 0355              ;init CH3
 581+ 0355              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 582+ 0355              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 583+ 0355 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 584+ 0357                                                      ; time constant follows; cont. operation; command word
 585+ 0357 D3 13                        out     (CTC_CH3),A     ; send to CH3
 586+ 0359 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 587+ 035B D3 13                        out     (CTC_CH3),A     ; send to CH3
 588+ 035D 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 589+ 035F                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 590+ 035F                                                      ; so int vector is 01000xx00
 591+ 035F D3 10                        out     (CTC_CH0),A     ; send to CTC
 592+ 0361                              ; reset cells of 100ths of a second counter
 593+ 0361 AF                           xor     A               ; reset A
 594+ 0362 21 DC 52                     ld      HL,TMRCNT       ; load TMR pointer
 595+ 0365 06 04                        ld      B,$04           ; 4 memory cells
 596+ 0367 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 597+ 0368 23                           inc     HL              ; next cell
 598+ 0369 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 599+ 036B C9                           ret
 600+ 036C
 601+ 036C
 602+ 036C              ;------------------------------------------------------------------------------
 603+ 036C              ; jump table for CHx interrupts
 604+ 036C FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 605+ 036F FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 606+ 0372 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 607+ 0375 C3 8D 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 608+ 0378
 609+ 0378
 610+ 0378              ;------------------------------------------------------------------------------
 611+ 0378              ; welcome messages
 612+ 0378              MSGTXT1:
 613+ 0378                  IFDEF LM80C64K
 614+ 0378 20 20 20 20                  defm    "    LM80C 64K Color Computer",CR
 614+ 037C 4C 4D 38 30
 614+ 0380 43 20 36 34
 614+ 0384 4B 20 43 6F
 614+ 0388 6C 6F 72 20
 614+ 038C 43 6F 6D 70
 614+ 0390 75 74 65 72
 614+ 0394 0D
 615+ 0395                  ELSE
 616+ 0395 ~                            defm    "      LM80C Color Computer",CR
 617+ 0395                  ENDIF
 618+ 0395 20 62 79 20                  defm    " by Leonardo Miliani * FW R","1.04",CR,0
 618+ 0399 4C 65 6F 6E
 618+ 039D 61 72 64 6F
 618+ 03A1 20 4D 69 6C
 618+ 03A5 69 61 6E 69
 618+ 03A9 20 2A 20 46
 618+ 03AD 57 20 52 31
 618+ 03B1 2E 30 34 0D
 618+ 03B5 00
 619+ 03B6 0D           MSGTXT2:        defb    CR
 620+ 03B7 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 620+ 03BB 43 3E 6F 6C
 620+ 03BF 64 20 6F 72
 620+ 03C3 20 3C 57 3E
 620+ 03C7 61 72 6D 20
 620+ 03CB 73 74 61 72
 620+ 03CF 74 3F 20 00
 621+ 03D3
# file closed: ../include/bootloader/bootloader-1.05.asm
  70  03D3
  71  03D3              ; incude the latest version of the VDP module
  72  03D3                  INCLUDE "../include/vdp/vdp-1.3.asm"
# file opened: ../include/vdp/vdp-1.3.asm
   1+ 03D3              ; ------------------------------------------------------------------------------
   2+ 03D3              ; LM80C - VDP ROUTINES - 1.3
   3+ 03D3              ; ------------------------------------------------------------------------------
   4+ 03D3              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03D3              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03D3              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03D3              ; kind of warranty: you can use them at your own risk.
   8+ 03D3              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03D3              ; maintain the copyright notices, include this advice and the note to the
  10+ 03D3              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03D3              ; redistribuite them.
  12+ 03D3              ; https://www.leonardomiliani.com
  13+ 03D3              ;
  14+ 03D3              ; Please support me by visiting the following links:
  15+ 03D3              ; Main project page: https://www.leonardomiliani.com
  16+ 03D3              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03D3              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03D3              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03D3              ; ------------------------------------------------------------------------------
  20+ 03D3              ;
  21+ 03D3              ;------------------------------------------------------------------------------
  22+ 03D3              ; VDP INITIALISATION
  23+ 03D3              ; initialize VDP for a specific graphics mode
  24+ 03D3              ; INPUT: E -> contains the graphics mode:
  25+ 03D3              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03D3 D5           initVDP:        push    DE              ; store E
  27+ 03D4 CD BB 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03D7 CD D9 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03DA CD CE 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03DD D1                           pop     DE              ; restore reg. E
  31+ 03DE AF                           xor     A               ; reset A
  32+ 03DF 47                           ld      B,A             ; reset B (will be used later)
  33+ 03E0 7B                           ld      A,E             ; move E into A
  34+ 03E1 32 EE 52                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03E4 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 03E6 CA 22 04                     jp      Z,G1MD          ; yes, jump over
  37+ 03E9 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 03EB CA 62 04                     jp      Z,G2MD          ; yes, jump over
  39+ 03EE FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 03F0 CA 84 04                     jp      Z,MCMD          ; yes, jump over
  41+ 03F3 FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 03F5 CA A7 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 03F8                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 03F8
  45+ 03F8              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 03F8
  47+ 03F8                              ; TEXT MODE (G0)
  48+ 03F8                              ; load charset
  49+ 03F8 60           TXTMD:          ld      H,B
  50+ 03F9 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 03FA CD F5 0A                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 03FD                              ; set cursor & video overlay
  53+ 03FD AF                           xor     A               ; reset A
  54+ 03FE 32 F2 52                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 0401 32 F3 52                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 0404 3E 05                        ld      A,$05           ; light blue
  57+ 0406 32 FC 52                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0409 3E 28                        ld      A,$28
  59+ 040B 32 EC 52                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 040E 3E 18                        ld      A,$18
  61+ 0410 32 ED 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 0413 3E 1E                        ld      A,$1E
  63+ 0415 32 C2 51                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0418 11 00 08                     ld      DE,$0800
  65+ 041B ED 53 F0 52                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 041F C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 0422
  68+ 0422                              ; GRAPHICS 1 MODE (G1)
  69+ 0422                              ; load pattern table
  70+ 0422 68           G1MD:           ld      L,B
  71+ 0423 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 0424 CD F5 0A                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0427                              ; set cursor & video overlay
  74+ 0427 AF                           xor     A               ; position cursor
  75+ 0428 32 F2 52                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 042B 32 F3 52                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 042E 3E 20                        ld      A,$20
  78+ 0430 32 EC 52                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 0433 3E 18                        ld      A,$18
  80+ 0435 32 ED 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0438 3E 14                        ld      A,$14
  82+ 043A 32 C2 51                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 043D 11 00 18                     ld      DE,$1800
  84+ 0440 ED 53 F0 52                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 0444                              ; load color table
  86+ 0444 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0447 CD 5D 06                     call    SETVDPADRS
  88+ 044A 3E 01                        ld      A,$01           ; foreground color...
  89+ 044C 32 FB 52                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 044F 3E 0F                        ld      A,$0F           ; background color...
  91+ 0451 32 FC 52                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 0454 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0456 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0458 0D                           dec     C              ; VDP data mode
  95+ 0459 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 045B 00                           nop
  97+ 045C 00                           nop
  98+ 045D 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 045F C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 0462
 101+ 0462                              ; GRAPHICS 2 MODE (G2)
 102+ 0462 AF           G2MD:           xor     A               ; position cursor
 103+ 0463 32 F2 52                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0466 32 F3 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0469 32 EC 52                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 046C 3C                           inc     A               ; black on...
 107+ 046D 32 FB 52                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 0470 3E 0F                        ld      A,$0F           ; white on...
 109+ 0472 32 FC 52                     ld      (BKGNDCLR),A    ; ...background
 110+ 0475 3E C0                        ld      A,$C0
 111+ 0477 32 ED 52                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 047A 11 00 18                     ld      DE,$1800
 113+ 047D ED 53 F0 52                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 0481 C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 0484
 116+ 0484                              ; MULTICOLOR MODE (G3)
 117+ 0484 AF           MCMD:           xor     A               ; position cursor
 118+ 0485 32 F2 52                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 0488 32 F3 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 048B 3E 0F                        ld      A,$0F           ; white color for...
 121+ 048D 32 FC 52                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 0490 32 FB 52                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 0493 3E 40                        ld      A,$40
 124+ 0495 32 EC 52                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 0498 3E 30                        ld      A,$30
 126+ 049A 32 ED 52                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 049D 11 00 08                     ld      DE,$0800
 128+ 04A0 ED 53 F0 52                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04A4 C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04A7
 131+ 04A7                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04A7              EXG2MD:         ; load pattern table
 133+ 04A7 60                           ld      H,B
 134+ 04A8 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04A9 CD F5 0A                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04AC                              ; set cursor & video overlay
 137+ 04AC AF                           xor     A               ; position cursor
 138+ 04AD 32 F2 52                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04B0 32 F3 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04B3 3E 20                        ld      A,$20
 141+ 04B5 32 EC 52                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04B8 3E 18                        ld      A,$18
 143+ 04BA 32 ED 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04BD 3E 14                        ld      A,$14
 145+ 04BF 32 C2 51                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04C2 11 00 38                     ld      DE,$3800
 147+ 04C5 ED 53 F0 52                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04C9                               ; load color table
 149+ 04C9 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04CC CD 5D 06                     call    SETVDPADRS
 151+ 04CF 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04D1 32 FB 52                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04D4 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04D6 32 FC 52                     ld      (BKGNDCLR),A    ; ...background
 155+ 04D9 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04DB 16 08                        ld      D,$08           ; 8 pages of
 157+ 04DD 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04DF 0D                           dec     C              ; VDP data mode
 159+ 04E0 ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 04E2 00                           nop
 161+ 04E3 00                           nop
 162+ 04E4 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 04E6 15                           dec     D               ; did we fill up all the cells?
 164+ 04E7 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 04E9                              ; LAST VDP SETTINGS
 166+ 04E9 CD 2F 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 04EC CD CE 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 04EF AF                           xor     A
 169+ 04F0 32 F6 52                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 04F3 C9                           ret                     ; return to caller
 171+ 04F4
 172+ 04F4
 173+ 04F4              ; show initial logo
 174+ 04F4 CD BB 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 04F7                              ; set VDP for G2 mode
 176+ 04F7 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 04F9 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 04FC CD E1 0A                     call    SET_GFX_MODE2   ; load register settings
 179+ 04FF 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 0501 ED 51                        out     (C),D           ; send data to VDP
 181+ 0503 ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0505                              ; set name table
 183+ 0505 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0508 CD 4B 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 050B CD 6E 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 050E                              ; set colors for logo
 187+ 050E 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 0511 CD 5D 06                     call    SETVDPADRS
 189+ 0514 06 05                        ld      B,$05           ; 5 bands
 190+ 0516 21 B9 05                     ld      HL,CLRTABLE
 191+ 0519 0D                           dec     C              ; set VDP_DAT
 192+ 051A 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 051C 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 051E 7E                           ld      A,(HL)          ; load data
 195+ 051F ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 0521 00                           nop                     ; little delay
 197+ 0522 1D                           dec     E               ; decrement counter
 198+ 0523 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0525 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0527 15                           dec     D               ; decrement char band counter
 201+ 0528 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 052A 23                           inc     HL              ; next pattern
 203+ 052B 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 052D                              ; set pattern table
 205+ 052D 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 0530 11 3D 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0533 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 208+ 0535 CD 99 05     RPT103:         call    LOADLOGOCHRS
 209+ 0538 13                           inc     DE              ; next logo pattern
 210+ 0539 10 FA                        djnz    RPT103
 211+ 053B 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 053D CD 99 05     RPT104:         call    LOADLOGOCHRS
 213+ 0540 13                           inc     DE              ; next logo pattern
 214+ 0541 10 FA                        djnz    RPT104
 215+ 0543                              ; show logo/message, play a beep, check for SHIFT pressure (to disable DOS), and wait a while
 216+ 0543 06 02                        ld      B,$02           ; two times
 217+ 0545 AF                           xor     A               ; reset A
 218+ 0546 57                           ld      D,A             ; 256 times
 219+ 0547 5F                           ld      E,A             ; x 256 times
 220+ 0548 32 FD 52                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 054B                  IFDEF LM80C64K
 222+ 054B 3C                           inc     A               ; by default, I/O DOS buffer is enabled on LM80C 64K, disabled on LM80C
 223+ 054C                  ENDIF
 224+ 054C 32 42 53                     ld      (DOS_EN),A      ; DOS enabled
 225+ 054F 00           DEC_D:          nop                     ; does nothing...
 226+ 0550 00                           nop
 227+ 0551 00                           nop
 228+ 0552 00                           nop
 229+ 0553 00                           nop
 230+ 0554 00                           nop                     ; ...until here
 231+ 0555 1D                           dec     E               ; decrement E
 232+ 0556 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 233+ 0558 7A                           ld      A,D
 234+ 0559 FE 40                        cp      $40             ; ...equal to 64
 235+ 055B CC 85 05                     call    Z,SETBEEP       ; if yes, start sound
 236+ 055E 15                           dec     D
 237+ 055F 20 EE                        jr      NZ,DEC_D        ; repeat
 238+ 0561 3A FD 52                     ld      A,(TMPBFR1)     ; sound state
 239+ 0564 FE 02                        cp      $02             ; check if sound is to be set off
 240+ 0566 C4 91 05                     call    NZ,BEEPOFF      ; yes
 241+ 0569                  IFDEF LM80C64K
 242+ 0569 CD BE 05                     call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 243+ 056C                                                      ; on LM80C 64K, you can disabled the I/O DOS buffer, on LM80C you can't
 244+ 056C                  ENDIF
 245+ 056C 10 E1                        djnz    DEC_D           ; repeat
 246+ 056E              ERASECLRTBL:    ; erase color table
 247+ 056E 3E 11                        ld      A,$11           ; foreground and background set to black
 248+ 0570 16 0A                        ld      D,$0A           ; 10 pages
 249+ 0572 06 00                        ld      B,$00           ; 256 color cells per page
 250+ 0574 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 251+ 0577 CD 5D 06                     call    SETVDPADRS      ; send address
 252+ 057A 0D                           dec     C              ; VDP address for passing data
 253+ 057B ED 79        RPT100:         out     (C),A           ; send data
 254+ 057D 00                           nop
 255+ 057E 00                           nop                     ; little delay
 256+ 057F 10 FA                        djnz    RPT100          ; repeat for entire page
 257+ 0581 15                           dec     D
 258+ 0582 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 259+ 0584 C9                           ret                     ; return to caller
 260+ 0585
 261+ 0585              ; play a beep
 262+ 0585 3A FD 52     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 263+ 0588 B7                           or      A               ; is it 0?
 264+ 0589 C0                           ret     NZ              ; no, exit
 265+ 058A 3C                           inc     A               ; flag to 1
 266+ 058B 32 FD 52                     ld      (TMPBFR1),A     ; set sound
 267+ 058E C3 AB 0C                     jp      WLCMBEEP        ; play a beep & return
 268+ 0591
 269+ 0591              ; beep off
 270+ 0591 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 271+ 0593 32 FD 52                     ld      (TMPBFR1),A     ; set flag
 272+ 0596 C3 B1 0C                     jp      NOBEEP          ; stop beep and return
 273+ 0599
 274+ 0599
 275+ 0599              ; used to load the chars that will compose the logo of the splash screen
 276+ 0599 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 277+ 059A 87                           add     A,A
 278+ 059B 87                           add     A,A
 279+ 059C 87                           add     A,A             ; multiply times 8 to get the offset
 280+ 059D C5                           push    BC
 281+ 059E D5                           push    DE              ; store BC and DE
 282+ 059F E5                           push    HL              ; store VRAM address to write to
 283+ 05A0 21 1B 50                     ld      HL,LOGOFONT     ; start of logo font data
 284+ 05A3 5F                           ld      E,A
 285+ 05A4 16 00                        ld      D,$00           ; put offset (A) into DE
 286+ 05A6 19                           add     HL,DE           ; get address of pattern data
 287+ 05A7 EB                           ex      DE,HL           ; move address into DE
 288+ 05A8 E1                           pop     HL              ; retrieve VRAM address
 289+ 05A9 06 08                        ld      B,$08           ; 8 bytes per pattern
 290+ 05AB CD 5D 06                     call    SETVDPADRS      ; set VDP address
 291+ 05AE 0D                           dec     C              ; VDP_DAT
 292+ 05AF 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 293+ 05B0 ED 79                        out     (C),A           ; and send to VRAM
 294+ 05B2 13                           inc     DE              ; next byte into RAM
 295+ 05B3 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 296+ 05B4 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 297+ 05B6 D1                           pop     DE
 298+ 05B7 C1                           pop     BC              ; retrieve BC & DE
 299+ 05B8 C9                           ret                     ; return to caller
 300+ 05B9              CLRTABLE:       equ $
 301+ 05B9 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 301+ 05BD 1D
 302+ 05BE
 303+ 05BE
 304+ 05BE              ; while showing the logo, check if special key (CTRL) is being pressed
 305+ 05BE              ; if yes, then disable DOS functions recovering RAM
 306+ 05BE F5           CHKSPCK:        push    AF
 307+ 05BF 3E FE                        ld      A,%11111110     ; select CTRL row
 308+ 05C1 CD 2F 0D                     call    READKBLN        ; read row
 309+ 05C4 CB 57                        bit     2,A             ; test if CTRL key is pressed
 310+ 05C6 20 04                        jr      NZ,LVCKSPLK     ; no, leave
 311+ 05C8 AF                           xor     A               ; yes, so...
 312+ 05C9 32 42 53                     ld      (DOS_EN),A      ; ...disable DOS
 313+ 05CC F1           LVCKSPLK:       pop     AF
 314+ 05CD C9                           ret
 315+ 05CE
 316+ 05CE
 317+ 05CE              ; empty video buffer
 318+ 05CE 3A EE 52     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 319+ 05D1 FE 02                        cp      $02             ; is it G2 mode?
 320+ 05D3 CA F6 05                     jp      Z,EMPTYG2       ; yes, jump over
 321+ 05D6 FE 03                        cp      $03             ; is it MC mode?
 322+ 05D8 CA 26 06                     jp      Z,EMPTYMC       ; yes, jump over
 323+ 05DB 3A ED 52                     ld      A,(SCR_SIZE_H)  ; load height of screen
 324+ 05DE 47                           ld      B,A             ; move rows into B
 325+ 05DF AF                           xor     A               ; filling char is $00
 326+ 05E0 2A F0 52                     ld      HL,(SCR_NAM_TB) ; load the name table address
 327+ 05E3 CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 328+ 05E6 0D                           dec     C              ; VDP address for passing data
 329+ 05E7 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 330+ 05E8 3A EC 52                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 331+ 05EB 57                           ld      D,A             ; move A into D
 332+ 05EC 7B                           ld      A,E             ; recover filling char
 333+ 05ED ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 334+ 05EF 00                           nop
 335+ 05F0 15                           dec     D               ; decr. D
 336+ 05F1 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 337+ 05F3 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 338+ 05F5 C9                           ret                     ; return to caller
 339+ 05F6 2A F0 52     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 340+ 05F9 CD 4B 06                     call    SETNAMETABLE    ; set name table
 341+ 05FC 21 00 00                     ld      HL,$0000        ; set pattern table
 342+ 05FF CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 343+ 0602 AF                           xor     A               ; empty pattern
 344+ 0603 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 345+ 0605 47                           ld      B,A             ; 256 bytes for page
 346+ 0606 0D                           dec     C              ; VDP data mode
 347+ 0607 ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 348+ 0609 00                           nop                     ; little delay
 349+ 060A 00                           nop
 350+ 060B 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 351+ 060D 15                           dec     D               ; next page
 352+ 060E 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 353+ 0610 21 00 20                     ld      HL,$2000        ; load the color table address
 354+ 0613 CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 355+ 0616 3A FB 52                     ld      A,(FRGNDCLR)    ; load foreground
 356+ 0619 87                           add     A,A
 357+ 061A 87                           add     A,A
 358+ 061B 87                           add     A,A
 359+ 061C 87                           add     A,A             ; move to high nibble
 360+ 061D 57                           ld      D,A             ; store into D
 361+ 061E 3A FC 52                     ld      A,(BKGNDCLR)    ; load background color
 362+ 0621 B2                           or      D               ; combine with background color
 363+ 0622 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 364+ 0624 18 17                        jr      STARTEMPTY
 365+ 0626 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 366+ 0629 CD 4B 06                     call    SETNAMETABLE    ; set name table
 367+ 062C 21 00 00                     ld      HL,$0000        ; color table address
 368+ 062F CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 369+ 0632 3A FC 52                     ld      A,(BKGNDCLR)    ; load background
 370+ 0635 57                           ld      D,A             ; store into D
 371+ 0636 87                           add     A,A
 372+ 0637 87                           add     A,A
 373+ 0638 87                           add     A,A
 374+ 0639 87                           add     A,A             ; move to high nibble
 375+ 063A B2                           or      D               ; set background color for high and low nibble
 376+ 063B 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 377+ 063D 0E 30        STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
 378+ 063F 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 379+ 0641 ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 380+ 0643 00                           nop                     ; wait a while
 381+ 0644 00                           nop
 382+ 0645 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 383+ 0647 15                           dec     D               ; have we filled all the pages?
 384+ 0648 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 385+ 064A C9                           ret                     ; return to caller
 386+ 064B
 387+ 064B              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 388+ 064B CD 5D 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 389+ 064E 0D                           dec     C              ; VDP address for passing data
 390+ 064F 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 391+ 0651 AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 392+ 0652 47                           ld      B,A             ; reset B
 393+ 0653 ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 394+ 0655 00                           nop
 395+ 0656 3C                           inc     A               ; increment # of name
 396+ 0657 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 397+ 0659 15                           dec     D               ; did we fill all the pages?
 398+ 065A 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 399+ 065C C9                           ret                     ; return to caller
 400+ 065D
 401+ 065D              ; set an address into VRAM: address is in HL - HL is changed after it
 402+ 065D 0E 32        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 403+ 065F CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 404+ 0661 ED 69                        out     (C),L           ; send low and...
 405+ 0663 ED 61                        out     (C),H           ; ...high byte of the first cell
 406+ 0665 C9                           ret                     ; return to caller
 407+ 0666
 408+ 0666              ; clear the video buffer and position the cursor at 0,0
 409+ 0666 CD CE 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 410+ 0669 AF                           xor     A               ; reset A
 411+ 066A 32 F2 52                     ld      (SCR_CURS_X),A  ; cursor X to 0
 412+ 066D 32 F3 52                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 413+ 0670 C3 B9 06                     jp      POS_CURSOR      ; position cursor & return to caller
 414+ 0673
 415+ 0673              ; HOME: position the cursor at coords. 0,0
 416+ 0673 AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 417+ 0674 32 F5 52                     ld      (SCR_CUR_NY),A  ; ...new Y...
 418+ 0677 32 F4 52                     ld      (SCR_CUR_NX),A  ; ...and new X
 419+ 067A C3 C3 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 420+ 067D
 421+ 067D              ; load the char or byte at the VRAM position set by HL
 422+ 067D              ; value is returned into A
 423+ 067D C5           READ_VIDEO_LOC: push    BC              ; store BC
 424+ 067E 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 425+ 0680 44                           ld      B,H
 426+ 0681 CB B8                        res     7,B
 427+ 0683 CB B0                        res     6,B
 428+ 0685 ED 69                        out     (C),L           ; low byte then...
 429+ 0687 ED 41                        out     (C),B           ; high byte
 430+ 0689 0D                           dec     C              ; VDP data mode
 431+ 068A 00                           nop                     ; wait...
 432+ 068B 00                           nop                     ; ...a while
 433+ 068C 00                           nop
 434+ 068D                  IFDEF LM80C64K
 435+ 068D 00                           nop
 436+ 068E                  ENDIF
 437+ 068E ED 78                        in      A,(C)           ; read byte at current VRAM location
 438+ 0690 C1                           pop     BC              ; restore BC
 439+ 0691 C9                           ret                     ; return to caller
 440+ 0692
 441+ 0692              ; write a byte at the VRAM position pointed by HL
 442+ 0692              ; value is in A
 443+ 0692 C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 444+ 0693 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 445+ 0695 44                           ld      B,H             ; copy H into B
 446+ 0696 CB B8                        res     7,B
 447+ 0698 CB F0                        set     6,B             ; write to VRAM
 448+ 069A ED 69                        out     (C),L           ; low byte then...
 449+ 069C ED 41                        out     (C),B           ; high byte of VRAM address
 450+ 069E 0D                           dec     C              ; VDP data mode
 451+ 069F 00                           nop                     ; wait...
 452+ 06A0 00                           nop                     ; ...a while
 453+ 06A1 00                           nop
 454+ 06A2                  IFDEF LM80C64K
 455+ 06A2 00                           nop
 456+ 06A3                  ENDIF
 457+ 06A3 ED 79                        out     (C),A           ; write byte into VRAM
 458+ 06A5 C1                           pop     BC              ; restore BC
 459+ 06A6 C9                           ret                     ; return to caller
 460+ 06A7
 461+ 06A7              ; write a value into a specific VDP register
 462+ 06A7              ; value is in E, register is in A
 463+ 06A7 C5           WRITE_VREG:     push    BC              ; store BC
 464+ 06A8 C6 80                        add     A,$80           ; set VDP to write to registers
 465+ 06AA 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 466+ 06AC ED 59                        out     (C),E           ; send data to VDP
 467+ 06AE ED 79                        out     (C),A           ; select the destination register
 468+ 06B0 C1                           pop     BC              ; restore BC
 469+ 06B1 C9                           ret                     ; return to caller
 470+ 06B2
 471+ 06B2              ; read VDP status register and return value into A
 472+ 06B2 C5           READ_VSTAT:     push    BC              ; store BC
 473+ 06B3 0E 32                        ld      C,VDP_SET       ; VDP register access
 474+ 06B5 ED 78                        in      A,(C)           ; read status register
 475+ 06B7 C1                           pop     BC              ; restore BC
 476+ 06B8 C9                           ret                     ; return to caller
 477+ 06B9
 478+ 06B9              ; position the cursor at the current coordinates, preserving underlying char
 479+ 06B9 CD FC 06     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 480+ 06BC CD 7D 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 481+ 06BF 32 F6 52                     ld      (SCR_ORG_CHR),A ; store the current char
 482+ 06C2 C9                           ret
 483+ 06C3
 484+ 06C3              ; move cursor to new X,Y coordinates
 485+ 06C3 CD F3 06     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 486+ 06C6 CD DE 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 487+ 06C9 CD B9 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 488+ 06CC 3A F7 52                     ld      A,(CRSR_STATE)  ; load status of cursor
 489+ 06CF A7                           and     A               ; is cursor off?
 490+ 06D0 C8                           ret     Z               ; yes, return
 491+ 06D1 3A DC 52                     ld      A,(TMRCNT)      ; load timer
 492+ 06D4 E6 20                        and     $20             ; check status of cursor flashing
 493+ 06D6 32 F8 52                     ld      (LSTCSRSTA),A   ; store the last cursor state
 494+ 06D9 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 495+ 06DB C3 92 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 496+ 06DE
 497+ 06DE
 498+ 06DE              ; set new cursor's coordinates
 499+ 06DE 3A F4 52     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 500+ 06E1 32 F2 52                     ld      (SCR_CURS_X),A  ; write new X
 501+ 06E4 3A F5 52                     ld      A,(SCR_CUR_NY)  ; load new Y
 502+ 06E7 32 F3 52                     ld      (SCR_CURS_Y),A  ; write new Y
 503+ 06EA 3E FF                        ld      A,$FF           ; delete new values
 504+ 06EC 32 F4 52                     ld      (SCR_CUR_NX),A  ; of X
 505+ 06EF 32 F5 52                     ld      (SCR_CUR_NY),A  ; and Y
 506+ 06F2 C9                           ret
 507+ 06F3
 508+ 06F3              ; recover char under the cursor and prints it onto the screen
 509+ 06F3 CD FC 06     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 510+ 06F6 3A F6 52                     ld      A,(SCR_ORG_CHR) ; recover old char
 511+ 06F9 C3 92 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 512+ 06FC
 513+ 06FC              ; retrieve cursor position from either current coordinates or next place
 514+ 06FC              ; return address position into HL
 515+ 06FC 3A F3 52     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 516+ 06FF 6F                           ld      L,A             ; move it into reg.L
 517+ 0700 AF                           xor     A               ; reset A
 518+ 0701 67                           ld      H,A             ; reset H
 519+ 0702 47                           ld      B,A             ; reset B
 520+ 0703 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 521+ 0704 11 8B 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 522+ 0707 3A EC 52                     ld      A,(SCR_SIZE_W)  ; load screen width
 523+ 070A FE 28                        cp      $28             ; is it 40 cols?
 524+ 070C 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 525+ 070E 11 5B 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 526+ 0711 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 527+ 0712 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 528+ 0713 23                           inc     HL
 529+ 0714 56                           ld      D,(HL)
 530+ 0715 2A F0 52                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 531+ 0718 19                           add     HL,DE           ; starting address of the current row into name table
 532+ 0719 3A F2 52                     ld      A,(SCR_CURS_X)  ; load cursor X
 533+ 071C 4F                           ld      C,A             ; transfer A into C
 534+ 071D 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 535+ 071E C9                           ret
 536+ 071F
 537+ 071F              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 538+ 071F              ; return them into L,A for X,Y
 539+ 071F D5           HL2XY:          push    DE              ; store DE
 540+ 0720 ED 5B F0 52                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 541+ 0724 AF                           xor     A               ; clear Carry
 542+ 0725 ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 543+ 0727 D1                           pop     DE
 544+ 0728 3A EC 52                     ld      A,(SCR_SIZE_W)  ; load screen width
 545+ 072B 4F                           ld      C,A             ; move it into C
 546+ 072C CD F7 3F                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 547+ 072F C9                           ret                     ; return to caller
 548+ 0730
 549+ 0730              ;-------------------------------------------------------------------------------
 550+ 0730              ; char table for jumps
 551+ 0730 19           CHRTBL:         defb    HOME
 552+ 0731 73 06                        defw    ATHOME          ; move the cursor to 0,0
 553+ 0733
 554+ 0733 0C                           defb    CS
 555+ 0734 66 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 556+ 0736
 557+ 0736 0D                           defb    CR
 558+ 0737 AE 09                        defw    CRGRETURN       ; go to the beginning of the next line
 559+ 0739
 560+ 0739 08                           defb    BKSP
 561+ 073A 1D 08                        defw    BACKSPACE       ; move cursor left 1 position
 562+ 073C
 563+ 073C 1C                           defb    CRSLFT
 564+ 073D 60 08                        defw    CURSORLEFT      ; move cursor left
 565+ 073F
 566+ 073F 1E                           defb    CRSUP
 567+ 0740 AC 08                        defw    CURSORUP        ; move cursor up
 568+ 0742
 569+ 0742 1D                           defb    CRSRGT
 570+ 0743 C5 08                        defw    CURSORRIGHT     ; move cursor right
 571+ 0745
 572+ 0745 1F                           defb    CRSDN
 573+ 0746 FA 08                        defw    CURSORDOWN      ; move cursor up
 574+ 0748
 575+ 0748 1A                           defb    INSRT
 576+ 0749 DB 07                        defw    INSERTKEY       ; insert a space
 577+ 074B
 578+ 074B 0A                           defb    LF
 579+ 074C B7 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 580+ 074E
 581+ 074E              ; send current char to video buffer
 582+ 074E F5           CHAR2VID:       push    AF              ; store AF
 583+ 074F C5                           push    BC              ; store BC
 584+ 0750 D5                           push    DE              ; store DE
 585+ 0751 E5                           push    HL              ; store HL
 586+ 0752 3A F7 52                     ld      A,(CRSR_STATE)  ; store cursor state...
 587+ 0755 F5                           push    AF              ; into stack
 588+ 0756 CD 2F 09                     call    CURSOR_OFF      ; cursor off
 589+ 0759 3A FA 52                     ld      A,(CHR4VID)     ; recover char
 590+ 075C 06 0A                        ld      B,$0A           ; 10 chars to check
 591+ 075E 21 30 07                     ld      HL,CHRTBL       ; address of key table
 592+ 0761 BE           RPTCPCK:        cp      (HL)            ; compare with char
 593+ 0762 23                           inc     HL              ; beginning of sub-routine address
 594+ 0763 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 595+ 0765 5E                           ld      E,(HL)          ; load addres into DE
 596+ 0766 23                           inc     HL
 597+ 0767 56                           ld      D,(HL)
 598+ 0768 EB                           ex      DE,HL           ; move user routine's address into HL
 599+ 0769 11 AA 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 600+ 076C D5                           push    DE              ; store into stack
 601+ 076D E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 602+ 076E 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 603+ 076F 23                           inc     HL              ; ...to the next char code
 604+ 0770 10 EF                        djnz    RPTCPCK         ; repeat
 605+ 0772                              ; it'a not a special char, just print it
 606+ 0772 CD FC 06                     call    LOAD_CRSR_POS   ; recover position of cursor
 607+ 0775 3A FA 52                     ld      A,(CHR4VID)     ; recover char to print
 608+ 0778 CD 92 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 609+ 077B 3A F3 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 610+ 077E 5F                           ld      E,A             ; store cursor Y into E
 611+ 077F 3A F2 52                     ld      A,(SCR_CURS_X)  ; load cursor X
 612+ 0782 3C                           inc     A               ; move 1 step to right
 613+ 0783 21 EC 52                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 614+ 0786 BE                           cp      (HL)            ; have we reached the most right position?
 615+ 0787 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 616+ 0789 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 617+ 078A 7B                           ld      A,E             ; move cursor Y into A
 618+ 078B 21 ED 52                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 619+ 078E BE                           cp      (HL)            ; have we reached the bottom of the screen?
 620+ 078F 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 621+ 0791 D5                           push    DE
 622+ 0792 CD 36 09                     call    SCROLLUP        ; scroll screen up
 623+ 0795 D1                           pop     DE
 624+ 0796 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 625+ 0797 AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 626+ 0798 32 F2 52     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 627+ 079B 7B                           ld      A,E             ; recover Y
 628+ 079C 32 F3 52                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 629+ 079F CD B9 06                     call    POS_CURSOR      ; position cursor into new location
 630+ 07A2 3A DC 52                     ld      A,(TMRCNT)      ; load status of cursor flashing
 631+ 07A5 E6 20                        and     $20             ; check cursor state
 632+ 07A7 32 F8 52                     ld      (LSTCSRSTA),A   ; store the last cursor state
 633+ 07AA AF           EXITCHAR2VID:   xor     A               ; reset char
 634+ 07AB 32 FA 52                     ld      (CHR4VID),A     ; to be sent to screen
 635+ 07AE F1                           pop     AF              ; recover cursor state
 636+ 07AF A7                           and     A               ; was it off (A=0)?
 637+ 07B0 C4 1A 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 638+ 07B3 E1                           pop     HL              ; restore HL
 639+ 07B4 D1                           pop     DE              ; restore DE
 640+ 07B5 C1                           pop     BC              ; restore BC
 641+ 07B6 F1                           pop     AF              ; restore AF
 642+ 07B7 C9           PLACEHOLDER:    ret                     ; return to caller
 643+ 07B8
 644+ 07B8              ; flash the cursor at the current position
 645+ 07B8              ; (this sub-routine is called by CH3 timer ISR)
 646+ 07B8 3A F7 52     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 647+ 07BB A7                           and     A               ; cursor off (A=0)?
 648+ 07BC C8                           ret     Z               ; yes, return
 649+ 07BD 3A DC 52                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 650+ 07C0 E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 651+ 07C2 21 F8 52                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 652+ 07C5 BE                           cp      (HL)            ; compare current state with last state
 653+ 07C6 C8                           ret     Z               ; same state, no change required - exit
 654+ 07C7 77                           ld      (HL),A          ; save new state
 655+ 07C8 F5                           push    AF              ; store A (keep state for later use)
 656+ 07C9 CD FC 06                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 657+ 07CC F1                           pop     AF              ; recover current state
 658+ 07CD 06 FF                        ld      B,$FF           ; cursor char
 659+ 07CF FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 660+ 07D1 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 661+ 07D3 3A F6 52                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 662+ 07D6 47                           ld      B,A             ; move char into B
 663+ 07D7 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 664+ 07D8 C3 92 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 665+ 07DB
 666+ 07DB
 667+ 07DB              ; insert an empty space at the current position of the cursor, moving the following text
 668+ 07DB              ; 1 cell straight
 669+ 07DB CD F3 06     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 670+ 07DE CD FC 06                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 671+ 07E1 22 FD 52                     ld      (CUR_POS),HL    ; store it
 672+ 07E4 CD 35 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 673+ 07E7                                                      ; DE is the address of the bottom right cell of the screen
 674+ 07E7 22 01 53                     ld      (ENDTXT),HL     ; store it
 675+ 07EA ED 4B FD 52                  ld      BC,(CUR_POS)    ; load starting address
 676+ 07EE AF                           xor     A
 677+ 07EF ED 42                        sbc     HL,BC           ; how many positions to move?
 678+ 07F1 CA C9 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 679+ 07F4 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 680+ 07F6 2A 01 53                     ld      HL,(ENDTXT)     ; load address of the end of text
 681+ 07F9 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 682+ 07FA E5                           push    HL
 683+ 07FB CD B8 3F                     call    CMP16           ; is it the last cell (bottom right) of screen?
 684+ 07FE E1                           pop     HL
 685+ 07FF D2 0A 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 686+ 0802 CD 7D 06                     call    READ_VIDEO_LOC  ; no, so read current char
 687+ 0805 23                           inc     HL              ; next cell
 688+ 0806 CD 92 06                     call    WRITE_VIDEO_LOC ; write into new position
 689+ 0809 2B                           dec     HL              ; decrement to old position
 690+ 080A 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 691+ 080B 79                           ld      A,C
 692+ 080C B0                           or      B               ; finished?
 693+ 080D 20 EA                        jr      NZ,CHKHL        ; no, repeat
 694+ 080F 3E 20        ENDINSRT:       ld      A,SPC           ; xor     A
 695+ 0811 2A FD 52                     ld      HL,(CUR_POS)
 696+ 0814 32 F6 52                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 697+ 0817 CD 92 06                     call    WRITE_VIDEO_LOC ; empty current video location
 698+ 081A C3 C9 06                     jp      MOVSHOWCRS      ; re-place cursor
 699+ 081D
 700+ 081D              ; delete the char at the left of the cursor
 701+ 081D CD F3 06     BACKSPACE:      call    RSTCHRCRS       ; restore char
 702+ 0820 2A F0 52                     ld      HL,(SCR_NAM_TB) ; address of origin of screen (location 0,0)
 703+ 0823 44 4D                        ld      BC,HL           ; store into BC
 704+ 0825 CD FC 06                     call    LOAD_CRSR_POS   ; load address of current cursor pos.
 705+ 0828 54 5D                        ld      DE,HL           ; copy into DE
 706+ 082A AF                           xor     A               ; reset Carry
 707+ 082B ED 42                        sbc     HL,BC           ; check how many chars between
 708+ 082D CA 57 08                     jp      Z,LVBKSP        ; none, so we are at the top left corner
 709+ 0830 ED 53 FD 52                  ld      (CUR_POS),DE    ; store current cursor position
 710+ 0834 CD 35 0A                     call    ENDOFLN         ; check end of text
 711+ 0837 ED 5B FD 52                  ld      DE,(CUR_POS)    ; retrieve cursor position
 712+ 083B AF                           xor     A               ; reset Carry
 713+ 083C ED 52                        sbc     HL,DE           ; check if none follows
 714+ 083E CA 57 08                     jp      Z,LVBKSP        ; no chars follow, so simply move the cursor
 715+ 0841 44 4D                        ld      BC,HL           ; save numbers of chars to move
 716+ 0843 EB                           ex      DE,HL           ; copy starting position into HL
 717+ 0844 CD 7D 06     MVBKSP:         call    READ_VIDEO_LOC  ; read char
 718+ 0847 2B                           dec     HL              ; 1 position to left
 719+ 0848 CD 92 06                     call    WRITE_VIDEO_LOC ; write char
 720+ 084B 23                           inc     HL              ; goto next char to copy (2 steps to right)
 721+ 084C 23                           inc     HL
 722+ 084D 0B                           dec     BC              ; decrement # of chars
 723+ 084E 79                           ld      A,C
 724+ 084F B0                           or      B               ; 0 chars?
 725+ 0850 20 F2                        jr      NZ,MVBKSP       ; not finished, continue
 726+ 0852 2B                           dec     HL
 727+ 0853 AF                           xor     A
 728+ 0854 CD 92 06                     call    WRITE_VIDEO_LOC ; reset last char
 729+ 0857 CD 89 08     LVBKSP:         call    MVCRS2LFT       ; move cursor to new position
 730+ 085A CD DE 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 731+ 085D C3 C9 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 732+ 0860
 733+ 0860
 734+ 0860              ; move cursor to left
 735+ 0860 F5           CURSORLEFT:     push    AF              ; store A
 736+ 0861 3A F2 52                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 737+ 0864 A7                           and     A               ; is it at the most left of the screen (X=0)?
 738+ 0865 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 739+ 0867 3D                           dec     A               ; no, decrement X
 740+ 0868 32 F4 52                     ld      (SCR_CUR_NX),A  ; store new X
 741+ 086B 3A F3 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 742+ 086E 32 F5 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 743+ 0871 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 744+ 0873 3A F3 52     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 745+ 0876 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 746+ 0877 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 747+ 0879 3D                           dec     A               ; no, decrement Y
 748+ 087A 32 F5 52                     ld      (SCR_CUR_NY),A  ; store new Y
 749+ 087D 3A EC 52                     ld      A,(SCR_SIZE_W)  ; load current screen width
 750+ 0880 3D                           dec     A               ; cursor to the most right position (width-0)
 751+ 0881 32 F4 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 752+ 0884 CD C3 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 753+ 0887 F1           EXITCURSORLEFT: pop     AF              ; restore A
 754+ 0888 C9                           ret                     ; return to caller
 755+ 0889
 756+ 0889              ; move cursor 1 position to the left
 757+ 0889 3A F2 52     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 758+ 088C A7                           and     A               ; is it at the most left of the screen (X=0)?
 759+ 088D 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 760+ 088F 3D                           dec     A               ; no, decrement X
 761+ 0890 32 F4 52                     ld      (SCR_CUR_NX),A  ; store new X
 762+ 0893 3A F3 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 763+ 0896 32 F5 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 764+ 0899 C9                           ret                     ; go on moving cursor
 765+ 089A 3A F3 52     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 766+ 089D A7                           and     A               ; is it at the most top of the screen (Y=0)?
 767+ 089E 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 768+ 08A0 3D                           dec     A               ; no, decrement Y
 769+ 08A1 32 F5 52                     ld      (SCR_CUR_NY),A  ; store new Y
 770+ 08A4 3A EC 52                     ld      A,(SCR_SIZE_W)  ; load current screen width
 771+ 08A7 3D                           dec     A               ; cursor to the most right position (width-1)
 772+ 08A8 32 F4 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 773+ 08AB C9                           ret                     ; return to caller
 774+ 08AC
 775+ 08AC              ; move cursor up
 776+ 08AC F5           CURSORUP:       push    AF              ; store A
 777+ 08AD 3A F3 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 778+ 08B0 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 779+ 08B1 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 780+ 08B3 3D                           dec     A               ; no, decrement Y
 781+ 08B4 32 F5 52                     ld      (SCR_CUR_NY),A  ; store new Y
 782+ 08B7 3A F2 52                     ld      A,(SCR_CURS_X)  ; load current cursor X
 783+ 08BA 32 F4 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 784+ 08BD CD F3 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 785+ 08C0 CD C3 06                     call    MOVCRS          ; move cursor into new position
 786+ 08C3 F1           EXITCURSORUP:   pop     AF              ; restore A
 787+ 08C4 C9                           ret                     ; return to caller
 788+ 08C5
 789+ 08C5
 790+ 08C5              ; move cursor to right
 791+ 08C5 F5           CURSORRIGHT:    push    AF              ; store A
 792+ 08C6 C5                           push    BC              ; store B
 793+ 08C7 3A EC 52                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 794+ 08CA 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 795+ 08CB 47                           ld      B,A             ; move A into B
 796+ 08CC 3A F2 52                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 797+ 08CF B8                           cp      B               ; is cursor at the most right position on the screen?
 798+ 08D0 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 799+ 08D2 3C                           inc     A               ; no, so increment X
 800+ 08D3 32 F4 52                     ld      (SCR_CUR_NX),A  ; store new X
 801+ 08D6 3A F3 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 802+ 08D9 32 F5 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 803+ 08DC 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 804+ 08DE 3A ED 52     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 805+ 08E1 3D                           dec     A               ; decrement it (last row can only be 23)
 806+ 08E2 47                           ld      B,A             ; move bottom into B
 807+ 08E3 3A F3 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 808+ 08E6 B8                           cp      B               ; is the cursor at the bottom of the screen?
 809+ 08E7 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 810+ 08E9 3C                           inc     A               ; no, increment Y
 811+ 08EA 32 F5 52                     ld      (SCR_CUR_NY),A  ; store new Y
 812+ 08ED AF                           xor     A               ; move cursor to top left
 813+ 08EE 32 F4 52                     ld      (SCR_CUR_NX),A  ; store new X
 814+ 08F1 CD F3 06     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 815+ 08F4 CD C3 06                     call    MOVCRS          ; move cursor into new position
 816+ 08F7 C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 817+ 08F8 F1                           pop     AF              ; restore A
 818+ 08F9 C9                           ret                     ; return to caller
 819+ 08FA
 820+ 08FA
 821+ 08FA              ; move cursor down
 822+ 08FA F5           CURSORDOWN:     push    AF              ; store A
 823+ 08FB C5                           push    BC              ; store B
 824+ 08FC 3A ED 52                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 825+ 08FF 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 826+ 0900 47                           ld      B,A             ; move X into B
 827+ 0901 3A F3 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 828+ 0904 B8                           cp      B               ; is current cursor position < 23?
 829+ 0905 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 830+ 0907 3C                           inc     A               ; yes, increment Y
 831+ 0908 32 F5 52                     ld      (SCR_CUR_NY),A  ; store new Y
 832+ 090B 3A F2 52                     ld      A,(SCR_CURS_X)  ; load current cursor X
 833+ 090E 32 F4 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 834+ 0911 CD F3 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 835+ 0914 CD C3 06                     call    MOVCRS          ; move cursor into new position
 836+ 0917 C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 837+ 0918 F1                           pop     AF              ; retrieve A
 838+ 0919 C9                           ret                     ; return to caller
 839+ 091A
 840+ 091A
 841+ 091A              ; set cursor on (visible on screen)
 842+ 091A F5           CURSOR_ON:      push    AF              ; store AF
 843+ 091B 3A F7 52                     ld      A,(CRSR_STATE)  ; load cursor state
 844+ 091E B7                           or      A               ; is it on?
 845+ 091F 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 846+ 0921 3A ED 52                     ld      A,(SCR_SIZE_H)  ; check the video mode
 847+ 0924 FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 848+ 0926 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 849+ 0928 3E 01                        ld      A,$01           ; cursor state ON
 850+ 092A 32 F7 52                     ld      (CRSR_STATE),A  ; set state
 851+ 092D F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 852+ 092E C9                           ret                     ; return to caller
 853+ 092F
 854+ 092F              ; set cursor off (invisible on screen)
 855+ 092F F5           CURSOR_OFF:     push    AF              ; store AF
 856+ 0930 AF                           xor     A               ; cursor state OFF
 857+ 0931 32 F7 52                     ld      (CRSR_STATE),A  ; set state
 858+ 0934 F1                           pop     AF              ; restore AF
 859+ 0935 C9                           ret
 860+ 0936
 861+ 0936              ; scroll the screen 1 row up
 862+ 0936 AF           SCROLLUP:       xor     A
 863+ 0937 32 F9 52                     ld      (PRNTVIDEO),A
 864+ 093A 2A F0 52                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 865+ 093D 22 2D 53                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 866+ 0940 3A EC 52                     ld      A,(SCR_SIZE_W)  ; load the screen width
 867+ 0943 5F                           ld      E,A             ; move width into E
 868+ 0944 16 00                        ld      D,$00           ; reset D
 869+ 0946 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 870+ 0947 22 2F 53                     ld      (VIDTMP2),HL    ; store address of source row
 871+ 094A 3A ED 52                     ld      A,(SCR_SIZE_H)  ; load the screen height
 872+ 094D 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 873+ 094E 47                           ld      B,A             ; move # of rows into B
 874+ 094F 3A EC 52     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 875+ 0952 5F                           ld      E,A             ; move width into E
 876+ 0953 2A 2F 53                     ld      HL,(VIDTMP2)    ; load source address
 877+ 0956 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 878+ 0958 ED 69                        out     (C),L           ; low byte of source
 879+ 095A ED 61                        out     (C),H           ; high byte of source
 880+ 095C 21 05 53                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 881+ 095F 0D                           dec     C              ; VDP data mode
 882+ 0960 ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 883+ 0962 77                           ld      (HL),A          ; store char
 884+ 0963 23                           inc     HL              ; next cell of the buffer
 885+ 0964 1D                           dec     E               ; count the chars to be read
 886+ 0965 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 887+ 0967 3A EC 52                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 888+ 096A 5F                           ld      E,A             ; move # of rows into E
 889+ 096B 16 00                        ld      D,$00           ; reset D
 890+ 096D 2A 2D 53                     ld      HL,(VIDTMP1)    ; load address of destination row
 891+ 0970 E5                           push    HL              ; store HL
 892+ 0971 2A 2F 53                     ld      HL,(VIDTMP2)    ; current source will be..
 893+ 0974 22 2D 53                     ld      (VIDTMP1),HL    ; ..new destination
 894+ 0977 19                           add     HL,DE           ; address of new
 895+ 0978 22 2F 53                     ld      (VIDTMP2),HL    ; source row
 896+ 097B E1                           pop     HL              ; restore address of current destination row
 897+ 097C CB F4                        set     6,H             ; writing mode
 898+ 097E 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 899+ 0980 ED 69                        out     (C),L           ; low byte
 900+ 0982 ED 61                        out     (C),H           ; high byte of address
 901+ 0984 21 05 53                     ld      HL,VIDEOBUFF    ; video buffer address
 902+ 0987 0D                           dec     C              ; VDP data mode
 903+ 0988 7E           WRITEBUF:       ld      A,(HL)          ; load char
 904+ 0989 ED 79                        out     (C),A           ; send char
 905+ 098B 23                           inc     HL              ; increment buffer index
 906+ 098C 1D                           dec     E               ; next row
 907+ 098D 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 908+ 098F 10 BE                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 909+ 0991 3A EC 52                     ld      A,(SCR_SIZE_W)  ; reload screen width
 910+ 0994 47                           ld      B,A             ; cells to empty into B
 911+ 0995 AF                           xor     A               ; null char
 912+ 0996 0E 32                        ld      C,VDP_SET       ; VDP set mode
 913+ 0998 2A 2D 53                     ld      HL,(VIDTMP1)    ; load address of the last row
 914+ 099B CB F4                        set     6,H             ; writing mode
 915+ 099D ED 69                        out     (C),L           ; low byte then..
 916+ 099F ED 61                        out     (C),H           ; high byte of address
 917+ 09A1 0D                           dec     C              ; VDP data mode
 918+ 09A2 ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 919+ 09A4 00                           nop                     ; delay
 920+ 09A5 00                           nop
 921+ 09A6 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 922+ 09A8 3E 01                        ld      A,$01
 923+ 09AA 32 F9 52                     ld      (PRNTVIDEO),A   ; set print-on-video on
 924+ 09AD C9                           ret                     ; return to caller
 925+ 09AE
 926+ 09AE              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 927+ 09AE              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 928+ 09AE              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 929+ 09AE              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 930+ 09AE              CUR_POS         equ     TMPBFR1         ; cursor position
 931+ 09AE              SRTTXT          equ     TMPBFR2         ; start of text line
 932+ 09AE              ENDTXT          equ     TMPBFR3         ; end of text line
 933+ 09AE              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 934+ 09AE 3A F7 52                     ld      A,(CRSR_STATE)  ; recover cursor state
 935+ 09B1 32 03 53                     ld      (TMPBFR4),A     ; store status
 936+ 09B4 A7                           and     A               ; is cursor on?
 937+ 09B5 C4 2F 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 938+ 09B8 CD F3 06                     call    RSTCHRCRS       ; restore char under it
 939+ 09BB                              ; first, check if cursor if off, so that we just interpret return as a new line command
 940+ 09BB 3A 37 53                     ld      A,(KBDNPT)      ; check if input from keyboad
 941+ 09BE A7                           and     A               ; if 0, input is not from keyboard...
 942+ 09BF CA 14 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 943+ 09C2                              ; first part: look for the beginning of the text line on screen
 944+ 09C2 CD FC 06                     call    LOAD_CRSR_POS   ; load cursor position into HL
 945+ 09C5 22 FD 52                     ld      (CUR_POS),HL    ; store it
 946+ 09C8 ED 5B F0 52                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 947+ 09CC E5           RPTNLLSRC:      push    HL
 948+ 09CD CD B8 3F                     call    CMP16           ; check if at "home"
 949+ 09D0 E1                           pop     HL
 950+ 09D1 CA DC 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 951+ 09D4 2B                           dec     HL              ; go 1 step back
 952+ 09D5 CD 7D 06                     call    READ_VIDEO_LOC  ; read char of current position
 953+ 09D8 A7                           and     A               ; is it $00 (null char)?
 954+ 09D9 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 955+ 09DB 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 956+ 09DC                              ; second part: look for the ending of the text on screen
 957+ 09DC 22 FF 52     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 958+ 09DF CD 35 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 959+ 09E2 22 01 53                     ld      (ENDTXT),HL     ; store ending of text line
 960+ 09E5 ED 5B FF 52                  ld      DE,(SRTTXT)     ; load beginning of text line
 961+ 09E9 A7                           and     A               ; clear Carry
 962+ 09EA ED 52                        sbc     HL,DE           ; how many chars?
 963+ 09EC 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 964+ 09EE                              ;---    central part: send the text on the screen to the interpreter
 965+ 09EE 2A FF 52                     ld      HL,(SRTTXT)     ; load beginning of text line
 966+ 09F1 ED 5B 01 53                  ld      DE,(ENDTXT)     ; load ending of text line
 967+ 09F5 CD 7D 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 968+ 09F8 E5                           push    HL
 969+ 09F9 CD F4 01                     call    CHARINTOBFR     ; send char to buffer
 970+ 09FC E1                           pop     HL
 971+ 09FD 23                           inc     HL              ; go to next char
 972+ 09FE E5                           push    HL              ; store HL
 973+ 09FF CD B8 3F                     call    CMP16           ; check if DE=HL (finish chars)
 974+ 0A02 E1                           pop     HL
 975+ 0A03 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 976+ 0A05 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 977+ 0A07 CD F4 01                     call    CHARINTOBFR     ; send to buffer
 978+ 0A0A 2A 01 53                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 979+ 0A0D CD 1F 07                     call    HL2XY           ; retrieve X,Y from address
 980+ 0A10 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 981+ 0A11 32 F3 52                     ld      (SCR_CURS_Y),A  ; store new Y
 982+ 0A14                              ;---    final part: go at the beginning of a new line on the screen
 983+ 0A14 AF           PRNTRETURN:     xor     A               ; move to col 0
 984+ 0A15 32 F2 52                     ld      (SCR_CURS_X),A  ; store new X
 985+ 0A18 3A F3 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 986+ 0A1B 3C                           inc     A               ; new row
 987+ 0A1C 21 ED 52                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 988+ 0A1F BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 989+ 0A20 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 990+ 0A22 3D                           dec     A               ; yes, so come back 1 row, then...
 991+ 0A23 F5                           push    AF              ; (store A)
 992+ 0A24 CD 36 09                     call    SCROLLUP        ; ...scroll the screen before to...
 993+ 0A27 F1                           pop     AF              ; (retrieve A)
 994+ 0A28 32 F3 52     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 995+ 0A2B 3A 03 53                     ld      A,(TMPBFR4)     ; retrieve cursor state
 996+ 0A2E A7                           and     A               ; was it off (A=0)?
 997+ 0A2F C4 1A 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 998+ 0A32 C3 B9 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
 999+ 0A35
1000+ 0A35              ; find end of text line
1001+ 0A35              ; destroys A, DE, and HL - store address of last char of text line into HL,
1002+ 0A35              ; while DE contains the address of the bottom right cell of the screen
1003+ 0A35 3A ED 52     ENDOFLN:        ld      A,(SCR_SIZE_H)
1004+ 0A38 5F                           ld      E,A             ; load screen height into DE
1005+ 0A39 3A EC 52                     ld      A,(SCR_SIZE_W)
1006+ 0A3C 6F                           ld      L,A             ; load screen width into HL
1007+ 0A3D AF                           xor     A
1008+ 0A3E 67                           ld      H,A
1009+ 0A3F 57                           ld      D,A
1010+ 0A40 CD C3 3F                     call    MUL16           ; multiply HL times DE to get the screen size
1011+ 0A43 ED 5B F0 52                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
1012+ 0A47 19                           add     HL,DE           ; get the address...
1013+ 0A48 2B                           dec     HL              ; ...of the "last" video cell
1014+ 0A49 EB                           ex      DE,HL           ; store address into DE
1015+ 0A4A 2A FD 52                     ld      HL,(CUR_POS)    ; retrieve original cursor position
1016+ 0A4D E5           RPTNLLSRC2:     push    HL
1017+ 0A4E CD B8 3F                     call    CMP16           ; check if at last position on screen (bottom right corner)
1018+ 0A51 E1                           pop     HL
1019+ 0A52 C8                           ret     Z               ; if yes, exit because these is nothing after
1020+ 0A53 23                           inc     HL              ; 1 more step forward
1021+ 0A54 CD 7D 06                     call    READ_VIDEO_LOC  ; read char of current position
1022+ 0A57 A7                           and     A               ; is it $00 (null char)?
1023+ 0A58 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1024+ 0A5A C9           CNTNULL2:       ret                     ; yes: found end of text, return to caller
1025+ 0A5B
1026+ 0A5B
1027+ 0A5B              ; ------------------------------------------------------------------------------
1028+ 0A5B                              ; this table contains the values of the offsets to be added to
1029+ 0A5B                              ; the starting address of the name table to find the correct
1030+ 0A5B                              ; value of the first cell of the corresponding row
1031+ 0A5B                              ; (by doing so, it's faster than doing a multipication)
1032+ 0A5B                              ; table for graphics 1 text mode: 32 cols
1033+ 0A5B 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1033+ 0A5F 40 00 60 00
1033+ 0A63 80 00 A0 00
1033+ 0A67 C0 00 E0 00
1034+ 0A6B 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1034+ 0A6F 40 01 60 01
1034+ 0A73 80 01 A0 01
1034+ 0A77 C0 01 E0 01
1035+ 0A7B 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1035+ 0A7F 40 02 60 02
1035+ 0A83 80 02 A0 02
1035+ 0A87 C0 02 E0 02
1036+ 0A8B                              ; table for pure text mode: 40 cols
1037+ 0A8B 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1037+ 0A8F 50 00 78 00
1037+ 0A93 A0 00 C8 00
1037+ 0A97 F0 00 18 01
1038+ 0A9B 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1038+ 0A9F 90 01 B8 01
1038+ 0AA3 E0 01 08 02
1038+ 0AA7 30 02 58 02
1039+ 0AAB 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1039+ 0AAF D0 02 F8 02
1039+ 0AB3 20 03 48 03
1039+ 0AB7 70 03 98 03
1040+ 0ABB
1041+ 0ABB              ; ------------------------------------------------------------------------------
1042+ 0ABB              ; reset VRAM
1043+ 0ABB AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1044+ 0ABC 67                           ld      H,A
1045+ 0ABD 6F                           ld      L,A             ; reset HL
1046+ 0ABE CD 5D 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1047+ 0AC1 06 40                        ld      B,$40           ; $40 pages of RAM...
1048+ 0AC3 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1049+ 0AC4 0D                           dec     C              ; VDP data mode
1050+ 0AC5 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1051+ 0AC7 14                           inc     D               ; next cell
1052+ 0AC8 00                           nop
1053+ 0AC9 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1054+ 0ACB 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1055+ 0ACD C9                           ret                     ; return to caller
1056+ 0ACE
1057+ 0ACE              ; clear video registers in SRAM
1058+ 0ACE 21 EC 52     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1059+ 0AD1 AF                           xor     A               ; $00 to clean the registers
1060+ 0AD2 06 45                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1061+ 0AD4 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1062+ 0AD5 23                           inc     HL              ; next register
1063+ 0AD6 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1064+ 0AD8 C9                           ret                     ; return to caller
1065+ 0AD9
1066+ 0AD9              ; ------------------------------------------------------------------------------
1067+ 0AD9              ; set a specific graphics mode, passed into reg. E
1068+ 0AD9 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1069+ 0ADB CB 23                        sla     E               ; multiply E by 8..
1070+ 0ADD CB 23                        sla     E               ; so that reg. E can point..
1071+ 0ADF CB 23                        sla     E               ; to the correct settings
1072+ 0AE1 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1073+ 0AE3 21 15 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1074+ 0AE6 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1075+ 0AE7 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1076+ 0AE9 0E 32                        ld      C,VDP_SET       ; VDP set
1077+ 0AEB 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1078+ 0AEC ED 51                        out     (C),D           ; send data to VDP
1079+ 0AEE ED 79                        out     (C),A           ; indicate the register to send data to
1080+ 0AF0 3C                           inc     A               ; next register
1081+ 0AF1 23                           inc     HL              ; next value
1082+ 0AF2 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1083+ 0AF4 C9                           ret
1084+ 0AF5
1085+ 0AF5              ; ------------------------------------------------------------------------------
1086+ 0AF5              LOADCHARSET:    ; reg. A contains the video mode
1087+ 0AF5                              ; reg. HL contains address of pattern table into VRAM
1088+ 0AF5 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1089+ 0AF7 CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1090+ 0AF9 0E 32                        ld      C,VDP_SET       ; load VDP address into C
1091+ 0AFB ED 69                        out     (C),L           ; send low byte of address
1092+ 0AFD ED 61                        out     (C),H           ; send high byte
1093+ 0AFF 0D                           dec     C              ; VDP data mode
1094+ 0B00 21 1B 40                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1095+ 0B03 A7                           and     A               ; is it text mode (A=0)?
1096+ 0B04 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1097+ 0B06 21 1B 48                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1098+ 0B09 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1099+ 0B0B 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1100+ 0B0C ED 79                        out     (C),A           ; write byte into VRAM
1101+ 0B0E 23                           inc     HL              ; inc byte pointer
1102+ 0B0F 15                           dec     D               ; 8 bytes sents (0 char)?
1103+ 0B10 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1104+ 0B12 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1105+ 0B14 C9                           ret                     ; return to caller
1106+ 0B15
1107+ 0B15              ;------------------------------------------------------------------------------
1108+ 0B15              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1109+ 0B15              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1110+ 0B15              ; COLOR TABLE:      color settings for chars/tiles
1111+ 0B15
1112+ 0B15                              ; VDP register settings for a text display
1113+ 0B15 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1114+ 0B16 D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1115+ 0B17 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1116+ 0B18 00                           defb    $00             ; reg.3: not used in text mode
1117+ 0B19 00                           defb    $00             ; reg.4: pattern table set to $0000
1118+ 0B1A 00                           defb    $00             ; reg.5: not used in text mode
1119+ 0B1B 00                           defb    $00             ; reg.6: not used in text mode
1120+ 0B1C F5                           defb    $f5             ; reg.7: white text on light blue background
1121+ 0B1D
1122+ 0B1D              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1123+ 0B1D 00                           defb    %00000000       ; reg.0: ext. video off
1124+ 0B1E C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1125+ 0B1F 06                           defb    $06             ; reg.2: name table address: $1800
1126+ 0B20 80                           defb    $80             ; reg.3: color table address: $2000
1127+ 0B21 00                           defb    $00             ; reg.4: pattern table address: $0000
1128+ 0B22 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1129+ 0B23 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1130+ 0B24 05                           defb    $05             ; reg.7: backdrop color (light blue)
1131+ 0B25
1132+ 0B25              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1133+ 0B25 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1134+ 0B26 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1135+ 0B27 06                           defb    $06             ; reg.2: name table addr.: $1800
1136+ 0B28 FF                           defb    $FF             ; reg.3: color table addr.: $2000
1137+ 0B29 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1138+ 0B2A 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1139+ 0B2B 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1140+ 0B2C 05                           defb    $05             ; reg.7: backdrop color: light blue
1141+ 0B2D
1142+ 0B2D              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1143+ 0B2D 00                           defb    %00000000       ; reg.0: ext. video dis.
1144+ 0B2E CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1145+ 0B2F 02                           defb    $02             ; reg.2: name table addr.: $0800
1146+ 0B30 00                           defb    $00             ; reg.3: don't care
1147+ 0B31 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1148+ 0B32 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1149+ 0B33 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1150+ 0B34 0F                           defb    $0F             ; reg.7: backdrop color (white)
1151+ 0B35
1152+ 0B35              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1153+ 0B35 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1154+ 0B36 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1155+ 0B37 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1156+ 0B38 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1157+ 0B39 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1158+ 0B3A 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1159+ 0B3B 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1160+ 0B3C 05                           defb    $05             ; reg.7: backdrop color: light blue
1161+ 0B3D
1162+ 0B3D              LM80CLOGO:      ; patterns to compose the splash screen logo
1163+ 0B3D                              ; 1st band
1164+ 0B3D 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1164+ 0B41 00 00 00 00
1164+ 0B45 00 00 00 00
1164+ 0B49 00 00 00 00
1164+ 0B4D 00 00 00 00
1164+ 0B51 00 00 00 00
1164+ 0B55 00 00 00 00
1164+ 0B59 00 00 00 00
1165+ 0B5D 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1165+ 0B61 0B 10 00 00
1165+ 0B65 00 00 00 00
1165+ 0B69 00 00 00 00
1165+ 0B6D 00 00 00 00
1165+ 0B71 00 00 00 00
1165+ 0B75 00 00 00 00
1165+ 0B79 00 00 00 00
1166+ 0B7D                              ; 2nd band
1167+ 0B7D 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1167+ 0B81 00 0C 00 00
1167+ 0B85 00 01 00 00
1167+ 0B89 00 14 00 00
1167+ 0B8D 06 05 06 15
1167+ 0B91 16 07 06 15
1167+ 0B95 16 07 06 01
1167+ 0B99 01 07 00 00
1168+ 0B9D 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1168+ 0BA1 00 0C 00 00
1168+ 0BA5 00 01 00 00
1168+ 0BA9 00 01 14 06
1168+ 0BAD 01 05 03 05
1168+ 0BB1 03 05 03 05
1168+ 0BB5 03 05 03 05
1168+ 0BB9 03 05 00 00
1169+ 0BBD                              ; 3rd band
1170+ 0BBD 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1170+ 0BC1 00 0C 00 00
1170+ 0BC5 00 01 00 00
1170+ 0BC9 00 01 01 01
1170+ 0BCD 01 05 09 14
1170+ 0BD1 13 08 03 05
1170+ 0BD5 13 05 03 05
1170+ 0BD9 00 00 00 00
1171+ 0BDD 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1171+ 0BE1 00 0C 00 00
1171+ 0BE5 00 01 00 00
1171+ 0BE9 00 01 00 08
1171+ 0BED 03 05 06 15
1171+ 0BF1 16 07 03 01
1171+ 0BF5 16 05 03 05
1171+ 0BF9 00 00 00 00
1172+ 0BFD                              ; 4th band
1173+ 0BFD 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1173+ 0C01 00 0C 00 00
1173+ 0C05 00 01 00 00
1173+ 0C09 00 01 00 00
1173+ 0C0D 03 05 03 05
1173+ 0C11 03 05 03 05
1173+ 0C15 03 05 03 05
1173+ 0C19 03 05 00 00
1174+ 0C1D 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1174+ 0C21 00 0C 00 00
1174+ 0C25 00 01 04 04
1174+ 0C29 00 01 00 00
1174+ 0C2D 03 05 09 14
1174+ 0C31 13 08 09 14
1174+ 0C35 13 08 09 01
1174+ 0C39 01 08 00 00
1175+ 0C3D                              ; 5th band
1176+ 0C3D 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1176+ 0C41 12 11 00 00
1176+ 0C45 00 00 00 00
1176+ 0C49 00 00 00 00
1176+ 0C4D 00 00 00 00
1176+ 0C51 00 00 00 00
1176+ 0C55 00 00 00 00
1176+ 0C59 00 00 00 00
1177+ 0C5D 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1177+ 0C61 00 00 00 00
1177+ 0C65 00 00 00 00
1177+ 0C69 00 00 00 00
1177+ 0C6D 00 00 00 00
1177+ 0C71 00 00 00 00
1177+ 0C75 00 00 00 00
1177+ 0C79 00 00 00 00
# file closed: ../include/vdp/vdp-1.3.asm
  73  0C7D
  74  0C7D              ; incude the latest version of the PSG module
  75  0C7D                  INCLUDE "../include/psg/psg-1.1.asm"
# file opened: ../include/psg/psg-1.1.asm
   1+ 0C7D              ; ------------------------------------------------------------------------------
   2+ 0C7D              ; LM80C - PSG ROUTINES - 1.1
   3+ 0C7D              ; ------------------------------------------------------------------------------
   4+ 0C7D              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C7D              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C7D              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C7D              ; kind of warranty: you can use them at your own risk.
   8+ 0C7D              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C7D              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C7D              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C7D              ; redistribuite them.
  12+ 0C7D              ; https://www.leonardomiliani.com
  13+ 0C7D              ;
  14+ 0C7D              ; Please support me by visiting the following links:
  15+ 0C7D              ; Main project page: https://www.leonardomiliani.com
  16+ 0C7D              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C7D              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C7D              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C7D              ; ------------------------------------------------------------------------------
  20+ 0C7D              ;
  21+ 0C7D              ; ------------------------------------------------------------------------------
  22+ 0C7D
  23+ 0C7D              ;------------------------------------------------------------------------------
  24+ 0C7D
  25+ 0C7D              ; configure the PSG
  26+ 0C7D 21 31 53     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0C80 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0C82 AF                           xor     A               ; reset A
  29+ 0C83 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0C84 23                           inc     HL              ; next register
  31+ 0C85 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0C87 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0C89 21 9B 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0C8C 16 00                        ld      D,$00           ; first register
  35+ 0C8E 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0C8F CD D5 0C                     call    SETSNDREG       ; select register
  37+ 0C92 7E                           ld      A,(HL)          ; load value
  38+ 0C93 CD DA 0C                     call    WRTSNDREG       ; write to register
  39+ 0C96 14                           inc     D               ; next register
  40+ 0C97 23                           inc     HL              ; next value
  41+ 0C98 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0C9A C9                           ret                     ; return to caller
  43+ 0C9B
  44+ 0C9B 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0C9F 00 00 00 BF
  45+ 0CA3 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0CA7 00 00 FF FF
  46+ 0CAB                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0CAB
  48+ 0CAB
  49+ 0CAB              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0CAB 21 C5 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0CAE C3 B4 0C                     jp      SENDSND
  52+ 0CB1 21 CD 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0CB4 C5           SENDSND:        push    BC
  54+ 0CB5 06 04                        ld      B,$04           ; 4 pairs
  55+ 0CB7 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0CB8 CD D5 0C                     call    SETSNDREG
  57+ 0CBB 23                           inc     HL              ; next cell
  58+ 0CBC 7E                           ld      A,(HL)          ; read value
  59+ 0CBD CD DA 0C                     call    WRTSNDREG
  60+ 0CC0 23                           inc     HL
  61+ 0CC1 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CC3 C1                           pop     BC
  63+ 0CC4 C9                           ret                     ; return to caller
  64+ 0CC5
  65+ 0CC5 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CC9 05 00 0A 0F
  66+ 0CCD 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CD1 0A 00 07 BF
  67+ 0CD5
  68+ 0CD5
  69+ 0CD5              ; select register on PSG
  70+ 0CD5 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CD7 ED 79                        out     (C),A           ; set register
  72+ 0CD9 C9                           ret                     ; return to caller
  73+ 0CDA
  74+ 0CDA              ; send data to PSG
  75+ 0CDA 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0CDC ED 79                        out     (C),A           ; send data
  77+ 0CDE C9                           ret                     ; return to caller
  78+ 0CDF
  79+ 0CDF              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0CDF              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0CDF              ; shut off the audio channel whose counter has reached 0.
  82+ 0CDF              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0CDF DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0CE1 DD 21 31 53                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0CE5 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0CE7 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0CE9 DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0CEC DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0CEF 7B                           ld      A,E             ; load E into A
  90+ 0CF0 B2                           or      D               ; check that DE=0
  91+ 0CF1 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0CF3 1B                           dec     DE              ; no, so decrement DE
  93+ 0CF4 7B                           ld      A,E             ; reload E into A...
  94+ 0CF5 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0CF8 DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0CFB B2                           or      D               ; ...do another check to see if DE=0
  97+ 0CFC 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0CFE                                                      ; if yes, let's shut down the corresponding channel
  99+ 0CFE                                                      ; to shut down a tone we disable it into the mixer
 100+ 0CFE                                                      ; then set 0 into its tone registers
 101+ 0CFE 16 07                        ld      D,$07           ; mixer register
 102+ 0D00 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0D02 ED 51                        out     (C),D           ; set mixer register
 104+ 0D04 ED 78                        in      A,(C)           ; load current value
 105+ 0D06 B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0D07 ED 51                        out     (C),D           ; select mixer register
 107+ 0D09 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0D0B ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0D0D 3E 03                        ld      A,$03           ; three channels
 110+ 0D0F 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0D10 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0D11 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0D13 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0D15 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0D17 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0D19 ED 69                        out     (C),L           ; write 0 into register
 117+ 0D1B 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0D1D 3C                           inc     A               ; next tone register
 119+ 0D1E ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0D20 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0D22 ED 69                        out     (C),L           ; write 0 into register
 122+ 0D24 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D26 DD 23                        inc     IX              ; ...next channel...
 124+ 0D28 CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D2A 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D2C DD E1                        pop     IX              ; restore IX
 127+ 0D2E C9                           ret                     ; return to caller
 128+ 0D2F
 129+ 0D2F              ; read a specific row of the keyboard matrix, set by A
 130+ 0D2F              ; return read into A
 131+ 0D2F C5           READKBLN:       push    BC              ; store BC
 132+ 0D30 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D32 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D34 ED 41                        out     (C),B           ; select reg #15
 135+ 0D36 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D38 ED 79                        out     (C),A           ; activate the row
 137+ 0D3A 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D3C 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D3E ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D40 ED 78                        in      A,(C)           ; read register #14
 141+ 0D42 C1                           pop     BC              ; retrieve BC
 142+ 0D43 C9                           ret
 143+ 0D44
 144+ 0D44              ; read the keyboard matrix to look for a key pressure
 145+ 0D44 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D46 06 07                        ld      B,$07           ; set register #7...
 147+ 0D48 ED 41                        out     (C),B           ; ...to work with
 148+ 0D4A ED 78                        in      A,(C)           ; read register #7
 149+ 0D4C CB FF                        set     7,A             ; port A set to output
 150+ 0D4E CB B7                        res     6,A             ; port B set to input
 151+ 0D50 ED 41                        out     (C),B           ; set register #7
 152+ 0D52 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D54 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D56                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D56 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D58 CD 2F 0D                     call    READKBLN        ; read row
 157+ 0D5B CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D5D 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D5F 21 3E 53                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D62 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D64 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D66 CD 2F 0D                     call    READKBLN        ; read ALT row
 163+ 0D69 CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D6B 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D6D 21 3E 53                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D70 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0D72 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0D74 CD 2F 0D                     call    READKBLN        ; read CTRL row
 169+ 0D77 CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0D79 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0D7B 21 3E 53                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0D7E 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0D80 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0D82 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0D84 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0D86 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0D88 ED 51                        out     (C),D           ; select reg. #15
 178+ 0D8A 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0D8C ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0D8E 5F                           ld      E,A             ; save current line into E
 181+ 0D8F 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0D91 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0D93 ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0D95 00                           nop
 185+ 0D96 ED 78                        in      A,(C)           ; read register #14
 186+ 0D98 FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0D9A 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0D9C                              ; check control keys
 189+ 0D9C 32 38 53                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0D9F 78                           ld      A,B             ; copy current row (B) into A
 191+ 0DA0 FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0DA2 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0DA4 3A 38 53                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0DA7 CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0DA9 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0DAB CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0DAD FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0DAF 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0DB1 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0DB3 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0DB5 3A 38 53                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0DB8 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0DBA CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0DBC 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0DBE CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0DC0 CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0DC2 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0DC4 CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0DC6 FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0DC8 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0DCA 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0DCB 0F                           rrca                    ; rotate right by 1
 213+ 0DCC 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0DCE AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0DCF 32 3A 53                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0DD2 32 3E 53                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0DD5 32 37 53                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0DD8 32 3B 53                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0DDB C9                           ret                     ; ...and leave
 220+ 0DDC 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0DDE 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0DDF CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0DE1 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0DE3 3A 3E 53                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0DE6 21 FF 0E                     ld      HL,KBMAP        ; normal keymap
 226+ 0DE9 FE 01                        cp      $01             ; SHIFT flag?
 227+ 0DEB 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0DED 21 3F 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0DF0 18 10                        jr      LOADMAP         ; and load it
 230+ 0DF2 FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0DF4 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0DF6 21 BF 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0DF9 18 07                        jr      LOADMAP         ; and load it
 234+ 0DFB FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0DFD 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0DFF 21 7F 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0E02 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0E03 48                           ld      C,B             ; move B into C and...
 239+ 0E04 CB 21                        sla     C               ; ...multiply it...
 240+ 0E06 CB 21                        sla     C               ; ...by 8 to find...
 241+ 0E08 CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0E0A 06 00                        ld      B,$00           ; reset B
 243+ 0E0C 09                           add     HL,BC           ; find the address of the current row
 244+ 0E0D 50                           ld      D,B             ; reset D
 245+ 0E0E 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0E0F 3A 3A 53                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0E12 BE                           cp      (HL)            ; is it the same key?
 248+ 0E13 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0E15 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0E17 2A DC 52                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0E1A ED 5B 3C 53                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0E1E 3A 3B 53                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0E21 FE 01                        cp      $01             ; is it initial pressure?
 254+ 0E23 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0E25 AF                           xor     A               ; clear Carry
 256+ 0E26 ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0E28 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0E2A 3A D2 51                     ld      A,(KEYDEL)
 259+ 0E2D 5F                           ld      E,A
 260+ 0E2E CD B8 3F                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E31 DA A6 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E34 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E36 32 3B 53                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E39 2A DC 52                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E3C 22 3C 53                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E3F 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E41 C3 63 0E                     jp      SENDKEY         ; send key
 268+ 0E44 AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E45 ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E47 16 00                        ld      D,$00
 271+ 0E49 3A D3 51                     ld      A,(AUTOKE)
 272+ 0E4C 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E4D CD B8 3F                     call    CMP16           ; check if interval is greater than delay
 274+ 0E50 DA A6 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E53 C3 34 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E56 AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E57 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E58 32 3B 53                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E5B ED 4B DC 52                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E5F ED 43 3C 53                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E63 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E64 32 3A 53                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E67 32 39 53                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E6A 32 FA 52                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E6D FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E6F 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E71 CD F4 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0E74 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0E76 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0E79 21 F7 0E                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0E7C BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0E7D CA AB 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0E80 0C                           inc     C               ; next FN key
 294+ 0E81 23                           inc     HL              ; next FN key code
 295+ 0E82 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0E84 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0E86 32 37 53                     ld      (KBDNPT),A      ; to keyboard
 298+ 0E89 3A F9 52                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0E8C B7                           or      A               ; is the print-on-video disabled?
 300+ 0E8D CA 96 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0E90 3A F7 52                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0E93 B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0E94 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0E96 AF           PUTCHRBUF:      xor     A
 305+ 0E97 32 37 53                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0E9A 3A 39 53                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0E9D CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0EA0 C3 A6 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0EA3 CD 4E 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0EA6 AF           LVKBRDCHK2:     xor     A
 311+ 0EA7 32 3E 53                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0EAA C9           LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0EAB                              ; manage FN keys
 314+ 0EAB 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0EAC 2A CE 51                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0EAF 23                           inc     HL              ; -1 means direct statement
 317+ 0EB0 7C                           ld      A,H
 318+ 0EB1 B5                           or      L
 319+ 0EB2 7A                           ld      A,D             ; retrieve char
 320+ 0EB3 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0EB5 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0EB6 87                           add     A,A
 323+ 0EB7 87                           add     A,A
 324+ 0EB8 87                           add     A,A
 325+ 0EB9 87                           add     A,A             ; FN key number * 16
 326+ 0EBA 4F                           ld      C,A             ; move it into C
 327+ 0EBB 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0EBD 21 D4 51                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0EC0 09                           add     HL,BC           ; get correct text address
 330+ 0EC1 06 10                        ld      B,$10           ; 16 chars
 331+ 0EC3 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0EC4 A7                           and     A               ; null char?
 333+ 0EC5 CA A6 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0EC8 57                           ld      D,A             ; pass char into D
 335+ 0EC9 3A F9 52                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0ECC B7                           or      A               ; is the print-on-video disabled?
 337+ 0ECD CA DD 0E                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0ED0 3A F7 52                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0ED3 B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0ED4 C4 EA 0E                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0ED7 23           CNTFNK:         inc     HL              ; next char
 342+ 0ED8 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0EDA C3 A6 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0EDD AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0EDE 32 37 53                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0EE1 7A                           ld      A,D             ; retrieve char
 347+ 0EE2 E5                           push    HL              ; store HL
 348+ 0EE3 CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0EE6 E1                           pop     HL              ; retrieve HL
 350+ 0EE7 C3 D7 0E                     jp      CNTFNK          ; repeat
 351+ 0EEA 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0EEB 32 FA 52                     ld      (CHR4VID),A     ; store char for printing
 353+ 0EEE 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0EF0 32 37 53                     ld      (KBDNPT),A      ; to keyboard
 355+ 0EF3 CD 4E 07                     call    CHAR2VID        ; print on screen
 356+ 0EF6 C9                           ret                     ; return to caller
 357+ 0EF7
 358+ 0EF7
 359+ 0EF7              ;-----------------------------------------------------------------------
 360+ 0EF7 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0EFB 06 16 17 18
 361+ 0EFF              ;-----------------------------------------------------------------------
 362+ 0EFF              ; key codes
 363+ 0EFF 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0F03 20 10 71 32
 364+ 0F07 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0F0B 7A 73 65 34
 365+ 0F0F 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0F13 63 66 74 36
 366+ 0F17 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0F1B 62 68 75 38
 367+ 0F1F 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0F23 6D 6B 6F 30
 368+ 0F27 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0F2B 2E 3A 2D 1E
 369+ 0F2F 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F33 1B 3D 2B 1D
 370+ 0F37 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F3B 01 02 04 18
 371+ 0F3F
 372+ 0F3F              ; shifted codes - not all the keys have the shifted version
 373+ 0F3F 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F43 20 10 51 22
 374+ 0F47 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F4B 5A 53 45 24
 375+ 0F4F 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F53 43 46 54 26
 376+ 0F57 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F5B 42 48 55 28
 377+ 0F5F 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F63 4D 4B 4F 5E
 378+ 0F67 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F6B 3E 5B 5F 1E
 379+ 0F6F 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0F73 1B C6 2B 1D
 380+ 0F77 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0F7B 05 06 16 17
 381+ 0F7F
 382+ 0F7F              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0F7F 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0F83 20 10 DE C4
 384+ 0F87 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0F8B 83 82 A5 34
 385+ 0F8F 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0F93 9D A3 A8 36
 386+ 0F97 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0F9B 9E AC D5 38
 387+ 0F9F 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0FA3 A0 D7 87 C3
 388+ 0FA7 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0FAB C0 7B 90 1E
 389+ 0FAF 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0FB3 1B D1 94 1D
 390+ 0FB7 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0FBB 05 06 16 17
 391+ 0FBF
 392+ 0FBF              ; CTRL codes - not all the keys have the control-ed version
 393+ 0FBF 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0FC3 20 10 9A 32
 394+ 0FC7 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0FCB 98 96 99 34
 395+ 0FCF 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 0FD3 B1 AF A5 36
 396+ 0FD7 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 0FDB B3 A9 A7 38
 397+ 0FDF 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 0FE3 AB B5 A4 30
 398+ 0FE7 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 0FEB 2E 3A BA 1E
 399+ 0FEF 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 0FF3 1B D4 B9 1D
 400+ 0FF7 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 0FFB 01 02 04 18
# file closed: ../include/psg/psg-1.1.asm
  76  0FFF
  77  0FFF              ; include the latest version of the LM80C 64K BASIC interpreter
  78  0FFF                  INCLUDE "../include/basic/basic-1.03.asm"
# file opened: ../include/basic/basic-1.03.asm
   1+ 0FFF              ; ------------------------------------------------------------------------------
   2+ 0FFF              ; LM80C BASIC (32K/64K) - R3.17
   3+ 0FFF              ; ------------------------------------------------------------------------------
   4+ 0FFF              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0FFF              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0FFF              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0FFF              ; kind of warranty: you can use them at your own risk.
   8+ 0FFF              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0FFF              ; maintain the copyright notices, include this advice and the note to the
  10+ 0FFF              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0FFF              ; redistribuite them.
  12+ 0FFF              ; https://www.leonardomiliani.com
  13+ 0FFF              ;
  14+ 0FFF              ; Please support me by visiting the following links:
  15+ 0FFF              ; Main project page: https://www.leonardomiliani.com
  16+ 0FFF              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0FFF              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0FFF              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0FFF              ; ------------------------------------------------------------------------------
  20+ 0FFF              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 0FFF              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 0FFF              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 0FFF
  24+ 0FFF
  25+ 0FFF              ;------------------------------------------------------------------------------
  26+ 0FFF              ;  L M 8 0 C   B A S I C
  27+ 0FFF              ;------------------------------------------------------------------------------
  28+ 0FFF
  29+ 0FFF              ; GENERAL EQUATES
  30+ 0FFF
  31+ 0FFF              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 0FFF              CTRLC           equ     $03             ; Control "C"
  33+ 0FFF              CTRLG           equ     $07             ; Control "G"
  34+ 0FFF              BKSP            equ     $08             ; Back space
  35+ 0FFF              LF              equ     $0A             ; Line feed
  36+ 0FFF              CS              equ     $0C             ; Clear screen
  37+ 0FFF              CR              equ     $0D             ; Carriage return
  38+ 0FFF              CTRLO           equ     $0F             ; Control "O"
  39+ 0FFF              CTRLQ           equ     $11             ; Control "Q"
  40+ 0FFF              CTRLR           equ     $12             ; Control "R"
  41+ 0FFF              CTRLS           equ     $13             ; Control "S"
  42+ 0FFF              CTRLU           equ     $15             ; Control "U"
  43+ 0FFF              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 0FFF              ESC             equ     $1B             ; Escape
  45+ 0FFF              SPC             equ     $20             ; Space
  46+ 0FFF              DEL             equ     $7F             ; Delete
  47+ 0FFF              INSRT           equ     $1A             ; Insert Key
  48+ 0FFF              ; cursor ASCII codes
  49+ 0FFF              CRSLFT          equ     $1C             ; cursor left
  50+ 0FFF              CRSRGT          equ     $1D             ; cursor right
  51+ 0FFF              CRSUP           equ     $1E             ; cursor up
  52+ 0FFF              CRSDN           equ     $1F             ; cursor down
  53+ 0FFF
  54+ 0FFF
  55+ 0FFF              ;-------------------------------------------------------------------------
  56+ 0FFF              ; BASIC ERROR MESSAGES
  57+ 0FFF              ; the interpreter looks for a single-byte code in the following list,
  58+ 0FFF              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 0FFF              ; find where to retrieve the message text in "ERRORS"
  60+ 0FFF
  61+ 0FFF              ; BASIC ERROR CODE VALUES
  62+ 0FFF              ; These values act as an offset to point to the error message into the error table
  63+ 0FFF              ; must be incremented by 2 because they point to a word address jump
  64+ 0FFF              NF              equ     $00     ; NEXT without FOR
  65+ 0FFF              SN              equ     $02     ; Syntax error
  66+ 0FFF              RG              equ     $04     ; RETURN without GOSUB
  67+ 0FFF              OD              equ     $06     ; Out of DATA
  68+ 0FFF              FC              equ     $08     ; Function call error
  69+ 0FFF              OV              equ     $0A     ; Overflow
  70+ 0FFF              OM              equ     $0C     ; Out of memory
  71+ 0FFF              UL              equ     $0E     ; Undefined line number
  72+ 0FFF              BS              equ     $10     ; Bad subscript
  73+ 0FFF              DD              equ     $12     ; Re-Dimensioned array
  74+ 0FFF              DZ              equ     $14     ; Division by zero (/0)
  75+ 0FFF              ID              equ     $16     ; Illegal direct
  76+ 0FFF              TM              equ     $18     ; Type mis-match
  77+ 0FFF              OS              equ     $1A     ; Out of string space
  78+ 0FFF              LS              equ     $1C     ; String too long
  79+ 0FFF              ST              equ     $1E     ; String formula too complex
  80+ 0FFF              CN              equ     $20     ; Can't continue
  81+ 0FFF              UF              equ     $22     ; Undefined FN function
  82+ 0FFF              MO              equ     $24     ; Missing operand
  83+ 0FFF              HX              equ     $26     ; HEX error
  84+ 0FFF              BN              equ     $28     ; BIN error
  85+ 0FFF              GM              equ     $2A     ; No Graphics Mode
  86+ 0FFF              SC              equ     $2C     ; Serial configuration
  87+ 0FFF              SA              equ     $2E     ; Serial port already open
  88+ 0FFF              SO              equ     $30     ; Serial buffer overrun
  89+ 0FFF              HP              equ     $32     ; HELP call
  90+ 0FFF
  91+ 0FFF              ; BASIC ERROR POINTER TABLE
  92+ 0FFF              ERRTBL: equ $
  93+ 0FFF 33 10        NFPTR:  defw    NFMSG
  94+ 1001 44 10        SNPTR:  defw    SNMSG
  95+ 1003 4B 10        RGPTR:  defw    RGMSG
  96+ 1005 60 10        ODPTR:  defw    ODMSG
  97+ 1007 6C 10        FCPTR:  defw    FCMSG
  98+ 1009 82 10        OVPTR:  defw    OVMSG
  99+ 100B 8B 10        OMPTR:  defw    OMMSG
 100+ 100D 99 10        ULPTR:  defw    ULMSG
 101+ 100F A8 10        BSPTR:  defw    BSMSG
 102+ 1011 B6 10        DDPTR:  defw    DDMSG
 103+ 1013 CB 10        DZPTR:  defw    DZMSG
 104+ 1015 DC 10        IDPTR:  defw    IDMSG
 105+ 1017 EB 10        TMPTR:  defw    TMMSG
 106+ 1019 FA 10        OSPTR:  defw    OSMSG
 107+ 101B 0E 11        LSPTR:  defw    LSMSG
 108+ 101D 1E 11        STPTR:  defw    STMSG
 109+ 101F 39 11        CNPTR:  defw    CNMSG
 110+ 1021 48 11        UFPTR:  defw    UFMSG
 111+ 1023 5E 11        MOPTR:  defw    MOMSG
 112+ 1025 6E 11        HXPTR:  defw    HXMSG
 113+ 1027 79 11        BNPTR:  defw    BNMSG
 114+ 1029 84 11        GMPRT:  defw    GMMSG
 115+ 102B 95 11        SCPTR:  defw    SCMSG
 116+ 102D AA 11        SAPTR:  defw    SAMSG
 117+ 102F C3 11        SOPTR:  defw    SOMSG
 118+ 1031 D9 11        HPPTR:  defw    HPMSG
 119+ 1033
 120+ 1033              ; BASIC ERROR MESSAGE LIST
 121+ 1033              ERRORS  equ $
 122+ 1033 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 122+ 1037 20 57 69 74
 122+ 103B 68 6F 75 74
 122+ 103F 20 46 4F 52
 122+ 1043 00
 123+ 1044 53 79 6E 74  SNMSG:  defb    "Syntax",0
 123+ 1048 61 78 00
 124+ 104B 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 124+ 104F 52 4E 20 77
 124+ 1053 69 74 68 6F
 124+ 1057 75 74 20 47
 124+ 105B 4F 53 55 42
 124+ 105F 00
 125+ 1060 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 125+ 1064 6F 66 20 44
 125+ 1068 41 54 41 00
 126+ 106C 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 126+ 1070 67 61 6C 20
 126+ 1074 46 75 6E 63
 126+ 1078 74 69 6F 6E
 126+ 107C 20 43 61 6C
 126+ 1080 6C 00
 127+ 1082 4F 76 65 72  OVMSG:  defb    "Overflow",0
 127+ 1086 66 6C 6F 77
 127+ 108A 00
 128+ 108B 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 128+ 108F 6F 66 20 4D
 128+ 1093 65 6D 6F 72
 128+ 1097 79 00
 129+ 1099 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 129+ 109D 66 69 6E 65
 129+ 10A1 64 20 4C 69
 129+ 10A5 6E 65 00
 130+ 10A8 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 130+ 10AC 53 75 62 73
 130+ 10B0 63 72 69 70
 130+ 10B4 74 00
 131+ 10B6 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 131+ 10BA 69 6D 65 6E
 131+ 10BE 73 69 6F 6E
 131+ 10C2 65 64 20 41
 131+ 10C6 72 72 61 79
 131+ 10CA 00
 132+ 10CB 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 132+ 10CF 73 69 6F 6E
 132+ 10D3 20 62 79 20
 132+ 10D7 5A 65 72 6F
 132+ 10DB 00
 133+ 10DC 49 6C 6C 65  IDMSG:  defb    "Illegal Direct",0
 133+ 10E0 67 61 6C 20
 133+ 10E4 44 69 72 65
 133+ 10E8 63 74 00
 134+ 10EB 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 134+ 10EF 20 4D 69 73
 134+ 10F3 2D 6D 61 74
 134+ 10F7 63 68 00
 135+ 10FA 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 135+ 10FE 6F 66 20 53
 135+ 1102 74 72 69 6E
 135+ 1106 67 20 53 70
 135+ 110A 61 63 65 00
 136+ 110E 53 74 72 69  LSMSG:  defb    "String Too Long",0
 136+ 1112 6E 67 20 54
 136+ 1116 6F 6F 20 4C
 136+ 111A 6F 6E 67 00
 137+ 111E 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 137+ 1122 6E 67 20 46
 137+ 1126 6F 72 6D 75
 137+ 112A 6C 61 20 54
 137+ 112E 6F 6F 20 43
 137+ 1132 6F 6D 70 6C
 137+ 1136 65 78 00
 138+ 1139 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 138+ 113D 74 20 43 6F
 138+ 1141 6E 74 69 6E
 138+ 1145 75 65 00
 139+ 1148 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 139+ 114C 66 69 6E 65
 139+ 1150 64 20 46 4E
 139+ 1154 20 46 75 6E
 139+ 1158 63 74 69 6F
 139+ 115C 6E 00
 140+ 115E 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 140+ 1162 69 6E 67 20
 140+ 1166 4F 70 65 72
 140+ 116A 61 6E 64 00
 141+ 116E 48 45 58 20  HXMSG:  defb    "HEX Format",0
 141+ 1172 46 6F 72 6D
 141+ 1176 61 74 00
 142+ 1179 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 142+ 117D 46 6F 72 6D
 142+ 1181 61 74 00
 143+ 1184 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 143+ 1188 72 61 70 68
 143+ 118C 69 63 73 20
 143+ 1190 4D 6F 64 65
 143+ 1194 00
 144+ 1195 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 144+ 1199 61 6C 20 43
 144+ 119D 6F 6E 66 69
 144+ 11A1 67 75 72 61
 144+ 11A5 74 69 6F 6E
 144+ 11A9 00
 145+ 11AA 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 145+ 11AE 61 6C 20 50
 145+ 11B2 6F 72 74 20
 145+ 11B6 41 6C 72 65
 145+ 11BA 61 64 79 20
 145+ 11BE 4F 70 65 6E
 145+ 11C2 00
 146+ 11C3 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 146+ 11C7 61 6C 20 42
 146+ 11CB 75 66 66 65
 146+ 11CF 72 20 4F 76
 146+ 11D3 65 72 72 75
 146+ 11D7 6E 00
 147+ 11D9 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 147+ 11DD 20 43 61 6C
 147+ 11E1 6C 00
 148+ 11E3
 149+ 11E3
 150+ 11E3              ;-----------------------------------------------------------------------------
 151+ 11E3              ; STARTING POINTS FOR BASIC BOOT
 152+ 11E3              ; COLD: reset every memory pointer, acting as a power-up boot
 153+ 11E3              ; WARM: preserve program in memory, keeping every current pointer
 154+ 11E3
 155+ 11E3 C3 E9 11     COLD:   jp      STARTB          ; Jump for cold start
 156+ 11E6 C3 97 12     WARM:   jp      WARMST          ; Jump for warm start
 157+ 11E9
 158+ 11E9 C3 F0 11     STARTB: jp      CSTART          ; Jump to initialise
 159+ 11EC A4 1C                defw    DEINT           ; Get integer -32768 to 32767
 160+ 11EE 61 24                defw    ABPASS          ; Return integer in AB
 161+ 11F0 21 7D 51     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 162+ 11F3 F9                   ld      SP,HL           ; Set up a temporary stack
 163+ 11F4 C3 A3 3F             jp      INITST          ; Go to initialise
 164+ 11F7
 165+ 11F7 21 64 15     INIT:   ld      HL,INITAB       ; Initialise workspace
 166+ 11FA 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 167+ 11FD 11 7D 51             ld      DE,WRKSPC       ; Into workspace RAM
 168+ 1200 ED B0                ldir                    ; Copy data
 169+ 1202 EB                   ex      DE,HL           ; Copy DE into HL
 170+ 1203 F9                   ld      SP,HL           ; Temporary stack
 171+ 1204 CD 17 18             call    CLREG           ; Clear registers and stack
 172+ 1207 CD BB 1E             call    PRNTCRLF        ; Output CRLF
 173+ 120A 32 B0 52             ld      (BUFFER+88+1),A ; Mark end of buffer
 174+ 120D 32 66 53             ld      (PROGST),A      ; Initialise program area
 175+ 1210 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 176+ 1212 21 FE 12     MSIZE:  ld      HL,MEMMSG       ; Point to message
 177+ 1215 CD 7F 25             call    PRS             ; Output "Memory size"
 178+ 1218 CD 34 18             call    PROMPT          ; Get input with '?'
 179+ 121B CD 1A 09             call    CURSOR_ON       ; enable cursor
 180+ 121E CD EE 1B             call    GETCHR          ; Get next character
 181+ 1221 B7                   or      A               ; Set flags
 182+ 1222 C2 3A 12             jp      NZ,TSTMEM       ; If number - Test if RAM there
 183+ 1225 21 CA 53     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 184+ 1228 23           MLOOP:  inc     HL              ; Next byte
 185+ 1229 7C                   ld      A,H             ; Above address FFFF ?
 186+ 122A B5                   or      L
 187+ 122B CA 4C 12             jp      Z,SETTOP        ; Yes - 64K RAM
 188+ 122E 7E                   ld      A,(HL)          ; Get contents
 189+ 122F 47                   ld      B,A             ; Save it
 190+ 1230 2F                   cpl                     ; Flip all bits
 191+ 1231 77                   ld      (HL),A          ; Put it back
 192+ 1232 BE                   cp      (HL)            ; RAM there if same
 193+ 1233 70                   ld      (HL),B          ; Restore old contents
 194+ 1234 CA 28 12             jp      Z,MLOOP         ; If RAM - test next byte
 195+ 1237 C3 4C 12             jp      SETTOP          ; Top of RAM found
 196+ 123A
 197+ 123A CD BE 1C     TSTMEM: call    ATOH            ; Get high memory into DE
 198+ 123D B7                   or      A               ; Set flags on last byte
 199+ 123E C2 CB 16             jp      NZ,SNERR        ; ?SN Error if bad character
 200+ 1241 EB                   ex      DE,HL           ; Address into HL
 201+ 1242 2B                   dec     HL              ; Back one byte
 202+ 1243 3E D9                ld      A,%11011001     ; Test byte
 203+ 1245 46                   ld      B,(HL)          ; Get old contents
 204+ 1246 77                   ld      (HL),A          ; Load test byte
 205+ 1247 BE                   cp      (HL)            ; RAM there if same
 206+ 1248 70                   ld      (HL),B          ; Restore old contents
 207+ 1249 C2 12 12             jp      NZ,MSIZE        ; Ask again if no RAM
 208+ 124C
 209+ 124C CD 2F 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 210+ 124F 2B                   dec     HL              ; Back one byte
 211+ 1250 11 C9 53             ld      DE,STLOOK-1     ; See if enough RAM
 212+ 1253 CD A7 19             call    CPDEHL          ; Compare DE with HL
 213+ 1256 DA 12 12             jp      C,MSIZE         ; Ask again if not enough RAM
 214+ 1259 3A 42 53             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 215+ 125C 1F                   rra                     ; is DOS disabled?
 216+ 125D 30 04                jr      NC,NODOS        ; yes, so jump over
 217+ 125F 11 00 FE             ld      DE,0-512        ; no, so reserve 512 bytes on top of RAM...
 218+ 1262 19                   add     HL,DE           ; ...for I/O buffer
 219+ 1263 11 9C FF     NODOS:  ld      DE,0-100        ; 100 Bytes string space
 220+ 1266 22 B5 52             ld      (LSTRAM),HL     ; Save last available RAM
 221+ 1269 19                   add     HL,DE           ; Allocate string space
 222+ 126A 22 CC 51             ld      (STRSPC),HL     ; Save string space
 223+ 126D CD F2 17             call    CLRPTR          ; Clear program area
 224+ 1270 2A CC 51             ld      HL,(STRSPC)     ; Get end of memory
 225+ 1273 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 226+ 1276 19                   add     HL,DE           ; Adjust HL
 227+ 1277 11 66 53             ld      DE,PROGST       ; Start of program text
 228+ 127A 7D                   ld      A,L             ; Get LSB
 229+ 127B 93                   sub     E               ; Adjust it
 230+ 127C 6F                   ld      L,A             ; Re-save
 231+ 127D 7C                   ld      A,H             ; Get MSB
 232+ 127E 9A                   sbc     A,D             ; Adjust it
 233+ 127F 67                   ld      H,A             ; Re-save
 234+ 1280 E5                   push    HL              ; Save bytes free
 235+ 1281 21 BD 12             ld      HL,SIGNON       ; Sign-on message
 236+ 1284 CD 7F 25             call    PRS             ; Output string
 237+ 1287 21 A6 12             ld      HL,BLNSPC       ; Empty space
 238+ 128A CD 7F 25             call    PRS             ; Output string
 239+ 128D E1                   pop     HL              ; Get bytes free back
 240+ 128E CD 1E 30             call    PRNTHL          ; Output amount of free memory
 241+ 1291 21 AF 12             ld      HL,BFREE        ; " Bytes free" message
 242+ 1294 CD 7F 25             call    PRS             ; Output string
 243+ 1297
 244+ 1297 31 5C 52     WARMST: ld      SP,STACK        ; Temporary stack
 245+ 129A CD 17 18     BRKRET: call    CLREG           ; Clear registers and stack
 246+ 129D CD 3A 3D             call    RESFN           ; reset FN keys and auto-repeat
 247+ 12A0 CD 1A 09             call    CURSOR_ON       ; enable cursor
 248+ 12A3 C3 25 17             jp      PRNTOK          ; Go to get command line
 249+ 12A6
 250+ 12A6 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 250+ 12AA 20 20 20 20
 250+ 12AE 00
 251+ 12AF 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 251+ 12B3 65 73 20 66
 251+ 12B7 72 65 65 0D
 251+ 12BB 0D 00
 252+ 12BD
 253+ 12BD 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.17 ",251,"2021 L.Miliani"
 253+ 12C1 43 20 42 41
 253+ 12C5 53 49 43 20
 253+ 12C9 33 2E 31 37
 253+ 12CD 20 FB 32 30
 253+ 12D1 32 31 20 4C
 253+ 12D5 2E 4D 69 6C
 253+ 12D9 69 61 6E 69
 254+ 12DD 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 254+ 12E1 20 42 41 53
 254+ 12E5 49 43 20 34
 254+ 12E9 2E 37 20 20
 254+ 12ED FB 31 39 37
 254+ 12F1 38 20 4D 69
 254+ 12F5 63 72 6F 73
 254+ 12F9 6F 66 74 0D
 254+ 12FD 00
 255+ 12FE
 256+ 12FE 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 256+ 1302 72 79 20 74
 256+ 1306 6F 70 00
 257+ 1309
 258+ 1309              ; The following list reports all the functions supported by the interpreter.
 259+ 1309              ; To add a custom function, the user must first insert the reserved word here,
 260+ 1309              ; then into the list of the reserved words below, and finally must increment the
 261+ 1309              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 262+ 1309              ; function.
 263+ 1309
 264+ 1309              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 265+ 1309              ; this list must be coherent with the tokens' functions list. This means that every
 266+ 1309              ; entry here must have the corresponding entry in the tokens list.
 267+ 1309 93 2E        FNCTAB: defw    SGN
 268+ 130B 29 24                defw    TMR         ; added by Leonardo Miliani
 269+ 130D 57 2F                defw    INT
 270+ 130F A9 2E                defw    ABS_        ; _ necessary for assembler warning
 271+ 1311 83 51                defw    USR
 272+ 1313 3F 24                defw    FRE
 273+ 1315 BA 28                defw    INP
 274+ 1317 6D 24                defw    POS
 275+ 1319 1D 31                defw    SQR
 276+ 131B FC 31                defw    RND
 277+ 131D E7 2C                defw    LOG
 278+ 131F 6B 31                defw    EXP
 279+ 1321 71 32                defw    COS
 280+ 1323 77 32                defw    SIN
 281+ 1325 D8 32                defw    TAN
 282+ 1327 ED 32                defw    ATN
 283+ 1329 96 29                defw    PEEK
 284+ 132B 58 33                defw    DEEK
 285+ 132D 9D 29                defw    VPEEK       ; added by Leonardo Miliani
 286+ 132F 6C 2B                defw    VSTAT       ; added by Leonardo Miliani
 287+ 1331 77 2B                defw    SSTAT       ; added by Leonardo Miliani
 288+ 1333 8B 2B                defw    INKEY       ; added by Leonardo Miliani
 289+ 1335 AF 36                defw    POINT       ; added by Leonardo Miliani
 290+ 1337 51 27                defw    INSTR       ; added by Leonardo Miliani
 291+ 1339 F1 26                defw    LEN
 292+ 133B 09 25                defw    STR
 293+ 133D 81 28                defw    VAL
 294+ 133F 00 27                defw    ASC
 295+ 1341 11 27                defw    CHR
 296+ 1343 9E 3E                defw    HEX         ; added by Grant Searle
 297+ 1345 2F 3F                defw    BIN         ; added by Grant Searle
 298+ 1347 21 27                defw    LEFT
 299+ 1349 47 28                defw    RIGHT
 300+ 134B 51 28                defw    MID
 301+ 134D
 302+ 134D              ; RESERVED WORD LIST
 303+ 134D              ; Here are all the reserved words used by the interpreter
 304+ 134D              ; To add custom functions/commands, the user must insert the keyword
 305+ 134D              ; in this list, following the schematic
 306+ 134D C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 307+ 1350 C6 4F 52             defb    'F'+$80,"OR"
 308+ 1353 CE 45 58 54          defb    'N'+$80,"EXT"
 309+ 1357 C4 41 54 41          defb    'D'+$80,"ATA"
 310+ 135B C9 4E 50 55          defb    'I'+$80,"NPUT"
 310+ 135F 54
 311+ 1360 C4 49 4D             defb    'D'+$80,"IM"
 312+ 1363 D2 45 41 44          defb    'R'+$80,"EAD"
 313+ 1367 CC 45 54             defb    'L'+$80,"ET"
 314+ 136A C7 4F 54 4F          defb    'G'+$80,"OTO"
 315+ 136E D2 55 4E             defb    'R'+$80,"UN"
 316+ 1371 C9 46                defb    'I'+$80,"F"
 317+ 1373 D2 45 53 54          defb    'R'+$80,"ESTORE"
 317+ 1377 4F 52 45
 318+ 137A C7 4F 53 55          defb    'G'+$80,"OSUB"
 318+ 137E 42
 319+ 137F D2 45 54 55          defb    'R'+$80,"ETURN"
 319+ 1383 52 4E
 320+ 1385 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 321+ 1388 D3 54 4F 50          defb    'S'+$80,"TOP"
 322+ 138C CF 55 54             defb    'O'+$80,"UT"
 323+ 138F CF 4E                defb    'O'+$80,"N"
 324+ 1391 C6 49 4C 45          defb    'F'+$80,"ILES"
 324+ 1395 53
 325+ 1396 C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 325+ 139A 45
 326+ 139B D7 41 49 54          defb    'W'+$80,"AIT"
 327+ 139F C4 45 46             defb    'D'+$80,"EF"
 328+ 13A2 D0 4F 4B 45          defb    'P'+$80,"OKE"
 329+ 13A6 C4 4F 4B 45          defb    'D'+$80,"OKE"
 330+ 13AA D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 330+ 13AE 45
 331+ 13AF D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 332+ 13B3 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 333+ 13B7 D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 333+ 13BB 45 4E
 334+ 13BD CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 334+ 13C1 54 45
 335+ 13C3 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 335+ 13C7 44
 336+ 13C8 D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 336+ 13CC 4D 45
 337+ 13CE D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 337+ 13D2 45
 338+ 13D3 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 338+ 13D7 52
 339+ 13D8 D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 340+ 13DC C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 341+ 13E0 C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 341+ 13E4 4C 45
 342+ 13E6 D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 342+ 13EA 54
 343+ 13EB D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 343+ 13EF 41 4C
 344+ 13F1 C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 345+ 13F5 C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 346+ 13F8 CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 347+ 13FB CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 348+ 13FE C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 348+ 1402 4E 54
 349+ 1404 D7 49 44 54          defb    'W'+$80,"IDTH"
 349+ 1408 48
 350+ 1409 D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 351+ 140C D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 351+ 1410 54
 352+ 1411 C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 353+ 1415 D0 52 49 4E          defb    'P'+$80,"RINT"
 353+ 1419 54
 354+ 141A C3 4F 4E 54          defb    'C'+$80,"ONT"
 355+ 141E CC 49 53 54          defb    'L'+$80,"IST"
 356+ 1422 C3 4C 45 41          defb    'C'+$80,"LEAR"
 356+ 1426 52
 357+ 1427 CC 4F 41 44          defb    'L'+$80,"OAD"
 358+ 142B D3 41 56 45          defb    'S'+$80,"AVE"
 359+ 142F CE 45 57             defb    'N'+$80,"EW"
 360+ 1432 D4 41 42 28          defb    'T'+$80,"AB("
 361+ 1436 D4 4F                defb    'T'+$80,"O"
 362+ 1438 C6 4E                defb    'F'+$80,"N"
 363+ 143A D3 50 43 28          defb    'S'+$80,"PC("
 364+ 143E D4 48 45 4E          defb    'T'+$80,"HEN"
 365+ 1442 CE 4F 54             defb    'N'+$80,"OT"
 366+ 1445 D3 54 45 50          defb    'S'+$80,"TEP"
 367+ 1449                      ; from here: operators
 368+ 1449 AB                   defb    '+'+$80
 369+ 144A AD                   defb    '-'+$80
 370+ 144B AA                   defb    '*'+$80
 371+ 144C AF                   defb    '/'+$80
 372+ 144D A5                   defb    '%'+$80
 373+ 144E A3                   defb    '#'+$80
 374+ 144F DE                   defb    '^'+$80
 375+ 1450 C1 4E 44             defb    'A'+$80,"ND"
 376+ 1453 D8 4F 52             defb    'X'+$80,"OR"
 377+ 1456 CF 52                defb    'O'+$80,"R"
 378+ 1458 BE                   defb    '>'+$80
 379+ 1459 BD                   defb    '='+$80
 380+ 145A BC                   defb    '<'+$80
 381+ 145B
 382+ 145B                      ; from here there are the tokens' FUNCTIONS list
 383+ 145B                      ; this list must be coherent with the functions list above
 384+ 145B D3 47 4E             defb    'S'+$80,"GN"
 385+ 145E D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 386+ 1461 C9 4E 54             defb    'I'+$80,"NT"
 387+ 1464 C1 42 53             defb    'A'+$80,"BS"
 388+ 1467 D5 53 52             defb    'U'+$80,"SR"
 389+ 146A C6 52 45             defb    'F'+$80,"RE"
 390+ 146D C9 4E 50             defb    'I'+$80,"NP"
 391+ 1470 D0 4F 53             defb    'P'+$80,"OS"
 392+ 1473 D3 51 52             defb    'S'+$80,"QR"
 393+ 1476 D2 4E 44             defb    'R'+$80,"ND"
 394+ 1479 CC 4F 47             defb    'L'+$80,"OG"
 395+ 147C C5 58 50             defb    'E'+$80,"XP"
 396+ 147F C3 4F 53             defb    'C'+$80,"OS"
 397+ 1482 D3 49 4E             defb    'S'+$80,"IN"
 398+ 1485 D4 41 4E             defb    'T'+$80,"AN"
 399+ 1488 C1 54 4E             defb    'A'+$80,"TN"
 400+ 148B D0 45 45 4B          defb    'P'+$80,"EEK"
 401+ 148F C4 45 45 4B          defb    'D'+$80,"EEK"
 402+ 1493 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 402+ 1497 4B
 403+ 1498 D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 403+ 149C 54
 404+ 149D D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 404+ 14A1 54
 405+ 14A2 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 405+ 14A6 59
 406+ 14A7 D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 406+ 14AB 54
 407+ 14AC C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 407+ 14B0 52
 408+ 14B1 CC 45 4E             defb    'L'+$80,"EN"
 409+ 14B4 D3 54 52 24          defb    'S'+$80,"TR$"
 410+ 14B8 D6 41 4C             defb    'V'+$80,"AL"
 411+ 14BB C1 53 43             defb    'A'+$80,"SC"
 412+ 14BE C3 48 52 24          defb    'C'+$80,"HR$"
 413+ 14C2 C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 414+ 14C6 C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 415+ 14CA CC 45 46 54          defb    'L'+$80,"EFT$"
 415+ 14CE 24
 416+ 14CF D2 49 47 48          defb    'R'+$80,"IGHT$"
 416+ 14D3 54 24
 417+ 14D5 CD 49 44 24          defb    'M'+$80,"ID$"
 418+ 14D9 80                   defb    $80                     ; End-of-list marker
 419+ 14DA
 420+ 14DA              ; KEYWORD ADDRESS TABLE
 421+ 14DA              ; this list must be coherent with the commands'
 422+ 14DA              ; tokens list above
 423+ 14DA 38 1C        WORDTB: defw    PEND
 424+ 14DC 35 1B                defw    FOR
 425+ 14DE 2C 20                defw    NEXT
 426+ 14E0 97 1D                defw    DATA
 427+ 14E2 31 1F                defw    INPUT
 428+ 14E4 81 22                defw    DIM
 429+ 14E6 63 1F                defw    READ
 430+ 14E8 AE 1D                defw    LET
 431+ 14EA 54 1D                defw    GOTO
 432+ 14EC 2F 1D                defw    RUN
 433+ 14EE 26 1E                defw    IF
 434+ 14F0 FE 1B                defw    RESTOR
 435+ 14F2 43 1D                defw    GOSUB
 436+ 14F4 72 1D                defw    RETURN
 437+ 14F6 99 1D                defw    REM         ; original REM
 438+ 14F8 36 1C                defw    STOP
 439+ 14FA C6 28                defw    POUT
 440+ 14FC 08 1E                defw    ON
 441+ 14FE 9C 3E                defw    FILES       ; changed by Leonardo Miliani - was NULL
 442+ 1500 9D 3E                defw    ERASE       ; added by Leonardo Miliani
 443+ 1502 CC 28                defw    WAIT
 444+ 1504 75 24                defw    DEF
 445+ 1506 C0 29                defw    POKE
 446+ 1508 63 33                defw    DOKE
 447+ 150A C5 29                defw    VPOKE       ; added by Leonardo Miliani
 448+ 150C 02 2A                defw    SREG        ; added by Leonardo Miliani
 449+ 150E 50 2B                defw    VREG        ; added by Leonardo Miliani
 450+ 1510 99 33                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 451+ 1512 D0 29                defw    LOCATE      ; added by Leonardo Miliani
 452+ 1514 5C 2A                defw    SOUND       ; added by Leonardo Miliani
 453+ 1516 23 2A                defw    VOLUME      ; added by Leonardo Miliani
 454+ 1518 7A 33                defw    PAUSE       ; added by Leonardo Miliani
 455+ 151A 14 34                defw    COLOR       ; added by Leonardo Miliani
 456+ 151C 02 37                defw    PLOT        ; added by Leonardo Miliani
 457+ 151E 95 37                defw    DRAW        ; added by Leonardo Miliani
 458+ 1520 CB 38                defw    CIRCLE      ; added by Leonardo Miliani
 459+ 1522 BF 35                defw    PAINT       ; added by Leonardo Miliani
 460+ 1524 D0 3A                defw    SERIAL      ; added by Leonardo Miliani
 461+ 1526 12 3D                defw    HELP        ; changed by Leonardo Miliani - was LINES
 462+ 1528 3C 33                defw    CLS
 463+ 152A 2D 3D                defw    KEY         ; added by Leonardo Miliani
 464+ 152C 0E 29                defw    NMI         ; added by Leonardo Miliani
 465+ 152E D0 34                defw    GPRINT      ; added by Leonardo Miliani
 466+ 1530 50 33                defw    WIDTH
 467+ 1532 68 29                defw    SYS         ; added by Leonardo Miliani
 468+ 1534 94 3F                defw    RESET       ; new behaviour: now it resets the system
 469+ 1536 9B 1D                defw    REM+2       ; ELSE: added by Leonardo Miliani
 470+ 1538 58 1E                defw    PRINT
 471+ 153A 6A 1C                defw    CONT
 472+ 153C 0C 1A                defw    LIST
 473+ 153E E3 1C                defw    CLEAR
 474+ 1540 9A 3E                defw    LOAD        ; re-implemented by Leonardo Miliani (was CLOAD)
 475+ 1542 9B 3E                defw    SAVE        ; re-implemented by Leonardo Miliani (was CSAVE)
 476+ 1544 F1 17                defw    NEW
 477+ 1546
 478+ 1546              ; RESERVED WORD TOKEN VALUES
 479+ 1546              ; if you add a function or command you must increment by 1
 480+ 1546              ; the values below. Pay attention that you must increment only the
 481+ 1546              ; values AFTER the position where you entered the function/command word
 482+ 1546              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 483+ 1546              ; DOKE and SCREEN, and since REM is the reserved work listed below
 484+ 1546              ; that is before the point where VPOKE has been entered, every entry
 485+ 1546              ; after REM has been incremented.
 486+ 1546              ; Another example: when TMR has been added, since it's a function, every
 487+ 1546              ; entry after & included ZSGN must be checked (read below)
 488+ 1546
 489+ 1546              ZEND    equ     $80             ; END        <-- from here, there are the commands
 490+ 1546              ZFOR    equ     $81             ; FOR
 491+ 1546              ZDATA   equ     $83             ; DATA
 492+ 1546              ZGOTO   equ     $88             ; GOTO
 493+ 1546              ZGOSUB  equ     $8C             ; GOSUB
 494+ 1546              ZREM    equ     $8E             ; REM
 495+ 1546              ZELSE   equ     $AE             ; ELSE
 496+ 1546              ZPRINT  equ     $AF             ; PRINT
 497+ 1546              ZNEW    equ     $B5             ; NEW
 498+ 1546
 499+ 1546              ZTAB    equ     $B6             ; TAB
 500+ 1546              ZTO     equ     $B7             ; TO
 501+ 1546              ZFN     equ     $B8             ; FN
 502+ 1546              ZSPC    equ     $B9             ; SPC
 503+ 1546              ZTHEN   equ     $BA             ; THEN
 504+ 1546              ZNOT    equ     $BB             ; NOT
 505+ 1546              ZSTEP   equ     $BC             ; STEP
 506+ 1546
 507+ 1546              ZPLUS   equ     $BD             ; +         <-- from here, there are the math operators
 508+ 1546              ZMINUS  equ     $BE             ; -
 509+ 1546              ZTIMES  equ     $BF             ; *
 510+ 1546              ZDIV    equ     $C0             ; /
 511+ 1546              ZMOD    equ     $C1             ; %
 512+ 1546              ZDINT   equ     $C2             ; #
 513+ 1546              ZOR     equ     $C6             ; OR
 514+ 1546              ZGTR    equ     $C7             ; >
 515+ 1546              ZEQUAL  equ     $C8             ; M
 516+ 1546              ZLTH    equ     $C9             ; <
 517+ 1546
 518+ 1546              ZSGN    equ     $CA             ; SGN       <-- from here, there are the functions
 519+ 1546              ZPOINT  equ     $E0             ; ZPOINT    <-- if the user enters a custom function, between
 520+ 1546                                              ;               SGN and POINT, he/she must increment this pointer by 1
 521+ 1546              ZINSTR  equ     $E1             ; ZINSTR    <-- same here
 522+ 1546              ZLEFT   equ     $E9             ; LEFT$     <-- if the user enters a custom function anywhere,
 523+ 1546                                              ;               he/she must increment this pointer by 1
 524+ 1546
 525+ 1546              ; ARITHMETIC PRECEDENCE TABLE
 526+ 1546              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 527+ 1546              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 528+ 1546 79           PRITAB: defb    $79             ; Precedence value
 529+ 1547 05 30                defw    PADD            ; FPREG = <last> + FPREG
 530+ 1549
 531+ 1549 79                   defb    $79             ; Precedence value
 532+ 154A E8 2B                defw    PSUB            ; FPREG = <last> - FPREG
 533+ 154C
 534+ 154C 7C                   defb    $7C             ; Precedence value
 535+ 154D 26 2D                defw    MULT            ; PPREG = <last> * FPREG
 536+ 154F
 537+ 154F 7C                   defb    $7C             ; Precedence value
 538+ 1550 D8 2D                defw    DIV             ; FPREG = <last> / FPREG
 539+ 1552
 540+ 1552 7C                   defb    $7C             ; Precedence value
 541+ 1553 83 2D                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 542+ 1555
 543+ 1555 7C                   defb    $7C             ; precedence value
 544+ 1556 7B 2D                defw    DINT            ; FPREG = INT(<last> / FPREG )
 545+ 1558
 546+ 1558 7F                   defb    $7F             ; Precedence value
 547+ 1559 26 31                defw    POWER           ; FPREG = <last> ^ FPREG
 548+ 155B
 549+ 155B 50                   defb    $50             ; Precedence value
 550+ 155C CA 21                defw    PAND            ; FPREG = <last> AND FPREG
 551+ 155E
 552+ 155E 4A                   defb    $4A             ; Precedence value
 553+ 155F D2 21                defw    PXOR            ; FPREG = <last> XOR FPREG
 554+ 1561
 555+ 1561 46                   defb    $46             ; Precedence value
 556+ 1562 CD 21                defw    POR             ; FPREG = <last> OR FPREG
 557+ 1564
 558+ 1564
 559+ 1564              ; INITIALISATION TABLE -------------------------------------------------------
 560+ 1564              ; these values are copied into RAM at startup
 561+ 1564 C3 97 12     INITAB: jp      WARMST          ; Warm start jump
 562+ 1567 ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 563+ 156A C3 B9 1C             jp      FCERR           ; "USR (X)" jump (Set to Error)
 564+ 156D D3 00                out     (0),A           ; "out p,n" skeleton
 565+ 156F C9                   ret
 566+ 1570 D6 00                sub     $00             ; Division support routine
 567+ 1572 6F                   ld      L,A
 568+ 1573 7C                   ld      A,H
 569+ 1574 DE 00                sbc     A,$00
 570+ 1576 67                   ld      H,A
 571+ 1577 78                   ld      A,B
 572+ 1578 DE 00                sbc     A,$00
 573+ 157A 47                   ld      B,A
 574+ 157B 3E 00                ld      A,$00
 575+ 157D C9                   ret
 576+ 157E 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 577+ 1581 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 578+ 1585 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 579+ 1589 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 580+ 158D 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 581+ 1591 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 582+ 1595 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 583+ 1599 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 584+ 159D D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 585+ 15A1 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 586+ 15A5 DB 00                in      A,($00)         ; INP (x) skeleton
 587+ 15A7 C9                   ret
 588+ 15A8 FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 589+ 15A9 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 590+ 15AA 00                   defb    $00             ; No nulls after input bytes
 591+ 15AB 00                   defb    $00             ; Output enabled (^O off)
 592+ 15AC 00 00                defw    $00             ; Array load/save check sum
 593+ 15AE 00                   defb    $00             ; Break not by NMI
 594+ 15AF 00                   defb    $00             ; Break flag
 595+ 15B0 C3 2D 19             jp      TTYLIN          ; Input reflection (set to TTY)
 596+ 15B3 CA 53                defw    STLOOK          ; Temp string space
 597+ 15B5 FE FF                defw    -2              ; Current line number (cold)
 598+ 15B7 FF FF                defw    -1              ; Current line with errors (no errors)
 599+ 15B9 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 600+ 15BA 08                   defb    $08             ; auto-repeat delay
 601+ 15BB 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 601+ 15BF 0D 00 00 00
 601+ 15C3 00 00 00 00
 601+ 15C7 00 00 00 00
 602+ 15CB 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 602+ 15CF 00 00 00 00
 602+ 15D3 00 00 00 00
 602+ 15D7 00 00 00 00
 603+ 15DB 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 603+ 15DF 45 4E 31 0D
 603+ 15E3 00 00 00 00
 603+ 15E7 00 00 00 00
 604+ 15EB 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 604+ 15EF 52 31 2C 31
 604+ 15F3 35 2C 35 0D
 604+ 15F7 00 00 00 00
 605+ 15FB 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 605+ 15FF 41 4C 31 2C
 605+ 1603 33 38 34 30
 605+ 1607 30 0D 00 00
 606+ 160B 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 606+ 160F 45 4E 32 0D
 606+ 1613 00 00 00 00
 606+ 1617 00 00 00 00
 607+ 161B 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 607+ 161F 0D 00 00 00
 607+ 1623 00 00 00 00
 607+ 1627 00 00 00 00
 608+ 162B 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 608+ 162F 0D 00 00 00
 608+ 1633 00 00 00 00
 608+ 1637 00 00 00 00
 609+ 163B 67 53                defw    PROGST+1        ; Start of program text
 610+ 163D              INITBE:
 611+ 163D
 612+ 163D              ; END OF INITIALISATION TABLE ---------------------------------------------------
 613+ 163D
 614+ 163D 20 45 72 72  ERRMSG: defb    " Error",0
 614+ 1641 6F 72 00
 615+ 1644 20 69 6E 20  INMSG:  defb    " in ",0
 615+ 1648 00
 616+ 1649              ZERBYT  equ     $-1             ; A zero byte
 617+ 1649 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 617+ 164D 00
 618+ 164E 42 72 65 61  BRKMSG: defb    "Break",0
 618+ 1652 6B 00
 619+ 1654
 620+ 1654 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 621+ 1657 39                   add     HL,SP           ; same index as specified
 622+ 1658 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 623+ 1659 23                   inc     HL              ; Point to index address
 624+ 165A FE 81                cp      ZFOR            ; Is it a "FOR" token
 625+ 165C C0                   ret     NZ              ; No - exit
 626+ 165D 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 627+ 165E 23                   inc     HL
 628+ 165F 46                   ld      B,(HL)
 629+ 1660 23                   inc     HL              ; Point to sign of STEP
 630+ 1661 E5                   push    HL              ; Save pointer to sign
 631+ 1662 69                   ld      L,C             ; HL = address of "FOR" index
 632+ 1663 60                   ld      H,B
 633+ 1664 7A                   ld      A,D             ; See if an index was specified
 634+ 1665 B3                   or      E               ; DE = 0 if no index specified
 635+ 1666 EB                   ex      DE,HL           ; Specified index into HL
 636+ 1667 CA 6E 16             jp      Z,INDFND        ; Skip if no index given
 637+ 166A EB                   ex      DE,HL           ; Index back into DE
 638+ 166B CD A7 19             call    CPDEHL          ; Compare index with one given
 639+ 166E 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 640+ 1671 E1                   pop     HL              ; Restore pointer to sign
 641+ 1672 C8                   ret     Z               ; Return if block found
 642+ 1673 09                   add     HL,BC           ; Point to next block
 643+ 1674 C3 58 16             jp      LOKFOR          ; Keep on looking
 644+ 1677
 645+ 1677 CD 91 16     MOVUP:  call    ENFMEM          ; See if enough memory
 646+ 167A C5           MOVSTR: push    BC              ; Save end of source
 647+ 167B E3                   ex      (SP),HL         ; Swap source and dest" end
 648+ 167C C1                   pop     BC              ; Get end of destination
 649+ 167D CD A7 19     MOVLP:  call    CPDEHL          ; See if list moved
 650+ 1680 7E                   ld      A,(HL)          ; Get byte
 651+ 1681 02                   ld      (BC),A          ; Move it
 652+ 1682 C8                   ret     Z               ; Exit if all done
 653+ 1683 0B                   dec     BC              ; Next byte to move to
 654+ 1684 2B                   dec     HL              ; Next byte to move
 655+ 1685 C3 7D 16             jp      MOVLP           ; Loop until all bytes moved
 656+ 1688
 657+ 1688 E5           CHKSTK: push    HL              ; Save code string address
 658+ 1689 2A 47 53             ld      HL,(ARREND)     ; Lowest free memory
 659+ 168C 06 00                ld      B,$00           ; BC = Number of levels to test
 660+ 168E 09                   add     HL,BC           ; 2 Bytes for each level
 661+ 168F 09                   add     HL,BC
 662+ 1690 3E                   defb    $3E             ; Skip "push HL"
 663+ 1691 E5           ENFMEM: push    HL              ; Save code string address
 664+ 1692 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 665+ 1694 95                   sub     L
 666+ 1695 6F                   ld      L,A
 667+ 1696 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 668+ 1698 9C                   sbc     A,H
 669+ 1699 DA A0 16             jp      C,OMERR         ; Not enough - ?OM Error
 670+ 169C 67                   ld      H,A
 671+ 169D 39                   add     HL,SP           ; Test if stack is overflowed
 672+ 169E E1                   pop     HL              ; Restore code string address
 673+ 169F D8                   ret     C               ; Return if enough memory
 674+ 16A0 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 675+ 16A2 C3 DF 16             jp      ERROR
 676+ 16A5
 677+ 16A5
 678+ 16A5              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 679+ 16A5 F5           EXITGM: push    AF              ; store AF
 680+ 16A6 3A EE 52             ld      A,(SCR_MODE)    ; check screen mode
 681+ 16A9 FE 02                cp      $02             ; G2?
 682+ 16AB CA B2 16             jp      Z,LDG1          ; yes, back to G1
 683+ 16AE FE 03                cp      $03             ; G3?
 684+ 16B0 20 11                jr      NZ,LDG1ND       ; no, so return
 685+ 16B2 E5           LDG1:   push    HL              ; store HL
 686+ 16B3 D5                   push    DE              ; store DE
 687+ 16B4 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 688+ 16B7 F3                   di                      ; disable INTs
 689+ 16B8 CD D3 03             call    initVDP         ; initialize VDP with mode pointed by E
 690+ 16BB FB                   ei                      ; re-enable INTs
 691+ 16BC 3E 01                ld      A,$01           ; activate the...
 692+ 16BE 32 F9 52             ld      (PRNTVIDEO),A   ; ...video buffer...
 693+ 16C1 D1                   pop     DE              ; retrieve DE
 694+ 16C2 E1                   pop     HL              ; retrieve HL
 695+ 16C3 F1           LDG1ND: pop     AF              ; retrieve AF
 696+ 16C4 C9                   ret                     ; return to caller
 697+ 16C5
 698+ 16C5
 699+ 16C5 2A CF 52     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 700+ 16C8 22 CE 51             ld      (LINEAT),HL     ; Save as current line
 701+ 16CB 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 702+ 16CD 01                   defb    $01             ; Skip "ld E,DZ"
 703+ 16CE 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 704+ 16D0 01                   defb    $01             ; Skip "ld E,NF"
 705+ 16D1 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 706+ 16D3 01                   defb    $01             ; Skip "ld E,DD"
 707+ 16D4 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 708+ 16D6 01                   defb    $01             ; Skip "ld E,UF"
 709+ 16D7 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 710+ 16D9 01                   defb    $01             ; Skip "ld E,OV
 711+ 16DA 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 712+ 16DC 01                   defb    $01             ; Skip "ld E,TM"
 713+ 16DD 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 714+ 16DF
 715+ 16DF CD 17 18     ERROR:  call    CLREG           ; Clear registers and stack
 716+ 16E2 CD A5 16             call    EXITGM          ; exit from graphic modes
 717+ 16E5 32 C4 51             ld      (CTLOFG),A      ; Enable output (A is 0)
 718+ 16E8 CD 1A 09             call    CURSOR_ON       ; enable cursor
 719+ 16EB CD A9 1E             call    STTLIN          ; Start new line
 720+ 16EE 21 FF 0F             ld      HL,ERRTBL       ; Point to error codes
 721+ 16F1 57                   ld      D,A             ; D = 0 (A is 0)
 722+ 16F2 3E 3F                ld      A,'?'
 723+ 16F4 CD B8 19             call    OUTC            ; Output '?'
 724+ 16F7 19                   add     HL,DE           ; Offset to correct error code
 725+ 16F8 5E                   ld      E,(HL)          ; load pointer to error message
 726+ 16F9 23                   inc     HL              ; by loading LSB,
 727+ 16FA 56                   ld      D,(HL)          ; then MSB
 728+ 16FB 62 6B                ld      HL,DE           ; load pointer to HL
 729+ 16FD CD 7F 25             call    PRS             ; Output error message
 730+ 1700 21 3D 16             ld      HL,ERRMSG       ; "Error" message
 731+ 1703 CD 7F 25     ERRIN:  call    PRS             ; Output message
 732+ 1706 2A CE 51             ld      HL,(LINEAT)     ; Get line of error
 733+ 1709 11 FE FF             ld      DE,-2           ; Cold start error if -2
 734+ 170C CD A7 19             call    CPDEHL          ; See if cold start error
 735+ 170F CA F0 11             jp      Z,CSTART        ; Cold start error - Restart
 736+ 1712 7C                   ld      A,H             ; Was it a direct error?
 737+ 1713 A5                   and     L               ; Line = -1 if direct error
 738+ 1714 3C                   inc     A
 739+ 1715 CA 20 17             jp      Z,PTLN          ; Yes, jump over
 740+ 1718 E5                   push    HL              ; indirect mode - store HL
 741+ 1719 2A CE 51             ld      HL,(LINEAT)     ; copy current line number
 742+ 171C 22 D0 51             ld      (HLPLN),HL      ; save in HELP line register
 743+ 171F E1                   pop     HL              ; retrieve HL
 744+ 1720 C4 16 30     PTLN:   call    NZ,LINEIN       ; No - output line of error
 745+ 1723
 746+ 1723 3E                   defb    $3E             ; Skip "pop BC"
 747+ 1724 C1           POPNOK: pop     BC              ; Drop address in input buffer
 748+ 1725
 749+ 1725              ; run into direct mode: print OK and get command
 750+ 1725 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 751+ 1726 32 C4 51             ld      (CTLOFG),A      ; Enable output
 752+ 1729 CD A9 1E             call    STTLIN          ; Start new line
 753+ 172C 21 49 16             ld      HL,OKMSG        ; "Ok" message
 754+ 172F CD 7F 25             call    PRS             ; Output "Ok"
 755+ 1732 CD 1A 09     GETCMD: call    CURSOR_ON       ; enable cursor
 756+ 1735 21 FF FF             ld      HL,-1           ; Flag direct mode
 757+ 1738 22 CE 51             ld      (LINEAT),HL     ; Save as current line
 758+ 173B CD 2D 19             call    GETLIN          ; Get an input line
 759+ 173E DA 32 17             jp      C,GETCMD        ; Get line again if break
 760+ 1741 CD EE 1B             call    GETCHR          ; Get first character
 761+ 1744 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 762+ 1745 DA CB 16             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 763+ 1748 1F                   rra                     ; recover original char and Carry
 764+ 1749 3C                   inc     A               ; Test if end of line
 765+ 174A 3D                   dec     A               ; Without affecting Carry
 766+ 174B CA 32 17             jp      Z,GETCMD        ; Nothing entered - Get another
 767+ 174E F5                   push    AF              ; Save Carry status
 768+ 174F CD 2F 09             call    CURSOR_OFF      ; cursor disabled
 769+ 1752 CD BE 1C             call    ATOH            ; Get line number into DE
 770+ 1755 D5                   push    DE              ; Save line number
 771+ 1756 CD 44 18             call    CRUNCH          ; Tokenise rest of line
 772+ 1759 47                   ld      B,A             ; Length of tokenised line
 773+ 175A D1                   pop     DE              ; Restore line number
 774+ 175B F1                   pop     AF              ; Restore Carry
 775+ 175C D2 CE 1B             jp      NC,EXCUTE       ; No line number - Direct mode
 776+ 175F D5                   push    DE              ; Save line number
 777+ 1760 C5                   push    BC              ; Save length of tokenised line
 778+ 1761 AF                   xor     A
 779+ 1762 32 D2 52             ld      (LSTBIN),A      ; Clear last byte input
 780+ 1765 CD EE 1B             call    GETCHR          ; Get next character
 781+ 1768 B7                   or      A               ; Set flags
 782+ 1769 F5                   push    AF              ; And save them
 783+ 176A CD D1 17             call    SRCHLN          ; Search for line number in DE
 784+ 176D DA 76 17             jp      C,LINFND        ; Jump if line found
 785+ 1770 F1                   pop     AF              ; Get status
 786+ 1771 F5                   push    AF              ; And re-save
 787+ 1772 CA 6D 1D             jp      Z,ULERR         ; Nothing after number - Error
 788+ 1775 B7                   or      A               ; Clear Carry
 789+ 1776 C5           LINFND: push    BC              ; Save address of line in prog
 790+ 1777 D2 8D 17             jp      NC,INEWLN       ; Line not found - Insert new
 791+ 177A EB                   ex      DE,HL           ; Next line address in DE
 792+ 177B 2A 43 53             ld      HL,(PROGND)     ; End of program
 793+ 177E 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 794+ 177F 02                   ld      (BC),A
 795+ 1780 03                   inc     BC              ; Next destination
 796+ 1781 13                   inc     DE              ; Next source
 797+ 1782 CD A7 19             call    CPDEHL          ; All done?
 798+ 1785 C2 7E 17             jp      NZ,SFTPRG       ; More to do
 799+ 1788 60                   ld      H,B             ; HL - New end of program
 800+ 1789 69                   ld      L,C
 801+ 178A 22 43 53             ld      (PROGND),HL     ; Update end of program
 802+ 178D
 803+ 178D D1           INEWLN: pop     DE              ; Get address of line,
 804+ 178E F1                   pop     AF              ; Get status
 805+ 178F CA B4 17             jp      Z,SETPTR        ; No text - Set up pointers
 806+ 1792 2A 43 53             ld      HL,(PROGND)     ; Get end of program
 807+ 1795 E3                   ex      (SP),HL         ; Get length of input line
 808+ 1796 C1                   pop     BC              ; End of program to BC
 809+ 1797 09                   add     HL,BC           ; Find new end
 810+ 1798 E5                   push    HL              ; Save new end
 811+ 1799 CD 77 16             call    MOVUP           ; Make space for line
 812+ 179C E1                   pop     HL              ; Restore new end
 813+ 179D 22 43 53             ld      (PROGND),HL     ; Update end of program pointer
 814+ 17A0 EB                   ex      DE,HL           ; Get line to move up in HL
 815+ 17A1 74                   ld      (HL),H          ; Save MSB
 816+ 17A2 D1                   pop     DE              ; Get new line number
 817+ 17A3 23                   inc     HL              ; Skip pointer
 818+ 17A4 23                   inc     HL
 819+ 17A5 73                   ld      (HL),E          ; Save LSB of line number
 820+ 17A6 23                   inc     HL
 821+ 17A7 72                   ld      (HL),D          ; Save MSB of line number
 822+ 17A8 23                   inc     HL              ; To first byte in line
 823+ 17A9 11 57 52             ld      DE,BUFFER       ; Copy buffer to program
 824+ 17AC 1A           MOVBUF: ld      A,(DE)          ; Get source
 825+ 17AD 77                   ld      (HL),A          ; Save destinations
 826+ 17AE 23                   inc     HL              ; Next source
 827+ 17AF 13                   inc     DE              ; Next destination
 828+ 17B0 B7                   or      A               ; Done?
 829+ 17B1 C2 AC 17             jp      NZ,MOVBUF       ; No - Repeat
 830+ 17B4 CD FD 17     SETPTR: call    RUNFST          ; Set line pointers
 831+ 17B7 23                   inc     HL              ; To LSB of pointer
 832+ 17B8 EB                   ex      DE,HL           ; Address to DE
 833+ 17B9 62           PTRLP:  ld      H,D             ; Address to HL
 834+ 17BA 6B                   ld      L,E
 835+ 17BB 7E                   ld      A,(HL)          ; Get LSB of pointer
 836+ 17BC 23                   inc     HL              ; To MSB of pointer
 837+ 17BD B6                   or      (HL)            ; Compare with MSB pointer
 838+ 17BE CA 32 17             jp      Z,GETCMD        ; Get command line if end
 839+ 17C1 23                   inc     HL              ; To LSB of line number
 840+ 17C2 23                   inc     HL              ; Skip line number
 841+ 17C3 23                   inc     HL              ; Point to first byte in line
 842+ 17C4 AF                   xor     A               ; Looking for 00 byte
 843+ 17C5 BE           FNDEND: cp      (HL)            ; Found end of line?
 844+ 17C6 23                   inc     HL              ; Move to next byte
 845+ 17C7 C2 C5 17             jp      NZ,FNDEND       ; No - Keep looking
 846+ 17CA EB                   ex      DE,HL           ; Next line address to HL
 847+ 17CB 73                   ld      (HL),E          ; Save LSB of pointer
 848+ 17CC 23                   inc     HL
 849+ 17CD 72                   ld      (HL),D          ; Save MSB of pointer
 850+ 17CE C3 B9 17             jp      PTRLP           ; Do next line
 851+ 17D1
 852+ 17D1 2A 54 52     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 853+ 17D4 44           SRCHLP: ld      B,H             ; BC = Address to look at
 854+ 17D5 4D                   ld      C,L
 855+ 17D6 7E                   ld      A,(HL)          ; Get address of next line
 856+ 17D7 23                   inc     HL
 857+ 17D8 B6                   or      (HL)            ; End of program found?
 858+ 17D9 2B                   dec     HL
 859+ 17DA C8                   ret     Z               ; Yes - Line not found
 860+ 17DB 23                   inc     HL
 861+ 17DC 23                   inc     HL
 862+ 17DD 7E                   ld      A,(HL)          ; Get LSB of line number
 863+ 17DE 23                   inc     HL
 864+ 17DF 66                   ld      H,(HL)          ; Get MSB of line number
 865+ 17E0 6F                   ld      L,A
 866+ 17E1 CD A7 19             call    CPDEHL          ; Compare with line in DE
 867+ 17E4 60                   ld      H,B             ; HL = Start of this line
 868+ 17E5 69                   ld      L,C
 869+ 17E6 7E                   ld      A,(HL)          ; Get LSB of next line address
 870+ 17E7 23                   inc     HL
 871+ 17E8 66                   ld      H,(HL)          ; Get MSB of next line address
 872+ 17E9 6F                   ld      L,A             ; Next line to HL
 873+ 17EA 3F                   ccf
 874+ 17EB C8                   ret     Z               ; Lines found - Exit
 875+ 17EC 3F                   ccf
 876+ 17ED D0                   ret     NC              ; Line not found,at line after
 877+ 17EE C3 D4 17             jp      SRCHLP          ; Keep looking
 878+ 17F1
 879+ 17F1 C0           NEW:    ret     NZ              ; Return if any more on line
 880+ 17F2 2A 54 52     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 881+ 17F5 AF                   xor     A               ; Set program area to empty
 882+ 17F6 77                   ld      (HL),A          ; Save LSB = 00
 883+ 17F7 23                   inc     HL
 884+ 17F8 77                   ld      (HL),A          ; Save MSB = 00
 885+ 17F9 23                   inc     HL
 886+ 17FA 22 43 53             ld      (PROGND),HL     ; Set program end
 887+ 17FD
 888+ 17FD 2A 54 52     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 889+ 1800 2B                   dec     HL
 890+ 1801
 891+ 1801 22 D4 52     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 892+ 1804 2A B5 52             ld      HL,(LSTRAM)     ; Get end of RAM
 893+ 1807 22 C9 52             ld      (STRBOT),HL     ; Clear string space
 894+ 180A AF                   xor     A
 895+ 180B CD FE 1B             call    RESTOR          ; Reset DATA pointers
 896+ 180E 2A 43 53             ld      HL,(PROGND)     ; Get end of program
 897+ 1811 22 45 53             ld      (VAREND),HL     ; Clear variables
 898+ 1814 22 47 53             ld      (ARREND),HL     ; Clear arrays
 899+ 1817
 900+ 1817 C1           CLREG:  pop     BC              ; Save return address
 901+ 1818 2A CC 51             ld      HL,(STRSPC)     ; Get end of working RAM
 902+ 181B F9                   ld      SP,HL           ; Set stack
 903+ 181C 21 B9 52             ld      HL,TMSTPL       ; Temporary string pool
 904+ 181F 22 B7 52             ld      (TMSTPT),HL     ; Reset temporary string ptr
 905+ 1822 AF                   xor     A               ; A = 00
 906+ 1823 6F                   ld      L,A             ; HL = 0000
 907+ 1824 67                   ld      H,A
 908+ 1825 22 DA 52             ld      (CONTAD),HL     ; No CONTinue
 909+ 1828 32 D1 52             ld      (FORFLG),A      ; Clear FOR flag
 910+ 182B 22 4B 53             ld      (FNRGNM),HL     ; Clear FN argument
 911+ 182E E5                   push    HL              ; HL = 0000
 912+ 182F C5                   push    BC              ; Put back return
 913+ 1830 2A D4 52     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 914+ 1833 C9                   ret                     ; Return to execution driver
 915+ 1834
 916+ 1834 3E 3F        PROMPT: ld      A,'?'           ; '?'
 917+ 1836 CD B8 19             call    OUTC            ; Output character
 918+ 1839 3E 00                ld      A,NLLCR         ; null char
 919+ 183B CD B8 19             call    OUTC            ; Output character
 920+ 183E CD 1A 09             call    CURSOR_ON       ; enable cursor
 921+ 1841 C3 C9 51             jp      RINPUT          ; Get input line
 922+ 1844
 923+ 1844 AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
 924+ 1845 32 B4 52             ld      (DATFLG),A      ; Reset literal flag
 925+ 1848 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
 926+ 184A 11 57 52             ld      DE,BUFFER       ; Start of input buffer
 927+ 184D 7E           CRNCLP: ld      A,(HL)          ; Get byte
 928+ 184E FE 20                cp      SPC             ; Is it a space?
 929+ 1850 CA CC 18             jp      Z,MOVDIR        ; Yes - Copy direct
 930+ 1853 47                   ld      B,A             ; Save character
 931+ 1854 FE 22                cp      $22             ; '"'             ; Is it a quote?
 932+ 1856 CA EC 18             jp      Z,CPYLIT        ; Yes - Copy literal string
 933+ 1859 B7                   or      A               ; Is it end of buffer?
 934+ 185A CA F3 18             jp      Z,ENDBUF        ; Yes - End buffer
 935+ 185D 3A B4 52             ld      A,(DATFLG)      ; Get data type
 936+ 1860 B7                   or      A               ; Literal?
 937+ 1861 7E                   ld      A,(HL)          ; Get byte to copy
 938+ 1862 C2 CC 18             jp      NZ,MOVDIR       ; Literal - Copy direct
 939+ 1865 FE 3F                cp      '?'             ; Is it '?' short for PRINT
 940+ 1867 3E AF                ld      A,ZPRINT        ; "PRINT" token
 941+ 1869 CA CC 18             jp      Z,MOVDIR        ; Yes - replace it
 942+ 186C 7E                   ld      A,(HL)          ; Get byte again
 943+ 186D FE 30                cp      '0'             ; Is it less than '0'
 944+ 186F DA 77 18             jp      C,FNDWRD        ; Yes - Look for reserved words
 945+ 1872 FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
 946+ 1874 DA CC 18             jp      C,MOVDIR        ; Yes - copy it direct
 947+ 1877 D5           FNDWRD: push    DE              ; Look for reserved words
 948+ 1878 11 4C 13             ld      DE,WORDS-1      ; Point to table
 949+ 187B C5                   push    BC              ; Save count
 950+ 187C 01 C8 18             ld      BC,RETNAD       ; Where to return to
 951+ 187F C5                   push    BC              ; Save return address
 952+ 1880 06 7F                ld      B,ZEND-1        ; First token value -1
 953+ 1882 7E                   ld      A,(HL)          ; Get byte
 954+ 1883 FE 61                cp      'a'             ; Less than 'a' ?
 955+ 1885 DA 90 18             jp      C,SEARCH        ; Yes - search for words
 956+ 1888 FE 7B                cp      'z'+1           ; Greater than 'z' ?
 957+ 188A D2 90 18             jp      NC,SEARCH       ; Yes - search for words
 958+ 188D E6 5F                and     %01011111       ; Force upper case
 959+ 188F 77                   ld      (HL),A          ; Replace byte
 960+ 1890 4E           SEARCH: ld      C,(HL)          ; Search for a word
 961+ 1891 EB                   ex      DE,HL
 962+ 1892 23           GETNXT: inc     HL              ; Get next reserved word
 963+ 1893 B6                   or      (HL)            ; Start of word?
 964+ 1894 F2 92 18             jp      P,GETNXT        ; No - move on
 965+ 1897 04                   inc     B               ; Increment token value
 966+ 1898 7E                   ld      A,(HL)          ; Get byte from table
 967+ 1899 E6 7F                and     %01111111       ; Strip bit 7
 968+ 189B C8                   ret     Z               ; Return if end of list
 969+ 189C B9                   cp      C               ; Same character as in buffer?
 970+ 189D C2 92 18             jp      NZ,GETNXT       ; No - get next word
 971+ 18A0 EB                   ex      DE,HL
 972+ 18A1 E5                   push    HL              ; Save start of word
 973+ 18A2
 974+ 18A2 13           NXTBYT: inc     DE              ; Look through rest of word
 975+ 18A3 1A                   ld      A,(DE)          ; Get byte from table
 976+ 18A4 B7                   or      A               ; End of word ?
 977+ 18A5 FA C4 18             jp      M,MATCH         ; Yes - Match found
 978+ 18A8 4F                   ld      C,A             ; Save it
 979+ 18A9 78                   ld      A,B             ; Get token value
 980+ 18AA FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
 981+ 18AC C2 B3 18             jp      NZ,NOSPC        ; No - Don't allow spaces
 982+ 18AF CD EE 1B             call    GETCHR          ; Get next character
 983+ 18B2 2B                   dec     HL              ; Cancel increment from GETCHR
 984+ 18B3 23           NOSPC:  inc     HL              ; Next byte
 985+ 18B4 7E                   ld      A,(HL)          ; Get byte
 986+ 18B5 FE 61                cp      'a'             ; Less than 'a' ?
 987+ 18B7 DA BC 18             jp      C,NOCHNG        ; Yes - don't change
 988+ 18BA E6 5F                and     %01011111       ; Make upper case
 989+ 18BC B9           NOCHNG: cp      C               ; Same as in buffer ?
 990+ 18BD CA A2 18             jp      Z,NXTBYT        ; Yes - keep testing
 991+ 18C0 E1                   pop     HL              ; Get back start of word
 992+ 18C1 C3 90 18             jp      SEARCH          ; Look at next word
 993+ 18C4
 994+ 18C4 48           MATCH:  ld      C,B             ; Word found - Save token value
 995+ 18C5 F1                   pop     AF              ; Throw away return
 996+ 18C6 EB                   ex      DE,HL
 997+ 18C7 C9                   ret                     ; Return to "RETNAD"
 998+ 18C8 EB           RETNAD: ex      DE,HL           ; Get address in string
 999+ 18C9 79                   ld      A,C             ; Get token value
1000+ 18CA C1                   pop     BC              ; Restore buffer length
1001+ 18CB D1                   pop     DE              ; Get destination address
1002+ 18CC 23           MOVDIR: inc     HL              ; Next source in buffer
1003+ 18CD 12                   ld      (DE),A          ; Put byte in buffer
1004+ 18CE 13                   inc     DE              ; Move up buffer
1005+ 18CF 0C                   inc     C               ; Increment length of buffer
1006+ 18D0 D6 3A                sub     ':'             ; End of statement?
1007+ 18D2 CA DA 18             jp      Z,SETLIT        ; Jump if multi-statement line
1008+ 18D5 FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1009+ 18D7 C2 DD 18             jp      NZ,TSTREM       ; No - see if REM
1010+ 18DA 32 B4 52     SETLIT: ld      (DATFLG),A      ; Set literal flag
1011+ 18DD D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1012+ 18DF C2 4D 18             jp      NZ,CRNCLP       ; No - Leave flag
1013+ 18E2 47                   ld      B,A             ; Copy rest of buffer
1014+ 18E3 7E           NXTCHR: ld      A,(HL)          ; Get byte
1015+ 18E4 B7                   or      A               ; End of line ?
1016+ 18E5 CA F3 18             jp      Z,ENDBUF        ; Yes - Terminate buffer
1017+ 18E8 B8                   cp      B               ; End of statement ?
1018+ 18E9 CA CC 18             jp      Z,MOVDIR        ; Yes - Get next one
1019+ 18EC 23           CPYLIT: inc     HL              ; Move up source string
1020+ 18ED 12                   ld      (DE),A          ; Save in destination
1021+ 18EE 0C                   inc     C               ; Increment length
1022+ 18EF 13                   inc     DE              ; Move up destination
1023+ 18F0 C3 E3 18             jp      NXTCHR          ; Repeat
1024+ 18F3
1025+ 18F3 21 56 52     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1026+ 18F6 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1027+ 18F7 13                   inc     DE
1028+ 18F8 12                   ld      (DE),A          ; A = 00
1029+ 18F9 13                   inc     DE
1030+ 18FA 12                   ld      (DE),A          ; A = 00
1031+ 18FB C9                   ret
1032+ 18FC
1033+ 18FC 3A C3 51     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1034+ 18FF B7                   or      A               ; Is it zero?
1035+ 1900 3E 00                ld      A,$00           ; Zero A - Leave flags
1036+ 1902 32 C3 51             ld      (NULFLG),A      ; Zero null flag
1037+ 1905 C2 10 19             jp      NZ,ECHDEL       ; Set - Echo it
1038+ 1908 05                   dec     B               ; Decrement length
1039+ 1909 CA 2D 19             jp      Z,GETLIN        ; Get line again if empty
1040+ 190C CD B8 19             call    OUTC            ; Output null character
1041+ 190F 3E                   defb    $3E             ; Skip "dec B"
1042+ 1910 05           ECHDEL: dec     B               ; Count bytes in buffer
1043+ 1911 2B                   dec     HL              ; Back space buffer
1044+ 1912 CA 24 19             jp      Z,OTKLN         ; No buffer - Try again
1045+ 1915 7E                   ld      A,(HL)          ; Get deleted byte
1046+ 1916 CD B8 19             call    OUTC            ; Echo it
1047+ 1919 C3 36 19             jp      MORINP          ; Get more input
1048+ 191C
1049+ 191C 05           DELCHR: dec     B               ; Count bytes in buffer
1050+ 191D 2B                   dec     HL              ; Back space buffer
1051+ 191E CD B8 19             call    OUTC            ; Output character in A
1052+ 1921 C2 36 19             jp      NZ,MORINP       ; Not end - Get more
1053+ 1924 CD B8 19     OTKLN:  call    OUTC            ; Output character in A
1054+ 1927 CD BB 1E     KILIN:  call    PRNTCRLF        ; Output CRLF
1055+ 192A C3 2D 19             jp      TTYLIN          ; Get line again
1056+ 192D
1057+ 192D              GETLIN:
1058+ 192D 21 57 52     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1059+ 1930 06 01                ld      B,$01           ; Set buffer as empty
1060+ 1932 AF                   xor     A
1061+ 1933 32 C3 51             ld      (NULFLG),A      ; Clear null flag
1062+ 1936 CD F9 19     MORINP: call    CLOTST          ; Get character and test ^O
1063+ 1939 4F                   ld      C,A             ; Save character in C
1064+ 193A FE 7F                cp      DEL             ; Delete character?
1065+ 193C CA FC 18             jp      Z,DODEL         ; Yes - Process it
1066+ 193F 3A C3 51             ld      A,(NULFLG)      ; Get null flag
1067+ 1942 B7                   or      A               ; Test null flag status
1068+ 1943 CA 4F 19             jp      Z,PROCES        ; Reset - Process character
1069+ 1946 3E 00                ld      A,$00           ; Set a null
1070+ 1948 CD B8 19             call    OUTC            ; Output null
1071+ 194B AF                   xor     A               ; Clear A
1072+ 194C 32 C3 51             ld      (NULFLG),A      ; Reset null flag
1073+ 194F 79           PROCES: ld      A,C             ; Get character
1074+ 1950 FE 07                cp      CTRLG           ; Bell?
1075+ 1952 CA 8F 19             jp      Z,PUTCTL        ; Yes - Save it
1076+ 1955 FE 03                cp      CTRLC           ; Is it control "C"?
1077+ 1957 CC 84 19             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1078+ 195A 37                   scf                     ; Flag break
1079+ 195B C8                   ret     Z               ; Return if control "C"
1080+ 195C FE 0D                cp      CR              ; Is it enter?
1081+ 195E CA B1 1E             jp      Z,ENDINP        ; Yes - Terminate input
1082+ 1961 FE 15                cp      CTRLU           ; Is it control "U"?
1083+ 1963 CA 27 19             jp      Z,KILIN         ; Yes - Get another line
1084+ 1966 FE 08                cp      BKSP            ; Is it backspace?
1085+ 1968 CA 1C 19             jp      Z,DELCHR        ; Yes - Delete character
1086+ 196B FE 12                cp      CTRLR           ; Is it control "R"?
1087+ 196D C2 8A 19             jp      NZ,PUTBUF       ; No - Put in buffer
1088+ 1970 C5                   push    BC              ; Save buffer length
1089+ 1971 D5                   push    DE              ; Save DE
1090+ 1972 E5                   push    HL              ; Save buffer address
1091+ 1973 36 00                ld      (HL),$00        ; Mark end of buffer
1092+ 1975 CD B2 3F             call    OUTNCR          ; Output and do CRLF
1093+ 1978 21 57 52             ld      HL,BUFFER       ; Point to buffer start
1094+ 197B CD 7F 25             call    PRS             ; Output buffer
1095+ 197E E1                   pop     HL              ; Restore buffer address
1096+ 197F D1                   pop     DE              ; Restore DE
1097+ 1980 C1                   pop     BC              ; Restore buffer length
1098+ 1981 C3 36 19             jp      MORINP          ; Get another character
1099+ 1984 CD A5 16     GMNCR:  call    EXITGM          ; exit from graphic mode
1100+ 1987 C3 BB 1E             jp      PRNTCRLF        ; output CRLF
1101+ 198A
1102+ 198A FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1103+ 198C DA 36 19             jp      C,MORINP        ; Yes - Ignore
1104+ 198F 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1105+ 1990 FE 59                cp      $58+$01         ; Test for line overflow
1106+ 1992 3E 08                ld      A,BKSP          ; Set a bell
1107+ 1994 D2 A1 19             jp      NC,OUTNBS       ; Ring bell if buffer full
1108+ 1997 79                   ld      A,C             ; Get character
1109+ 1998 71                   ld      (HL),C          ; Save in buffer
1110+ 1999 32 D2 52             ld      (LSTBIN),A      ; Save last input byte
1111+ 199C 23                   inc     HL              ; Move up buffer
1112+ 199D 04                   inc     B               ; Increment length
1113+ 199E C3 36 19     OUTIT:  jp      MORINP          ; Get another character
1114+ 19A1
1115+ 19A1 CD B8 19     OUTNBS: call    OUTC            ; Output bell and back over it
1116+ 19A4 C3 9E 19             jp      OUTIT           ; get more chars
1117+ 19A7
1118+ 19A7 7C           CPDEHL: ld      A,H             ; Get H
1119+ 19A8 92                   sub     D               ; Compare with D
1120+ 19A9 C0                   ret     NZ              ; Different - Exit
1121+ 19AA 7D                   ld      A,L             ; Get L
1122+ 19AB 93                   sub     E               ; Compare with E
1123+ 19AC C9                   ret                     ; Return status
1124+ 19AD
1125+ 19AD 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1126+ 19AE E3                   ex      (SP),HL         ; Address of test byte
1127+ 19AF BE                   cp      (HL)            ; Same as in code string?
1128+ 19B0 23                   inc     HL              ; Return address
1129+ 19B1 E3                   ex      (SP),HL         ; Put it back
1130+ 19B2 CA EE 1B             jp      Z,GETCHR        ; Yes - Get next character
1131+ 19B5 C3 CB 16             jp      SNERR           ; Different - ?SN Error
1132+ 19B8
1133+ 19B8 F5           OUTC:   push    AF              ; Save character
1134+ 19B9 3A C4 51             ld      A,(CTLOFG)      ; Get control "O" flag
1135+ 19BC B7                   or      A               ; Is it set?
1136+ 19BD C2 B4 25             jp      NZ,POPAF        ; Yes - don't output
1137+ 19C0 F1                   pop     AF              ; Restore character
1138+ 19C1 C5                   push    BC              ; Save buffer length
1139+ 19C2 F5                   push    AF              ; Save character
1140+ 19C3 FE 20                cp      SPC             ; Is it a control code?
1141+ 19C5 DA DC 19             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1142+ 19C8 3A C1 51             ld      A,(LWIDTH)      ; Get line width
1143+ 19CB 47                   ld      B,A             ; To B
1144+ 19CC 3A B1 52             ld      A,(CURPOS)      ; Get cursor position
1145+ 19CF 04                   inc     B               ; Width 255?
1146+ 19D0 CA D8 19             jp      Z,INCLEN        ; Yes - No width limit
1147+ 19D3 05                   dec     B               ; Restore width
1148+ 19D4 B8                   cp      B               ; At end of line?
1149+ 19D5 CC BB 1E             call    Z,PRNTCRLF      ; Yes - output CRLF
1150+ 19D8 3C           INCLEN: inc     A               ; Move on one character
1151+ 19D9 32 B1 52             ld      (CURPOS),A      ; Save new position
1152+ 19DC AF           DINPOS: xor     A
1153+ 19DD 32 37 53             ld      (KBDNPT),A      ; set flag for no char from keyboard
1154+ 19E0 F1                   pop     AF              ; Restore character
1155+ 19E1 C1                   pop     BC              ; Restore buffer length
1156+ 19E2 F5                   push    AF
1157+ 19E3 CD EB 19             call    SND2VID         ; send char to video
1158+ 19E6 F1                   pop     AF
1159+ 19E7 CD 91 3F             call    MONOUT          ; send char to serial if enabled
1160+ 19EA C9                   ret
1161+ 19EB
1162+ 19EB              ; print char to video if cursor is on
1163+ 19EB 32 FA 52     SND2VID:ld      (CHR4VID),A     ; store A
1164+ 19EE 3A F9 52             ld      A,(PRNTVIDEO)   ; check print-on-video
1165+ 19F1 B7                   or      A               ; is it off?
1166+ 19F2 C8                   ret     Z               ; yes, so return
1167+ 19F3 F3                   di                      ; disable INTs
1168+ 19F4 CD 4E 07             call    CHAR2VID        ; cursor is on, so print char on screen
1169+ 19F7 FB                   ei                      ; re-enable INTs
1170+ 19F8 C9                   ret                     ; return to caller
1171+ 19F9
1172+ 19F9 CD 3A 33     CLOTST: call    GETINP          ; Get input character
1173+ 19FC FE 0F                cp      CTRLO           ; Is it control "O"?
1174+ 19FE C0                   ret     NZ              ; No don't flip flag
1175+ 19FF 3A C4 51             ld      A,(CTLOFG)      ; Get flag
1176+ 1A02 2F                   cpl                     ; Flip it
1177+ 1A03 32 C4 51             ld      (CTLOFG),A      ; Put it back
1178+ 1A06 A7                   and     A               ; is output enabled?
1179+ 1A07 CC 1A 09             call    Z,CURSOR_ON     ; yes, so cursor on
1180+ 1A0A AF                   xor     A               ; Null character
1181+ 1A0B C9                   ret
1182+ 1A0C
1183+ 1A0C              ; LIST: list the program stored into memory
1184+ 1A0C C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1185+ 1A0D 2B                   dec     HL              ; dec 'cos GETCHR INCs
1186+ 1A0E CD EE 1B             call    GETCHR          ; Get next character
1187+ 1A11 CA 67 1A             jp      Z,LSTALL        ; list all if nothing follows
1188+ 1A14 FE BE                cp      ZMINUS          ; is it '-'?
1189+ 1A16 20 20                jr      NZ,LST01        ; no, look for a line number
1190+ 1A18 11 00 00             ld      DE,$0000        ; yes, set search from 0
1191+ 1A1B CD 08 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1192+ 1A1E ED 43 FD 52          ld      (TMPBFR1),BC    ; store address of starting line
1193+ 1A22 CD AD 19             call    CHKSYN          ; skip '-'
1194+ 1A25 BE                   defb    ZMINUS
1195+ 1A26 CD BE 1C             call    ATOH            ; now, look for another number (ASCII number to DE)
1196+ 1A29 CD 0E 1B             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1197+ 1A2C ED 43 FF 52          ld      (TMPBFR2),BC    ; store address of ending line
1198+ 1A30 ED 4B FD 52          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1199+ 1A34 C5                   push    BC              ; store address of line for later use
1200+ 1A35 C3 9F 1A             jp      LISTLP          ; go listing
1201+ 1A38 CD BE 1C     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1202+ 1A3B ED 53 03 53  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1203+ 1A3F CD 08 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1204+ 1A42 ED 43 FD 52          ld      (TMPBFR1),BC    ; store address of starting line
1205+ 1A46 ED 43 FF 52          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1206+ 1A4A 2B                   dec     HL              ; dec 'cos GETCHR INCs
1207+ 1A4B CD EE 1B             call    GETCHR          ; Get next character
1208+ 1A4E CA 5A 1A             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1209+ 1A51 FE BE                cp      ZMINUS          ; is it '-'?
1210+ 1A53 CA 7F 1A             jp      Z,LST03         ; yes, read ending line
1211+ 1A56 C5           LST06:  push    BC              ; store address for later use
1212+ 1A57 C3 9F 1A             jp      LISTLP          ; jump to list
1213+ 1A5A ED 5B 03 53  LSTNOT: ld      DE,(TMPBFR4)
1214+ 1A5E CD 08 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1215+ 1A61 DA 56 1A             jp      C,LST06
1216+ 1A64 C3 25 17             jp      PRNTOK
1217+ 1A67 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1218+ 1A6A CD 08 1B             call    SRCHLIN         ; get address of last line
1219+ 1A6D ED 43 FF 52          ld      (TMPBFR2),BC    ; store it
1220+ 1A71 11 00 00             ld      DE,$0000        ; set start to first line in memory
1221+ 1A74 CD 08 1B             call    SRCHLIN         ; get address of first line
1222+ 1A77 ED 43 FD 52          ld      (TMPBFR1),BC    ; store it
1223+ 1A7B C5                   push    BC              ; store address of starting line for later use
1224+ 1A7C C3 9F 1A             jp      LISTLP          ; start printing
1225+ 1A7F CD AD 19     LST03:  call    CHKSYN          ; skip '-'
1226+ 1A82 BE                   defb    ZMINUS
1227+ 1A83 CD BE 1C             call    ATOH            ; look for another number (return into DE)
1228+ 1A86 7A                   ld      A,D
1229+ 1A87 B3                   or      E               ; is line=0?
1230+ 1A88 20 09                jr      NZ,LST05        ; no, jump over
1231+ 1A8A 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1232+ 1A8D CD 08 1B             call    SRCHLIN         ; get address of last line
1233+ 1A90 C3 96 1A             jp      LST02
1234+ 1A93 CD 0E 1B     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1235+ 1A96 ED 43 FF 52  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1236+ 1A9A ED 4B FD 52          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1237+ 1A9E C5                   push    BC              ; store it for later use
1238+ 1A9F E1           LISTLP: pop     HL              ; Restore address of line
1239+ 1AA0 4E                   ld      C,(HL)          ; Get LSB of next line
1240+ 1AA1 23                   inc     HL
1241+ 1AA2 46                   ld      B,(HL)          ; Get MSB of next line
1242+ 1AA3 23                   inc     HL
1243+ 1AA4 78                   ld      A,B             ; BC = 0 (End of program)?
1244+ 1AA5 B1                   or      C
1245+ 1AA6 CA 25 17             jp      Z,PRNTOK        ; Yes - Go to command mode
1246+ 1AA9 CD 19 1C             call    TSTBRK          ; Test for break key
1247+ 1AAC CD 1C 1B             call    TSTSPC          ; test for space
1248+ 1AAF C5                   push    BC              ; Save address of next line
1249+ 1AB0 3A F2 52             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1250+ 1AB3 A7                   and     A               ; is it at the beginning of a new line?
1251+ 1AB4 20 0B                jr      NZ,LST08        ; No, jump over
1252+ 1AB6 3E 0D                ld      A,CR            ; yes, so just send a CR
1253+ 1AB8 CD 91 3F             call    MONOUT          ; to serial if it's open
1254+ 1ABB AF                   xor     A               ; then, set cursor
1255+ 1ABC 32 B1 52             ld      (CURPOS),A      ; to position 0
1256+ 1ABF 18 03                jr      LST07           ; and continue
1257+ 1AC1 CD BB 1E     LST08:  call    PRNTCRLF        ; output CRLF
1258+ 1AC4 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1259+ 1AC5 23                   inc     HL
1260+ 1AC6 56                   ld      D,(HL)          ; Get MSB of line number
1261+ 1AC7 23                   inc     HL
1262+ 1AC8 E5                   push    HL              ; Save address of line start
1263+ 1AC9 EB                   ex      DE,HL           ; Line number to HL
1264+ 1ACA CD 1E 30             call    PRNTHL          ; Output line number in decimal
1265+ 1ACD 3E 20                ld      A,SPC           ; Space after line number
1266+ 1ACF E1                   pop     HL              ; Restore start of line address
1267+ 1AD0 CD B8 19     LSTLP2: call    OUTC            ; Output character in A
1268+ 1AD3 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1269+ 1AD4 B7                   or      A               ; End of line?
1270+ 1AD5 23                   inc     HL              ; To next byte in line
1271+ 1AD6 CA FA 1A             jp      Z,NXTLN         ; Yes - check next line
1272+ 1AD9 F2 D0 1A             jp      P,LSTLP2        ; No token - output it
1273+ 1ADC D6 7F                sub     ZEND-1          ; Find and output word
1274+ 1ADE 4F                   ld      C,A             ; Token offset+1 to C
1275+ 1ADF 11 4D 13             ld      DE,WORDS        ; Reserved word list
1276+ 1AE2 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1277+ 1AE3 13                   inc     DE              ; Move on to next
1278+ 1AE4 B7                   or      A               ; Is it start of word?
1279+ 1AE5 F2 E2 1A             jp      P,FNDTOK        ; No - Keep looking for word
1280+ 1AE8 0D                   dec     C               ; Count words
1281+ 1AE9 C2 E2 1A             jp      NZ,FNDTOK       ; Not there - keep looking
1282+ 1AEC E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1283+ 1AEE CD B8 19             call    OUTC            ; Output character
1284+ 1AF1 1A                   ld      A,(DE)          ; Get next character
1285+ 1AF2 13                   inc     DE              ; Move on to next
1286+ 1AF3 B7                   or      A               ; Is it end of word?
1287+ 1AF4 F2 EC 1A             jp      P,OUTWRD        ; No - output the rest
1288+ 1AF7 C3 D3 1A             jp      LSTLP3          ; Next byte in line
1289+ 1AFA D1           NXTLN:  pop     DE              ; recover address of current line
1290+ 1AFB 2A FF 52             ld      HL,(TMPBFR2)    ; address of last line to print
1291+ 1AFE CD B8 3F             call    CMP16           ; check if current line is over last printable line
1292+ 1B01 DA 25 17             jp      C,PRNTOK        ; finish - leave & print OK
1293+ 1B04 D5                   push    DE              ; store address of current line
1294+ 1B05 C3 9F 1A             jp      LISTLP          ; continue listing
1295+ 1B08              ; look for the address of a program line
1296+ 1B08 E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1297+ 1B09 CD D1 17             call    SRCHLN          ; search for line number in DE
1298+ 1B0C E1                   pop     HL              ; retrieve HL
1299+ 1B0D C9                   ret                     ; return to caller
1300+ 1B0E              ; look for the address of a program line - if the line isn't found,
1301+ 1B0E              ; it look backward for the previous line
1302+ 1B0E E5           SRCLN:  push    HL              ; store HL
1303+ 1B0F CD D1 17     SRCLN1: call    SRCHLN          ; search for line in DE
1304+ 1B12 DA 1A 1B             jp      C,LVSRLN        ; found it, leave loop
1305+ 1B15 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1306+ 1B16 7B                   ld      A,E
1307+ 1B17 B2                   or      D               ; is line number zero?
1308+ 1B18 20 F5                jr      NZ,SRCLN1       ; no, continue
1309+ 1B1A E1           LVSRLN: pop     HL              ; retrieve HL
1310+ 1B1B C9                   ret                     ; return to caller
1311+ 1B1C
1312+ 1B1C              ; during LISTing, check if PAUSE is pressed, then pause listing and
1313+ 1B1C              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1314+ 1B1C 3A 39 53     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1315+ 1B1F FE 20                cp      SPC             ; Is it SPACE?
1316+ 1B21 C0                   ret     NZ              ; No, return
1317+ 1B22 CD 3A 33     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1318+ 1B25 FE 20                cp      SPC             ; is it SPACE?
1319+ 1B27 20 05                jr      NZ,CNTWTSP      ; no, continue
1320+ 1B29 AF                   xor     A
1321+ 1B2A 32 39 53             ld      (TMPKEYBFR),A   ; reset key
1322+ 1B2D C9                   ret                     ; return to caller
1323+ 1B2E FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1324+ 1B30 20 F0                jr      NZ,WTSPC        ; no, loop
1325+ 1B32 C3 9A 12             jp      BRKRET          ; exit and output "Ok"
1326+ 1B35
1327+ 1B35
1328+ 1B35 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1329+ 1B37 32 D1 52             ld      (FORFLG),A      ; Save "FOR" flag
1330+ 1B3A CD AE 1D             call    LET             ; Set up initial index
1331+ 1B3D C1                   pop     BC              ; Drop RETurn address
1332+ 1B3E E5                   push    HL              ; Save code string address
1333+ 1B3F CD 97 1D             call    DATA            ; Get next statement address
1334+ 1B42 22 CD 52             ld      (LOOPST),HL     ; Save it for start of loop
1335+ 1B45 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1336+ 1B48 39                   add     HL,SP           ; Point to it
1337+ 1B49 CD 58 16     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1338+ 1B4C D1                   pop     DE              ; Get code string address
1339+ 1B4D C2 65 1B             jp      NZ,FORFND       ; No nesting found
1340+ 1B50 09                   add     HL,BC           ; Move into "FOR" block
1341+ 1B51 D5                   push    DE              ; Save code string address
1342+ 1B52 2B                   dec     HL
1343+ 1B53 56                   ld      D,(HL)          ; Get MSB of loop statement
1344+ 1B54 2B                   dec     HL
1345+ 1B55 5E                   ld      E,(HL)          ; Get LSB of loop statement
1346+ 1B56 23                   inc     HL
1347+ 1B57 23                   inc     HL
1348+ 1B58 E5                   push    HL              ; Save block address
1349+ 1B59 2A CD 52             ld      HL,(LOOPST)     ; Get address of loop statement
1350+ 1B5C CD A7 19             call    CPDEHL          ; Compare the FOR loops
1351+ 1B5F E1                   pop     HL              ; Restore block address
1352+ 1B60 C2 49 1B             jp      NZ,FORSLP       ; Different FORs - Find another
1353+ 1B63 D1                   pop     DE              ; Restore code string address
1354+ 1B64 F9                   ld      SP,HL           ; Remove all nested loops
1355+ 1B65
1356+ 1B65 EB           FORFND: ex      DE,HL           ; Code string address to HL
1357+ 1B66 0E 08                ld      C,$08
1358+ 1B68 CD 88 16             call    CHKSTK          ; Check for 8 levels of stack
1359+ 1B6B E5                   push    HL              ; Save code string address
1360+ 1B6C 2A CD 52             ld      HL,(LOOPST)     ; Get first statement of loop
1361+ 1B6F E3                   ex      (SP),HL         ; Save and restore code string
1362+ 1B70 E5                   push    HL              ; Re-save code string address
1363+ 1B71 2A CE 51             ld      HL,(LINEAT)     ; Get current line number
1364+ 1B74 E3                   ex      (SP),HL         ; Save and restore code string
1365+ 1B75 CD 7A 20             call    TSTNUM          ; Make sure it's a number
1366+ 1B78 CD AD 19             call    CHKSYN          ; Make sure "TO" is next
1367+ 1B7B B7                   defb    ZTO             ; "TO" token
1368+ 1B7C CD 77 20             call    GETNUM          ; Get "TO" expression value
1369+ 1B7F E5                   push    HL              ; Save code string address
1370+ 1B80 CD D0 2E             call    BCDEFP          ; Move "TO" value to BCDE
1371+ 1B83 E1                   pop     HL              ; Restore code string address
1372+ 1B84 C5                   push    BC              ; Save "TO" value in block
1373+ 1B85 D5                   push    DE
1374+ 1B86 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1375+ 1B89 51                   ld      D,C             ; C=0
1376+ 1B8A 5A                   ld      E,D             ; D=0
1377+ 1B8B 7E                   ld      A,(HL)          ; Get next byte in code string
1378+ 1B8C FE BC                cp      ZSTEP           ; See if "STEP" is stated
1379+ 1B8E 3E 01                ld      A,$01           ; Sign of step = 1
1380+ 1B90 C2 A1 1B             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1381+ 1B93 CD EE 1B             call    GETCHR          ; Jump over "STEP" token
1382+ 1B96 CD 77 20             call    GETNUM          ; Get step value
1383+ 1B99 E5                   push    HL              ; Save code string address
1384+ 1B9A CD D0 2E             call    BCDEFP          ; Move STEP to BCDE
1385+ 1B9D CD 84 2E             call    TSTSGN          ; Test sign of FPREG
1386+ 1BA0 E1                   pop     HL              ; Restore code string address
1387+ 1BA1 C5           SAVSTP: push    BC              ; Save the STEP value in block
1388+ 1BA2 D5                   push    DE
1389+ 1BA3 F5                   push    AF              ; Save sign of STEP
1390+ 1BA4 33                   inc     SP              ; Don't save flags
1391+ 1BA5 E5                   push    HL              ; Save code string address
1392+ 1BA6 2A D4 52             ld      HL,(BRKLIN)     ; Get address of index variable
1393+ 1BA9 E3                   ex      (SP),HL         ; Save and restore code string
1394+ 1BAA 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1395+ 1BAC C5                   push    BC              ; Save it
1396+ 1BAD 33                   inc     SP              ; Don't save C
1397+ 1BAE
1398+ 1BAE CD 19 1C     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1399+ 1BB1 22 D4 52             ld      (BRKLIN),HL     ; Save code address for break
1400+ 1BB4 7E                   ld      A,(HL)          ; Get next byte in code string
1401+ 1BB5 FE 3A                cp      ':'             ; Multi statement line?
1402+ 1BB7 CA CE 1B             jp      Z,EXCUTE        ; Yes - Execute it
1403+ 1BBA B7                   or      A               ; End of line?
1404+ 1BBB C2 CB 16             jp      NZ,SNERR        ; No - Syntax error
1405+ 1BBE 23                   inc     HL              ; Point to address of next line
1406+ 1BBF 7E                   ld      A,(HL)          ; Get LSB of line pointer
1407+ 1BC0 23                   inc     HL
1408+ 1BC1 B6                   or      (HL)            ; Is it zero (End of prog)?
1409+ 1BC2 CA 40 1C             jp      Z,ENDPRG        ; Yes - Terminate execution
1410+ 1BC5 23                   inc     HL              ; Point to line number
1411+ 1BC6 5E                   ld      E,(HL)          ; Get LSB of line number
1412+ 1BC7 23                   inc     HL
1413+ 1BC8 56                   ld      D,(HL)          ; Get MSB of line number
1414+ 1BC9 EB                   ex      DE,HL           ; Line number to HL
1415+ 1BCA 22 CE 51             ld      (LINEAT),HL     ; Save as current line number
1416+ 1BCD EB                   ex      DE,HL           ; Line number back to DE
1417+ 1BCE CD EE 1B     EXCUTE: call    GETCHR          ; Get key word
1418+ 1BD1 11 AE 1B             ld      DE,RUNCNT       ; Where to RETurn to
1419+ 1BD4 D5                   push    DE              ; Save for RETurn
1420+ 1BD5 C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1421+ 1BD6
1422+ 1BD6 D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1423+ 1BD8 DA AE 1D             jp      C,LET           ; No - try to assign it
1424+ 1BDB FE 36                cp      ZNEW+1-ZEND     ; END to NEW ?
1425+ 1BDD D2 CB 16             jp      NC,SNERR        ; Not a key word - ?SN Error
1426+ 1BE0 07                   rlca                    ; Double it
1427+ 1BE1 4F                   ld      C,A             ; BC = Offset into table
1428+ 1BE2 06 00                ld      B,0
1429+ 1BE4 EB                   ex      DE,HL           ; Save code string address
1430+ 1BE5 21 DA 14             ld      HL,WORDTB       ; Keyword address table
1431+ 1BE8 09                   add     HL,BC           ; Point to routine address
1432+ 1BE9 4E                   ld      C,(HL)          ; Get LSB of routine address
1433+ 1BEA 23                   inc     HL
1434+ 1BEB 46                   ld      B,(HL)          ; Get MSB of routine address
1435+ 1BEC C5                   push    BC              ; Save routine address
1436+ 1BED EB                   ex      DE,HL           ; Restore code string address
1437+ 1BEE
1438+ 1BEE              ; get a char from input buffer: exit with NC if character found is
1439+ 1BEE              ; not a number; exit with Z if nothing found; char is into A
1440+ 1BEE 23           GETCHR: inc     HL              ; Point to next character
1441+ 1BEF 7E                   ld      A,(HL)          ; Get next code string byte
1442+ 1BF0 FE 3A                cp      ':'             ; Z if ':'
1443+ 1BF2 D0                   ret     NC              ; NC if > "9"
1444+ 1BF3 FE 20                cp      SPC
1445+ 1BF5 CA EE 1B             jp      Z,GETCHR        ; Skip over spaces
1446+ 1BF8 FE 30                cp      '0'
1447+ 1BFA 3F                   ccf                     ; NC if < '0'
1448+ 1BFB 3C                   inc     A               ; Test for zero - Leave carry
1449+ 1BFC 3D                   dec     A               ; Z if Null
1450+ 1BFD C9                   ret
1451+ 1BFE
1452+ 1BFE EB           RESTOR: ex      DE,HL           ; Save code string address
1453+ 1BFF 2A 54 52             ld      HL,(BASTXT)     ; Point to start of program
1454+ 1C02 CA 13 1C             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1455+ 1C05 EB                   ex      DE,HL           ; Restore code string address
1456+ 1C06 CD BE 1C             call    ATOH            ; Get line number to DE
1457+ 1C09 E5                   push    HL              ; Save code string address
1458+ 1C0A CD D1 17             call    SRCHLN          ; Search for line number in DE
1459+ 1C0D 60                   ld      H,B             ; HL = Address of line
1460+ 1C0E 69                   ld      L,C
1461+ 1C0F D1                   pop     DE              ; Restore code string address
1462+ 1C10 D2 6D 1D             jp      NC,ULERR        ; ?UL Error if not found
1463+ 1C13 2B           RESTNL: dec     HL              ; Byte before DATA statement
1464+ 1C14 22 49 53     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1465+ 1C17 EB                   ex      DE,HL           ; Restore code string address
1466+ 1C18 C9                   ret
1467+ 1C19
1468+ 1C19
1469+ 1C19              ; check if CTRL-C is into input buffer
1470+ 1C19 DF           TSTBRK: rst     $18             ; Check input status
1471+ 1C1A C8                   ret     Z               ; No key, go back
1472+ 1C1B D7                   rst     $10             ; Get the key into A
1473+ 1C1C FE 1B                cp      ESC             ; Escape key?
1474+ 1C1E 28 11                jr      Z,BRK           ; Yes, break
1475+ 1C20 FE 03                cp      CTRLC           ; <Ctrl-C>
1476+ 1C22 28 0D                jr      Z,BRK           ; Yes, break
1477+ 1C24 FE 13                cp      CTRLS           ; Stop scrolling?
1478+ 1C26 C0                   ret     NZ              ; Other key, ignore
1479+ 1C27
1480+ 1C27
1481+ 1C27              ; wait for a key while listing
1482+ 1C27 D7           STALL:  rst     $10             ; Wait for key
1483+ 1C28 FE 11                cp      CTRLQ           ; Resume scrolling?
1484+ 1C2A C8                   ret     Z               ; Release the chokehold
1485+ 1C2B FE 03                cp      CTRLC           ; Second break?
1486+ 1C2D 28 07                jr      Z,STOP          ; Break during hold exits prog
1487+ 1C2F 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1488+ 1C31
1489+ 1C31 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1490+ 1C33 32 C8 51             ld      (BRKFLG),A      ; Store it
1491+ 1C36
1492+ 1C36 C0           STOP:   ret     NZ              ; Exit if anything else
1493+ 1C37 F6                   defb    $F6             ; Flag "STOP"
1494+ 1C38 C0           PEND:   ret     NZ              ; Exit if anything else
1495+ 1C39 22 D4 52             ld      (BRKLIN),HL     ; Save point of break
1496+ 1C3C 21                   defb    $21             ; Skip "OR 11111111B"
1497+ 1C3D F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1498+ 1C3F C1                   pop     BC              ; Return not needed and more
1499+ 1C40 2A CE 51     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1500+ 1C43 F5                   push    AF              ; Save STOP / END status
1501+ 1C44 7D                   ld      A,L             ; Is it direct break?
1502+ 1C45 A4                   and     H
1503+ 1C46 3C                   inc     A               ; Line is -1 if direct break
1504+ 1C47 CA 53 1C             jp      Z,NOLIN         ; Yes - No line number
1505+ 1C4A 22 D8 52             ld      (ERRLIN),HL     ; Save line of break
1506+ 1C4D 2A D4 52             ld      HL,(BRKLIN)     ; Get point of break
1507+ 1C50 22 DA 52             ld      (CONTAD),HL     ; Save point to CONTinue
1508+ 1C53 AF           NOLIN:  xor     A
1509+ 1C54 32 C4 51             ld      (CTLOFG),A      ; Enable output
1510+ 1C57 CD A9 1E             call    STTLIN          ; Start a new line
1511+ 1C5A F1                   pop     AF              ; Restore STOP / END status
1512+ 1C5B 21 4E 16             ld      HL,BRKMSG       ; "Break" message
1513+ 1C5E C2 64 1C             jp      NZ,ERRINT       ; "in line" wanted?
1514+ 1C61 C3 25 17             jp      PRNTOK          ; Go to command mode
1515+ 1C64 CD A5 16     ERRINT: call    EXITGM          ; exit from graphics mode
1516+ 1C67 C3 03 17             jp      ERRIN           ; print message
1517+ 1C6A
1518+ 1C6A
1519+ 1C6A              ; CONTinue after a break/error
1520+ 1C6A 21 FF FF     CONT:   ld      HL,-1           ; reset...
1521+ 1C6D 22 D0 51             ld      (HLPLN),HL      ; ...HELP line register
1522+ 1C70 2A DA 52             ld      HL,(CONTAD)     ; Get CONTinue address
1523+ 1C73 7C                   ld      A,H             ; Is it zero?
1524+ 1C74 B5                   or      L
1525+ 1C75 1E 20                ld      E,CN            ; ?CN Error
1526+ 1C77 CA DF 16             jp      Z,ERROR         ; Yes - output "?CN Error"
1527+ 1C7A EB                   ex      DE,HL           ; Save code string address
1528+ 1C7B 2A D8 52             ld      HL,(ERRLIN)     ; Get line of last break
1529+ 1C7E 22 CE 51             ld      (LINEAT),HL     ; Set up current line number
1530+ 1C81 EB                   ex      DE,HL           ; Restore code string address
1531+ 1C82 C9                   ret                     ; CONTinue where left off
1532+ 1C83
1533+ 1C83 E5           ACCSUM: push    HL              ; Save address in array
1534+ 1C84 2A C5 51             ld      HL,(CHKSUM)     ; Get check sum
1535+ 1C87 06 00                ld      B,$00           ; BC - Value of byte
1536+ 1C89 4F                   ld      C,A
1537+ 1C8A 09                   add     HL,BC           ; Add byte to check sum
1538+ 1C8B 22 C5 51             ld      (CHKSUM),HL     ; Re-save check sum
1539+ 1C8E E1                   pop     HL              ; Restore address in array
1540+ 1C8F C9                   ret
1541+ 1C90
1542+ 1C90 7E           CHKLTR: ld      A,(HL)          ; Get byte
1543+ 1C91 FE 41                cp      'A'             ; < 'a' ?
1544+ 1C93 D8                   ret     C               ; Carry set if not letter
1545+ 1C94 FE 5B                cp      'Z'+1           ; > 'z' ?
1546+ 1C96 3F                   ccf
1547+ 1C97 C9                   ret                     ; Carry set if not letter
1548+ 1C98
1549+ 1C98 CD EE 1B     FPSINT: call    GETCHR          ; Get next character
1550+ 1C9B CD 77 20     POSINT: call    GETNUM          ; Get integer 0 to 32767
1551+ 1C9E CD 84 2E     DEPINT: call    TSTSGN          ; Test sign of FPREG
1552+ 1CA1 FA B9 1C             jp      M,FCERR         ; Negative - ?FC Error
1553+ 1CA4 3A 54 53     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1554+ 1CA7 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1555+ 1CA9 DA 2C 2F             jp      C,FPINT         ; Yes - convert it
1556+ 1CAC 01 80 90             ld      BC,$9080        ; BCDE = -32768
1557+ 1CAF 11 00 00             ld      DE,$0000
1558+ 1CB2 E5                   push    HL              ; Save code string address
1559+ 1CB3 CD FF 2E             call    CMPNUM          ; Compare FPREG with BCDE
1560+ 1CB6 E1                   pop     HL              ; Restore code string address
1561+ 1CB7 51                   ld      D,C             ; MSB to D
1562+ 1CB8 C8                   ret     Z               ; Return if in range
1563+ 1CB9 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1564+ 1CBB C3 DF 16             jp      ERROR           ; Output error-
1565+ 1CBE
1566+ 1CBE
1567+ 1CBE              ; convert a number in ASCII chars into an integer into DE
1568+ 1CBE 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1569+ 1CBF 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1570+ 1CC2 CD EE 1B     GTLNLP: call    GETCHR          ; Get next character
1571+ 1CC5 D0                   ret     NC              ; Exit if not a digit
1572+ 1CC6 E5                   push    HL              ; Save code string address
1573+ 1CC7 F5                   push    AF              ; Save digit
1574+ 1CC8 21 98 19             ld      HL,65529/10     ; Largest number 65529
1575+ 1CCB CD A7 19             call    CPDEHL          ; Number in range?
1576+ 1CCE DA CB 16             jp      C,SNERR         ; No - ?SN Error
1577+ 1CD1 62                   ld      H,D             ; HL = Number
1578+ 1CD2 6B                   ld      L,E
1579+ 1CD3 19                   add     HL,DE           ; Times 2
1580+ 1CD4 29                   add     HL,HL           ; Times 4
1581+ 1CD5 19                   add     HL,DE           ; Times 5
1582+ 1CD6 29                   add     HL,HL           ; Times 10
1583+ 1CD7 F1                   pop     AF              ; Restore digit
1584+ 1CD8 D6 30                sub     '0'             ; Make it 0 to 9
1585+ 1CDA 5F                   ld      E,A             ; DE = Value of digit
1586+ 1CDB 16 00                ld      D,0
1587+ 1CDD 19                   add     HL,DE           ; Add to number
1588+ 1CDE EB                   ex      DE,HL           ; Number to DE
1589+ 1CDF E1                   pop     HL              ; Restore code string address
1590+ 1CE0 C3 C2 1C             jp      GTLNLP          ; Go to next character
1591+ 1CE3
1592+ 1CE3 CA 01 18     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1593+ 1CE6 CD 77 20             call    GETNUM          ; Evaluate a number
1594+ 1CE9 CD A4 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1595+ 1CEC 2B                   dec     HL              ; Cancel increment
1596+ 1CED CD EE 1B             call    GETCHR          ; Get next character
1597+ 1CF0 E5                   push    HL              ; Save code string address
1598+ 1CF1 2A B5 52             ld      HL,(LSTRAM)     ; Get end of RAM
1599+ 1CF4 CA 0C 1D             jp      Z,STORED        ; No value given - Use stored
1600+ 1CF7 E1                   pop     HL              ; Restore code string address
1601+ 1CF8 CD AD 19             call    CHKSYN          ; Check for comma
1602+ 1CFB 2C                   defb    ','
1603+ 1CFC D5                   push    DE              ; Save number
1604+ 1CFD CD 77 20             call    GETNUM          ; Evaluate a number
1605+ 1D00 CD A4 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1606+ 1D03 2B                   dec     HL              ; Cancel increment
1607+ 1D04 CD EE 1B             call    GETCHR          ; Get next character
1608+ 1D07 C2 CB 16             jp      NZ,SNERR        ; ?SN Error if more on line
1609+ 1D0A E3                   ex      (SP),HL         ; Save code string address
1610+ 1D0B EB                   ex      DE,HL           ; Number to DE
1611+ 1D0C 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1612+ 1D0D 93                   sub     E               ; Subtract LSB of string space
1613+ 1D0E 5F                   ld      E,A             ; Save LSB
1614+ 1D0F 7C                   ld      A,H             ; Get MSB of new RAM top
1615+ 1D10 9A                   sbc     A,D             ; Subtract MSB of string space
1616+ 1D11 57                   ld      D,A             ; Save MSB
1617+ 1D12 DA A0 16             jp      C,OMERR         ; ?OM Error if not enough mem
1618+ 1D15 E5                   push    HL              ; Save RAM top
1619+ 1D16 2A 43 53             ld      HL,(PROGND)     ; Get program end
1620+ 1D19 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1621+ 1D1C 09                   add     HL,BC           ; Get lowest address
1622+ 1D1D CD A7 19             call    CPDEHL          ; Enough memory?
1623+ 1D20 D2 A0 16             jp      NC,OMERR        ; No - ?OM Error
1624+ 1D23 EB                   ex      DE,HL           ; RAM top to HL
1625+ 1D24 22 CC 51             ld      (STRSPC),HL     ; Set new string space
1626+ 1D27 E1                   pop     HL              ; End of memory to use
1627+ 1D28 22 B5 52             ld      (LSTRAM),HL     ; Set new top of RAM
1628+ 1D2B E1                   pop     HL              ; Restore code string address
1629+ 1D2C C3 01 18             jp      INTVAR          ; Initialise variables
1630+ 1D2F
1631+ 1D2F E5           RUN:    push    HL              ; store HL
1632+ 1D30 21 FF FF             ld      HL,-1           ; reset...
1633+ 1D33 22 D0 51             ld      (HLPLN),HL      ; ...HELP line register
1634+ 1D36 E1                   pop     HL              ; retrieve HL
1635+ 1D37 CA FD 17             jp      Z,RUNFST        ; RUN from start if just RUN
1636+ 1D3A CD 01 18             call    INTVAR          ; Initialise variables
1637+ 1D3D 01 AE 1B             ld      BC,RUNCNT       ; Execution driver loop
1638+ 1D40 C3 53 1D             jp      RUNLIN          ; RUN from line number
1639+ 1D43
1640+ 1D43 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1641+ 1D45 CD 88 16             call    CHKSTK          ; Check for 3 levels of stack
1642+ 1D48 C1                   pop     BC              ; Get return address
1643+ 1D49 E5                   push    HL              ; Save code string for RETURN
1644+ 1D4A E5                   push    HL              ; And for GOSUB routine
1645+ 1D4B 2A CE 51             ld      HL,(LINEAT)     ; Get current line
1646+ 1D4E E3                   ex      (SP),HL         ; Into stack - Code string out
1647+ 1D4F 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1648+ 1D51 F5                   push    AF              ; Save token
1649+ 1D52 33                   inc     SP              ; Don't save flags
1650+ 1D53
1651+ 1D53 C5           RUNLIN: push    BC              ; Save return address
1652+ 1D54 CD BE 1C     GOTO:   call    ATOH            ; ASCII number to DE binary
1653+ 1D57 CD 99 1D             call    REM             ; Get end of line
1654+ 1D5A E5                   push    HL              ; Save end of line
1655+ 1D5B 2A CE 51             ld      HL,(LINEAT)     ; Get current line
1656+ 1D5E CD A7 19             call    CPDEHL          ; Line after current?
1657+ 1D61 E1                   pop     HL              ; Restore end of line
1658+ 1D62 23                   inc     HL              ; Start of next line
1659+ 1D63 DC D4 17             call    C,SRCHLP        ; Line is after current line
1660+ 1D66 D4 D1 17             call    NC,SRCHLN       ; Line is before current line
1661+ 1D69 60                   ld      H,B             ; Set up code string address
1662+ 1D6A 69                   ld      L,C
1663+ 1D6B 2B                   dec     HL              ; Incremented after
1664+ 1D6C D8                   ret     C               ; Line found
1665+ 1D6D 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1666+ 1D6F C3 DF 16             jp      ERROR           ; Output error message
1667+ 1D72
1668+ 1D72 C0           RETURN: ret     NZ              ; Return if not just RETURN
1669+ 1D73 16 FF                ld      D,-1            ; Flag "GOSUB" search
1670+ 1D75 CD 54 16             call    BAKSTK          ; Look "GOSUB" block
1671+ 1D78 F9                   ld      SP,HL           ; Kill all FORs in subroutine
1672+ 1D79 FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1673+ 1D7B 1E 04                ld      E,RG            ; ?RG Error
1674+ 1D7D C2 DF 16             jp      NZ,ERROR        ; Error if no "GOSUB" found
1675+ 1D80 E1                   pop     HL              ; Get RETURN line number
1676+ 1D81 22 CE 51             ld      (LINEAT),HL     ; Save as current
1677+ 1D84 23                   inc     HL              ; Was it from direct statement?
1678+ 1D85 7C                   ld      A,H
1679+ 1D86 B5                   or      L               ; Return to line
1680+ 1D87 C2 91 1D             jp      NZ,RETLIN       ; No - Return to line
1681+ 1D8A 3A D2 52             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1682+ 1D8D B7                   or      A               ; If so buffer is corrupted
1683+ 1D8E C2 24 17             jp      NZ,POPNOK       ; Yes - Go to command mode
1684+ 1D91 21 AE 1B     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1685+ 1D94 E3                   ex      (SP),HL         ; Into stack - Code string out
1686+ 1D95 3E                   defb    $3E             ; Skip "pop HL"
1687+ 1D96 E1           NXTDTA: pop     HL              ; Restore code string address
1688+ 1D97
1689+ 1D97 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1690+ 1D99 0E 00        REM:    ld      C,$00           ; 00  End of statement
1691+ 1D9B 06 00                ld      B,$00
1692+ 1D9D 79           NXTSTL: ld      A,C             ; Statement and byte
1693+ 1D9E 48                   ld      C,B
1694+ 1D9F 47                   ld      B,A             ; Statement end byte
1695+ 1DA0 7E           NXTSTT: ld      A,(HL)          ; Get byte
1696+ 1DA1 B7                   or      A               ; End of line?
1697+ 1DA2 C8                   ret     Z               ; Yes - Exit
1698+ 1DA3 B8                   cp      B               ; End of statement?
1699+ 1DA4 C8                   ret     Z               ; Yes - Exit
1700+ 1DA5 23                   inc     HL              ; Next byte
1701+ 1DA6 FE 22                cp      $22             ; '"'             ; Literal string?
1702+ 1DA8 CA 9D 1D             jp      Z,NXTSTL        ; Yes - Look for another '"'
1703+ 1DAB C3 A0 1D             jp      NXTSTT          ; Keep looking
1704+ 1DAE
1705+ 1DAE CD 86 22     LET:    call    GETVAR          ; Get variable name
1706+ 1DB1 CD AD 19             call    CHKSYN          ; Make sure "=" follows
1707+ 1DB4 C8                   defb    ZEQUAL          ; "=" token
1708+ 1DB5 D5                   push    DE              ; Save address of variable
1709+ 1DB6 3A B3 52             ld      A,(TYPE)        ; Get data type
1710+ 1DB9 F5                   push    AF              ; Save type
1711+ 1DBA CD 89 20             call    EVAL            ; Evaluate expression
1712+ 1DBD F1                   pop     AF              ; Restore type
1713+ 1DBE E3                   ex      (SP),HL         ; Save code - Get var addr
1714+ 1DBF 22 D4 52             ld      (BRKLIN),HL     ; Save address of variable
1715+ 1DC2 1F                   rra                     ; Adjust type
1716+ 1DC3 CD 7C 20             call    CHKTYP          ; Check types are the same
1717+ 1DC6 CA 01 1E             jp      Z,LETNUM        ; Numeric - Move value
1718+ 1DC9 E5           LETSTR: push    HL              ; Save address of string var
1719+ 1DCA 2A 51 53             ld      HL,(FPREG)      ; Pointer to string entry
1720+ 1DCD E5                   push    HL              ; Save it on stack
1721+ 1DCE 23                   inc     HL              ; Skip over length
1722+ 1DCF 23                   inc     HL
1723+ 1DD0 5E                   ld      E,(HL)          ; LSB of string address
1724+ 1DD1 23                   inc     HL
1725+ 1DD2 56                   ld      D,(HL)          ; MSB of string address
1726+ 1DD3 2A 54 52             ld      HL,(BASTXT)     ; Point to start of program
1727+ 1DD6 CD A7 19             call    CPDEHL          ; Is string before program?
1728+ 1DD9 D2 F0 1D             jp      NC,CRESTR       ; Yes - Create string entry
1729+ 1DDC 2A CC 51             ld      HL,(STRSPC)     ; Point to string space
1730+ 1DDF CD A7 19             call    CPDEHL          ; Is string literal in program?
1731+ 1DE2 D1                   pop     DE              ; Restore address of string
1732+ 1DE3 D2 F8 1D             jp      NC,MVSTPT       ; Yes - Set up pointer
1733+ 1DE6 21 C5 52             ld      HL,TMPSTR       ; Temporary string pool
1734+ 1DE9 CD A7 19             call    CPDEHL          ; Is string in temporary pool?
1735+ 1DEC D2 F8 1D             jp      NC,MVSTPT       ; No - Set up pointer
1736+ 1DEF 3E                   defb    $3E             ; Skip "pop DE"
1737+ 1DF0 D1           CRESTR: pop     DE              ; Restore address of string
1738+ 1DF1 CD E0 26             call    BAKTMP          ; Back to last tmp-str entry
1739+ 1DF4 EB                   ex      DE,HL           ; Address of string entry
1740+ 1DF5 CD 19 25             call    SAVSTR          ; Save string in string area
1741+ 1DF8 CD E0 26     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1742+ 1DFB E1                   pop     HL              ; Get string pointer
1743+ 1DFC CD DF 2E             call    DETHL4          ; Move string pointer to var
1744+ 1DFF E1                   pop     HL              ; Restore code string address
1745+ 1E00 C9                   ret
1746+ 1E01
1747+ 1E01 E5           LETNUM: push    HL              ; Save address of variable
1748+ 1E02 CD DC 2E             call    FPTHL           ; Move value to variable
1749+ 1E05 D1                   pop     DE              ; Restore address of variable
1750+ 1E06 E1                   pop     HL              ; Restore code string address
1751+ 1E07 C9                   ret
1752+ 1E08
1753+ 1E08 CD FD 28     ON:     call    GETINT          ; Get integer 0-255
1754+ 1E0B 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1755+ 1E0C 47                   ld      B,A             ; Save in B
1756+ 1E0D FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1757+ 1E0F CA 17 1E             jp      Z,ONGO          ; Yes - Find line number
1758+ 1E12 CD AD 19             call    CHKSYN          ; Make sure it's "GOTO"
1759+ 1E15 88                   defb    ZGOTO           ; "GOTO" token
1760+ 1E16 2B                   dec     HL              ; Cancel increment
1761+ 1E17 4B           ONGO:   ld      C,E             ; Integer of branch value
1762+ 1E18 0D           ONGOLP: dec     C               ; Count branches
1763+ 1E19 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1764+ 1E1A CA D6 1B             jp      Z,ONJMP         ; Go to that line if right one
1765+ 1E1D CD BF 1C             call    GETLN           ; Get line number to DE
1766+ 1E20 FE 2C                cp      ','             ; Another line number?
1767+ 1E22 C0                   ret     NZ              ; No - Drop through
1768+ 1E23 C3 18 1E             jp      ONGOLP          ; Yes - loop
1769+ 1E26
1770+ 1E26 CD 89 20     IF:     call    EVAL            ; Evaluate expression
1771+ 1E29 7E                   ld      A,(HL)          ; Get token
1772+ 1E2A FE 88                cp      ZGOTO           ; "GOTO" token?
1773+ 1E2C CA 34 1E             jp      Z,IFGO          ; Yes - Get line
1774+ 1E2F CD AD 19             call    CHKSYN          ; Make sure it's "THEN"
1775+ 1E32 BA                   defb    ZTHEN           ; "THEN" token
1776+ 1E33 2B                   dec     HL              ; Cancel increment
1777+ 1E34 CD 7A 20     IFGO:   call    TSTNUM          ; Make sure it's numeric
1778+ 1E37 CD 84 2E             call    TSTSGN          ; Test state of expression
1779+ 1E3A CA 46 1E             jp      Z,IF1           ; False - Jump over
1780+ 1E3D CD EE 1B     IF0:    call    GETCHR          ; Get next character
1781+ 1E40 DA 54 1D             jp      C,GOTO          ; Number - GOTO that line
1782+ 1E43 C3 D5 1B             jp      IFJMP           ; Otherwise do statement
1783+ 1E46 0E AE        IF1:    ld      C,ZELSE
1784+ 1E48 CD 9B 1D             call    REM+2           ; check statement
1785+ 1E4B B7                   or      A               ; end of line?
1786+ 1E4C C8                   ret     Z               ; yes, leave
1787+ 1E4D FE AE                cp      ZELSE
1788+ 1E4F 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1789+ 1E51 C3 3D 1E             jp      IF0             ; return to IF
1790+ 1E54
1791+ 1E54
1792+ 1E54 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1793+ 1E55 CD EE 1B             call    GETCHR          ; Get next character
1794+ 1E58 CA BB 1E     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1795+ 1E5B C8           PRNTLP: ret     Z               ; End of list - Exit
1796+ 1E5C FE B6                cp      ZTAB            ; "TAB(" token?
1797+ 1E5E CA E3 1E             jp      Z,DOTAB         ; Yes - Do TAB routine
1798+ 1E61 FE B9                cp      ZSPC            ; "SPC(" token?
1799+ 1E63 CA E3 1E             jp      Z,DOTAB         ; Yes - Do SPC routine
1800+ 1E66 E5                   push    HL              ; Save code string address
1801+ 1E67 FE 2C                cp      ','             ; Comma?
1802+ 1E69 CA CA 1E             jp      Z,DOCOM         ; Yes - Move to next zone
1803+ 1E6C FE 3B                cp      ';'             ; Semi-colon?
1804+ 1E6E CA 07 1F             jp      Z,NEXITM        ; Do semi-colon routine
1805+ 1E71 C1                   pop     BC              ; Code string address to BC
1806+ 1E72 CD 89 20             call    EVAL            ; Evaluate expression
1807+ 1E75 E5                   push    HL              ; Save code string address
1808+ 1E76 3A B3 52             ld      A,(TYPE)        ; Get variable type
1809+ 1E79 B7                   or      A               ; Is it a string variable?
1810+ 1E7A C2 A2 1E             jp      NZ,PRNTST       ; Yes - Output string contents
1811+ 1E7D CD 29 30             call    NUMASC          ; Convert number to text
1812+ 1E80 CD 3D 25             call    CRTST           ; Create temporary string
1813+ 1E83 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1814+ 1E85 2A 51 53             ld      HL,(FPREG)      ; Get length of output
1815+ 1E88 34                   inc     (HL)            ; Plus 1 for the space
1816+ 1E89 2A 51 53             ld      HL,(FPREG)      ; < Not needed >
1817+ 1E8C 3A C1 51             ld      A,(LWIDTH)      ; Get width of line
1818+ 1E8F 47                   ld      B,A             ; To B
1819+ 1E90 04                   inc     B               ; Width 255 (No limit)?
1820+ 1E91 CA 9E 1E             jp      Z,PRNTNB        ; Yes - Output number string
1821+ 1E94 04                   inc     B               ; Adjust it
1822+ 1E95 3A B1 52             ld      A,(CURPOS)      ; Get cursor position
1823+ 1E98 86                   add     A,(HL)          ; Add length of string
1824+ 1E99 3D                   dec     A               ; Adjust it
1825+ 1E9A B8                   cp      B               ; Will output fit on this line?
1826+ 1E9B D4 BB 1E             call    NC,PRNTCRLF     ; No - CRLF first
1827+ 1E9E CD 82 25     PRNTNB: call    PRS1            ; Output string at (HL)
1828+ 1EA1 AF                   xor     A               ; Skip call by setting 'z' flag
1829+ 1EA2 C4 82 25     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1830+ 1EA5 E1                   pop     HL              ; Restore code string address
1831+ 1EA6 C3 54 1E             jp      MRPRNT          ; See if more to PRINT
1832+ 1EA9
1833+ 1EA9 3A B1 52     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1834+ 1EAC B7                   or      A               ; Already at start?
1835+ 1EAD C8                   ret     Z               ; Yes - Do nothing
1836+ 1EAE C3 BB 1E             jp      PRNTCRLF        ; Start a new line
1837+ 1EB1
1838+ 1EB1 AF           ENDINP: xor     A
1839+ 1EB2 32 37 53             ld      (KBDNPT),A      ; char is not from keyboard
1840+ 1EB5 77                   ld      (HL),A          ; Mark end of buffer
1841+ 1EB6 21 56 52             ld      HL,BUFFER-1     ; Point to buffer
1842+ 1EB9 18 0A                jr      CNTEND
1843+ 1EBB 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1844+ 1EBD CD B8 19             call    OUTC            ; Output character
1845+ 1EC0 3E 0A                ld      A,LF            ; Load a LF
1846+ 1EC2 CD B8 19             call    OUTC            ; Output character
1847+ 1EC5 AF           CNTEND: xor     A               ; Set to position 0
1848+ 1EC6 32 B1 52             ld      (CURPOS),A      ; Store it
1849+ 1EC9 C9                   ret                     ; return to caller
1850+ 1ECA
1851+ 1ECA 3A C2 51     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1852+ 1ECD 47                   ld      B,A             ; Save in B
1853+ 1ECE 3A F2 52             ld      A,(SCR_CURS_X)  ; Get current position
1854+ 1ED1 B8                   cp      B               ; Within the limit?
1855+ 1ED2 D4 BB 1E             call    NC,PRNTCRLF     ; No - output CRLF
1856+ 1ED5 D2 07 1F             jp      NC,NEXITM       ; Get next item
1857+ 1ED8 D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1858+ 1EDA D2 D8 1E             jp      NC,ZONELP       ; Repeat if more zones
1859+ 1EDD 2F                   cpl                     ; Number of null chars to output
1860+ 1EDE 0E 00                ld      C,NLLCR         ; null char
1861+ 1EE0 C3 FD 1E             jp      ASPCS           ; Output them
1862+ 1EE3
1863+ 1EE3 F5           DOTAB:  push    AF              ; Save token
1864+ 1EE4 CD FA 28             call    FNDNUM          ; Evaluate expression
1865+ 1EE7 CD AD 19             call    CHKSYN          ; Make sure ")" follows
1866+ 1EEA 29                   defb    ')'
1867+ 1EEB 2B                   dec     HL              ; Back space on to ")"
1868+ 1EEC F1                   pop     AF              ; Restore token
1869+ 1EED 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1870+ 1EEF D6 B9                sub     ZSPC            ; Was it "SPC(" ?
1871+ 1EF1 E5                   push    HL              ; Save code string address
1872+ 1EF2 CA F8 1E             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1873+ 1EF5 3A F2 52             ld      A,(SCR_CURS_X)  ; Get current X position
1874+ 1EF8 2F           DOSPC:  cpl                     ; Number of spaces to print to
1875+ 1EF9 83                   add     A,E             ; Total number to print
1876+ 1EFA D2 07 1F             jp      NC,NEXITM       ; TAB < Current POS(X)
1877+ 1EFD 3C           ASPCS:  inc     A               ; Output A spaces
1878+ 1EFE 47                   ld      B,A             ; Save number to print
1879+ 1EFF 79           SPCLP:  ld      A,C             ; char to print
1880+ 1F00 CD B8 19             call    OUTC            ; Output character in A
1881+ 1F03 05                   dec     B               ; Count them
1882+ 1F04 C2 FF 1E             jp      NZ,SPCLP        ; Repeat if more
1883+ 1F07 E1           NEXITM: pop     HL              ; Restore code string address
1884+ 1F08 CD EE 1B             call    GETCHR          ; Get next character
1885+ 1F0B C3 5B 1E             jp      PRNTLP          ; More to print
1886+ 1F0E
1887+ 1F0E 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1887+ 1F12 6F 20 66 72
1887+ 1F16 6F 6D 20 73
1887+ 1F1A 74 61 72 74
1887+ 1F1E 0D 00
1888+ 1F20
1889+ 1F20 3A D3 52     BADINP: ld      A,(READFG)      ; READ or INPUT?
1890+ 1F23 B7                   or      A
1891+ 1F24 C2 C5 16             jp      NZ,DATSNR       ; READ - ?SN Error
1892+ 1F27 C1                   pop     BC              ; Throw away code string addr
1893+ 1F28 21 0E 1F             ld      HL,REDO         ; "Redo from start" message
1894+ 1F2B CD 7F 25             call    PRS             ; Output string
1895+ 1F2E C3 30 18             jp      DOAGN           ; Do last INPUT again
1896+ 1F31
1897+ 1F31 CD EA 24     INPUT:  call    IDTEST          ; Test for illegal direct
1898+ 1F34 7E                   ld      A,(HL)          ; Get character after "INPUT"
1899+ 1F35 FE 22                cp      $22             ; '"' ; Is there a prompt string?
1900+ 1F37 3E 00                ld      A,$00           ; Clear A and leave flags
1901+ 1F39 32 C4 51             ld      (CTLOFG),A      ; Enable output
1902+ 1F3C C2 4B 1F             jp      NZ,NOPMPT       ; No prompt - get input
1903+ 1F3F CD 3E 25             call    QTSTR           ; Get string terminated by '"'
1904+ 1F42 CD AD 19             call    CHKSYN          ; Check for ';' after prompt
1905+ 1F45 3B                   defb    ";"
1906+ 1F46 E5                   push    HL              ; Save code string address
1907+ 1F47 CD 82 25             call    PRS1            ; Output prompt string
1908+ 1F4A 3E                   defb    $3E             ; Skip "push HL"
1909+ 1F4B E5           NOPMPT: push    HL              ; Save code string address
1910+ 1F4C CD 34 18             call    PROMPT          ; Get input with "? " prompt
1911+ 1F4F C1                   pop     BC              ; Restore code string address
1912+ 1F50 DA 3D 1C             jp      C,INPBRK        ; Break pressed - Exit
1913+ 1F53 23                   inc     HL              ; Next byte
1914+ 1F54 7E                   ld      A,(HL)          ; Get it
1915+ 1F55 B7                   or      A               ; End of line?
1916+ 1F56 2B                   dec     HL              ; Back again
1917+ 1F57 C5                   push    BC              ; Re-save code string address
1918+ 1F58 CD 2F 09             call    CURSOR_OFF      ; disable cursor
1919+ 1F5B CA 96 1D             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1920+ 1F5E 36 2C                ld      (HL),','        ; Store comma as separator
1921+ 1F60 C3 68 1F             jp      NXTITM          ; Get next item
1922+ 1F63
1923+ 1F63 E5           READ:   push    HL              ; Save code string address
1924+ 1F64 2A 49 53             ld      HL,(NXTDAT)     ; Next DATA statement
1925+ 1F67 F6                   defb    $F6             ; Flag "READ"
1926+ 1F68 AF           NXTITM: xor     A               ; Flag "INPUT"
1927+ 1F69 32 D3 52             ld      (READFG),A      ; Save "READ"/"INPUT" flag
1928+ 1F6C E3                   ex      (SP),HL         ; Get code str' , Save pointer
1929+ 1F6D C3 74 1F             jp      GTVLUS          ; Get values
1930+ 1F70
1931+ 1F70 CD AD 19     NEDMOR: call    CHKSYN          ; Check for comma between items
1932+ 1F73 2C                   defb    ','
1933+ 1F74 CD 86 22     GTVLUS: call    GETVAR          ; Get variable name
1934+ 1F77 E3                   ex      (SP),HL         ; Save code str" , Get pointer
1935+ 1F78 D5                   push    DE              ; Save variable address
1936+ 1F79 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1937+ 1F7A FE 2C                cp      ','             ; Comma?
1938+ 1F7C CA 9C 1F             jp      Z,ANTVLU        ; Yes - Get another value
1939+ 1F7F 3A D3 52             ld      A,(READFG)      ; Is it READ?
1940+ 1F82 B7                   or      A
1941+ 1F83 C2 08 20             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1942+ 1F86 3E 3F                ld      A,'?'           ; More INPUT needed
1943+ 1F88 CD B8 19             call    OUTC            ; Output character
1944+ 1F8B CD 34 18             call    PROMPT          ; Get INPUT with prompt
1945+ 1F8E D1                   pop     DE              ; Variable address
1946+ 1F8F C1                   pop     BC              ; Code string address
1947+ 1F90 DA 3D 1C             jp      C,INPBRK        ; Break pressed
1948+ 1F93 23                   inc     HL              ; Point to next DATA byte
1949+ 1F94 7E                   ld      A,(HL)          ; Get byte
1950+ 1F95 B7                   or      A               ; Is it zero (No input) ?
1951+ 1F96 2B                   dec     HL              ; Back space INPUT pointer
1952+ 1F97 C5                   push    BC              ; Save code string address
1953+ 1F98 CA 96 1D             jp      Z,NXTDTA        ; Find end of buffer
1954+ 1F9B D5                   push    DE              ; Save variable address
1955+ 1F9C 3A B3 52     ANTVLU: ld      A,(TYPE)        ; Check data type
1956+ 1F9F B7                   or      A               ; Is it numeric?
1957+ 1FA0 CA C6 1F             jp      Z,INPBIN        ; Yes - Convert to binary
1958+ 1FA3 CD EE 1B             call    GETCHR          ; Get next character
1959+ 1FA6 57                   ld      D,A             ; Save input character
1960+ 1FA7 47                   ld      B,A             ; Again
1961+ 1FA8 FE 22                cp      $22             ; '"'     ; Start of literal sting?
1962+ 1FAA CA BA 1F             jp      Z,STRENT        ; Yes - Create string entry
1963+ 1FAD 3A D3 52             ld      A,(READFG)      ; "READ" or "INPUT" ?
1964+ 1FB0 B7                   or      A
1965+ 1FB1 57                   ld      D,A             ; Save 00 if "INPUT"
1966+ 1FB2 CA B7 1F             jp      Z,ITMSEP        ; "INPUT" - End with 00
1967+ 1FB5 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
1968+ 1FB7 06 2C        ITMSEP: ld      B,','           ; Item separator
1969+ 1FB9 2B                   dec     HL              ; Back space for DTSTR
1970+ 1FBA CD 41 25     STRENT: call    DTSTR           ; Get string terminated by D
1971+ 1FBD EB                   ex      DE,HL           ; String address to DE
1972+ 1FBE 21 D1 1F             ld      HL,LTSTND       ; Where to go after LETSTR
1973+ 1FC1 E3                   ex      (SP),HL         ; Save HL , get input pointer
1974+ 1FC2 D5                   push    DE              ; Save address of string
1975+ 1FC3 C3 C9 1D             jp      LETSTR          ; Assign string to variable
1976+ 1FC6
1977+ 1FC6 CD EE 1B     INPBIN: call    GETCHR          ; Get next character
1978+ 1FC9 CD 8B 2F             call    ASCTFP          ; Convert ASCII to FP number
1979+ 1FCC E3                   ex      (SP),HL         ; Save input ptr, Get var addr
1980+ 1FCD CD DC 2E             call    FPTHL           ; Move FPREG to variable
1981+ 1FD0 E1                   pop     HL              ; Restore input pointer
1982+ 1FD1 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1983+ 1FD2 CD EE 1B             call    GETCHR          ; Get next character
1984+ 1FD5 CA DD 1F             jp      Z,MORDT         ; End of line - More needed?
1985+ 1FD8 FE 2C                cp      ','             ; Another value?
1986+ 1FDA C2 20 1F             jp      NZ,BADINP       ; No - Bad input
1987+ 1FDD E3           MORDT:  ex      (SP),HL         ; Get code string address
1988+ 1FDE 2B                   dec     HL              ; dec 'cos GETCHR INCs
1989+ 1FDF CD EE 1B             call    GETCHR          ; Get next character
1990+ 1FE2 C2 70 1F             jp      NZ,NEDMOR       ; More needed - Get it
1991+ 1FE5 D1                   pop     DE              ; Restore DATA pointer
1992+ 1FE6 3A D3 52             ld      A,(READFG)      ; "READ" or "INPUT" ?
1993+ 1FE9 B7                   or      A
1994+ 1FEA EB                   ex      DE,HL           ; DATA pointer to HL
1995+ 1FEB C2 14 1C             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1996+ 1FEE D5                   push    DE              ; Save code string address
1997+ 1FEF B6                   or      (HL)            ; More input given?
1998+ 1FF0 21 F8 1F             ld      HL,EXTIG        ; "?Extra ignored" message
1999+ 1FF3 C4 7F 25             call    NZ,PRS          ; Output string if extra given
2000+ 1FF6 E1                   pop     HL              ; Restore code string address
2001+ 1FF7 C9                   ret
2002+ 1FF8
2003+ 1FF8 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2003+ 1FFC 72 61 20 69
2003+ 2000 67 6E 6F 72
2003+ 2004 65 64 0D 00
2004+ 2008
2005+ 2008 CD 97 1D     FDTLP:  call    DATA            ; Get next statement
2006+ 200B B7                   or      A               ; End of line?
2007+ 200C C2 21 20             jp      NZ,FANDT        ; No - See if DATA statement
2008+ 200F 23                   inc     HL
2009+ 2010 7E                   ld      A,(HL)          ; End of program?
2010+ 2011 23                   inc     HL
2011+ 2012 B6                   or      (HL)            ; 00 00 Ends program
2012+ 2013 1E 06                ld      E,OD            ; ?OD Error
2013+ 2015 CA DF 16             jp      Z,ERROR         ; Yes - Out of DATA
2014+ 2018 23                   inc     HL
2015+ 2019 5E                   ld      E,(HL)          ; LSB of line number
2016+ 201A 23                   inc     HL
2017+ 201B 56                   ld      D,(HL)          ; MSB of line number
2018+ 201C EB                   ex      DE,HL
2019+ 201D 22 CF 52             ld      (DATLIN),HL     ; Set line of current DATA item
2020+ 2020 EB                   ex      DE,HL
2021+ 2021 CD EE 1B     FANDT:  call    GETCHR          ; Get next character
2022+ 2024 FE 83                cp      ZDATA           ; "DATA" token
2023+ 2026 C2 08 20             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2024+ 2029 C3 9C 1F             jp      ANTVLU          ; Found - Convert input
2025+ 202C
2026+ 202C 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2027+ 202F C4 86 22     NEXT1:  call    NZ,GETVAR       ; Get index address
2028+ 2032 22 D4 52             ld      (BRKLIN),HL     ; Save code string address
2029+ 2035 CD 54 16             call    BAKSTK          ; Look for "FOR" block
2030+ 2038 C2 D1 16             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2031+ 203B F9                   ld      SP,HL           ; Clear nested loops
2032+ 203C D5                   push    DE              ; Save index address
2033+ 203D 7E                   ld      A,(HL)          ; Get sign of STEP
2034+ 203E 23                   inc     HL
2035+ 203F F5                   push    AF              ; Save sign of STEP
2036+ 2040 D5                   push    DE              ; Save index address
2037+ 2041 CD C2 2E             call    PHLTFP          ; Move index value to FPREG
2038+ 2044 E3                   ex      (SP),HL         ; Save address of TO value
2039+ 2045 E5                   push    HL              ; Save address of index
2040+ 2046 CD DE 2B             call    ADDPHL          ; Add STEP to index value
2041+ 2049 E1                   pop     HL              ; Restore address of index
2042+ 204A CD DC 2E             call    FPTHL           ; Move value to index variable
2043+ 204D E1                   pop     HL              ; Restore address of TO value
2044+ 204E CD D3 2E             call    LOADFP          ; Move TO value to BCDE
2045+ 2051 E5                   push    HL              ; Save address of line of FOR
2046+ 2052 CD FF 2E             call    CMPNUM          ; Compare index with TO value
2047+ 2055 E1                   pop     HL              ; Restore address of line num
2048+ 2056 C1                   pop     BC              ; Address of sign of STEP
2049+ 2057 90                   sub     B               ; Compare with expected sign
2050+ 2058 CD D3 2E             call    LOADFP          ; BC = Loop stmt,DE = Line num
2051+ 205B CA 67 20             jp      Z,KILFOR        ; Loop finished - Terminate it
2052+ 205E EB                   ex      DE,HL           ; Loop statement line number
2053+ 205F 22 CE 51             ld      (LINEAT),HL     ; Set loop line number
2054+ 2062 69                   ld      L,C             ; Set code string to loop
2055+ 2063 60                   ld      H,B
2056+ 2064 C3 AA 1B             jp      PUTFID          ; Put back "FOR" and continue
2057+ 2067
2058+ 2067 F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2059+ 2068 2A D4 52             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2060+ 206B 7E                   ld      A,(HL)          ; Get next byte in code string
2061+ 206C FE 2C                cp      ','             ; More NEXTs ?
2062+ 206E C2 AE 1B             jp      NZ,RUNCNT       ; No - Do next statement
2063+ 2071 CD EE 1B             call    GETCHR          ; Position to index name
2064+ 2074 CD 2F 20             call    NEXT1           ; Re-enter NEXT routine
2065+ 2077              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2066+ 2077
2067+ 2077 CD 89 20     GETNUM: call    EVAL            ; Get a numeric expression
2068+ 207A F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2069+ 207B 37           TSTSTR: scf                     ; Set carry (string)
2070+ 207C 3A B3 52     CHKTYP: ld      A,(TYPE)        ; Check types match
2071+ 207F 8F                   adc     A,A             ; Expected + actual
2072+ 2080 B7                   or      A               ; Clear carry , set parity
2073+ 2081 E8                   ret     PE              ; Even parity - Types match
2074+ 2082 C3 DD 16             jp      TMERR           ; Different types - Error
2075+ 2085
2076+ 2085 CD AD 19     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2077+ 2088 28                   defb    '('
2078+ 2089 2B           EVAL:   dec     HL              ; Evaluate expression & save
2079+ 208A 16 00                ld      D,$00           ; Precedence value
2080+ 208C D5           EVAL1:  push    DE              ; Save precedence
2081+ 208D 0E 01                ld      C,$01
2082+ 208F CD 88 16             call    CHKSTK          ; Check for 1 level of stack
2083+ 2092 CD 00 21             call    OPRND           ; Get next expression value
2084+ 2095 22 D6 52     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2085+ 2098 2A D6 52     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2086+ 209B C1                   pop     BC              ; Precedence value and operator
2087+ 209C 78                   ld      A,B             ; Get precedence value
2088+ 209D FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2089+ 209F D4 7A 20             call    NC,TSTNUM       ; No - Make sure it's a number
2090+ 20A2 7E                   ld      A,(HL)          ; Get next operator / function
2091+ 20A3 16 00                ld      D,$00           ; Clear Last relation
2092+ 20A5 D6 C7        RLTLP:  sub     ZGTR            ; ">" Token
2093+ 20A7 DA C1 20             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2094+ 20AA FE 03                cp      ZLTH+1-ZGTR     ; < = >
2095+ 20AC D2 C1 20             jp      NC,FOPRND       ; Function - Call it
2096+ 20AF FE 01                cp      ZEQUAL-ZGTR     ; "="
2097+ 20B1 17                   rla                     ; <- Test for legal
2098+ 20B2 AA                   xor     D               ; <- combinations of < = >
2099+ 20B3 BA                   cp      D               ; <- by combining last token
2100+ 20B4 57                   ld      D,A             ; <- with current one
2101+ 20B5 DA CB 16             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2102+ 20B8 22 CB 52             ld      (CUROPR),HL     ; Save address of current token
2103+ 20BB CD EE 1B             call    GETCHR          ; Get next character
2104+ 20BE C3 A5 20             jp      RLTLP           ; Treat the two as one
2105+ 20C1
2106+ 20C1 7A           FOPRND: ld      A,D             ; < = > found ?
2107+ 20C2 B7                   or      A
2108+ 20C3 C2 01 22             jp      NZ,TSTRED       ; Yes - Test for reduction
2109+ 20C6 7E                   ld      A,(HL)          ; Get operator token
2110+ 20C7 22 CB 52             ld      (CUROPR),HL     ; Save operator address
2111+ 20CA D6 BD                sub     ZPLUS           ; Operator or function?
2112+ 20CC D8                   ret     C               ; Neither - Exit
2113+ 20CD FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2114+ 20CF D0                   ret     NC              ; No - Exit
2115+ 20D0 5F                   ld      E,A             ; Coded operator
2116+ 20D1 3A B3 52             ld      A,(TYPE)        ; Get data type
2117+ 20D4 3D                   dec     A               ; FF = numeric , 00 = string
2118+ 20D5 B3                   or      E               ; Combine with coded operator
2119+ 20D6 7B                   ld      A,E             ; Get coded operator
2120+ 20D7 CA 75 26             jp      Z,CONCAT        ; String concatenation
2121+ 20DA 07                   rlca                    ; Times 2
2122+ 20DB 83                   add     A,E             ; Times 3
2123+ 20DC 5F                   ld      E,A             ; To DE (D is 0)
2124+ 20DD 21 46 15             ld      HL,PRITAB       ; Precedence table
2125+ 20E0 19                   add     HL,DE           ; To the operator concerned
2126+ 20E1 78                   ld      A,B             ; Last operator precedence
2127+ 20E2 56                   ld      D,(HL)          ; Get evaluation precedence
2128+ 20E3 BA                   cp      D               ; Compare with eval precedence
2129+ 20E4 D0                   ret     NC              ; Exit if higher precedence
2130+ 20E5 23                   inc     HL              ; Point to routine address
2131+ 20E6 CD 7A 20             call    TSTNUM          ; Make sure it's a number
2132+ 20E9
2133+ 20E9 C5           STKTHS: push    BC              ; Save last precedence & token
2134+ 20EA 01 98 20             ld      BC,EVAL3        ; Where to go on prec' break
2135+ 20ED C5                   push    BC              ; Save on stack for return
2136+ 20EE 43                   ld      B,E             ; Save operator
2137+ 20EF 4A                   ld      C,D             ; Save precedence
2138+ 20F0 CD B5 2E             call    STAKFP          ; Move value to stack
2139+ 20F3 58                   ld      E,B             ; Restore operator
2140+ 20F4 51                   ld      D,C             ; Restore precedence
2141+ 20F5 4E                   ld      C,(HL)          ; Get LSB of routine address
2142+ 20F6 23                   inc     HL
2143+ 20F7 46                   ld      B,(HL)          ; Get MSB of routine address
2144+ 20F8 23                   inc     HL
2145+ 20F9 C5                   push    BC              ; Save routine address
2146+ 20FA 2A CB 52             ld      HL,(CUROPR)     ; Address of current operator
2147+ 20FD C3 8C 20             jp      EVAL1           ; Loop until prec' break
2148+ 2100
2149+ 2100 AF           OPRND:  xor     A               ; Get operand routine
2150+ 2101 32 B3 52             ld      (TYPE),A        ; Set numeric expected
2151+ 2104 CD EE 1B             call    GETCHR          ; Get next character
2152+ 2107 1E 24                ld      E,MO            ; ?MO Error
2153+ 2109 CA DF 16             jp      Z,ERROR         ; No operand - Error
2154+ 210C DA 8B 2F             jp      C,ASCTFP        ; Number - Get value
2155+ 210F CD 90 1C             call    CHKLTR          ; See if a letter
2156+ 2112 D2 67 21             jp      NC,CONVAR       ; Letter - Find variable
2157+ 2115 FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2158+ 2117 20 12                jr      NZ,NOTAMP
2159+ 2119 CD EE 1B             call    GETCHR          ; Get next character
2160+ 211C FE 48                cp      'H'             ; Hex number indicated? [function added]
2161+ 211E CA F1 3E             jp      Z,HEXTFP        ; Convert Hex to FPREG
2162+ 2121 FE 42                cp      'B'             ; Binary number indicated? [function added]
2163+ 2123 CA 61 3F             jp      Z,BINTFP        ; Convert Bin to FPREG
2164+ 2126 1E 02                ld      E,SN            ; If neither then a ?SN Error
2165+ 2128 CA DF 16             jp      Z,ERROR         ;
2166+ 212B FE BD        NOTAMP: cp      ZPLUS           ; '+' Token ?
2167+ 212D CA 00 21             jp      Z,OPRND         ; Yes - Look for operand
2168+ 2130 FE 2E                cp      '.'             ; '.' ?
2169+ 2132 CA 8B 2F             jp      Z,ASCTFP        ; Yes - Create FP number
2170+ 2135 FE BE                cp      ZMINUS          ; '-' Token ?
2171+ 2137 CA 56 21             jp      Z,MINUS         ; Yes - Do minus
2172+ 213A FE 22                cp      $22             ; '"'             ; Literal string ?
2173+ 213C CA 3E 25             jp      Z,QTSTR         ; Get string terminated by '"'
2174+ 213F FE BB                cp      ZNOT            ; "NOT" Token ?
2175+ 2141 CA 61 22             jp      Z,EVNOT         ; Yes - Eval NOT expression
2176+ 2144 FE B8                cp      ZFN             ; "FN" Token ?
2177+ 2146 CA A2 24             jp      Z,DOFN          ; Yes - Do FN routine
2178+ 2149 D6 CA                sub     ZSGN            ; Is it a function?
2179+ 214B D2 78 21             jp      NC,FNOFST       ; Yes - Evaluate function
2180+ 214E CD 85 20     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2181+ 2151 CD AD 19             call    CHKSYN          ; Make sure ")" follows
2182+ 2154 29                   defb    ')'
2183+ 2155 C9                   ret
2184+ 2156
2185+ 2156 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2186+ 2158 CD 8C 20             call    EVAL1           ; Evaluate until prec' break
2187+ 215B 2A D6 52             ld      HL,(NXTOPR)     ; Get next operator address
2188+ 215E E5                   push    HL              ; Save next operator address
2189+ 215F CD AD 2E             call    INVSGN          ; Negate value
2190+ 2162 CD 7A 20     RETNUM: call    TSTNUM          ; Make sure it's a number
2191+ 2165 E1                   pop     HL              ; Restore next operator address
2192+ 2166 C9                   ret
2193+ 2167
2194+ 2167 CD 86 22     CONVAR: call    GETVAR          ; Get variable address to DE
2195+ 216A E5           FRMEVL: push    HL              ; Save code string address
2196+ 216B EB                   ex      DE,HL           ; Variable address to HL
2197+ 216C 22 51 53             ld      (FPREG),HL      ; Save address of variable
2198+ 216F 3A B3 52             ld      A,(TYPE)        ; Get type
2199+ 2172 B7                   or      A               ; Numeric?
2200+ 2173 CC C2 2E             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2201+ 2176 E1                   pop     HL              ; Restore code string address
2202+ 2177 C9                   ret
2203+ 2178
2204+ 2178 06 00        FNOFST: ld      B,$00           ; Get address of function
2205+ 217A 07                   rlca                    ; Double function offset
2206+ 217B 4F                   ld      C,A             ; BC = Offset in function table
2207+ 217C C5                   push    BC              ; Save adjusted token value
2208+ 217D CD EE 1B             call    GETCHR          ; Get next character
2209+ 2180 79                   ld      A,C             ; Get adjusted token value
2210+ 2181 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2211+ 2183 CA AF 36             jp      Z,POINT         ; Yes, do "POINT"
2212+ 2186 FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2213+ 2188 CA 51 27             jp      Z,INSTR         ; Yes, do "INSTR"
2214+ 218B FE 3D                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2215+ 218D DA A9 21             jp      C,FNVAL         ; No - Do function
2216+ 2190 CD 85 20             call    OPNPAR          ; Evaluate expression  (X,...
2217+ 2193 CD AD 19             call    CHKSYN          ; Make sure ',' follows
2218+ 2196 2C                   defb    ','
2219+ 2197 CD 7B 20             call    TSTSTR          ; Make sure it's a string
2220+ 219A EB                   ex      DE,HL           ; Save code string address
2221+ 219B 2A 51 53             ld      HL,(FPREG)      ; Get address of string
2222+ 219E E3                   ex      (SP),HL         ; Save address of string
2223+ 219F E5                   push    HL              ; Save adjusted token value
2224+ 21A0 EB                   ex      DE,HL           ; Restore code string address
2225+ 21A1 CD FD 28             call    GETINT          ; Get integer 0-255
2226+ 21A4 EB                   ex      DE,HL           ; Save code string address
2227+ 21A5 E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2228+ 21A6 C3 B1 21             jp      GOFUNC          ; Jump to string function
2229+ 21A9
2230+ 21A9 CD 4E 21     FNVAL:  call    EVLPAR          ; Evaluate expression
2231+ 21AC E3                   ex      (SP),HL         ; HL = Adjusted token value
2232+ 21AD 11 62 21             ld      DE,RETNUM       ; Return number from function
2233+ 21B0 D5                   push    DE              ; Save on stack
2234+ 21B1 01 09 13     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2235+ 21B4 09                   add     HL,BC           ; Point to right address
2236+ 21B5 4E                   ld      C,(HL)          ; Get LSB of address
2237+ 21B6 23                   inc     HL              ;
2238+ 21B7 66                   ld      H,(HL)          ; Get MSB of address
2239+ 21B8 69                   ld      L,C             ; Address to HL
2240+ 21B9 E9                   jp      (HL)            ; Jump to function
2241+ 21BA
2242+ 21BA 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2243+ 21BB FE BE                cp      ZMINUS          ; '-' token ?
2244+ 21BD C8                   ret     Z               ; Yes - Return
2245+ 21BE FE 2D                cp      '-'             ; '-' ASCII ?
2246+ 21C0 C8                   ret     Z               ; Yes - Return
2247+ 21C1 14                   inc     D               ; Inc to flag positive exponent
2248+ 21C2 FE 2B                cp      '+'             ; '+' ASCII ?
2249+ 21C4 C8                   ret     Z               ; Yes - Return
2250+ 21C5 FE BD                cp      ZPLUS           ; '+' token ?
2251+ 21C7 C8                   ret     Z               ; Yes - Return
2252+ 21C8 2B                   dec     HL              ; dec 'cos GETCHR INCs
2253+ 21C9 C9                   ret                     ; Return "NZ"
2254+ 21CA
2255+ 21CA              ; execute OR, AND, and XOR operations
2256+ 21CA AF           PAND:   xor     A               ; for AND, Z=1
2257+ 21CB 18 07                jr      CNTLGC
2258+ 21CD AF           POR:    xor     A               ; for OR, Z=0, S=1
2259+ 21CE D6 01                sub     $01
2260+ 21D0 18 02                jr      CNTLGC
2261+ 21D2 AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2262+ 21D3 3C                   inc     A
2263+ 21D4 F5           CNTLGC: push    AF              ; store operand's flags
2264+ 21D5 CD 7A 20             call    TSTNUM          ; Make sure it's a number
2265+ 21D8 CD A4 1C             call    DEINT           ; Get integer -32768 to 32767
2266+ 21DB F1                   pop     AF              ; retrieve operand's flags
2267+ 21DC EB                   ex      DE,HL           ; <- Get last
2268+ 21DD C1                   pop     BC              ; <-  value
2269+ 21DE E3                   ex      (SP),HL         ; <-  from
2270+ 21DF EB                   ex      DE,HL           ; <-  stack
2271+ 21E0 CD C5 2E             call    FPBCDE          ; Move last value to FPREG
2272+ 21E3 F5                   push    AF              ; store operand's flags
2273+ 21E4 CD A4 1C             call    DEINT           ; Get integer -32768 to 32767
2274+ 21E7 F1                   pop     AF              ; retrieve operand's flags
2275+ 21E8 C1                   pop     BC              ; Get value
2276+ 21E9 79                   ld      A,C             ; Get LSB
2277+ 21EA 21 60 24             ld      HL,ACPASS       ; Address of save AC as current
2278+ 21ED 20 05                jr      NZ,POR1         ; if X/OR, jump over
2279+ 21EF A3           PAND1:  and     E               ; "AND" LSBs
2280+ 21F0 4F                   ld      C,A             ; Save LSB
2281+ 21F1 78                   ld      A,B             ; Get MSB
2282+ 21F2 A2                   and     D               ; "AND" MSBs
2283+ 21F3 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2284+ 21F4 F2 FC 21     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2285+ 21F7 B3                   or      E               ; "OR" LSBs
2286+ 21F8 4F                   ld      C,A             ; Save LSB
2287+ 21F9 78                   ld      A,B             ; Get MSB
2288+ 21FA B2                   or      D               ; "OR" MSBs
2289+ 21FB E9                   jp      (HL)            ; Save AC as current (ACPASS)
2290+ 21FC AB           PXOR1:  xor     E               ; "XOR" LSBs
2291+ 21FD 4F                   ld      C,A             ; Save LSB
2292+ 21FE 78                   ld      A,B             ; Get MSB
2293+ 21FF AA                   xor     D               ; "XOR" MSBs
2294+ 2200 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2295+ 2201
2296+ 2201 21 13 22     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2297+ 2204 3A B3 52             ld      A,(TYPE)        ; Get data type
2298+ 2207 1F                   rra                     ; Carry set = string
2299+ 2208 7A                   ld      A,D             ; Get last precedence value
2300+ 2209 17                   rla                     ; Times 2 plus carry
2301+ 220A 5F                   ld      E,A             ; To E
2302+ 220B 16 64                ld      D,$64           ; Relational precedence
2303+ 220D 78                   ld      A,B             ; Get current precedence
2304+ 220E BA                   cp      D               ; Compare with last
2305+ 220F D0                   ret     NC              ; Eval if last was rel' or log'
2306+ 2210 C3 E9 20             jp      STKTHS          ; Stack this one and get next
2307+ 2213
2308+ 2213 15 22        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2309+ 2215 79           CMPLG1: ld      A,C             ; Get data type
2310+ 2216 B7                   or      A
2311+ 2217 1F                   rra
2312+ 2218 C1                   pop     BC              ; Get last expression to BCDE
2313+ 2219 D1                   pop     DE
2314+ 221A F5                   push    AF              ; Save status
2315+ 221B CD 7C 20             call    CHKTYP          ; Check that types match
2316+ 221E 21 57 22             ld      HL,CMPRES       ; Result to comparison
2317+ 2221 E5                   push    HL              ; Save for RETurn
2318+ 2222 CA FF 2E             jp      Z,CMPNUM        ; Compare values if numeric
2319+ 2225 AF                   xor     A               ; Compare two strings
2320+ 2226 32 B3 52             ld      (TYPE),A        ; Set type to numeric
2321+ 2229 D5                   push    DE              ; Save string name
2322+ 222A CD C2 26             call    GSTRCU          ; Get current string
2323+ 222D 7E                   ld      A,(HL)          ; Get length of string
2324+ 222E 23                   inc     HL
2325+ 222F 23                   inc     HL
2326+ 2230 4E                   ld      C,(HL)          ; Get LSB of address
2327+ 2231 23                   inc     HL
2328+ 2232 46                   ld      B,(HL)          ; Get MSB of address
2329+ 2233 D1                   pop     DE              ; Restore string name
2330+ 2234 C5                   push    BC              ; Save address of string
2331+ 2235 F5                   push    AF              ; Save length of string
2332+ 2236 CD C6 26             call    GSTRDE          ; Get second string
2333+ 2239 CD D3 2E             call    LOADFP          ; Get address of second string
2334+ 223C F1                   pop     AF              ; Restore length of string 1
2335+ 223D 57                   ld      D,A             ; Length to D
2336+ 223E E1                   pop     HL              ; Restore address of string 1
2337+ 223F 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2338+ 2240 B2                   or      D               ; Bytes of string 1 to do
2339+ 2241 C8                   ret     Z               ; Exit if all bytes compared
2340+ 2242 7A                   ld      A,D             ; Get bytes of string 1 to do
2341+ 2243 D6 01                sub     $01
2342+ 2245 D8                   ret     C               ; Exit if end of string 1
2343+ 2246 AF                   xor     A
2344+ 2247 BB                   cp      E               ; Bytes of string 2 to do
2345+ 2248 3C                   inc     A
2346+ 2249 D0                   ret     NC              ; Exit if end of string 2
2347+ 224A 15                   dec     D               ; Count bytes in string 1
2348+ 224B 1D                   dec     E               ; Count bytes in string 2
2349+ 224C 0A                   ld      A,(BC)          ; Byte in string 2
2350+ 224D BE                   cp      (HL)            ; Compare to byte in string 1
2351+ 224E 23                   inc     HL              ; Move up string 1
2352+ 224F 03                   inc     BC              ; Move up string 2
2353+ 2250 CA 3F 22             jp      Z,CMPSTR        ; Same - Try next bytes
2354+ 2253 3F                   ccf                     ; Flag difference (">" or "<")
2355+ 2254 C3 8F 2E             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2356+ 2257
2357+ 2257 3C           CMPRES: inc     A               ; Increment current value
2358+ 2258 8F                   adc     A,A             ; Double plus carry
2359+ 2259 C1                   pop     BC              ; Get other value
2360+ 225A A0                   and     B               ; Combine them
2361+ 225B C6 FF                add     A,-1            ; Carry set if different
2362+ 225D 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2363+ 225E C3 96 2E             jp      FLGREL          ; Set current value & continue
2364+ 2261
2365+ 2261 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2366+ 2263 CD 8C 20             call    EVAL1           ; Eval until precedence break
2367+ 2266 CD 7A 20             call    TSTNUM          ; Make sure it's a number
2368+ 2269 CD A4 1C             call    DEINT           ; Get integer -32768 - 32767
2369+ 226C 7B                   ld      A,E             ; Get LSB
2370+ 226D 2F                   cpl                     ; Invert LSB
2371+ 226E 4F                   ld      C,A             ; Save "NOT" of LSB
2372+ 226F 7A                   ld      A,D             ; Get MSB
2373+ 2270 2F                   cpl                     ; Invert MSB
2374+ 2271 CD 60 24             call    ACPASS          ; Save AC as current
2375+ 2274 C1                   pop     BC              ; Clean up stack
2376+ 2275 C3 98 20             jp      EVAL3           ; Continue evaluation
2377+ 2278
2378+ 2278 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2379+ 2279 CD EE 1B             call    GETCHR          ; Get next character
2380+ 227C C8                   ret     Z               ; End of DIM statement
2381+ 227D CD AD 19             call    CHKSYN          ; Make sure ',' follows
2382+ 2280 2C                   defb    ','
2383+ 2281 01 78 22     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2384+ 2284 C5                   push    BC              ; Save on stack
2385+ 2285 F6                   defb    $F6             ; Flag "Create" variable
2386+ 2286 AF           GETVAR: xor     A               ; Find variable address,to DE
2387+ 2287 32 B2 52             ld      (LCRFLG),A      ; Set locate / create flag
2388+ 228A 46                   ld      B,(HL)          ; Get First byte of name
2389+ 228B CD 90 1C     GTFNAM: call    CHKLTR          ; See if a letter
2390+ 228E DA CB 16             jp      C,SNERR         ; ?SN Error if not a letter
2391+ 2291 AF                   xor     A
2392+ 2292 4F                   ld      C,A             ; Clear second byte of name
2393+ 2293 32 B3 52             ld      (TYPE),A        ; Set type to numeric
2394+ 2296 CD EE 1B             call    GETCHR          ; Get next character
2395+ 2299 DA A2 22             jp      C,SVNAM2        ; Numeric - Save in name
2396+ 229C CD 90 1C             call    CHKLTR          ; See if a letter
2397+ 229F DA AF 22             jp      C,CHARTY        ; Not a letter - Check type
2398+ 22A2 4F           SVNAM2: ld      C,A             ; Save second byte of name
2399+ 22A3 CD EE 1B     ENDNAM: call    GETCHR          ; Get next character
2400+ 22A6 DA A3 22             jp      C,ENDNAM        ; Numeric - Get another
2401+ 22A9 CD 90 1C             call    CHKLTR          ; See if a letter
2402+ 22AC D2 A3 22             jp      NC,ENDNAM       ; Letter - Get another
2403+ 22AF D6 24        CHARTY: sub     '$'             ; String variable?
2404+ 22B1 C2 BE 22             jp      NZ,NOTSTR       ; No - Numeric variable
2405+ 22B4 3C                   inc     A               ; A = 1 (string type)
2406+ 22B5 32 B3 52             ld      (TYPE),A        ; Set type to string
2407+ 22B8 0F                   rrca                    ; A = 80H , Flag for string
2408+ 22B9 81                   add     A,C             ; 2nd byte of name has bit 7 on
2409+ 22BA 4F                   ld      C,A             ; Resave second byte on name
2410+ 22BB CD EE 1B             call    GETCHR          ; Get next character
2411+ 22BE 3A D1 52     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2412+ 22C1 3D                   dec     A
2413+ 22C2 CA 6B 23             jp      Z,ARLDSV        ; Yes - Get array name
2414+ 22C5 F2 CE 22             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2415+ 22C8 7E                   ld      A,(HL)          ; Get byte again
2416+ 22C9 D6 28                sub     '('             ; Subscripted variable?
2417+ 22CB CA 43 23             jp      Z,SBSCPT        ; Yes - Sort out subscript
2418+ 22CE
2419+ 22CE AF           NSCFOR: xor     A               ; Simple variable
2420+ 22CF 32 D1 52             ld      (FORFLG),A      ; Clear "FOR" flag
2421+ 22D2 E5                   push    HL              ; Save code string address
2422+ 22D3 50                   ld      D,B             ; DE = Variable name to find
2423+ 22D4 59                   ld      E,C
2424+ 22D5 2A 4B 53             ld      HL,(FNRGNM)     ; FN argument name
2425+ 22D8 CD A7 19             call    CPDEHL          ; Is it the FN argument?
2426+ 22DB 11 4D 53             ld      DE,FNARG        ; Point to argument value
2427+ 22DE CA 74 2D             jp      Z,POPHRT        ; Yes - Return FN argument value
2428+ 22E1 2A 45 53             ld      HL,(VAREND)     ; End of variables
2429+ 22E4 EB                   ex      DE,HL           ; Address of end of search
2430+ 22E5 2A 43 53             ld      HL,(PROGND)     ; Start of variables address
2431+ 22E8 CD A7 19     FNDVAR: call    CPDEHL          ; End of variable list table?
2432+ 22EB CA 01 23             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2433+ 22EE 79                   ld      A,C             ; Get second byte of name
2434+ 22EF 96                   sub     (HL)            ; Compare with name in list
2435+ 22F0 23                   inc     HL              ; Move on to first byte
2436+ 22F1 C2 F6 22             jp      NZ,FNTHR        ; Different - Find another
2437+ 22F4 78                   ld      A,B             ; Get first byte of name
2438+ 22F5 96                   sub     (HL)            ; Compare with name in list
2439+ 22F6 23           FNTHR:  inc     HL              ; Move on to LSB of value
2440+ 22F7 CA 35 23             jp      Z,RETADR        ; Found - Return address
2441+ 22FA 23                   inc     HL              ; <- Skip
2442+ 22FB 23                   inc     HL              ; <- over
2443+ 22FC 23                   inc     HL              ; <- F.P.
2444+ 22FD 23                   inc     HL              ; <- value
2445+ 22FE C3 E8 22             jp      FNDVAR          ; Keep looking
2446+ 2301
2447+ 2301 E1           CFEVAL: pop     HL              ; Restore code string address
2448+ 2302 E3                   ex      (SP),HL         ; Get return address
2449+ 2303 D5                   push    DE              ; Save address of variable
2450+ 2304 11 6A 21             ld      DE,FRMEVL       ; Return address in EVAL
2451+ 2307 CD A7 19             call    CPDEHL          ; Called from EVAL ?
2452+ 230A D1                   pop     DE              ; Restore address of variable
2453+ 230B CA 38 23             jp      Z,RETNUL        ; Yes - Return null variable
2454+ 230E E3                   ex      (SP),HL         ; Put back return
2455+ 230F E5                   push    HL              ; Save code string address
2456+ 2310 C5                   push    BC              ; Save variable name
2457+ 2311 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2458+ 2314 2A 47 53             ld      HL,(ARREND)     ; End of arrays
2459+ 2317 E5                   push    HL              ; Save end of arrays
2460+ 2318 09                   add     HL,BC           ; Move up 6 bytes
2461+ 2319 C1                   pop     BC              ; Source address in BC
2462+ 231A E5                   push    HL              ; Save new end address
2463+ 231B CD 77 16             call    MOVUP           ; Move arrays up
2464+ 231E E1                   pop     HL              ; Restore new end address
2465+ 231F 22 47 53             ld      (ARREND),HL     ; Set new end address
2466+ 2322 60                   ld      H,B             ; End of variables to HL
2467+ 2323 69                   ld      L,C
2468+ 2324 22 45 53             ld      (VAREND),HL     ; Set new end address
2469+ 2327
2470+ 2327 2B           ZEROLP: dec     HL              ; Back through to zero variable
2471+ 2328 36 00                ld      (HL),$00        ; Zero byte in variable
2472+ 232A CD A7 19             call    CPDEHL          ; Done them all?
2473+ 232D C2 27 23             jp      NZ,ZEROLP       ; No - Keep on going
2474+ 2330 D1                   pop     DE              ; Get variable name
2475+ 2331 73                   ld      (HL),E          ; Store second character
2476+ 2332 23                   inc     HL
2477+ 2333 72                   ld      (HL),D          ; Store first character
2478+ 2334 23                   inc     HL
2479+ 2335 EB           RETADR: ex      DE,HL           ; Address of variable in DE
2480+ 2336 E1                   pop     HL              ; Restore code string address
2481+ 2337 C9                   ret
2482+ 2338
2483+ 2338 32 54 53     RETNUL: ld      (FPEXP),A       ; Set result to zero
2484+ 233B 21 48 16             ld      HL,ZERBYT       ; Also set a null string
2485+ 233E 22 51 53             ld      (FPREG),HL      ; Save for EVAL
2486+ 2341 E1                   pop     HL              ; Restore code string address
2487+ 2342 C9                   ret
2488+ 2343
2489+ 2343 E5           SBSCPT: push    HL              ; Save code string address
2490+ 2344 2A B2 52             ld      HL,(LCRFLG)     ; Locate/Create and Type
2491+ 2347 E3                   ex      (SP),HL         ; Save and get code string
2492+ 2348 57                   ld      D,A             ; Zero number of dimensions
2493+ 2349 D5           SCPTLP: push    DE              ; Save number of dimensions
2494+ 234A C5                   push    BC              ; Save array name
2495+ 234B CD 98 1C             call    FPSINT          ; Get subscript (0-32767)
2496+ 234E C1                   pop     BC              ; Restore array name
2497+ 234F F1                   pop     AF              ; Get number of dimensions
2498+ 2350 EB                   ex      DE,HL
2499+ 2351 E3                   ex      (SP),HL         ; Save subscript value
2500+ 2352 E5                   push    HL              ; Save LCRFLG and TYPE
2501+ 2353 EB                   ex      DE,HL
2502+ 2354 3C                   inc     A               ; Count dimensions
2503+ 2355 57                   ld      D,A             ; Save in D
2504+ 2356 7E                   ld      A,(HL)          ; Get next byte in code string
2505+ 2357 FE 2C                cp      ','             ; Comma (more to come)?
2506+ 2359 CA 49 23             jp      Z,SCPTLP        ; Yes - More subscripts
2507+ 235C CD AD 19             call    CHKSYN          ; Make sure ")" follows
2508+ 235F 29                   defb    ')'
2509+ 2360 22 D6 52             ld      (NXTOPR),HL     ; Save code string address
2510+ 2363 E1                   pop     HL              ; Get LCRFLG and TYPE
2511+ 2364 22 B2 52             ld      (LCRFLG),HL     ; Restore Locate/create & type
2512+ 2367 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2513+ 2369 D5                   push    DE              ; Save number of dimensions (D)
2514+ 236A 11                   defb    $11             ; Skip "push HL" and "push AF'
2515+ 236B
2516+ 236B E5           ARLDSV: push    HL              ; Save code string address
2517+ 236C F5                   push    AF              ; A = 00 , Flags set = Z,N
2518+ 236D 2A 45 53             ld      HL,(VAREND)     ; Start of arrays
2519+ 2370 3E                   defb    $3E             ; Skip "add HL,DE"
2520+ 2371 19           FNDARY: add     HL,DE           ; Move to next array start
2521+ 2372 EB                   ex      DE,HL
2522+ 2373 2A 47 53             ld      HL,(ARREND)     ; End of arrays
2523+ 2376 EB                   ex      DE,HL           ; Current array pointer
2524+ 2377 CD A7 19             call    CPDEHL          ; End of arrays found?
2525+ 237A CA A3 23             jp      Z,CREARY        ; Yes - Create array
2526+ 237D 7E                   ld      A,(HL)          ; Get second byte of name
2527+ 237E B9                   cp      C               ; Compare with name given
2528+ 237F 23                   inc     HL              ; Move on
2529+ 2380 C2 85 23             jp      NZ,NXTARY       ; Different - Find next array
2530+ 2383 7E                   ld      A,(HL)          ; Get first byte of name
2531+ 2384 B8                   cp      B               ; Compare with name given
2532+ 2385 23           NXTARY: inc     HL              ; Move on
2533+ 2386 5E                   ld      E,(HL)          ; Get LSB of next array address
2534+ 2387 23                   inc     HL
2535+ 2388 56                   ld      D,(HL)          ; Get MSB of next array address
2536+ 2389 23                   inc     HL
2537+ 238A C2 71 23             jp      NZ,FNDARY       ; Not found - Keep looking
2538+ 238D 3A B2 52             ld      A,(LCRFLG)      ; Found Locate or Create it?
2539+ 2390 B7                   or      A
2540+ 2391 C2 D4 16             jp      NZ,DDERR        ; Create - ?DD Error
2541+ 2394 F1                   pop     AF              ; Locate - Get number of dim'ns
2542+ 2395 44                   ld      B,H             ; BC Points to array dim'ns
2543+ 2396 4D                   ld      C,L
2544+ 2397 CA 74 2D             jp      Z,POPHRT        ; Jump if array load/save
2545+ 239A 96                   sub     (HL)            ; Same number of dimensions?
2546+ 239B CA 01 24             jp      Z,FINDEL        ; Yes - Find element
2547+ 239E 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2548+ 23A0 C3 DF 16             jp      ERROR           ; Output error
2549+ 23A3
2550+ 23A3 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2551+ 23A6 F1                   pop     AF              ; Array to save or 0 dim'ns?
2552+ 23A7 CA B9 1C             jp      Z,FCERR         ; Yes - ?FC Error
2553+ 23AA 71                   ld      (HL),C          ; Save second byte of name
2554+ 23AB 23                   inc     HL
2555+ 23AC 70                   ld      (HL),B          ; Save first byte of name
2556+ 23AD 23                   inc     HL
2557+ 23AE 4F                   ld      C,A             ; Number of dimensions to C
2558+ 23AF CD 88 16             call    CHKSTK          ; Check if enough memory
2559+ 23B2 23                   inc     HL              ; Point to number of dimensions
2560+ 23B3 23                   inc     HL
2561+ 23B4 22 CB 52             ld      (CUROPR),HL     ; Save address of pointer
2562+ 23B7 71                   ld      (HL),C          ; Set number of dimensions
2563+ 23B8 23                   inc     HL
2564+ 23B9 3A B2 52             ld      A,(LCRFLG)      ; Locate of Create?
2565+ 23BC 17                   rla                     ; Carry set = Create
2566+ 23BD 79                   ld      A,C             ; Get number of dimensions
2567+ 23BE 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2568+ 23C1 D2 C6 23             jp      NC,DEFSIZ       ; Locate - Set default size
2569+ 23C4 C1                   pop     BC              ; Get specified dimension size
2570+ 23C5 03                   inc     BC              ; Include zero element
2571+ 23C6 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2572+ 23C7 23                   inc     HL
2573+ 23C8 70                   ld      (HL),B          ; Save MSB of dimension size
2574+ 23C9 23                   inc     HL
2575+ 23CA F5                   push    AF              ; Save num' of dim'ns an status
2576+ 23CB E5                   push    HL              ; Save address of dim'n size
2577+ 23CC CD 70 2F             call    MLDEBC          ; Multiply DE by BC to find
2578+ 23CF EB                   ex      DE,HL           ; amount of mem needed (to DE)
2579+ 23D0 E1                   pop     HL              ; Restore address of dimension
2580+ 23D1 F1                   pop     AF              ; Restore number of dimensions
2581+ 23D2 3D                   dec     A               ; Count them
2582+ 23D3 C2 BE 23             jp      NZ,CRARLP       ; Do next dimension if more
2583+ 23D6 F5                   push    AF              ; Save locate/create flag
2584+ 23D7 42                   ld      B,D             ; MSB of memory needed
2585+ 23D8 4B                   ld      C,E             ; LSB of memory needed
2586+ 23D9 EB                   ex      DE,HL
2587+ 23DA 19                   add     HL,DE           ; Add bytes to array start
2588+ 23DB DA A0 16             jp      C,OMERR         ; Too big - Error
2589+ 23DE CD 91 16             call    ENFMEM          ; See if enough memory
2590+ 23E1 22 47 53             ld      (ARREND),HL     ; Save new end of array
2591+ 23E4
2592+ 23E4 2B           ZERARY: dec     HL              ; Back through array data
2593+ 23E5 36 00                ld      (HL),$00        ; Set array element to zero
2594+ 23E7 CD A7 19             call    CPDEHL          ; All elements zeroed?
2595+ 23EA C2 E4 23             jp      NZ,ZERARY       ; No - Keep on going
2596+ 23ED 03                   inc     BC              ; Number of bytes + 1
2597+ 23EE 57                   ld      D,A             ; A=0
2598+ 23EF 2A CB 52             ld      HL,(CUROPR)     ; Get address of array
2599+ 23F2 5E                   ld      E,(HL)          ; Number of dimensions
2600+ 23F3 EB                   ex      DE,HL           ; To HL
2601+ 23F4 29                   add     HL,HL           ; Two bytes per dimension size
2602+ 23F5 09                   add     HL,BC           ; Add number of bytes
2603+ 23F6 EB                   ex      DE,HL           ; Bytes needed to DE
2604+ 23F7 2B                   dec     HL
2605+ 23F8 2B                   dec     HL
2606+ 23F9 73                   ld      (HL),E          ; Save LSB of bytes needed
2607+ 23FA 23                   inc     HL
2608+ 23FB 72                   ld      (HL),D          ; Save MSB of bytes needed
2609+ 23FC 23                   inc     HL
2610+ 23FD F1                   pop     AF              ; Locate / Create?
2611+ 23FE DA 25 24             jp      C,ENDDIM        ; A is 0 , End if create
2612+ 2401 47           FINDEL: ld      B,A             ; Find array element
2613+ 2402 4F                   ld      C,A
2614+ 2403 7E                   ld      A,(HL)          ; Number of dimensions
2615+ 2404 23                   inc     HL
2616+ 2405 16                   defb    $16             ; Skip "pop HL"
2617+ 2406 E1           FNDELP: pop     HL              ; Address of next dim' size
2618+ 2407 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2619+ 2408 23                   inc     HL
2620+ 2409 56                   ld      D,(HL)          ; Get MSB of dim'n size
2621+ 240A 23                   inc     HL
2622+ 240B E3                   ex      (SP),HL         ; Save address - Get index
2623+ 240C F5                   push    AF              ; Save number of dim'ns
2624+ 240D CD A7 19             call    CPDEHL          ; Dimension too large?
2625+ 2410 D2 9E 23             jp      NC,BSERR        ; Yes - ?BS Error
2626+ 2413 E5                   push    HL              ; Save index
2627+ 2414 CD 70 2F             call    MLDEBC          ; Multiply previous by size
2628+ 2417 D1                   pop     DE              ; Index supplied to DE
2629+ 2418 19                   add     HL,DE           ; Add index to pointer
2630+ 2419 F1                   pop     AF              ; Number of dimensions
2631+ 241A 3D                   dec     A               ; Count them
2632+ 241B 44                   ld      B,H             ; MSB of pointer
2633+ 241C 4D                   ld      C,L             ; LSB of pointer
2634+ 241D C2 06 24             jp      NZ,FNDELP       ; More - Keep going
2635+ 2420 29                   add     HL,HL           ; 4 Bytes per element
2636+ 2421 29                   add     HL,HL
2637+ 2422 C1                   pop     BC              ; Start of array
2638+ 2423 09                   add     HL,BC           ; Point to element
2639+ 2424 EB                   ex      DE,HL           ; Address of element to DE
2640+ 2425 2A D6 52     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2641+ 2428 C9                   ret
2642+ 2429
2643+ 2429
2644+ 2429              ; returns the value of the 32-bit system tick counter as
2645+ 2429              ; two 16-bit words
2646+ 2429 CD 7A 20     TMR:    call    TSTNUM          ; Make sure it's a number
2647+ 242C CD A4 1C             call    DEINT           ; Get integer (-32768 to 32767)
2648+ 242F 2A DC 52             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2649+ 2432 7B                   ld      A,E
2650+ 2433 B2                   or      D               ; is it 0?
2651+ 2434 CA 3A 24             jp      Z,ENDTMR        ; yes, jump over
2652+ 2437 2A DE 52             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2653+ 243A 45           ENDTMR: ld      B,L             ; move bytes...
2654+ 243B 7C                   ld      A,H             ; ...into AB
2655+ 243C C3 61 24             jp      ABPASS          ; return word into AB
2656+ 243F
2657+ 243F
2658+ 243F              ; returns the free space for BASIC or into the string pool
2659+ 243F 2A 47 53     FRE:    ld      HL,(ARREND)     ; Start of free memory
2660+ 2442 EB                   ex      DE,HL           ; To DE
2661+ 2443 21 00 00             ld      HL,$0000        ; End of free memory
2662+ 2446 39                   add     HL,SP           ; Current stack value
2663+ 2447 3A B3 52             ld      A,(TYPE)        ; Dummy argument type
2664+ 244A B7                   or      A
2665+ 244B CA 5B 24             jp      Z,FRENUM        ; Numeric - Free variable space
2666+ 244E CD C2 26             call    GSTRCU          ; Current string to pool
2667+ 2451 CD C2 25             call    GARBGE          ; Garbage collection
2668+ 2454 2A CC 51             ld      HL,(STRSPC)     ; Bottom of string space in use
2669+ 2457 EB                   ex      DE,HL           ; To DE
2670+ 2458 2A C9 52             ld      HL,(STRBOT)     ; Bottom of string space
2671+ 245B 7D           FRENUM: ld      A,L             ; Get LSB of end
2672+ 245C 93                   sub     E               ; Subtract LSB of beginning
2673+ 245D 4F                   ld      C,A             ; Save difference if C
2674+ 245E 7C                   ld      A,H             ; Get MSB of end
2675+ 245F 9A                   sbc     A,D             ; Subtract MSB of beginning
2676+ 2460 41           ACPASS: ld      B,C             ; Return integer AC
2677+ 2461 50           ABPASS: ld      D,B             ; Return integer AB
2678+ 2462 1E 00                ld      E,$00
2679+ 2464 21 B3 52             ld      HL,TYPE         ; Point to type
2680+ 2467 73                   ld      (HL),E          ; Set type to numeric
2681+ 2468 06 90                ld      B,$80+$10       ; 16 bit integer
2682+ 246A C3 9B 2E             jp      RETINT          ; Return the integer
2683+ 246D
2684+ 246D              ; returns the X position of the cursor during a print
2685+ 246D 3A B1 52     POS:    ld      A,(CURPOS)      ; Get cursor position
2686+ 2470 47           PASSA:  ld      B,A             ; Put A into AB
2687+ 2471 AF                   xor     A               ; Zero A
2688+ 2472 C3 61 24             jp      ABPASS          ; Return integer AB
2689+ 2475
2690+ 2475 CD F8 24     DEF:    call    CHEKFN          ; Get "FN" and name
2691+ 2478 CD EA 24             call    IDTEST          ; Test for illegal direct
2692+ 247B 01 97 1D             ld      BC,DATA         ; To get next statement
2693+ 247E C5                   push    BC              ; Save address for RETurn
2694+ 247F D5                   push    DE              ; Save address of function ptr
2695+ 2480 CD AD 19             call    CHKSYN          ; Make sure "(" follows
2696+ 2483 28                   defb    '('
2697+ 2484 CD 86 22             call    GETVAR          ; Get argument variable name
2698+ 2487 E5                   push    HL              ; Save code string address
2699+ 2488 EB                   ex      DE,HL           ; Argument address to HL
2700+ 2489 2B                   dec     HL
2701+ 248A 56                   ld      D,(HL)          ; Get first byte of arg name
2702+ 248B 2B                   dec     HL
2703+ 248C 5E                   ld      E,(HL)          ; Get second byte of arg name
2704+ 248D E1                   pop     HL              ; Restore code string address
2705+ 248E CD 7A 20             call    TSTNUM          ; Make sure numeric argument
2706+ 2491 CD AD 19             call    CHKSYN          ; Make sure ")" follows
2707+ 2494 29                   defb    ')'
2708+ 2495 CD AD 19             call    CHKSYN          ; Make sure "=" follows
2709+ 2498 C8                   defb    ZEQUAL          ; "=" token
2710+ 2499 44                   ld      B,H             ; Code string address to BC
2711+ 249A 4D                   ld      C,L
2712+ 249B E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2713+ 249C 71                   ld      (HL),C          ; Save LSB of FN code string
2714+ 249D 23                   inc     HL
2715+ 249E 70                   ld      (HL),B          ; Save MSB of FN code string
2716+ 249F C3 37 25             jp      SVSTAD          ; Save address and do function
2717+ 24A2
2718+ 24A2 CD F8 24     DOFN:   call    CHEKFN          ; Make sure FN follows
2719+ 24A5 D5                   push    DE              ; Save function pointer address
2720+ 24A6 CD 4E 21             call    EVLPAR          ; Evaluate expression in "()"
2721+ 24A9 CD 7A 20             call    TSTNUM          ; Make sure numeric result
2722+ 24AC E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2723+ 24AD 5E                   ld      E,(HL)          ; Get LSB of FN code string
2724+ 24AE 23                   inc     HL
2725+ 24AF 56                   ld      D,(HL)          ; Get MSB of FN code string
2726+ 24B0 23                   inc     HL
2727+ 24B1 7A                   ld      A,D             ; And function DEFined?
2728+ 24B2 B3                   or      E
2729+ 24B3 CA D7 16             jp      Z,UFERR         ; No - ?UF Error
2730+ 24B6 7E                   ld      A,(HL)          ; Get LSB of argument address
2731+ 24B7 23                   inc     HL
2732+ 24B8 66                   ld      H,(HL)          ; Get MSB of argument address
2733+ 24B9 6F                   ld      L,A             ; HL = Arg variable address
2734+ 24BA E5                   push    HL              ; Save it
2735+ 24BB 2A 4B 53             ld      HL,(FNRGNM)     ; Get old argument name
2736+ 24BE E3                   ex      (SP),HL         ; Save old , Get new
2737+ 24BF 22 4B 53             ld      (FNRGNM),HL     ; Set new argument name
2738+ 24C2 2A 4F 53             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2739+ 24C5 E5                   push    HL              ; Save it
2740+ 24C6 2A 4D 53             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2741+ 24C9 E5                   push    HL              ; Save it
2742+ 24CA 21 4D 53             ld      HL,FNARG        ; HL = Value of argument
2743+ 24CD D5                   push    DE              ; Save FN code string address
2744+ 24CE CD DC 2E             call    FPTHL           ; Move FPREG to argument
2745+ 24D1 E1                   pop     HL              ; Get FN code string address
2746+ 24D2 CD 77 20             call    GETNUM          ; Get value from function
2747+ 24D5 2B                   dec     HL              ; dec 'cos GETCHR INCs
2748+ 24D6 CD EE 1B             call    GETCHR          ; Get next character
2749+ 24D9 C2 CB 16             jp      NZ,SNERR        ; Bad character in FN - Error
2750+ 24DC E1                   pop     HL              ; Get MSB,EXP of old arg
2751+ 24DD 22 4D 53             ld      (FNARG),HL      ; Restore it
2752+ 24E0 E1                   pop     HL              ; Get LSB,NLSB of old arg
2753+ 24E1 22 4F 53             ld      (FNARG+2),HL    ; Restore it
2754+ 24E4 E1                   pop     HL              ; Get name of old arg
2755+ 24E5 22 4B 53             ld      (FNRGNM),HL     ; Restore it
2756+ 24E8 E1                   pop     HL              ; Restore code string address
2757+ 24E9 C9                   ret
2758+ 24EA
2759+ 24EA E5           IDTEST: push    HL              ; Save code string address
2760+ 24EB 2A CE 51             ld      HL,(LINEAT)     ; Get current line number
2761+ 24EE 23                   inc     HL              ; -1 means direct statement
2762+ 24EF 7C                   ld      A,H
2763+ 24F0 B5                   or      L
2764+ 24F1 E1                   pop     HL              ; Restore code string address
2765+ 24F2 C0                   ret     NZ              ; Return if in program
2766+ 24F3 1E 16                ld      E,ID            ; ?ID Error
2767+ 24F5 C3 DF 16             jp      ERROR
2768+ 24F8
2769+ 24F8 CD AD 19     CHEKFN: call    CHKSYN          ; Make sure FN follows
2770+ 24FB B8                   defb    ZFN             ; "FN" token
2771+ 24FC 3E 80                ld      A,$80
2772+ 24FE 32 D1 52             ld      (FORFLG),A      ; Flag FN name to find
2773+ 2501 B6                   or      (HL)            ; FN name has bit 7 set
2774+ 2502 47                   ld      B,A             ; in first byte of name
2775+ 2503 CD 8B 22             call    GTFNAM          ; Get FN name
2776+ 2506 C3 7A 20             jp      TSTNUM          ; Make sure numeric function
2777+ 2509
2778+ 2509 CD 7A 20     STR:    call    TSTNUM          ; Make sure it's a number
2779+ 250C CD 29 30             call    NUMASC          ; Turn number into text
2780+ 250F CD 3D 25     STR1:   call    CRTST           ; Create string entry for it
2781+ 2512 CD C2 26             call    GSTRCU          ; Current string to pool
2782+ 2515 01 1D 27             ld      BC,TOPOOL       ; Save in string pool
2783+ 2518 C5                   push    BC              ; Save address on stack
2784+ 2519
2785+ 2519 7E           SAVSTR: ld      A,(HL)          ; Get string length
2786+ 251A 23                   inc     HL
2787+ 251B 23                   inc     HL
2788+ 251C E5                   push    HL              ; Save pointer to string
2789+ 251D CD 98 25             call    TESTR           ; See if enough string space
2790+ 2520 E1                   pop     HL              ; Restore pointer to string
2791+ 2521 4E                   ld      C,(HL)          ; Get LSB of address
2792+ 2522 23                   inc     HL
2793+ 2523 46                   ld      B,(HL)          ; Get MSB of address
2794+ 2524 CD 31 25             call    CRTMST          ; Create string entry
2795+ 2527 E5                   push    HL              ; Save pointer to MSB of addr
2796+ 2528 6F                   ld      L,A             ; Length of string
2797+ 2529 CD B5 26             call    TOSTRA          ; Move to string area
2798+ 252C D1                   pop     DE              ; Restore pointer to MSB
2799+ 252D C9                   ret
2800+ 252E
2801+ 252E CD 98 25     MKTMST: call    TESTR           ; See if enough string space
2802+ 2531 21 C5 52     CRTMST: ld      HL,TMPSTR       ; Temporary string
2803+ 2534 E5                   push    HL              ; Save it
2804+ 2535 77                   ld      (HL),A          ; Save length of string
2805+ 2536 23                   inc     HL
2806+ 2537 23           SVSTAD: inc     HL
2807+ 2538 73                   ld      (HL),E          ; Save LSB of address
2808+ 2539 23                   inc     HL
2809+ 253A 72                   ld      (HL),D          ; Save MSB of address
2810+ 253B E1                   pop     HL              ; Restore pointer
2811+ 253C C9                   ret
2812+ 253D
2813+ 253D 2B           CRTST:  dec     HL              ; dec - INCed after
2814+ 253E 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2815+ 2540 50                   ld      D,B             ; Quote to D
2816+ 2541 E5           DTSTR:  push    HL              ; Save start
2817+ 2542 0E FF                ld      C,-1            ; Set counter to -1
2818+ 2544 23           QTSTLP: inc     HL              ; Move on
2819+ 2545 7E                   ld      A,(HL)          ; Get byte
2820+ 2546 0C                   inc     C               ; Count bytes
2821+ 2547 B7                   or      A               ; End of line?
2822+ 2548 CA 53 25             jp      Z,CRTSTE        ; Yes - Create string entry
2823+ 254B BA                   cp      D               ; Terminator D found?
2824+ 254C CA 53 25             jp      Z,CRTSTE        ; Yes - Create string entry
2825+ 254F B8                   cp      B               ; Terminator B found?
2826+ 2550 C2 44 25             jp      NZ,QTSTLP       ; No - Keep looking
2827+ 2553 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2828+ 2555 CC EE 1B             call    Z,GETCHR        ; Yes - Get next character
2829+ 2558 E3                   ex      (SP),HL         ; Starting quote
2830+ 2559 23                   inc     HL              ; First byte of string
2831+ 255A EB                   ex      DE,HL           ; To DE
2832+ 255B 79                   ld      A,C             ; Get length
2833+ 255C CD 31 25             call    CRTMST          ; Create string entry
2834+ 255F 11 C5 52     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2835+ 2562 2A B7 52             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2836+ 2565 22 51 53             ld      (FPREG),HL      ; Save address of string ptr
2837+ 2568 3E 01                ld      A,$01
2838+ 256A 32 B3 52             ld      (TYPE),A        ; Set type to string
2839+ 256D CD DF 2E             call    DETHL4          ; Move string to pool
2840+ 2570 CD A7 19             call    CPDEHL          ; Out of string pool?
2841+ 2573 22 B7 52             ld      (TMSTPT),HL     ; Save new pointer
2842+ 2576 E1                   pop     HL              ; Restore code string address
2843+ 2577 7E                   ld      A,(HL)          ; Get next code byte
2844+ 2578 C0                   ret     NZ              ; Return if pool OK
2845+ 2579 1E 1E                ld      E,ST            ; ?ST Error
2846+ 257B C3 DF 16             jp      ERROR           ; String pool overflow
2847+ 257E
2848+ 257E 23           PRNUMS: inc     HL              ; Skip leading space
2849+ 257F CD 3D 25     PRS:    call    CRTST           ; Create string entry for it
2850+ 2582 CD C2 26     PRS1:   call    GSTRCU          ; Current string to pool
2851+ 2585 CD D3 2E             call    LOADFP          ; Move string block to BCDE
2852+ 2588 1C                   inc     E               ; Length + 1
2853+ 2589 1D           PRSLP:  dec     E               ; Count characters
2854+ 258A C8                   ret     Z               ; End of string
2855+ 258B 0A                   ld      A,(BC)          ; Get byte to output
2856+ 258C CD B8 19             call    OUTC            ; Output character in A
2857+ 258F FE 0D                cp      CR              ; Return?
2858+ 2591 CC C5 1E             call    Z,CNTEND        ; Yes - Position cursor to 0
2859+ 2594 03                   inc     BC              ; Next byte in string
2860+ 2595 C3 89 25             jp      PRSLP           ; More characters to output
2861+ 2598
2862+ 2598 B7           TESTR:  or      A               ; Test if enough room
2863+ 2599 0E                   defb    $0E             ; No garbage collection done
2864+ 259A F1           GRBDON: pop     AF              ; Garbage collection done
2865+ 259B F5                   push    AF              ; Save status
2866+ 259C 2A CC 51             ld      HL,(STRSPC)     ; Bottom of string space in use
2867+ 259F EB                   ex      DE,HL           ; To DE
2868+ 25A0 2A C9 52             ld      HL,(STRBOT)     ; Bottom of string area
2869+ 25A3 2F                   cpl                     ; Negate length (Top down)
2870+ 25A4 4F                   ld      C,A             ; -Length to BC
2871+ 25A5 06 FF                ld      B,-1            ; BC = -ve length of string
2872+ 25A7 09                   add     HL,BC           ; Add to bottom of space in use
2873+ 25A8 23                   inc     HL              ; Plus one for 2's complement
2874+ 25A9 CD A7 19             call    CPDEHL          ; Below string RAM area?
2875+ 25AC DA B6 25             jp      C,TESTOS        ; Tidy up if not done else err
2876+ 25AF 22 C9 52             ld      (STRBOT),HL     ; Save new bottom of area
2877+ 25B2 23                   inc     HL              ; Point to first byte of string
2878+ 25B3 EB                   ex      DE,HL           ; Address to DE
2879+ 25B4 F1           POPAF:  pop     AF              ; Throw away status push
2880+ 25B5 C9                   ret
2881+ 25B6
2882+ 25B6 F1           TESTOS: pop     AF              ; Garbage collect been done?
2883+ 25B7 1E 1A                ld      E,OS            ; ?OS Error
2884+ 25B9 CA DF 16             jp      Z,ERROR         ; Yes - Not enough string space
2885+ 25BC BF                   cp      A               ; Flag garbage collect done
2886+ 25BD F5                   push    AF              ; Save status
2887+ 25BE 01 9A 25             ld      BC,GRBDON       ; Garbage collection done
2888+ 25C1 C5                   push    BC              ; Save for RETurn
2889+ 25C2 2A B5 52     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2890+ 25C5 22 C9 52     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2891+ 25C8 21 00 00             ld      HL,$0000
2892+ 25CB E5                   push    HL              ; Flag no string found
2893+ 25CC 2A CC 51             ld      HL,(STRSPC)     ; Get bottom of string space
2894+ 25CF E5                   push    HL              ; Save bottom of string space
2895+ 25D0 21 B9 52             ld      HL,TMSTPL       ; Temporary string pool
2896+ 25D3 EB           GRBLP:  ex      DE,HL
2897+ 25D4 2A B7 52             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2898+ 25D7 EB                   ex      DE,HL
2899+ 25D8 CD A7 19             call    CPDEHL          ; Temporary string pool done?
2900+ 25DB 01 D3 25             ld      BC,GRBLP        ; Loop until string pool done
2901+ 25DE C2 27 26             jp      NZ,STPOOL       ; No - See if in string area
2902+ 25E1 2A 43 53             ld      HL,(PROGND)     ; Start of simple variables
2903+ 25E4 EB           SMPVAR: ex      DE,HL
2904+ 25E5 2A 45 53             ld      HL,(VAREND)     ; End of simple variables
2905+ 25E8 EB                   ex      DE,HL
2906+ 25E9 CD A7 19             call    CPDEHL          ; All simple strings done?
2907+ 25EC CA FA 25             jp      Z,ARRLP         ; Yes - Do string arrays
2908+ 25EF 7E                   ld      A,(HL)          ; Get type of variable
2909+ 25F0 23                   inc     HL
2910+ 25F1 23                   inc     HL
2911+ 25F2 B7                   or      A               ; "S" flag set if string
2912+ 25F3 CD 2A 26             call    STRADD          ; See if string in string area
2913+ 25F6 C3 E4 25             jp      SMPVAR          ; Loop until simple ones done
2914+ 25F9
2915+ 25F9 C1           GNXARY: pop     BC              ; Scrap address of this array
2916+ 25FA EB           ARRLP:  ex      DE,HL
2917+ 25FB 2A 47 53             ld      HL,(ARREND)     ; End of string arrays
2918+ 25FE EB                   ex      DE,HL
2919+ 25FF CD A7 19             call    CPDEHL          ; All string arrays done?
2920+ 2602 CA 50 26             jp      Z,SCNEND        ; Yes - Move string if found
2921+ 2605 CD D3 2E             call    LOADFP          ; Get array name to BCDE
2922+ 2608 7B                   ld      A,E             ; Get type of array
2923+ 2609 E5                   push    HL              ; Save address of num of dim'ns
2924+ 260A 09                   add     HL,BC           ; Start of next array
2925+ 260B B7                   or      A               ; Test type of array
2926+ 260C F2 F9 25             jp      P,GNXARY        ; Numeric array - Ignore it
2927+ 260F 22 CB 52             ld      (CUROPR),HL     ; Save address of next array
2928+ 2612 E1                   pop     HL              ; Get address of num of dim'ns
2929+ 2613 4E                   ld      C,(HL)          ; BC = Number of dimensions
2930+ 2614 06 00                ld      B,$00
2931+ 2616 09                   add     HL,BC           ; Two bytes per dimension size
2932+ 2617 09                   add     HL,BC
2933+ 2618 23                   inc     HL              ; Plus one for number of dim'ns
2934+ 2619 EB           GRBARY: ex      DE,HL
2935+ 261A 2A CB 52             ld      HL,(CUROPR)     ; Get address of next array
2936+ 261D EB                   ex      DE,HL
2937+ 261E CD A7 19             call    CPDEHL          ; Is this array finished?
2938+ 2621 CA FA 25             jp      Z,ARRLP         ; Yes - Get next one
2939+ 2624 01 19 26             ld      BC,GRBARY       ; Loop until array all done
2940+ 2627 C5           STPOOL: push    BC              ; Save return address
2941+ 2628 F6 80                or      $80             ; Flag string type
2942+ 262A 7E           STRADD: ld      A,(HL)          ; Get string length
2943+ 262B 23                   inc     HL
2944+ 262C 23                   inc     HL
2945+ 262D 5E                   ld      E,(HL)          ; Get LSB of string address
2946+ 262E 23                   inc     HL
2947+ 262F 56                   ld      D,(HL)          ; Get MSB of string address
2948+ 2630 23                   inc     HL
2949+ 2631 F0                   ret     P               ; Not a string - Return
2950+ 2632 B7                   or      A               ; Set flags on string length
2951+ 2633 C8                   ret     Z               ; Null string - Return
2952+ 2634 44                   ld      B,H             ; Save variable pointer
2953+ 2635 4D                   ld      C,L
2954+ 2636 2A C9 52             ld      HL,(STRBOT)     ; Bottom of new area
2955+ 2639 CD A7 19             call    CPDEHL          ; String been done?
2956+ 263C 60                   ld      H,B             ; Restore variable pointer
2957+ 263D 69                   ld      L,C
2958+ 263E D8                   ret     C               ; String done - Ignore
2959+ 263F E1                   pop     HL              ; Return address
2960+ 2640 E3                   ex      (SP),HL         ; Lowest available string area
2961+ 2641 CD A7 19             call    CPDEHL          ; String within string area?
2962+ 2644 E3                   ex      (SP),HL         ; Lowest available string area
2963+ 2645 E5                   push    HL              ; Re-save return address
2964+ 2646 60                   ld      H,B             ; Restore variable pointer
2965+ 2647 69                   ld      L,C
2966+ 2648 D0                   ret     NC              ; Outside string area - Ignore
2967+ 2649 C1                   pop     BC              ; Get return , Throw 2 away
2968+ 264A F1                   pop     AF              ;
2969+ 264B F1                   pop     AF              ;
2970+ 264C E5                   push    HL              ; Save variable pointer
2971+ 264D D5                   push    DE              ; Save address of current
2972+ 264E C5                   push    BC              ; Put back return address
2973+ 264F C9                   ret                     ; Go to it
2974+ 2650
2975+ 2650 D1           SCNEND: pop     DE              ; Addresses of strings
2976+ 2651 E1                   pop     HL              ;
2977+ 2652 7D                   ld      A,L             ; HL = 0 if no more to do
2978+ 2653 B4                   or      H
2979+ 2654 C8                   ret     Z               ; No more to do - Return
2980+ 2655 2B                   dec     HL
2981+ 2656 46                   ld      B,(HL)          ; MSB of address of string
2982+ 2657 2B                   dec     HL
2983+ 2658 4E                   ld      C,(HL)          ; LSB of address of string
2984+ 2659 E5                   push    HL              ; Save variable address
2985+ 265A 2B                   dec     HL
2986+ 265B 2B                   dec     HL
2987+ 265C 6E                   ld      L,(HL)          ; HL = Length of string
2988+ 265D 26 00                ld      H,$00
2989+ 265F 09                   add     HL,BC           ; Address of end of string+1
2990+ 2660 50                   ld      D,B             ; String address to DE
2991+ 2661 59                   ld      E,C
2992+ 2662 2B                   dec     HL              ; Last byte in string
2993+ 2663 44                   ld      B,H             ; Address to BC
2994+ 2664 4D                   ld      C,L
2995+ 2665 2A C9 52             ld      HL,(STRBOT)     ; Current bottom of string area
2996+ 2668 CD 7A 16             call    MOVSTR          ; Move string to new address
2997+ 266B E1                   pop     HL              ; Restore variable address
2998+ 266C 71                   ld      (HL),C          ; Save new LSB of address
2999+ 266D 23                   inc     HL
3000+ 266E 70                   ld      (HL),B          ; Save new MSB of address
3001+ 266F 69                   ld      L,C             ; Next string area+1 to HL
3002+ 2670 60                   ld      H,B
3003+ 2671 2B                   dec     HL              ; Next string area address
3004+ 2672 C3 C5 25             jp      GARBLP          ; Look for more strings
3005+ 2675
3006+ 2675 C5           CONCAT: push    BC              ; Save prec' opr & code string
3007+ 2676 E5                   push    HL              ;
3008+ 2677 2A 51 53             ld      HL,(FPREG)      ; Get first string
3009+ 267A E3                   ex      (SP),HL         ; Save first string
3010+ 267B CD 00 21             call    OPRND           ; Get second string
3011+ 267E E3                   ex      (SP),HL         ; Restore first string
3012+ 267F CD 7B 20             call    TSTSTR          ; Make sure it's a string
3013+ 2682 7E                   ld      A,(HL)          ; Get length of second string
3014+ 2683 E5                   push    HL              ; Save first string
3015+ 2684 2A 51 53             ld      HL,(FPREG)      ; Get second string
3016+ 2687 E5                   push    HL              ; Save second string
3017+ 2688 86                   add     A,(HL)          ; Add length of second string
3018+ 2689 1E 1C                ld      E,LS            ; ?LS Error
3019+ 268B DA DF 16             jp      C,ERROR         ; String too long - Error
3020+ 268E CD 2E 25             call    MKTMST          ; Make temporary string
3021+ 2691 D1                   pop     DE              ; Get second string to DE
3022+ 2692 CD C6 26             call    GSTRDE          ; Move to string pool if needed
3023+ 2695 E3                   ex      (SP),HL         ; Get first string
3024+ 2696 CD C5 26             call    GSTRHL          ; Move to string pool if needed
3025+ 2699 E5                   push    HL              ; Save first string
3026+ 269A 2A C7 52             ld      HL,(TMPSTR+2)   ; Temporary string address
3027+ 269D EB                   ex      DE,HL           ; To DE
3028+ 269E CD AC 26             call    SSTSA           ; First string to string area
3029+ 26A1 CD AC 26             call    SSTSA           ; Second string to string area
3030+ 26A4 21 95 20             ld      HL,EVAL2        ; Return to evaluation loop
3031+ 26A7 E3                   ex      (SP),HL         ; Save return,get code string
3032+ 26A8 E5                   push    HL              ; Save code string address
3033+ 26A9 C3 5F 25             jp      TSTOPL          ; To temporary string to pool
3034+ 26AC
3035+ 26AC E1           SSTSA:  pop     HL              ; Return address
3036+ 26AD E3                   ex      (SP),HL         ; Get string block,save return
3037+ 26AE 7E                   ld      A,(HL)          ; Get length of string
3038+ 26AF 23                   inc     HL
3039+ 26B0 23                   inc     HL
3040+ 26B1 4E                   ld      C,(HL)          ; Get LSB of string address
3041+ 26B2 23                   inc     HL
3042+ 26B3 46                   ld      B,(HL)          ; Get MSB of string address
3043+ 26B4 6F                   ld      L,A             ; Length to L
3044+ 26B5 2C           TOSTRA: inc     L               ; inc - DECed after
3045+ 26B6 2D           TSALP:  dec     L               ; Count bytes moved
3046+ 26B7 C8                   ret     Z               ; End of string - Return
3047+ 26B8 0A                   ld      A,(BC)          ; Get source
3048+ 26B9 12                   ld      (DE),A          ; Save destination
3049+ 26BA 03                   inc     BC              ; Next source
3050+ 26BB 13                   inc     DE              ; Next destination
3051+ 26BC C3 B6 26             jp      TSALP           ; Loop until string moved
3052+ 26BF
3053+ 26BF CD 7B 20     GETSTR: call    TSTSTR          ; Make sure it's a string
3054+ 26C2 2A 51 53     GSTRCU: ld      HL,(FPREG)      ; Get current string
3055+ 26C5 EB           GSTRHL: ex      DE,HL           ; Save DE
3056+ 26C6 CD E0 26     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3057+ 26C9 EB                   ex      DE,HL           ; Restore DE
3058+ 26CA C0                   ret     NZ              ; No - Return
3059+ 26CB D5                   push    DE              ; Save string
3060+ 26CC 50                   ld      D,B             ; String block address to DE
3061+ 26CD 59                   ld      E,C
3062+ 26CE 1B                   dec     DE              ; Point to length
3063+ 26CF 4E                   ld      C,(HL)          ; Get string length
3064+ 26D0 2A C9 52             ld      HL,(STRBOT)     ; Current bottom of string area
3065+ 26D3 CD A7 19             call    CPDEHL          ; Last one in string area?
3066+ 26D6 C2 DE 26             jp      NZ,POPHL        ; No - Return
3067+ 26D9 47                   ld      B,A             ; Clear B (A=0)
3068+ 26DA 09                   add     HL,BC           ; Remove string from str' area
3069+ 26DB 22 C9 52             ld      (STRBOT),HL     ; Save new bottom of str' area
3070+ 26DE E1           POPHL:  pop     HL              ; Restore string
3071+ 26DF C9                   ret
3072+ 26E0
3073+ 26E0 2A B7 52     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3074+ 26E3 2B                   dec     HL              ; Back
3075+ 26E4 46                   ld      B,(HL)          ; Get MSB of address
3076+ 26E5 2B                   dec     HL              ; Back
3077+ 26E6 4E                   ld      C,(HL)          ; Get LSB of address
3078+ 26E7 2B                   dec     HL              ; Back
3079+ 26E8 2B                   dec     HL              ; Back
3080+ 26E9 CD A7 19             call    CPDEHL          ; String last in string pool?
3081+ 26EC C0                   ret     NZ              ; Yes - Leave it
3082+ 26ED 22 B7 52             ld      (TMSTPT),HL     ; Save new string pool top
3083+ 26F0 C9                   ret
3084+ 26F1
3085+ 26F1 01 70 24     LEN:    ld      BC,PASSA        ; To return integer A
3086+ 26F4 C5                   push    BC              ; Save address
3087+ 26F5 CD BF 26     GETLEN: call    GETSTR          ; Get string and its length
3088+ 26F8 AF                   xor     A
3089+ 26F9 57                   ld      D,A             ; Clear D
3090+ 26FA 32 B3 52             ld      (TYPE),A        ; Set type to numeric
3091+ 26FD 7E                   ld      A,(HL)          ; Get length of string
3092+ 26FE B7                   or      A               ; Set status flags
3093+ 26FF C9                   ret
3094+ 2700
3095+ 2700 01 70 24     ASC:    ld      BC,PASSA        ; To return integer A
3096+ 2703 C5                   push    BC              ; Save address
3097+ 2704 CD F5 26     GTFLNM: call    GETLEN          ; Get length of string
3098+ 2707 CA B9 1C             jp      Z,FCERR         ; Null string - Error
3099+ 270A 23                   inc     HL
3100+ 270B 23                   inc     HL
3101+ 270C 5E                   ld      E,(HL)          ; Get LSB of address
3102+ 270D 23                   inc     HL
3103+ 270E 56                   ld      D,(HL)          ; Get MSB of address
3104+ 270F 1A                   ld      A,(DE)          ; Get first byte of string
3105+ 2710 C9                   ret
3106+ 2711
3107+ 2711 3E 01        CHR:    ld      A,$01           ; One character string
3108+ 2713 CD 2E 25             call    MKTMST          ; Make a temporary string
3109+ 2716 CD 00 29             call    MAKINT          ; Make it integer A
3110+ 2719 2A C7 52             ld      HL,(TMPSTR+2)   ; Get address of string
3111+ 271C 73                   ld      (HL),E          ; Save character
3112+ 271D C1           TOPOOL: pop     BC              ; Clean up stack
3113+ 271E C3 5F 25             jp      TSTOPL          ; Temporary string to pool
3114+ 2721
3115+ 2721 CD B0 28     LEFT:   call    LFRGNM          ; Get number and ending ")"
3116+ 2724 AF                   xor     A               ; Start at first byte in string
3117+ 2725 E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3118+ 2726 4F                   ld      C,A             ; Starting position in string
3119+ 2727 E5           MID1:   push    HL              ; Save string block address
3120+ 2728 7E                   ld      A,(HL)          ; Get length of string
3121+ 2729 B8                   cp      B               ; Compare with number given
3122+ 272A DA 2F 27             jp      C,ALLFOL        ; All following bytes required
3123+ 272D 78                   ld      A,B             ; Get new length
3124+ 272E 11                   defb    $11             ; Skip "ld C,0"
3125+ 272F 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3126+ 2731 C5                   push    BC              ; Save position in string
3127+ 2732 CD 98 25             call    TESTR           ; See if enough string space
3128+ 2735 C1                   pop     BC              ; Get position in string
3129+ 2736 E1                   pop     HL              ; Restore string block address
3130+ 2737 E5                   push    HL              ; And re-save it
3131+ 2738 23                   inc     HL
3132+ 2739 23                   inc     HL
3133+ 273A 46                   ld      B,(HL)          ; Get LSB of address
3134+ 273B 23                   inc     HL
3135+ 273C 66                   ld      H,(HL)          ; Get MSB of address
3136+ 273D 68                   ld      L,B             ; HL = address of string
3137+ 273E 06 00                ld      B,$00           ; BC = starting address
3138+ 2740 09                   add     HL,BC           ; Point to that byte
3139+ 2741 44                   ld      B,H             ; BC = source string
3140+ 2742 4D                   ld      C,L
3141+ 2743 CD 31 25             call    CRTMST          ; Create a string entry
3142+ 2746 6F                   ld      L,A             ; Length of new string
3143+ 2747 CD B5 26             call    TOSTRA          ; Move string to string area
3144+ 274A D1                   pop     DE              ; Clear stack
3145+ 274B CD C6 26             call    GSTRDE          ; Move to string pool if needed
3146+ 274E C3 5F 25             jp      TSTOPL          ; Temporary string to pool
3147+ 2751
3148+ 2751
3149+ 2751              ; INSTR statement - look for a string inside another string
3150+ 2751              ; usage: INSTR(A$,B$) -> search for B$ into A$
3151+ 2751              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3152+ 2751              ; return 1~255 to indicate the starting position of B$ into A$
3153+ 2751              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3154+ 2751              LNS1    equ     TMPBFR1
3155+ 2751              ADRS1   equ     TMPBFR2
3156+ 2751              LNS2    equ     TMPBFR3
3157+ 2751              ADRS2   equ     TMPBFR4
3158+ 2751              PT      equ     VIDEOBUFF
3159+ 2751              PT1     equ     VIDEOBUFF+2
3160+ 2751              PT2     equ     VIDEOBUFF+4
3161+ 2751              TP      equ     VIDEOBUFF+6
3162+ 2751              TF      equ     VIDEOBUFF+8
3163+ 2751 CD AD 19     INSTR:  call    CHKSYN          ; make sure "(" follows
3164+ 2754 28                   defb    '('
3165+ 2755 2B                   dec     HL              ; dec 'cause GETCHR increments
3166+ 2756 CD EE 1B             call    GETCHR          ; check if something follows
3167+ 2759 CA CB 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3168+ 275C CD 89 20             call    EVAL            ; Evaluate expression
3169+ 275F CD 7B 20             call    TSTSTR          ; Make sure it's a string
3170+ 2762 22 05 53             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3171+ 2765 CD C2 26             call    GSTRCU          ; check that a string follows
3172+ 2768 CD D3 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3173+ 276B ED 53 FD 52          ld      (LNS1),DE       ; store values into
3174+ 276F ED 43 FF 52          ld      (ADRS1),BC      ; temp buffers
3175+ 2773 2A 05 53             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3176+ 2776 CD AD 19             call    CHKSYN          ; Make sure ',' follows
3177+ 2779 2C                   defb    ','
3178+ 277A 2B                   dec     HL              ; dec 'cause GETCHR increments
3179+ 277B CD EE 1B             call    GETCHR          ; check if something follows
3180+ 277E CA CB 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3181+ 2781 CD 89 20             call    EVAL            ; Evaluate expression
3182+ 2784 CD 7B 20             call    TSTSTR          ; Make sure it's a string
3183+ 2787 22 05 53             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3184+ 278A CD C2 26             call    GSTRCU          ; check that a string follows
3185+ 278D CD D3 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3186+ 2790 ED 53 01 53          ld      (LNS2),DE       ; store values into
3187+ 2794 ED 43 03 53          ld      (ADRS2),BC      ; temp buffers
3188+ 2798 2A 05 53             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3189+ 279B CD AD 19             call    CHKSYN          ; make sure ")" follows
3190+ 279E 29                   defb    ')'
3191+ 279F E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3192+ 27A0 FD E1                pop     IY              ; ...into IY
3193+ 27A2 AF                   xor     A               ; reset 10 RAM cells
3194+ 27A3 06 0A                ld      B,$0A           ; (INSTR registers)
3195+ 27A5 21 05 53             ld      HL,PT           ; first cell
3196+ 27A8 77           EMPTINS:ld      (HL),A          ; reset cell
3197+ 27A9 23                   inc     HL              ; next cell
3198+ 27AA 10 FC                djnz    EMPTINS         ; repeat
3199+ 27AC ED 5B 01 53          ld      DE,(LNS2)       ; load len(S2) into DE
3200+ 27B0 2A FD 52             ld      HL,(LNS1)       ; load len(S1) into HL
3201+ 27B3 CD B8 3F             call    CMP16           ; check that len(S1)>=len(S2)
3202+ 27B6 DA 2B 28             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3203+ 27B9 AF           RPTINST:xor     A               ; reset...
3204+ 27BA 32 0B 53             ld      (TP),A          ; ...TP...
3205+ 27BD 32 0D 53             ld      (TF),A          ; ...and TF
3206+ 27C0 ED 4B 05 53          ld      BC,(PT)         ; pointer to S1
3207+ 27C4 2A FF 52             ld      HL,(ADRS1)      ; first cell of S1
3208+ 27C7 09                   add     HL,BC           ; get current position into RAM
3209+ 27C8 7E                   ld      A,(HL)          ; load S1(PT)
3210+ 27C9 2A 03 53             ld      HL,(ADRS2)      ; pointer to first char of S2
3211+ 27CC BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3212+ 27CD 20 3A                jr      NZ,CNT1INS      ; no, continue
3213+ 27CF 3A 05 53             ld      A,(PT)          ; load current PT
3214+ 27D2 32 0B 53             ld      (TP),A          ; TP=PT
3215+ 27D5 32 07 53             ld      (PT1),A         ; P1=PT
3216+ 27D8 AF                   xor     A               ; set...
3217+ 27D9 32 09 53             ld      (PT2),A         ; ...PT2=0
3218+ 27DC 3C                   inc     A               ;
3219+ 27DD 32 0D 53             ld      (TF),A          ; set TF=1
3220+ 27E0 ED 4B 07 53  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3221+ 27E4 2A FF 52             ld      HL,(ADRS1)      ; load address of S1
3222+ 27E7 09                   add     HL,BC           ; find char of S1 pointed by PT1
3223+ 27E8 7E                   ld      A,(HL)          ; load S1(PT1)
3224+ 27E9 ED 4B 09 53          ld      BC,(PT2)        ; load pointer PT2
3225+ 27ED 2A 03 53             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3226+ 27F0 09                   add     HL,BC           ; find S2(PT2)
3227+ 27F1 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3228+ 27F2 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3229+ 27F4 21 07 53             ld      HL,PT1
3230+ 27F7 34                   inc     (HL)            ; increment PT1
3231+ 27F8 3A 09 53             ld      A,(PT2)
3232+ 27FB 3C                   inc     A               ; increment PT2
3233+ 27FC 32 09 53             ld      (PT2),A
3234+ 27FF CA 09 28             jp      Z,CNT1INS       ; if PT2>255 then exit
3235+ 2802 21 01 53             ld      HL,LNS2         ; len(S2)
3236+ 2805 BE                   cp      (HL)            ; PT2=len(S2)?
3237+ 2806 DA E0 27             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3238+ 2809 3A 0D 53     CNT1INS:ld      A,(TF)          ; check TF
3239+ 280C A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3240+ 280D 20 1C                jr      NZ,RZINSTR      ; no, exit
3241+ 280F 2A FD 52             ld      HL,(LNS1)       ; load len(S1)
3242+ 2812 ED 4B 01 53          ld      BC,(LNS2)       ; load len(S2)
3243+ 2816 ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3244+ 2818 ED 5B 05 53          ld      DE,(PT)         ; load pointer
3245+ 281C 1C                   inc     E               ; PT=PT+1
3246+ 281D ED 53 05 53          ld      (PT),DE         ; store new value
3247+ 2821 EB                   ex      DE,HL           ; invert registers
3248+ 2822 CD B8 3F             call    CMP16           ; check if PT>len(S1)-len(S2)
3249+ 2825 DA B9 27             jp      C,RPTINST       ; repeat if <
3250+ 2828 CA B9 27             jp      Z,RPTINST       ; repeat if =
3251+ 282B 3A 0D 53     RZINSTR:ld      A,(TF)          ; current value of TF
3252+ 282E A7                   and     A               ; is it 0?
3253+ 282F CA 36 28             jp      Z,LVINSTR       ; yes, return 0
3254+ 2832 3A 0B 53             ld      A,(TP)          ; return TP...
3255+ 2835 3C                   inc     A               ; ...incremented by 1
3256+ 2836 E1           LVINSTR:pop     HL              ; drop original return point
3257+ 2837 FD E5                push    IY              ; load current string address from IY into stack
3258+ 2839 11 62 21             ld      DE,RETNUM       ; Address of Return number from function...
3259+ 283C D5                   push    DE              ; ...saved on stack
3260+ 283D C3 70 24             jp      PASSA           ; return TP
3261+ 2840 AF           CNTZIN: xor     A               ; set...
3262+ 2841 32 0D 53             ld      (TF),A          ; TF=0
3263+ 2844 C3 09 28             jp      CNT1INS         ; continue
3264+ 2847
3265+ 2847
3266+ 2847              ; returns the right portion of a string
3267+ 2847 CD B0 28     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3268+ 284A D1                   pop     DE              ; Get string length
3269+ 284B D5                   push    DE              ; And re-save
3270+ 284C 1A                   ld      A,(DE)          ; Get length
3271+ 284D 90                   sub     B               ; Move back N bytes
3272+ 284E C3 25 27             jp      RIGHT1          ; Go and get sub-string
3273+ 2851
3274+ 2851              ; returns a piece of a string
3275+ 2851 EB           MID:    ex      DE,HL           ; Get code string address
3276+ 2852 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3277+ 2853 CD B5 28             call    MIDNUM          ; Get number supplied
3278+ 2856 04                   inc     B               ; Is it character zero?
3279+ 2857 05                   dec     B
3280+ 2858 CA B9 1C             jp      Z,FCERR         ; Yes - Error
3281+ 285B C5                   push    BC              ; Save starting position
3282+ 285C 1E FF                ld      E,$FF           ; All of string
3283+ 285E FE 29                cp      ')'             ; Any length given?
3284+ 2860 CA 6A 28             jp      Z,RSTSTR        ; No - Rest of string
3285+ 2863 CD AD 19             call    CHKSYN          ; Make sure ',' follows
3286+ 2866 2C                   defb    ','
3287+ 2867 CD FD 28             call    GETINT          ; Get integer 0-255
3288+ 286A CD AD 19     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3289+ 286D 29                   defb    ')'
3290+ 286E F1                   pop     AF              ; Restore starting position
3291+ 286F E3                   ex      (SP),HL         ; Get string,save code string
3292+ 2870 01 27 27             ld      BC,MID1         ; Continuation of MID$ routine
3293+ 2873 C5                   push    BC              ; Save for return
3294+ 2874 3D                   dec     A               ; Starting position-1
3295+ 2875 BE                   cp      (HL)            ; Compare with length
3296+ 2876 06 00                ld      B,$00           ; Zero bytes length
3297+ 2878 D0                   ret     NC              ; Null string if start past end
3298+ 2879 4F                   ld      C,A             ; Save starting position-1
3299+ 287A 7E                   ld      A,(HL)          ; Get length of string
3300+ 287B 91                   sub     C               ; Subtract start
3301+ 287C BB                   cp      E               ; Enough string for it?
3302+ 287D 47                   ld      B,A             ; Save maximum length available
3303+ 287E D8                   ret     C               ; Truncate string if needed
3304+ 287F 43                   ld      B,E             ; Set specified length
3305+ 2880 C9                   ret                     ; Go and create string
3306+ 2881
3307+ 2881
3308+ 2881              ; return the value of a numeric string
3309+ 2881 CD F5 26     VAL:    call    GETLEN          ; Get length of string
3310+ 2884 CA 53 2C             jp      Z,RESZER        ; Result zero
3311+ 2887 5F                   ld      E,A             ; Save length
3312+ 2888 23                   inc     HL
3313+ 2889 23                   inc     HL
3314+ 288A 7E                   ld      A,(HL)          ; Get LSB of address
3315+ 288B 23                   inc     HL
3316+ 288C 66                   ld      H,(HL)          ; Get MSB of address
3317+ 288D 6F                   ld      L,A             ; HL = String address
3318+ 288E E5                   push    HL              ; Save string address
3319+ 288F 19                   add     HL,DE
3320+ 2890 46                   ld      B,(HL)          ; Get end of string+1 byte
3321+ 2891 72                   ld      (HL),D          ; Zero it to terminate
3322+ 2892 E3                   ex      (SP),HL         ; Save string end,get start
3323+ 2893 C5                   push    BC              ; Save end+1 byte
3324+ 2894 7E                   ld      A,(HL)          ; Get starting byte
3325+ 2895 FE 24                cp      '$'             ; Hex number indicated? [function added]
3326+ 2897 C2 9F 28             jp      NZ,VAL1
3327+ 289A CD F1 3E             call    HEXTFP          ; Convert Hex to FPREG
3328+ 289D 18 0D                jr      VAL3
3329+ 289F FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3330+ 28A1 C2 A9 28             jp      NZ,VAL2
3331+ 28A4 CD 61 3F             call    BINTFP          ; Convert Bin to FPREG
3332+ 28A7 18 03                jr      VAL3
3333+ 28A9 CD 8B 2F     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3334+ 28AC C1           VAL3:   pop     BC              ; Restore end+1 byte
3335+ 28AD E1                   pop     HL              ; Restore end+1 address
3336+ 28AE 70                   ld      (HL),B          ; Put back original byte
3337+ 28AF C9                   ret
3338+ 28B0
3339+ 28B0 EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3340+ 28B1 CD AD 19             call    CHKSYN          ; Make sure ")" follows
3341+ 28B4 29                   defb    ')'
3342+ 28B5 C1           MIDNUM: pop     BC              ; Get return address
3343+ 28B6 D1                   pop     DE              ; Get number supplied
3344+ 28B7 C5                   push    BC              ; Re-save return address
3345+ 28B8 43                   ld      B,E             ; Number to B
3346+ 28B9 C9                   ret
3347+ 28BA
3348+ 28BA CD 00 29     INP:    call    MAKINT          ; Make it integer A
3349+ 28BD 32 BF 51             ld      (INPORT),A      ; Set input port
3350+ 28C0 CD BE 51             call    INPSUB          ; Get input from port
3351+ 28C3 C3 70 24             jp      PASSA           ; Return integer A
3352+ 28C6
3353+ 28C6 CD EA 28     POUT:   call    SETIO           ; Set up port number
3354+ 28C9 C3 86 51             jp      OUTSUB          ; Output data and return
3355+ 28CC
3356+ 28CC CD EA 28     WAIT:   call    SETIO           ; Set up port number
3357+ 28CF F5                   push    AF              ; Save AND mask
3358+ 28D0 1E 00                ld      E,$00           ; Assume zero if none given
3359+ 28D2 2B                   dec     HL              ; dec 'cos GETCHR INCs
3360+ 28D3 CD EE 1B             call    GETCHR          ; Get next character
3361+ 28D6 CA E0 28             jp      Z,NOXOR         ; No XOR byte given
3362+ 28D9 CD AD 19             call    CHKSYN          ; Make sure ',' follows
3363+ 28DC 2C                   defb    ','
3364+ 28DD CD FD 28             call    GETINT          ; Get integer 0-255 to XOR with
3365+ 28E0 C1           NOXOR:  pop     BC              ; Restore AND mask
3366+ 28E1 CD BE 51     WAITLP: call    INPSUB          ; Get input
3367+ 28E4 AB                   xor     E               ; Flip selected bits
3368+ 28E5 A0                   and     B               ; Result non-zero?
3369+ 28E6 CA E1 28             jp      Z,WAITLP        ; No = keep waiting
3370+ 28E9 C9                   ret
3371+ 28EA
3372+ 28EA CD FD 28     SETIO:  call    GETINT          ; Get integer 0-255
3373+ 28ED 32 BF 51             ld      (INPORT),A      ; Set input port
3374+ 28F0 32 87 51             ld      (OTPORT),A      ; Set output port
3375+ 28F3 CD AD 19             call    CHKSYN          ; Make sure ',' follows
3376+ 28F6 2C                   defb    ','
3377+ 28F7 C3 FD 28             jp      GETINT          ; Get integer 0-255 and return
3378+ 28FA
3379+ 28FA CD EE 1B     FNDNUM: call    GETCHR          ; Get next character
3380+ 28FD CD 77 20     GETINT: call    GETNUM          ; Get a number from 0 to 255
3381+ 2900 CD 9E 1C     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3382+ 2903 7A                   ld      A,D             ; Get MSB of number
3383+ 2904 B7                   or      A               ; Zero?
3384+ 2905 C2 B9 1C             jp      NZ,FCERR        ; No - Error
3385+ 2908 2B                   dec     HL              ; dec 'cos GETCHR INCs
3386+ 2909 CD EE 1B             call    GETCHR          ; Get next character
3387+ 290C 7B                   ld      A,E             ; Get number to A
3388+ 290D C9                   ret
3389+ 290E
3390+ 290E
3391+ 290E              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3392+ 290E              ; address must point to an ISR routine that terminates with EI/RETN instructions
3393+ 290E CD 77 20     NMI:    call    GETNUM          ; Get memory address
3394+ 2911 CD A4 1C             call    DEINT           ; get integer -32768 to 32767
3395+ 2914 7B                   ld      A,E             ; check if address is 0
3396+ 2915 B2                   or      D
3397+ 2916 20 11                jr      NZ,NM1          ; no, so jump over
3398+ 2918 F3           DISNMI: di                      ; disable INTs
3399+ 2919 CD 45 29             call    NMIDINT         ; disable VDP INT
3400+ 291C E5                   push    HL              ; store HL
3401+ 291D 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3402+ 2920 22 80 51             ld      (NMIUSR),HL     ; store RETN
3403+ 2923 AF                   xor     A
3404+ 2924 32 82 51             ld      (NMIUSR+2),A    ; "NOP"
3405+ 2927 18 11                jr      NMI2            ; execute the last part of code
3406+ 2929 E5           NM1:    push    HL              ; store current HL
3407+ 292A EB                   ex      DE,HL           ; move address argument into HL
3408+ 292B F3                   di                      ; disable INTs
3409+ 292C CD 45 29             call    NMIDINT         ; disable VDP INT, if enabled
3410+ 292F 3E C3                ld      A,$C3           ; "jp" instruction
3411+ 2931 32 80 51             ld      (NMIUSR),A      ; store it
3412+ 2934 22 81 51             ld      (NMIUSR+1),HL   ; store address
3413+ 2937 CD 3E 29             call    NMIEINT         ; re-enable VDP INT
3414+ 293A FB           NMI2:   ei                      ; re-enable INTS
3415+ 293B 00                   nop                     ; wait for INTs
3416+ 293C E1                   pop    HL               ; retrieve HL
3417+ 293D C9                   ret                     ; return to caller
3418+ 293E              ; enable VDP INT
3419+ 293E CD 54 29     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3420+ 2941 F6 20                or      %00100000       ; enable VDP INT
3421+ 2943 18 03                jr      NMIINT          ; rest of code is shared
3422+ 2945              ; disable VDP INT
3423+ 2945 CD 54 29     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3424+ 2948 D5           NMIINT: push    DE              ; store DE
3425+ 2949 5F                   ld      E,A             ; move value into E
3426+ 294A 3E 01                ld      A,$01           ; VREG #1
3427+ 294C F3                   di                      ; disable INTs
3428+ 294D CD A7 06             call    WRITE_VREG      ; disable VDP INT
3429+ 2950 FB                   ei                      ; re-enable INTs
3430+ 2951 00                   nop                     ; wait for INTs being enabled
3431+ 2952 D1                   pop     DE              ; retrieve DE
3432+ 2953 C9                   ret                     ; return to caller
3433+ 2954
3434+ 2954              ; load VREG #1 setting for current screen mode and return it into A
3435+ 2954 E5           NMIVR1: push    HL              ; store HL
3436+ 2955 D5                   push    DE              ; store DE
3437+ 2956 3A EE 52             ld      A,(SCR_MODE)    ; check screen mode
3438+ 2959 87                   add     A,A             ; multiply A by 8...
3439+ 295A 87                   add     A,A             ; ...so that reg. A can points..
3440+ 295B 87                   add     A,A             ; to the correct settings
3441+ 295C 3C                   inc     A               ; need to change VREG 1
3442+ 295D 5F                   ld      E,A             ; copy A into E
3443+ 295E 16 00                ld      D,$00           ; reset D
3444+ 2960 21 15 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3445+ 2963 19                   add     HL,DE           ; ...for current screen mode
3446+ 2964 7E                   ld      A,(HL)          ; load current setting
3447+ 2965 D1                   pop     DE              ; retrieve DE
3448+ 2966 E1                   pop     HL              ; retrieve HL
3449+ 2967 C9                   ret                     ; return to caller
3450+ 2968
3451+ 2968              ; execute a machine language routine, eventually passing a param into A
3452+ 2968 CD 77 20     SYS:    call    GETNUM          ; Get memory address
3453+ 296B CD A4 1C             call    DEINT           ; Get integer -32768 to 32767
3454+ 296E ED 53 FF 52          ld      (TMPBFR2),DE    ; store user routine's address
3455+ 2972 AF                   xor     A               ; reset A
3456+ 2973 32 FD 52             ld      (TMPBFR1),A     ; store into temp buffer
3457+ 2976 2B                   dec     HL              ; dec 'cos GETCHR INCs
3458+ 2977 CD EE 1B             call    GETCHR          ; check next character
3459+ 297A 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3460+ 297C CD AD 19             call    CHKSYN          ; Make sure ',' follows
3461+ 297F 2C                   defb    ','
3462+ 2980 CD FD 28             call    GETINT          ; get byte value (0~255) if something follows
3463+ 2983 32 FD 52             ld      (TMPBFR1),A     ; store into temp buffer
3464+ 2986 3A FD 52     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3465+ 2989 ED 5B FF 52          ld      DE,(TMPBFR2)    ; recover user routine's address
3466+ 298D E5                   push    HL              ; save code string address
3467+ 298E EB                   ex      DE,HL           ; move user routine's address into HL
3468+ 298F 11 94 29             ld      DE,SYSRET       ; set point of return after the user routine
3469+ 2992 D5                   push    DE              ; store into stack
3470+ 2993 E9                   jp      (HL)            ; call user routine
3471+ 2994 E1           SYSRET: pop     HL              ; retrieve code string address
3472+ 2995 C9                   ret                     ; return to caller
3473+ 2996
3474+ 2996
3475+ 2996              ; read the contents of a RAM location
3476+ 2996 CD A4 1C     PEEK:   call    DEINT           ; Get memory address into DE
3477+ 2999 1A                   ld      A,(DE)          ; Read value of memory cell
3478+ 299A C3 70 24             jp      PASSA           ; Return into A
3479+ 299D
3480+ 299D              ; read the contents of a VRAM location
3481+ 299D CD A4 1C     VPEEK:  call    DEINT           ; Get VRAM address into DE
3482+ 29A0 EB                   ex      DE,HL           ; Copy param into HL
3483+ 29A1 F3                   di                      ; Disable interrupts
3484+ 29A2 CD 7D 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3485+ 29A5 FB                   ei                      ; Re-enable interrupts
3486+ 29A6 EB                   ex      DE,HL           ; Restore HL
3487+ 29A7 C3 70 24             jp      PASSA           ; Return value into A
3488+ 29AA
3489+ 29AA              ; recover params for POKE/VPOKE commands
3490+ 29AA              ; returns address into DE and byte to be written into A
3491+ 29AA CD 77 20     PKEPRMS:call    GETNUM          ; Get memory address
3492+ 29AD CD A4 1C             call    DEINT           ; Get integer -32768 to 32767
3493+ 29B0 ED 53 FD 52          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3494+ 29B4 CD AD 19             call    CHKSYN          ; Make sure ',' follows
3495+ 29B7 2C                   defb    ','
3496+ 29B8 CD FD 28             call    GETINT          ; Get integer 0-255
3497+ 29BB ED 5B FD 52          ld      DE,(TMPBFR1)    ; Restore memory address
3498+ 29BF C9                   ret                     ; Return to caller
3499+ 29C0
3500+ 29C0              ; write a byte into a RAM location
3501+ 29C0 CD AA 29     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3502+ 29C3 12                   ld      (DE),A          ; Load it into memory
3503+ 29C4 C9                   ret
3504+ 29C5
3505+ 29C5              ; write a byte into a VRAM location
3506+ 29C5 CD AA 29     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3507+ 29C8 EB                   ex      DE,HL           ; Copy address into HL
3508+ 29C9 F3                   di                      ; Disable interrupts
3509+ 29CA CD 92 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3510+ 29CD FB                   ei                      ; Re-enable interrupts
3511+ 29CE EB                   ex      DE,HL           ; Restore HL
3512+ 29CF C9                   ret                     ; Return to caller
3513+ 29D0
3514+ 29D0              ; position the cursor at a specific X,Y location onto screen
3515+ 29D0 CD FD 28     LOCATE: call    GETINT          ; get the first param into A
3516+ 29D3 E5                   push    HL              ; store HL
3517+ 29D4 21 EC 52             ld      HL,SCR_SIZE_W   ; load address of screen width
3518+ 29D7 5E                   ld      E,(HL)          ; load screen width into E
3519+ 29D8 E1                   pop     HL              ; restore HL
3520+ 29D9 BB                   cp      E               ; compare witdh with param
3521+ 29DA D2 B9 1C             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3522+ 29DD 32 FD 52             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3523+ 29E0 CD AD 19             call    CHKSYN          ; Make sure ',' follows
3524+ 29E3 2C                   defb    ','
3525+ 29E4 CD FD 28             call    GETINT          ; Get the second param into A
3526+ 29E7 E5                   push    HL              ; store HL
3527+ 29E8 21 ED 52             ld      HL,SCR_SIZE_H   ; load address of screen width
3528+ 29EB 5E                   ld      E,(HL)          ; load screen width into A
3529+ 29EC E1                   pop     HL              ; restore HL
3530+ 29ED BB                   cp      E               ; compare witdh with param
3531+ 29EE D2 B9 1C             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3532+ 29F1 32 F5 52             ld      (SCR_CUR_NY),A  ; store new Y
3533+ 29F4 3A FD 52             ld      A,(TMPBFR1)     ; recover the new X
3534+ 29F7 32 F4 52             ld      (SCR_CUR_NX),A  ; store new X
3535+ 29FA E5                   push    HL              ; store HL
3536+ 29FB F3                   di                      ; disable INTs
3537+ 29FC CD C3 06             call    MOVCRS          ; move cursor to new location
3538+ 29FF FB                   ei                      ; re-enable INTs
3539+ 2A00 E1                   pop     HL              ; restore HL
3540+ 2A01 C9                   ret                     ; return to caller
3541+ 2A02
3542+ 2A02              ; write a byte into one of the PSG registers
3543+ 2A02 CD FD 28     SREG:   call    GETINT          ; Get register number back into A
3544+ 2A05 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3545+ 2A07 D2 B9 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3546+ 2A0A 32 FD 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3547+ 2A0D CD AD 19             call    CHKSYN          ; Make sure ',' follows
3548+ 2A10 2C                   defb    ','
3549+ 2A11 CD FD 28             call    GETINT          ; get second value (0-255), returned into A
3550+ 2A14 5F                   ld      E,A             ; store value into E
3551+ 2A15 3A FD 52             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3552+ 2A18 F3                   di                      ; disable INTs
3553+ 2A19 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3554+ 2A1B ED 79                out     (C),A           ; send register # to PSG
3555+ 2A1D 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3556+ 2A1F ED 59                out     (C),E           ; send byte to write into selected register
3557+ 2A21 FB                   ei                      ; re-enable INTs
3558+ 2A22 C9                   ret                     ; return to caller
3559+ 2A23
3560+ 2A23              ; VOLUME ch,vol
3561+ 2A23              ; set the volume for the audio channels
3562+ 2A23              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3563+ 2A23 CD FD 28     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3564+ 2A26 FE 04                cp      $04             ; check if it's in the range 0~3
3565+ 2A28 D2 B9 1C             jp      NC,FCERR        ; if not, exit with Illegal function call error
3566+ 2A2B 32 FD 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3567+ 2A2E CD AD 19             call    CHKSYN          ; Make sure ',' follows
3568+ 2A31 2C                   defb    ','
3569+ 2A32 CD FD 28             call    GETINT          ; get integer 0-255 (recover channel)
3570+ 2A35 FE 10                cp      $10             ; check if it's in the range 0~15
3571+ 2A37 D2 B9 1C             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3572+ 2A3A 57                   ld      D,A             ; store volume into D
3573+ 2A3B 3A FD 52             ld      A,(TMPBFR1)     ; retrieve channel
3574+ 2A3E A7                   and     A               ; is it 0? (0=every channel)
3575+ 2A3F 20 10                jr      NZ,VOLCH        ; no, jump over
3576+ 2A41 06 03                ld      B,$03           ; yes, set every channel
3577+ 2A43 1E 08                ld      E,$08           ; register volume of first channel
3578+ 2A45 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3579+ 2A47 ED 59                out     (C),E           ; set register #
3580+ 2A49 0E 41                ld      C,PSG_DAT       ; PSG data port
3581+ 2A4B ED 51                out     (C),D           ; send volume
3582+ 2A4D 1C                   inc     E               ; next register
3583+ 2A4E 10 F5                djnz    RPVOLCG         ; repeat for each channel
3584+ 2A50 C9                   ret                     ; return to caller
3585+ 2A51 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3586+ 2A53 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3587+ 2A55 ED 79                out     (C),A           ; set register
3588+ 2A57 0E 41                ld      C,PSG_DAT       ; PSG data port
3589+ 2A59 ED 51                out     (C),D           ; send volume level
3590+ 2A5B C9                   ret                     ; return to caller
3591+ 2A5C
3592+ 2A5C              ; SOUND ch,tone,dur
3593+ 2A5C              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3594+ 2A5C              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3595+ 2A5C              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3596+ 2A5C CD FD 28     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3597+ 2A5F A7                   and     A               ; is it zero?
3598+ 2A60 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3599+ 2A62 E5                   push    HL              ; store HL
3600+ 2A63 F3                   di                      ; disable INTs
3601+ 2A64 CD 87 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3602+ 2A67 FB                   ei                      ; re-enable INTs
3603+ 2A68 E1                   pop     HL              ; retrieve HL
3604+ 2A69 C9                   ret                     ; return to caller
3605+ 2A6A 32 FD 52     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3606+ 2A6D FE 04                cp      $04             ; is channel >3?
3607+ 2A6F D2 EE 2A             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3608+ 2A72 CD AD 19             call    CHKSYN          ; No, continue checking by making sure ',' follows
3609+ 2A75 2C                   defb    ','
3610+ 2A76 CD 77 20             call    GETNUM          ; Get tone frequency
3611+ 2A79 CD A4 1C             call    DEINT           ; Get integer -32768 to 32767
3612+ 2A7C ED 53 FF 52          ld      (TMPBFR2),DE    ; Store frequency
3613+ 2A80 CD AD 19             call    CHKSYN          ; Make sure ',' follows
3614+ 2A83 2C                   defb    ','
3615+ 2A84 CD 77 20             call    GETNUM          ; Get duration
3616+ 2A87 CD A4 1C             call    DEINT           ; Get integer -32768 to 32767
3617+ 2A8A ED 53 01 53          ld      (TMPBFR3),DE    ; Store duration
3618+ 2A8E                                              ; CHECK CHANNEL
3619+ 2A8E 3A FD 52             ld      A,(TMPBFR1)     ; recover channel
3620+ 2A91 FE 01                cp      $01             ; is channel <1?
3621+ 2A93 DA B9 1C             jp      C,FCERR         ; Yes - Illegal function call error
3622+ 2A96                                              ; CHECK FREQUENCY
3623+ 2A96 ED 5B FF 52          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3624+ 2A9A 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3625+ 2A9B FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3626+ 2A9D D2 B9 1C             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3627+ 2AA0                                              ; CHECK DURATION
3628+ 2AA0 ED 5B 01 53          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3629+ 2AA4 7A                   ld      A,D             ; check if it is in the range 0~16383...
3630+ 2AA5 E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3631+ 2AA7 C2 B9 1C             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3632+ 2AAA                                              ;
3633+ 2AAA                                              ; SET TONE:
3634+ 2AAA                                              ; let's start by setting up the channel
3635+ 2AAA 3A FD 52             ld      A,(TMPBFR1)     ; restore channel value
3636+ 2AAD FE 03                cp      $03             ; is it 3?
3637+ 2AAF 20 02                jr      NZ,SND1         ; no, jump over
3638+ 2AB1 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3639+ 2AB3 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3640+ 2AB4 CD 3B 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3641+ 2AB7                                              ; SET FREQUENCY
3642+ 2AB7                                              ; we simply get frequency and subtract from 4096. The result
3643+ 2AB7                                              ; is put into register pair of the corresponding freq tone channel
3644+ 2AB7 ED 5B FF 52          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3645+ 2ABB E5                   push    HL              ; store HL (it will be used by the subroutine)
3646+ 2ABC 21 00 10             ld      HL,$1000        ; load 4096 into HL
3647+ 2ABF A7                   and     A               ; reset C flag
3648+ 2AC0 ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3649+ 2AC2 3A FD 52             ld      A,(TMPBFR1)     ; restore channel value
3650+ 2AC5 3D                   dec     A               ; set A into the range 0~2
3651+ 2AC6 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3652+ 2AC7 0E 40                ld      C,PSG_REG       ; PSG register port
3653+ 2AC9 ED 79                out     (C),A           ; select first register of the pair
3654+ 2ACB 0E 41                ld      C,PSG_DAT       ; PSG data port
3655+ 2ACD ED 69                out     (C),L           ; send high byte
3656+ 2ACF 0E 40                ld      C,PSG_REG       ; PSG register support
3657+ 2AD1 3C                   inc     A               ; second register of the pair
3658+ 2AD2 ED 79                out     (C),A           ; select register
3659+ 2AD4 0E 41                ld      C,PSG_DAT       ; PSG data port
3660+ 2AD6 ED 61                out     (C),H           ; send low byte
3661+ 2AD8 ED 5B 01 53          ld      DE,(TMPBFR3)    ; recover duration
3662+ 2ADC 3A FD 52             ld      A,(TMPBFR1)     ; recover channel value
3663+ 2ADF 3D                   dec     A               ; set channel into the range 0~2
3664+ 2AE0 87                   add     A,A             ; double A to find the correct offset
3665+ 2AE1 21 31 53             ld      HL,CHASNDDTN    ; set duration into...
3666+ 2AE4 85                   add     A,L             ; ...the proper...
3667+ 2AE5 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3668+ 2AE7 24                   inc     H               ; yes, increment H)
3669+ 2AE8 6F           SNDOVR: ld      L,A             ; ...register pair...
3670+ 2AE9 73                   ld      (HL),E          ; ...and store the value
3671+ 2AEA 23                   inc     HL
3672+ 2AEB 72                   ld      (HL),D
3673+ 2AEC E1                   pop     HL              ; retrieve HL
3674+ 2AED C9                   ret                     ; Return to caller
3675+ 2AEE FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3676+ 2AF0 D2 B9 1C             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3677+ 2AF3 CD AD 19             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3678+ 2AF6 2C                   defb    ','
3679+ 2AF7 CD FD 28             call    GETINT          ; get integer 0-255 (frequency)
3680+ 2AFA FE 20                cp      $20             ; make sure it's in range 0~31
3681+ 2AFC D2 B9 1C             jp      NC,FCERR        ; no, so Illegal function call
3682+ 2AFF 32 FF 52             ld      (TMPBFR2),A     ; store freq.
3683+ 2B02 2B                   dec     HL              ; dec 'cos GETCHR INCs
3684+ 2B03 CD EE 1B             call    GETCHR          ; check that nothing follows
3685+ 2B06 C2 CB 16             jp      NZ,SNERR        ; error if no empty line
3686+ 2B09 3A FF 52             ld      A,(TMPBFR2)     ; retrieve freq.
3687+ 2B0C 5F                   ld      E,A             ; store freq into E
3688+ 2B0D 3A FD 52             ld      A,(TMPBFR1)     ; retrieve channel
3689+ 2B10 D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3690+ 2B12 FE 03                cp      $03             ; is it 3?
3691+ 2B14 20 02                jr      NZ,NOS1         ; no, jump over
3692+ 2B16 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3693+ 2B18 87           NOS1:   add     A,A
3694+ 2B19 87                   add     A,A
3695+ 2B1A 87                   add     A,A             ; let's move A 3 bits to left
3696+ 2B1B 47                   ld      B,A             ; store channel into B
3697+ 2B1C 7B                   ld      A,E             ; check if
3698+ 2B1D A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3699+ 2B1E F3                   di                      ; disable INts
3700+ 2B1F 20 0A                jr      NZ,NOS2         ; no, so jump over
3701+ 2B21 3E 07                ld      A,$07           ; mixer register
3702+ 2B23 CD D5 0C             call    SETSNDREG       ; set mixer register
3703+ 2B26 ED 78                in      A,(C)           ; load current mixer value
3704+ 2B28 B0                   or      B               ; disable noise
3705+ 2B29 18 19                jr      NOS3            ; continue over
3706+ 2B2B 78           NOS2:   ld      A,B             ; recover channel
3707+ 2B2C 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3708+ 2B2D CD 3B 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3709+ 2B30 3E 06                ld      A,$06           ; write into noise register
3710+ 2B32 CD D5 0C             call    SETSNDREG       ; set register into PSG
3711+ 2B35 7B                   ld      A,E             ; load value for noise frequency
3712+ 2B36 CD DA 0C             call    WRTSNDREG       ; write data into register $06
3713+ 2B39 FB                   ei                      ; re-enable INTs
3714+ 2B3A C9                   ret
3715+ 2B3B                      ; enable line into mixer of channel stored in A
3716+ 2B3B 47           WRTSND: ld      B,A             ; move channel into B
3717+ 2B3C 3E 07                ld      A,$07           ; mixer register
3718+ 2B3E CD D5 0C             call    SETSNDREG       ; set mixer register
3719+ 2B41 ED 78                in      A,(C)           ; load current value
3720+ 2B43 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3721+ 2B44                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3722+ 2B44                                              ; the register is still unchanged after reset) is 11111111 and
3723+ 2B44                                              ; 11111111 AND 11111110 is equal to 11111110
3724+ 2B44                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3725+ 2B44 47           NOS3:   ld      B,A             ; store new mixer value into B
3726+ 2B45 3E 07                ld      A,$07           ; mixer address
3727+ 2B47 CD D5 0C             call    SETSNDREG       ; set register
3728+ 2B4A 78                   ld      A,B             ; retrieve new mixer value from B
3729+ 2B4B CD DA 0C             call    WRTSNDREG       ; send new value for the mixer
3730+ 2B4E FB                   ei                      ; re-enable INTs
3731+ 2B4F C9                   ret                     ; return to caller
3732+ 2B50
3733+ 2B50              ; write a byte into one of the VDP registers
3734+ 2B50 CD FD 28     VREG:   call    GETINT          ; Get register number back into A
3735+ 2B53 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3736+ 2B55 D2 B9 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3737+ 2B58 32 FD 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3738+ 2B5B CD AD 19             call    CHKSYN          ; Make sure ',' follows
3739+ 2B5E 2C                   defb    ','
3740+ 2B5F CD FD 28             call    GETINT          ; get value (0-255)
3741+ 2B62 5F                   ld      E,A             ; store value into E
3742+ 2B63 3A FD 52             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3743+ 2B66 F3                   di                      ; disable INTs
3744+ 2B67 CD A7 06             call    WRITE_VREG      ; write value into VDP register
3745+ 2B6A FB                   ei                      ; re-enable INTs
3746+ 2B6B C9                   ret                     ; return to caller
3747+ 2B6C
3748+ 2B6C              ; read the VDP status register and return it into A
3749+ 2B6C CD A4 1C     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3750+ 2B6F F3                   di                      ; disable INTs
3751+ 2B70 CD B2 06             call    READ_VSTAT      ; read VDP register status
3752+ 2B73 FB                   ei                      ; re-enable INTs
3753+ 2B74 C3 70 24             jp      PASSA           ; Return integer A
3754+ 2B77
3755+ 2B77              ; read from PSG register and return it into A
3756+ 2B77 CD A4 1C     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3757+ 2B7A 7B                   ld      A,E             ; consider LSB
3758+ 2B7B FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3759+ 2B7D D2 B9 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3760+ 2B80 F3                   di                      ; disable INts
3761+ 2B81 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3762+ 2B83 ED 79                out     (C),A           ; send register to read from
3763+ 2B85 ED 78                in      A,(C)           ; read register's contents and store into A
3764+ 2B87 FB                   ei                      ; re-enable INTs
3765+ 2B88 C3 70 24             jp      PASSA           ; return A
3766+ 2B8B
3767+ 2B8B              ; read the temp key buffer and return the value of the current key being pressed
3768+ 2B8B              ; can wait for the number of 100thds of second before to return
3769+ 2B8B CD EA 24     INKEY:  call    IDTEST          ; Test for illegal direct
3770+ 2B8E CD A4 1C             call    DEINT           ; get number param (100thds of second to wait) into DE
3771+ 2B91 C5                   push    BC              ; store BC
3772+ 2B92 3A DC 52             ld      A,(TMRCNT)      ; Load current value of system timer
3773+ 2B95 47                   ld      B,A             ; move it into B
3774+ 2B96 3A DC 52     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3775+ 2B99 B8                   cp      B               ; ...to let the sniffer collect...
3776+ 2B9A 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3777+ 2B9C 7A                   ld      A,D             ; check the param
3778+ 2B9D B3                   or      E               ; if DE<>0 then...
3779+ 2B9E 20 05                jr      NZ,INKEY2       ; ...jump over...
3780+ 2BA0 3A 39 53             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3781+ 2BA3 18 2A                jr      ENDINK          ; ...return it
3782+ 2BA5 7A           INKEY2: ld      A,D             ; check if param>1023
3783+ 2BA6 FE 04                cp      $04             ; to do this we check if MSB>3
3784+ 2BA8 D2 B9 1C             jp      NC,FCERR        ; if MSB >=4 then error
3785+ 2BAB E5                   push    HL              ; store HL
3786+ 2BAC 21 09 00             ld      HL,$0009        ; check if value
3787+ 2BAF CD B8 3F             call    CMP16           ; is < 10
3788+ 2BB2 E1                   pop     HL              ; retrieve HL
3789+ 2BB3 DA B9 2B             jp      C,SRTINK        ; if value >= 10 then jump over
3790+ 2BB6 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3791+ 2BB9 3A DC 52     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3792+ 2BBC 47                   ld      B,A             ; move it into B
3793+ 2BBD 3A 39 53     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3794+ 2BC0 A7                   and     A               ; is it 0?
3795+ 2BC1 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3796+ 2BC3 3A DC 52             ld      A,(TMRCNT)      ; load the first byte of the system timer
3797+ 2BC6 B8                   cp      B               ; is it the same value?
3798+ 2BC7 28 F4                jr      Z,CHKINK        ; yes, so read again
3799+ 2BC9 47                   ld      B,A             ; store new value
3800+ 2BCA 1B                   dec     DE              ; no, decrement timer
3801+ 2BCB 7A                   ld      A,D             ; check if zero reached
3802+ 2BCC B3                   or      E               ; by ORing D and E
3803+ 2BCD 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3804+ 2BCF C1           ENDINK: pop     BC              ; restore BC
3805+ 2BD0 F5                   push    AF              ; store A
3806+ 2BD1 F3                   di                      ; disable INTs
3807+ 2BD2 AF                   xor     A               ; clear the...
3808+ 2BD3 32 39 53             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3809+ 2BD6 FB                   ei                      ; re-enable INTs
3810+ 2BD7 F1                   pop     AF              ; retrieve A
3811+ 2BD8 C3 70 24     ENDINK2:jp      PASSA           ; return A as ASCII value
3812+ 2BDB
3813+ 2BDB
3814+ 2BDB 21 02 31     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3815+ 2BDE CD D3 2E     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3816+ 2BE1 C3 ED 2B             jp      FPADD           ; Add BCDE to FPREG
3817+ 2BE4
3818+ 2BE4
3819+ 2BE4 CD D3 2E     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3820+ 2BE7 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3821+ 2BE8 C1           PSUB:   pop     BC              ; Get FP number from stack
3822+ 2BE9 D1                   pop     DE
3823+ 2BEA CD AD 2E     SUBCDE: call    INVSGN          ; Negate FPREG
3824+ 2BED 78           FPADD:  ld      A,B             ; Get FP exponent
3825+ 2BEE B7                   or      A               ; Is number zero?
3826+ 2BEF C8                   ret     Z               ; Yes - Nothing to add
3827+ 2BF0 3A 54 53             ld      A,(FPEXP)       ; Get FPREG exponent
3828+ 2BF3 B7                   or      A               ; Is this number zero?
3829+ 2BF4 CA C5 2E             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3830+ 2BF7 90                   sub     B               ; BCDE number larger?
3831+ 2BF8 D2 07 2C             jp      NC,NOSWAP       ; No - Don't swap them
3832+ 2BFB 2F                   cpl                     ; Two's complement
3833+ 2BFC 3C                   inc     A               ;  FP exponent
3834+ 2BFD EB                   ex      DE,HL
3835+ 2BFE CD B5 2E             call    STAKFP          ; Put FPREG on stack
3836+ 2C01 EB                   ex      DE,HL
3837+ 2C02 CD C5 2E             call    FPBCDE          ; Move BCDE to FPREG
3838+ 2C05 C1                   pop     BC              ; Restore number from stack
3839+ 2C06 D1                   pop     DE
3840+ 2C07 FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3841+ 2C09 D0                   ret     NC              ; Yes - First number is result
3842+ 2C0A F5                   push    AF              ; Save number of bits to scale
3843+ 2C0B CD EA 2E             call    SIGNS           ; Set MSBs & sign of result
3844+ 2C0E 67                   ld      H,A             ; Save sign of result
3845+ 2C0F F1                   pop     AF              ; Restore scaling factor
3846+ 2C10 CD B2 2C             call    SCALE           ; Scale BCDE to same exponent
3847+ 2C13 B4                   or      H               ; Result to be positive?
3848+ 2C14 21 51 53             ld      HL,FPREG        ; Point to FPREG
3849+ 2C17 F2 2D 2C             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3850+ 2C1A CD 92 2C             call    PLUCDE          ; Add FPREG to CDE
3851+ 2C1D D2 73 2C             jp      NC,RONDUP       ; No overflow - Round it up
3852+ 2C20 23                   inc     HL              ; Point to exponent
3853+ 2C21 34                   inc     (HL)            ; Increment it
3854+ 2C22 CA DA 16             jp      Z,OVERR         ; Number overflowed - Error
3855+ 2C25 2E 01                ld      L,$01           ; 1 bit to shift right
3856+ 2C27 CD C8 2C             call    SHRT1           ; Shift result right
3857+ 2C2A C3 73 2C             jp      RONDUP          ; Round it up
3858+ 2C2D
3859+ 2C2D AF           MINCDE: xor     A               ; Clear A and carry
3860+ 2C2E 90                   sub     B               ; Negate exponent
3861+ 2C2F 47                   ld      B,A             ; Re-save exponent
3862+ 2C30 7E                   ld      A,(HL)          ; Get LSB of FPREG
3863+ 2C31 9B                   sbc     A, E            ; Subtract LSB of BCDE
3864+ 2C32 5F                   ld      E,A             ; Save LSB of BCDE
3865+ 2C33 23                   inc     HL
3866+ 2C34 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3867+ 2C35 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3868+ 2C36 57                   ld      D,A             ; Save NMSB of BCDE
3869+ 2C37 23                   inc     HL
3870+ 2C38 7E                   ld      A,(HL)          ; Get MSB of FPREG
3871+ 2C39 99                   sbc     A,C             ; Subtract MSB of BCDE
3872+ 2C3A 4F                   ld      C,A             ; Save MSB of BCDE
3873+ 2C3B DC 9E 2C     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3874+ 2C3E
3875+ 2C3E 68           BNORM:  ld      L,B             ; L = Exponent
3876+ 2C3F 63                   ld      H,E             ; H = LSB
3877+ 2C40 AF                   xor     A
3878+ 2C41 47           BNRMLP: ld      B,A             ; Save bit count
3879+ 2C42 79                   ld      A,C             ; Get MSB
3880+ 2C43 B7                   or      A               ; Is it zero?
3881+ 2C44 C2 60 2C             jp      NZ,PNORM        ; No - Do it bit at a time
3882+ 2C47 4A                   ld      C,D             ; MSB = NMSB
3883+ 2C48 54                   ld      D,H             ; NMSB= LSB
3884+ 2C49 65                   ld      H,L             ; LSB = VLSB
3885+ 2C4A 6F                   ld      L,A             ; VLSB= 0
3886+ 2C4B 78                   ld      A,B             ; Get exponent
3887+ 2C4C D6 08                sub     $08             ; Count 8 bits
3888+ 2C4E FE E0                cp      -24-8           ; Was number zero?
3889+ 2C50 C2 41 2C             jp      NZ,BNRMLP       ; No - Keep normalising
3890+ 2C53 AF           RESZER: xor     A               ; Result is zero
3891+ 2C54 32 54 53     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3892+ 2C57 C9                   ret
3893+ 2C58
3894+ 2C58 05           NORMAL: dec     B               ; Count bits
3895+ 2C59 29                   add     HL,HL           ; Shift HL left
3896+ 2C5A 7A                   ld      A,D             ; Get NMSB
3897+ 2C5B 17                   rla                     ; Shift left with last bit
3898+ 2C5C 57                   ld      D,A             ; Save NMSB
3899+ 2C5D 79                   ld      A,C             ; Get MSB
3900+ 2C5E 8F                   adc     A,A             ; Shift left with last bit
3901+ 2C5F 4F                   ld      C,A             ; Save MSB
3902+ 2C60 F2 58 2C     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3903+ 2C63 78                   ld      A,B             ; Number of bits shifted
3904+ 2C64 5C                   ld      E,H             ; Save HL in EB
3905+ 2C65 45                   ld      B,L
3906+ 2C66 B7                   or      A               ; Any shifting done?
3907+ 2C67 CA 73 2C             jp      Z,RONDUP        ; No - Round it up
3908+ 2C6A 21 54 53             ld      HL,FPEXP        ; Point to exponent
3909+ 2C6D 86                   add     A,(HL)          ; Add shifted bits
3910+ 2C6E 77                   ld      (HL),A          ; Re-save exponent
3911+ 2C6F D2 53 2C             jp      NC,RESZER       ; Underflow - Result is zero
3912+ 2C72 C8                   ret     Z               ; Result is zero
3913+ 2C73 78           RONDUP: ld      A,B             ; Get VLSB of number
3914+ 2C74 21 54 53     RONDB:  ld      HL,FPEXP        ; Point to exponent
3915+ 2C77 B7                   or      A               ; Any rounding?
3916+ 2C78 FC 85 2C             call    M,FPROND        ; Yes - Round number up
3917+ 2C7B 46                   ld      B,(HL)          ; B = Exponent
3918+ 2C7C 23                   inc     HL
3919+ 2C7D 7E                   ld      A,(HL)          ; Get sign of result
3920+ 2C7E E6 80                and     %10000000       ; Only bit 7 needed
3921+ 2C80 A9                   xor     C               ; Set correct sign
3922+ 2C81 4F                   ld      C,A             ; Save correct sign in number
3923+ 2C82 C3 C5 2E             jp      FPBCDE          ; Move BCDE to FPREG
3924+ 2C85
3925+ 2C85 1C           FPROND: inc     E               ; Round LSB
3926+ 2C86 C0                   ret     NZ              ; Return if ok
3927+ 2C87 14                   inc     D               ; Round NMSB
3928+ 2C88 C0                   ret     NZ              ; Return if ok
3929+ 2C89 0C                   inc     C               ; Round MSB
3930+ 2C8A C0                   ret     NZ              ; Return if ok
3931+ 2C8B 0E 80                ld      C,$80           ; Set normal value
3932+ 2C8D 34                   inc     (HL)            ; Increment exponent
3933+ 2C8E C0                   ret     NZ              ; Return if ok
3934+ 2C8F C3 DA 16             jp      OVERR           ; Overflow error
3935+ 2C92
3936+ 2C92 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
3937+ 2C93 83                   add     A,E             ; Add LSB of BCDE
3938+ 2C94 5F                   ld      E,A             ; Save LSB of BCDE
3939+ 2C95 23                   inc     HL
3940+ 2C96 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3941+ 2C97 8A                   adc     A,D             ; Add NMSB of BCDE
3942+ 2C98 57                   ld      D,A             ; Save NMSB of BCDE
3943+ 2C99 23                   inc     HL
3944+ 2C9A 7E                   ld      A,(HL)          ; Get MSB of FPREG
3945+ 2C9B 89                   adc     A,C             ; Add MSB of BCDE
3946+ 2C9C 4F                   ld      C,A             ; Save MSB of BCDE
3947+ 2C9D C9                   ret
3948+ 2C9E
3949+ 2C9E 21 55 53     COMPL:  ld      HL,SGNRES       ; Sign of result
3950+ 2CA1 7E                   ld      A,(HL)          ; Get sign of result
3951+ 2CA2 2F                   cpl                     ; Negate it
3952+ 2CA3 77                   ld      (HL),A          ; Put it back
3953+ 2CA4 AF                   xor     A
3954+ 2CA5 6F                   ld      L,A             ; Set L to zero
3955+ 2CA6 90                   sub     B               ; Negate exponent,set carry
3956+ 2CA7 47                   ld      B,A             ; Re-save exponent
3957+ 2CA8 7D                   ld      A,L             ; Load zero
3958+ 2CA9 9B                   sbc     A,E             ; Negate LSB
3959+ 2CAA 5F                   ld      E,A             ; Re-save LSB
3960+ 2CAB 7D                   ld      A,L             ; Load zero
3961+ 2CAC 9A                   sbc     A,D             ; Negate NMSB
3962+ 2CAD 57                   ld      D,A             ; Re-save NMSB
3963+ 2CAE 7D                   ld      A,L             ; Load zero
3964+ 2CAF 99                   sbc     A,C             ; Negate MSB
3965+ 2CB0 4F                   ld      C,A             ; Re-save MSB
3966+ 2CB1 C9                   ret
3967+ 2CB2
3968+ 2CB2 06 00        SCALE:  ld      B,$00           ; Clear underflow
3969+ 2CB4 D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
3970+ 2CB6 DA C1 2C             jp      C,SHRITE        ; No - Shift right A bits
3971+ 2CB9 43                   ld      B,E             ; <- Shift
3972+ 2CBA 5A                   ld      E,D             ; <- right
3973+ 2CBB 51                   ld      D,C             ; <- eight
3974+ 2CBC 0E 00                ld      C,$00           ; <- bits
3975+ 2CBE C3 B4 2C             jp      SCALLP          ; More bits to shift
3976+ 2CC1
3977+ 2CC1 C6 09        SHRITE: add     A,8+1           ; Adjust count
3978+ 2CC3 6F                   ld      L,A             ; Save bits to shift
3979+ 2CC4 AF           SHRLP:  xor     A               ; Flag for all done
3980+ 2CC5 2D                   dec     L               ; All shifting done?
3981+ 2CC6 C8                   ret     Z               ; Yes - Return
3982+ 2CC7 79                   ld      A,C             ; Get MSB
3983+ 2CC8 1F           SHRT1:  rra                     ; Shift it right
3984+ 2CC9 4F                   ld      C,A             ; Re-save
3985+ 2CCA 7A                   ld      A,D             ; Get NMSB
3986+ 2CCB 1F                   rra                     ; Shift right with last bit
3987+ 2CCC 57                   ld      D,A             ; Re-save it
3988+ 2CCD 7B                   ld      A,E             ; Get LSB
3989+ 2CCE 1F                   rra                     ; Shift right with last bit
3990+ 2CCF 5F                   ld      E,A             ; Re-save it
3991+ 2CD0 78                   ld      A,B             ; Get underflow
3992+ 2CD1 1F                   rra                     ; Shift right with last bit
3993+ 2CD2 47                   ld      B,A             ; Re-save underflow
3994+ 2CD3 C3 C4 2C             jp      SHRLP           ; More bits to do
3995+ 2CD6
3996+ 2CD6 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
3997+ 2CDA
3998+ 2CDA 03           LOGTAB: defb    $03             ; Table used by LOG
3999+ 2CDB AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4000+ 2CDF F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4001+ 2CE3 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4002+ 2CE7
4003+ 2CE7 CD 84 2E     LOG:    call    TSTSGN          ; Test sign of value
4004+ 2CEA B7                   or      A
4005+ 2CEB EA B9 1C             jp      PE,FCERR        ; ?FC Error if <= zero
4006+ 2CEE 21 54 53             ld      HL,FPEXP        ; Point to exponent
4007+ 2CF1 7E                   ld      A,(HL)          ; Get exponent
4008+ 2CF2 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4009+ 2CF5 11 F3 04             ld      DE,$04F3
4010+ 2CF8 90                   sub     B               ; Scale value to be < 1
4011+ 2CF9 F5                   push    AF              ; Save scale factor
4012+ 2CFA 70                   ld      (HL),B          ; Save new exponent
4013+ 2CFB D5                   push    DE              ; Save SQR(1/2)
4014+ 2CFC C5                   push    BC
4015+ 2CFD CD ED 2B             call    FPADD           ; Add SQR(1/2) to value
4016+ 2D00 C1                   pop     BC              ; Restore SQR(1/2)
4017+ 2D01 D1                   pop     DE
4018+ 2D02 04                   inc     B               ; Make it SQR(2)
4019+ 2D03 CD DA 2D             call    DVBCDE          ; Divide by SQR(2)
4020+ 2D06 21 D6 2C             ld      HL,UNITY        ; Point to 1.
4021+ 2D09 CD E4 2B             call    SUBPHL          ; Subtract FPREG from 1
4022+ 2D0C 21 DA 2C             ld      HL,LOGTAB       ; Coefficient table
4023+ 2D0F CD CC 31             call    SUMSER          ; Evaluate sum of series
4024+ 2D12 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4025+ 2D15 11 00 00             ld      DE,$0000
4026+ 2D18 CD ED 2B             call    FPADD           ; Subtract 0.5 from FPREG
4027+ 2D1B F1                   pop     AF              ; Restore scale factor
4028+ 2D1C CD FF 2F             call    RSCALE          ; Re-scale number
4029+ 2D1F 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4030+ 2D22 11 18 72             ld      DE,$7218
4031+ 2D25 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4032+ 2D26
4033+ 2D26 C1           MULT:   pop     BC              ; Get number from stack
4034+ 2D27 D1                   pop     DE
4035+ 2D28 CD 84 2E     FPMULT: call    TSTSGN          ; Test sign of FPREG
4036+ 2D2B C8                   ret     Z               ; Return zero if zero
4037+ 2D2C 2E 00                ld      L,$00           ; Flag add exponents
4038+ 2D2E CD 42 2E             call    ADDEXP          ; Add exponents
4039+ 2D31 79                   ld      A,C             ; Get MSB of multiplier
4040+ 2D32 32 63 53             ld      (MULVAL),A      ; Save MSB of multiplier
4041+ 2D35 EB                   ex      DE,HL
4042+ 2D36 22 64 53             ld      (MULVAL+1),HL   ; Save rest of multiplier
4043+ 2D39 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4044+ 2D3C 50                   ld      D,B
4045+ 2D3D 58                   ld      E,B
4046+ 2D3E 21 3E 2C             ld      HL,BNORM        ; Address of normalise
4047+ 2D41 E5                   push    HL              ; Save for return
4048+ 2D42 21 4A 2D             ld      HL,MULT8        ; Address of 8 bit multiply
4049+ 2D45 E5                   push    HL              ; Save for NMSB,MSB
4050+ 2D46 E5                   push    HL              ;
4051+ 2D47 21 51 53             ld      HL,FPREG        ; Point to number
4052+ 2D4A 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4053+ 2D4B 23                   inc     HL              ; Point to NMSB
4054+ 2D4C B7                   or      A               ; Test LSB
4055+ 2D4D CA 76 2D             jp      Z,BYTSFT        ; Zero - shift to next byte
4056+ 2D50 E5                   push    HL              ; Save address of number
4057+ 2D51 2E 08                ld      L,$08           ; 8 bits to multiply by
4058+ 2D53 1F           MUL8LP: rra                     ; Shift LSB right
4059+ 2D54 67                   ld      H,A             ; Save LSB
4060+ 2D55 79                   ld      A,C             ; Get MSB
4061+ 2D56 D2 64 2D             jp      NC,NOMADD       ; Bit was zero - Don't add
4062+ 2D59 E5                   push    HL              ; Save LSB and count
4063+ 2D5A 2A 64 53             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4064+ 2D5D 19                   add     HL,DE           ; Add NMSB and LSB
4065+ 2D5E EB                   ex      DE,HL           ; Leave sum in DE
4066+ 2D5F E1                   pop     HL              ; Restore MSB and count
4067+ 2D60 3A 63 53             ld      A,(MULVAL)      ; Get MSB of multiplier
4068+ 2D63 89                   adc     A,C             ; Add MSB
4069+ 2D64 1F           NOMADD: rra                     ; Shift MSB right
4070+ 2D65 4F                   ld      C,A             ; Re-save MSB
4071+ 2D66 7A                   ld      A,D             ; Get NMSB
4072+ 2D67 1F                   rra                     ; Shift NMSB right
4073+ 2D68 57                   ld      D,A             ; Re-save NMSB
4074+ 2D69 7B                   ld      A,E             ; Get LSB
4075+ 2D6A 1F                   rra                     ; Shift LSB right
4076+ 2D6B 5F                   ld      E,A             ; Re-save LSB
4077+ 2D6C 78                   ld      A,B             ; Get VLSB
4078+ 2D6D 1F                   rra                     ; Shift VLSB right
4079+ 2D6E 47                   ld      B,A             ; Re-save VLSB
4080+ 2D6F 2D                   dec     L               ; Count bits multiplied
4081+ 2D70 7C                   ld      A,H             ; Get LSB of multiplier
4082+ 2D71 C2 53 2D             jp      NZ,MUL8LP       ; More - Do it
4083+ 2D74 E1           POPHRT: pop     HL              ; Restore address of number
4084+ 2D75 C9                   ret
4085+ 2D76
4086+ 2D76 43           BYTSFT: ld      B,E             ; Shift partial product left
4087+ 2D77 5A                   ld      E,D
4088+ 2D78 51                   ld      D,C
4089+ 2D79 4F                   ld      C,A
4090+ 2D7A C9                   ret
4091+ 2D7B
4092+ 2D7B
4093+ 2D7B              ; WORKING ââ
4094+ 2D7B C1           DINT:   pop     BC              ; Get number from stack
4095+ 2D7C D1                   pop     DE
4096+ 2D7D CD DA 2D             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4097+ 2D80 C3 57 2F             jp      INT             ; return INT(FPREG)
4098+ 2D83
4099+ 2D83
4100+ 2D83              ; A MODULO B - return remainder of the integer division A/B where:
4101+ 2D83              ; A is in stack; B is in FPREG
4102+ 2D83              ; math is:
4103+ 2D83              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4104+ 2D83 CD 57 2F     MOD:    call    INT             ; B=INT(B)
4105+ 2D86 CD D0 2E             call    BCDEFP          ; copy B (from FPREG) into BCDE
4106+ 2D89 ED 53 01 53          ld      (TMPBFR3),DE    ; store B into...
4107+ 2D8D ED 43 03 53          ld      (TMPBFR4),BC    ; ...a temp buffer
4108+ 2D91 C1                   pop     BC              ; recover A...
4109+ 2D92 D1                   pop     DE              ; ...from stack
4110+ 2D93 CD C5 2E             call    FPBCDE          ; store A into FPREG
4111+ 2D96 CD 57 2F             call    INT             ; get integer part: A=INT(A)
4112+ 2D99 CD D0 2E             call    BCDEFP          ; copy A (from FPREG) into BCDE
4113+ 2D9C ED 53 FD 52          ld      (TMPBFR1),DE    ; store A into...
4114+ 2DA0 ED 43 FF 52          ld      (TMPBFR2),BC    ; ...a temp buffer
4115+ 2DA4                                              ; begin calculation
4116+ 2DA4 2A 01 53             ld      HL,(TMPBFR3)    ; move B...
4117+ 2DA7 22 51 53             ld      (FPREG),HL      ; ...from...
4118+ 2DAA 2A 03 53             ld      HL,(TMPBFR4)    ; ...temp buffer...
4119+ 2DAD 22 53 53             ld      (FPREG+2),HL    ; ...into FPREG
4120+ 2DB0 CD DA 2D             call    DVBCDE          ; compute A/B and store into FPREG
4121+ 2DB3 CD 57 2F             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4122+ 2DB6 ED 5B 01 53          ld      DE,(TMPBFR3)    ; load B...
4123+ 2DBA ED 4B 03 53          ld      BC,(TMPBFR4)    ; ...into BCDE
4124+ 2DBE CD 28 2D             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4125+ 2DC1 ED 5B FD 52          ld      DE,(TMPBFR1)    ; retrieve A from...
4126+ 2DC5 ED 4B FF 52          ld      BC,(TMPBFR2)    ; ...temp buffer
4127+ 2DC9 C3 EA 2B             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4128+ 2DCC
4129+ 2DCC
4130+ 2DCC CD B5 2E     DIV10:  call    STAKFP          ; Save FPREG on stack
4131+ 2DCF 01 20 84             ld      BC,$8420        ; BCDE = 10.
4132+ 2DD2 11 00 00             ld      DE,$0000
4133+ 2DD5 CD C5 2E             call    FPBCDE          ; Move 10 to FPREG
4134+ 2DD8
4135+ 2DD8 C1           DIV:    pop     BC              ; Get number from stack
4136+ 2DD9 D1                   pop     DE
4137+ 2DDA CD 84 2E     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4138+ 2DDD CA CE 16             jp      Z,DZERR         ; Error if division by zero
4139+ 2DE0 2E FF                ld      L,-1            ; Flag subtract exponents
4140+ 2DE2 CD 42 2E             call    ADDEXP          ; Subtract exponents
4141+ 2DE5 34                   inc     (HL)            ; Add 2 to exponent to adjust
4142+ 2DE6 34                   inc     (HL)
4143+ 2DE7 2B                   dec     HL              ; Point to MSB
4144+ 2DE8 7E                   ld      A,(HL)          ; Get MSB of dividend
4145+ 2DE9 32 92 51             ld      (DIV3),A        ; Save for subtraction
4146+ 2DEC 2B                   dec     HL
4147+ 2DED 7E                   ld      A,(HL)          ; Get NMSB of dividend
4148+ 2DEE 32 8E 51             ld      (DIV2),A        ; Save for subtraction
4149+ 2DF1 2B                   dec     HL
4150+ 2DF2 7E                   ld      A,(HL)          ; Get MSB of dividend
4151+ 2DF3 32 8A 51             ld      (DIV1),A        ; Save for subtraction
4152+ 2DF6 41                   ld      B,C             ; Get MSB
4153+ 2DF7 EB                   ex      DE,HL           ; NMSB,LSB to HL
4154+ 2DF8 AF                   xor     A
4155+ 2DF9 4F                   ld      C,A             ; Clear MSB of quotient
4156+ 2DFA 57                   ld      D,A             ; Clear NMSB of quotient
4157+ 2DFB 5F                   ld      E,A             ; Clear LSB of quotient
4158+ 2DFC 32 95 51             ld      (DIV4),A        ; Clear overflow count
4159+ 2DFF E5           DIVLP:  push    HL              ; Save divisor
4160+ 2E00 C5                   push    BC
4161+ 2E01 7D                   ld      A,L             ; Get LSB of number
4162+ 2E02 CD 89 51             call    DIVSUP          ; Subt' divisor from dividend
4163+ 2E05 DE 00                sbc     A,$00           ; Count for overflows
4164+ 2E07 3F                   ccf
4165+ 2E08 D2 12 2E             jp      NC,RESDIV       ; Restore divisor if borrow
4166+ 2E0B 32 95 51             ld      (DIV4),A        ; Re-save overflow count
4167+ 2E0E F1                   pop     AF              ; Scrap divisor
4168+ 2E0F F1                   pop     AF
4169+ 2E10 37                   scf                     ; Set carry to
4170+ 2E11 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4171+ 2E12
4172+ 2E12 C1           RESDIV: pop     BC              ; Restore divisor
4173+ 2E13 E1                   pop     HL
4174+ 2E14 79                   ld      A,C             ; Get MSB of quotient
4175+ 2E15 3C                   inc     A
4176+ 2E16 3D                   dec     A
4177+ 2E17 1F                   rra                     ; Bit 0 to bit 7
4178+ 2E18 FA 74 2C             jp      M,RONDB         ; Done - Normalise result
4179+ 2E1B 17                   rla                     ; Restore carry
4180+ 2E1C 7B                   ld      A,E             ; Get LSB of quotient
4181+ 2E1D 17                   rla                     ; Double it
4182+ 2E1E 5F                   ld      E,A             ; Put it back
4183+ 2E1F 7A                   ld      A,D             ; Get NMSB of quotient
4184+ 2E20 17                   rla                     ; Double it
4185+ 2E21 57                   ld      D,A             ; Put it back
4186+ 2E22 79                   ld      A,C             ; Get MSB of quotient
4187+ 2E23 17                   rla                     ; Double it
4188+ 2E24 4F                   ld      C,A             ; Put it back
4189+ 2E25 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4190+ 2E26 78                   ld      A,B             ; Get MSB of divisor
4191+ 2E27 17                   rla                     ; Double it
4192+ 2E28 47                   ld      B,A             ; Put it back
4193+ 2E29 3A 95 51             ld      A,(DIV4)        ; Get VLSB of quotient
4194+ 2E2C 17                   rla                     ; Double it
4195+ 2E2D 32 95 51             ld      (DIV4),A        ; Put it back
4196+ 2E30 79                   ld      A,C             ; Get MSB of quotient
4197+ 2E31 B2                   or      D               ; Merge NMSB
4198+ 2E32 B3                   or      E               ; Merge LSB
4199+ 2E33 C2 FF 2D             jp      NZ,DIVLP        ; Not done - Keep dividing
4200+ 2E36 E5                   push    HL              ; Save divisor
4201+ 2E37 21 54 53             ld      HL,FPEXP        ; Point to exponent
4202+ 2E3A 35                   dec     (HL)            ; Divide by 2
4203+ 2E3B E1                   pop     HL              ; Restore divisor
4204+ 2E3C C2 FF 2D             jp      NZ,DIVLP        ; Ok - Keep going
4205+ 2E3F C3 DA 16             jp      OVERR           ; Overflow error
4206+ 2E42
4207+ 2E42
4208+ 2E42 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4209+ 2E43 B7                   or      A               ; Test it
4210+ 2E44 CA 66 2E             jp      Z,OVTST3        ; Zero - Result zero
4211+ 2E47 7D                   ld      A,L             ; Get add/subtract flag
4212+ 2E48 21 54 53             ld      HL,FPEXP        ; Point to exponent
4213+ 2E4B AE                   xor     (HL)            ; Add or subtract it
4214+ 2E4C 80                   add     A,B             ; Add the other exponent
4215+ 2E4D 47                   ld      B,A             ; Save new exponent
4216+ 2E4E 1F                   rra                     ; Test exponent for overflow
4217+ 2E4F A8                   xor     B
4218+ 2E50 78                   ld      A,B             ; Get exponent
4219+ 2E51 F2 65 2E             jp      P,OVTST2        ; Positive - Test for overflow
4220+ 2E54 C6 80                add     A,$80           ; Add excess 128
4221+ 2E56 77                   ld      (HL),A          ; Save new exponent
4222+ 2E57 CA 74 2D             jp      Z,POPHRT        ; Zero - Result zero
4223+ 2E5A CD EA 2E             call    SIGNS           ; Set MSBs and sign of result
4224+ 2E5D 77                   ld      (HL),A          ; Save new exponent
4225+ 2E5E 2B                   dec     HL              ; Point to MSB
4226+ 2E5F C9                   ret
4227+ 2E60
4228+ 2E60 CD 84 2E     OVTST1: call    TSTSGN          ; Test sign of FPREG
4229+ 2E63 2F                   cpl                     ; Invert sign
4230+ 2E64 E1                   pop     HL              ; Clean up stack
4231+ 2E65 B7           OVTST2: or      A               ; Test if new exponent zero
4232+ 2E66 E1           OVTST3: pop     HL              ; Clear off return address
4233+ 2E67 F2 53 2C             jp      P,RESZER        ; Result zero
4234+ 2E6A C3 DA 16             jp      OVERR           ; Overflow error
4235+ 2E6D
4236+ 2E6D CD D0 2E     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4237+ 2E70 78                   ld      A,B             ; Get exponent
4238+ 2E71 B7                   or      A               ; Is it zero?
4239+ 2E72 C8                   ret     Z               ; Yes - Result is zero
4240+ 2E73 C6 02                add     A,$02           ; Multiply by 4
4241+ 2E75 DA DA 16             jp      C,OVERR         ; Overflow - ?OV Error
4242+ 2E78 47                   ld      B,A             ; Re-save exponent
4243+ 2E79 CD ED 2B             call    FPADD           ; Add BCDE to FPREG (Times 5)
4244+ 2E7C 21 54 53             ld      HL,FPEXP        ; Point to exponent
4245+ 2E7F 34                   inc     (HL)            ; Double number (Times 10)
4246+ 2E80 C0                   ret     NZ              ; Ok - Return
4247+ 2E81 C3 DA 16             jp      OVERR           ; Overflow error
4248+ 2E84
4249+ 2E84 3A 54 53     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4250+ 2E87 B7                   or      A
4251+ 2E88 C8                   ret     Z               ; RETurn if number is zero
4252+ 2E89 3A 53 53             ld      A,(FPREG+2)     ; Get MSB of FPREG
4253+ 2E8C FE                   defb    0FEH            ; Test sign
4254+ 2E8D 2F           RETREL: cpl                     ; Invert sign
4255+ 2E8E 17                   rla                     ; Sign bit to carry
4256+ 2E8F 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4257+ 2E90 C0                   ret     NZ              ; Return -1 if negative
4258+ 2E91 3C                   inc     A               ; Bump to +1
4259+ 2E92 C9                   ret                     ; Positive - Return +1
4260+ 2E93
4261+ 2E93 CD 84 2E     SGN:    call    TSTSGN          ; Test sign of FPREG
4262+ 2E96 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4263+ 2E98 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4264+ 2E9B 21 54 53     RETINT: ld      HL,FPEXP        ; Point to exponent
4265+ 2E9E 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4266+ 2E9F 70                   ld      (HL),B          ; Save exponent
4267+ 2EA0 06 00                ld      B,0             ; CDE = integer to normalise
4268+ 2EA2 23                   inc     HL              ; Point to sign of result
4269+ 2EA3 36 80                ld      (HL),$80        ; Set sign of result
4270+ 2EA5 17                   rla                     ; Carry = sign of integer
4271+ 2EA6 C3 3B 2C             jp      CONPOS          ; Set sign of result
4272+ 2EA9
4273+ 2EA9 CD 84 2E     ABS_:   call    TSTSGN          ; Test sign of FPREG
4274+ 2EAC F0                   ret     P               ; Return if positive
4275+ 2EAD 21 53 53     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4276+ 2EB0 7E                   ld      A,(HL)          ; Get sign of mantissa
4277+ 2EB1 EE 80                xor     $80             ; Invert sign of mantissa
4278+ 2EB3 77                   ld      (HL),A          ; Re-save sign of mantissa
4279+ 2EB4 C9                   ret
4280+ 2EB5
4281+ 2EB5 EB           STAKFP: ex      DE,HL           ; Save code string address
4282+ 2EB6 2A 51 53             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4283+ 2EB9 E3                   ex      (SP),HL         ; Stack them,get return
4284+ 2EBA E5                   push    HL              ; Re-save return
4285+ 2EBB 2A 53 53             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4286+ 2EBE E3                   ex      (SP),HL         ; Stack them,get return
4287+ 2EBF E5                   push    HL              ; Re-save return
4288+ 2EC0 EB                   ex      DE,HL           ; Restore code string address
4289+ 2EC1 C9                   ret
4290+ 2EC2
4291+ 2EC2              ; store F.P. number from BCDE into (FPREG)
4292+ 2EC2 CD D3 2E     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4293+ 2EC5 EB           FPBCDE: ex      DE,HL           ; Save code string address
4294+ 2EC6 22 51 53             ld      (FPREG),HL      ; Save LSB,NLSB of number
4295+ 2EC9 60                   ld      H,B             ; Exponent of number
4296+ 2ECA 69                   ld      L,C             ; MSB of number
4297+ 2ECB 22 53 53             ld      (FPREG+2),HL    ; Save MSB and exponent
4298+ 2ECE EB                   ex      DE,HL           ; Restore code string address
4299+ 2ECF C9                   ret
4300+ 2ED0
4301+ 2ED0              ; load F.P. number from (FPREG) into BCDE
4302+ 2ED0 21 51 53     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4303+ 2ED3 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4304+ 2ED4 23                   inc     HL
4305+ 2ED5 56                   ld      D,(HL)          ; Get NMSB of number
4306+ 2ED6 23                   inc     HL
4307+ 2ED7 4E                   ld      C,(HL)          ; Get MSB of number
4308+ 2ED8 23                   inc     HL
4309+ 2ED9 46                   ld      B,(HL)          ; Get exponent of number
4310+ 2EDA 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4311+ 2EDB C9                   ret
4312+ 2EDC
4313+ 2EDC              ; move floating point from (FPREG) into (HL)
4314+ 2EDC 11 51 53     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4315+ 2EDF 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4316+ 2EE1 1A           DETHLB: ld      A,(DE)          ; Get source
4317+ 2EE2 77                   ld      (HL),A          ; Save destination
4318+ 2EE3 13                   inc     DE              ; Next source
4319+ 2EE4 23                   inc     HL              ; Next destination
4320+ 2EE5 05                   dec     B               ; Count bytes
4321+ 2EE6 C2 E1 2E             jp      NZ,DETHLB       ; Loop if more
4322+ 2EE9 C9                   ret
4323+ 2EEA
4324+ 2EEA 21 53 53     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4325+ 2EED 7E                   ld      A,(HL)          ; Get MSB
4326+ 2EEE 07                   rlca                    ; Old sign to carry
4327+ 2EEF 37                   scf                     ; Set MSBit
4328+ 2EF0 1F                   rra                     ; Set MSBit of MSB
4329+ 2EF1 77                   ld      (HL),A          ; Save new MSB
4330+ 2EF2 3F                   ccf                     ; Complement sign
4331+ 2EF3 1F                   rra                     ; Old sign to carry
4332+ 2EF4 23                   inc     HL
4333+ 2EF5 23                   inc     HL
4334+ 2EF6 77                   ld      (HL),A          ; Set sign of result
4335+ 2EF7 79                   ld      A,C             ; Get MSB
4336+ 2EF8 07                   rlca                    ; Old sign to carry
4337+ 2EF9 37                   scf                     ; Set MSBit
4338+ 2EFA 1F                   rra                     ; Set MSBit of MSB
4339+ 2EFB 4F                   ld      C,A             ; Save MSB
4340+ 2EFC 1F                   rra
4341+ 2EFD AE                   xor     (HL)            ; New sign of result
4342+ 2EFE C9                   ret
4343+ 2EFF
4344+ 2EFF 78           CMPNUM: ld      A,B             ; Get exponent of number
4345+ 2F00 B7                   or      A
4346+ 2F01 CA 84 2E             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4347+ 2F04 21 8D 2E             ld      HL,RETREL       ; Return relation routine
4348+ 2F07 E5                   push    HL              ; Save for return
4349+ 2F08 CD 84 2E             call    TSTSGN          ; Test sign of FPREG
4350+ 2F0B 79                   ld      A,C             ; Get MSB of number
4351+ 2F0C C8                   ret     Z               ; FPREG zero - Number's MSB
4352+ 2F0D 21 53 53             ld      HL,FPREG+2      ; MSB of FPREG
4353+ 2F10 AE                   xor     (HL)            ; Combine signs
4354+ 2F11 79                   ld      A,C             ; Get MSB of number
4355+ 2F12 F8                   ret     M               ; Exit if signs different
4356+ 2F13 CD 19 2F             call    CMPFP           ; Compare FP numbers
4357+ 2F16 1F                   rra                     ; Get carry to sign
4358+ 2F17 A9                   xor     C               ; Combine with MSB of number
4359+ 2F18 C9                   ret
4360+ 2F19
4361+ 2F19 23           CMPFP:  inc     HL              ; Point to exponent
4362+ 2F1A 78                   ld      A,B             ; Get exponent
4363+ 2F1B BE                   cp      (HL)            ; Compare exponents
4364+ 2F1C C0                   ret     NZ              ; Different
4365+ 2F1D 2B                   dec     HL              ; Point to MBS
4366+ 2F1E 79                   ld      A,C             ; Get MSB
4367+ 2F1F BE                   cp      (HL)            ; Compare MSBs
4368+ 2F20 C0                   ret     NZ              ; Different
4369+ 2F21 2B                   dec     HL              ; Point to NMSB
4370+ 2F22 7A                   ld      A,D             ; Get NMSB
4371+ 2F23 BE                   cp      (HL)            ; Compare NMSBs
4372+ 2F24 C0                   ret     NZ              ; Different
4373+ 2F25 2B                   dec     HL              ; Point to LSB
4374+ 2F26 7B                   ld      A,E             ; Get LSB
4375+ 2F27 96                   sub     (HL)            ; Compare LSBs
4376+ 2F28 C0                   ret     NZ              ; Different
4377+ 2F29 E1                   pop     HL              ; Drop RETurn
4378+ 2F2A E1                   pop     HL              ; Drop another RETurn
4379+ 2F2B C9                   ret
4380+ 2F2C
4381+ 2F2C 47           FPINT:  ld      B,A             ; <- Move
4382+ 2F2D 4F                   ld      C,A             ; <- exponent
4383+ 2F2E 57                   ld      D,A             ; <- to all
4384+ 2F2F 5F                   ld      E,A             ; <- bits
4385+ 2F30 B7                   or      A               ; Test exponent
4386+ 2F31 C8                   ret     Z               ; Zero - Return zero
4387+ 2F32 E5                   push    HL              ; Save pointer to number
4388+ 2F33 CD D0 2E             call    BCDEFP          ; Move FPREG to BCDE
4389+ 2F36 CD EA 2E             call    SIGNS           ; Set MSBs & sign of result
4390+ 2F39 AE                   xor     (HL)            ; Combine with sign of FPREG
4391+ 2F3A 67                   ld      H,A             ; Save combined signs
4392+ 2F3B FC 50 2F             call    M,DCBCDE        ; Negative - Decrement BCDE
4393+ 2F3E 3E 98                ld      A,$80+24        ; 24 bits
4394+ 2F40 90                   sub     B               ; Bits to shift
4395+ 2F41 CD B2 2C             call    SCALE           ; Shift BCDE
4396+ 2F44 7C                   ld      A,H             ; Get combined sign
4397+ 2F45 17                   rla                     ; Sign to carry
4398+ 2F46 DC 85 2C             call    C,FPROND        ; Negative - Round number up
4399+ 2F49 06 00                ld      B,$00           ; Zero exponent
4400+ 2F4B DC 9E 2C             call    C,COMPL         ; If negative make positive
4401+ 2F4E E1                   pop     HL              ; Restore pointer to number
4402+ 2F4F C9                   ret
4403+ 2F50
4404+ 2F50 1B           DCBCDE: dec     DE              ; Decrement BCDE
4405+ 2F51 7A                   ld      A,D             ; Test LSBs
4406+ 2F52 A3                   and     E
4407+ 2F53 3C                   inc     A
4408+ 2F54 C0                   ret     NZ              ; Exit if LSBs not FFFF
4409+ 2F55 0B                   dec     BC              ; Decrement MSBs
4410+ 2F56 C9                   ret
4411+ 2F57
4412+ 2F57 21 54 53     INT:    ld      HL,FPEXP        ; Point to exponent
4413+ 2F5A 7E                   ld      A,(HL)          ; Get exponent
4414+ 2F5B FE 98                cp      $80+24          ; Integer accuracy only?
4415+ 2F5D 3A 51 53             ld      A,(FPREG)       ; Get LSB
4416+ 2F60 D0                   ret     NC              ; Yes - Already integer
4417+ 2F61 7E                   ld      A,(HL)          ; Get exponent
4418+ 2F62 CD 2C 2F             call    FPINT           ; F.P to integer
4419+ 2F65 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4420+ 2F67 7B                   ld      A,E             ; Get LSB of number
4421+ 2F68 F5                   push    AF              ; Save LSB
4422+ 2F69 79                   ld      A,C             ; Get MSB of number
4423+ 2F6A 17                   rla                     ; Sign to carry
4424+ 2F6B CD 3B 2C             call    CONPOS          ; Set sign of result
4425+ 2F6E F1                   pop     AF              ; Restore LSB of number
4426+ 2F6F C9                   ret
4427+ 2F70
4428+ 2F70 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4429+ 2F73 78                   ld      A,B             ; Test multiplier
4430+ 2F74 B1                   or      C
4431+ 2F75 C8                   ret     Z               ; Return zero if zero
4432+ 2F76 3E 10                ld      A,$10           ; 16 bits
4433+ 2F78 29           MLDBLP: add     HL,HL           ; Shift P.P left
4434+ 2F79 DA 9E 23             jp      C,BSERR         ; ?BS Error if overflow
4435+ 2F7C EB                   ex      DE,HL
4436+ 2F7D 29                   add     HL,HL           ; Shift multiplier left
4437+ 2F7E EB                   ex      DE,HL
4438+ 2F7F D2 86 2F             jp      NC,NOMLAD       ; Bit was zero - No add
4439+ 2F82 09                   add     HL,BC           ; Add multiplicand
4440+ 2F83 DA 9E 23             jp      C,BSERR         ; ?BS Error if overflow
4441+ 2F86 3D           NOMLAD: dec     A               ; Count bits
4442+ 2F87 C2 78 2F             jp      NZ,MLDBLP       ; More
4443+ 2F8A C9                   ret
4444+ 2F8B
4445+ 2F8B FE 2D        ASCTFP: cp      '-'             ; Negative?
4446+ 2F8D F5                   push    AF              ; Save it and flags
4447+ 2F8E CA 97 2F             jp      Z,CNVNUM        ; Yes - Convert number
4448+ 2F91 FE 2B                cp      '+'             ; Positive?
4449+ 2F93 CA 97 2F             jp      Z,CNVNUM        ; Yes - Convert number
4450+ 2F96 2B                   dec     HL              ; dec 'cos GETCHR INCs
4451+ 2F97 CD 53 2C     CNVNUM: call    RESZER          ; Set result to zero
4452+ 2F9A 47                   ld      B,A             ; Digits after point counter
4453+ 2F9B 57                   ld      D,A             ; Sign of exponent
4454+ 2F9C 5F                   ld      E,A             ; Exponent of ten
4455+ 2F9D 2F                   cpl
4456+ 2F9E 4F                   ld      C,A             ; Before or after point flag
4457+ 2F9F CD EE 1B     MANLP:  call    GETCHR          ; Get next character
4458+ 2FA2 DA E8 2F             jp      C,ADDIG         ; Digit - Add to number
4459+ 2FA5 FE 2E                cp      '.'
4460+ 2FA7 CA C3 2F             jp      Z,DPOINT        ; '.' - Flag point
4461+ 2FAA FE 45                cp      'E'
4462+ 2FAC C2 C7 2F             jp      NZ,CONEXP       ; Not 'E' - Scale number
4463+ 2FAF CD EE 1B             call    GETCHR          ; Get next character
4464+ 2FB2 CD BA 21             call    SGNEXP          ; Get sign of exponent
4465+ 2FB5 CD EE 1B     EXPLP:  call    GETCHR          ; Get next character
4466+ 2FB8 DA 0A 30             jp      C,EDIGIT        ; Digit - Add to exponent
4467+ 2FBB 14                   inc     D               ; Is sign negative?
4468+ 2FBC C2 C7 2F             jp      NZ,CONEXP       ; No - Scale number
4469+ 2FBF AF                   xor     A
4470+ 2FC0 93                   sub     E               ; Negate exponent
4471+ 2FC1 5F                   ld      E,A             ; And re-save it
4472+ 2FC2 0C                   inc     C               ; Flag end of number
4473+ 2FC3 0C           DPOINT: inc     C               ; Flag point passed
4474+ 2FC4 CA 9F 2F             jp      Z,MANLP         ; Zero - Get another digit
4475+ 2FC7 E5           CONEXP: push    HL              ; Save code string address
4476+ 2FC8 7B                   ld      A,E             ; Get exponent
4477+ 2FC9 90                   sub     B               ; Subtract digits after point
4478+ 2FCA F4 E0 2F     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4479+ 2FCD F2 D6 2F             jp      P,ENDCON        ; Positive - All done
4480+ 2FD0 F5                   push    AF              ; Save number of times to /10
4481+ 2FD1 CD CC 2D             call    DIV10           ; Divide by 10
4482+ 2FD4 F1                   pop     AF              ; Restore count
4483+ 2FD5 3C                   inc     A               ; Count divides
4484+ 2FD6
4485+ 2FD6 C2 CA 2F     ENDCON: jp      NZ,SCALMI       ; More to do
4486+ 2FD9 D1                   pop     DE              ; Restore code string address
4487+ 2FDA F1                   pop     AF              ; Restore sign of number
4488+ 2FDB CC AD 2E             call    Z,INVSGN        ; Negative - Negate number
4489+ 2FDE EB                   ex      DE,HL           ; Code string address to HL
4490+ 2FDF C9                   ret
4491+ 2FE0
4492+ 2FE0 C8           SCALPL: ret     Z               ; Exit if no scaling needed
4493+ 2FE1 F5           MULTEN: push    AF              ; Save count
4494+ 2FE2 CD 6D 2E             call    MLSP10          ; Multiply number by 10
4495+ 2FE5 F1                   pop     AF              ; Restore count
4496+ 2FE6 3D                   dec     A               ; Count multiplies
4497+ 2FE7 C9                   ret
4498+ 2FE8
4499+ 2FE8 D5           ADDIG:  push    DE              ; Save sign of exponent
4500+ 2FE9 57                   ld      D,A             ; Save digit
4501+ 2FEA 78                   ld      A,B             ; Get digits after point
4502+ 2FEB 89                   adc     A,C             ; Add one if after point
4503+ 2FEC 47                   ld      B,A             ; Re-save counter
4504+ 2FED C5                   push    BC              ; Save point flags
4505+ 2FEE E5                   push    HL              ; Save code string address
4506+ 2FEF D5                   push    DE              ; Save digit
4507+ 2FF0 CD 6D 2E             call    MLSP10          ; Multiply number by 10
4508+ 2FF3 F1                   pop     AF              ; Restore digit
4509+ 2FF4 D6 30                sub     '0'             ; Make it absolute
4510+ 2FF6 CD FF 2F             call    RSCALE          ; Re-scale number
4511+ 2FF9 E1                   pop     HL              ; Restore code string address
4512+ 2FFA C1                   pop     BC              ; Restore point flags
4513+ 2FFB D1                   pop     DE              ; Restore sign of exponent
4514+ 2FFC C3 9F 2F             jp      MANLP           ; Get another digit
4515+ 2FFF
4516+ 2FFF CD B5 2E     RSCALE: call    STAKFP          ; Put number on stack
4517+ 3002 CD 96 2E             call    FLGREL          ; Digit to add to FPREG
4518+ 3005 C1           PADD:   pop     BC              ; Restore number
4519+ 3006 D1                   pop     DE
4520+ 3007 C3 ED 2B             jp      FPADD           ; Add BCDE to FPREG and return
4521+ 300A
4522+ 300A 7B           EDIGIT: ld      A,E             ; Get digit
4523+ 300B 07                   rlca                    ; Times 2
4524+ 300C 07                   rlca                    ; Times 4
4525+ 300D 83                   add     A,E             ; Times 5
4526+ 300E 07                   rlca                    ; Times 10
4527+ 300F 86                   add     A,(HL)          ; Add next digit
4528+ 3010 D6 30                sub     '0'             ; Make it absolute
4529+ 3012 5F                   ld      E,A             ; Save new digit
4530+ 3013 C3 B5 2F             jp      EXPLP           ; Look for another digit
4531+ 3016
4532+ 3016 E5           LINEIN: push    HL              ; Save code string address
4533+ 3017 21 44 16             ld      HL,INMSG        ; Output " in "
4534+ 301A CD 7F 25             call    PRS             ; Output string at HL
4535+ 301D E1                   pop     HL              ; Restore code string address
4536+ 301E EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4537+ 301F AF                   xor     A
4538+ 3020 06 98                ld      B,$80+24        ; 24 bits
4539+ 3022 CD 9B 2E             call    RETINT          ; Return the integer
4540+ 3025 21 7E 25             ld      HL,PRNUMS       ; Print number string
4541+ 3028 E5                   push    HL              ; Save for return
4542+ 3029 21 56 53     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4543+ 302C E5                   push    HL              ; Save for return
4544+ 302D CD 84 2E             call    TSTSGN          ; Test sign of FPREG
4545+ 3030 36 20                ld      (HL),SPC        ; Space at start
4546+ 3032 F2 37 30             jp      P,SPCFST        ; Positive - Space to start
4547+ 3035 36 2D                ld      (HL),'-'        ; '-' sign at start
4548+ 3037 23           SPCFST: inc     HL              ; First byte of number
4549+ 3038 36 30                ld      (HL),'0'        ; '0' if zero
4550+ 303A CA ED 30             jp      Z,JSTZER        ; Return '0' if zero
4551+ 303D E5                   push    HL              ; Save buffer address
4552+ 303E FC AD 2E             call    M,INVSGN        ; Negate FPREG if negative
4553+ 3041 AF                   xor     A               ; Zero A
4554+ 3042 F5                   push    AF              ; Save it
4555+ 3043 CD F3 30             call    RNGTST          ; Test number is in range
4556+ 3046 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4557+ 3049 11 F8 4F             ld      DE,$4FF8
4558+ 304C CD FF 2E             call    CMPNUM          ; Compare numbers
4559+ 304F B7                   or      A
4560+ 3050 E2 64 30             jp      PO,INRNG        ; > 99999.9 - Sort it out
4561+ 3053 F1                   pop     AF              ; Restore count
4562+ 3054 CD E1 2F             call    MULTEN          ; Multiply by ten
4563+ 3057 F5                   push    AF              ; Re-save count
4564+ 3058 C3 46 30             jp      SIXDIG          ; Test it again
4565+ 305B
4566+ 305B CD CC 2D     GTSIXD: call    DIV10           ; Divide by 10
4567+ 305E F1                   pop     AF              ; Get count
4568+ 305F 3C                   inc     A               ; Count divides
4569+ 3060 F5                   push    AF              ; Re-save count
4570+ 3061 CD F3 30             call    RNGTST          ; Test number is in range
4571+ 3064 CD DB 2B     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4572+ 3067 3C                   inc     A
4573+ 3068 CD 2C 2F             call    FPINT           ; F.P to integer
4574+ 306B CD C5 2E             call    FPBCDE          ; Move BCDE to FPREG
4575+ 306E 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4576+ 3071 F1                   pop     AF              ; Restore count
4577+ 3072 81                   add     A,C             ; 6 digits before point
4578+ 3073 3C                   inc     A               ; Add one
4579+ 3074 FA 80 30             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4580+ 3077 FE 08                cp      6+1+1           ; More than 999999 ?
4581+ 3079 D2 80 30             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4582+ 307C 3C                   inc     A               ; Adjust for exponent
4583+ 307D 47                   ld      B,A             ; Exponent of number
4584+ 307E 3E 02                ld      A,2             ; Make it zero after
4585+ 3080
4586+ 3080 3D           MAKNUM: dec     A               ; Adjust for digits to do
4587+ 3081 3D                   dec     A
4588+ 3082 E1                   pop     HL              ; Restore buffer address
4589+ 3083 F5                   push    AF              ; Save count
4590+ 3084 11 06 31             ld      DE,POWERS       ; Powers of ten
4591+ 3087 05                   dec     B               ; Count digits before point
4592+ 3088 C2 91 30             jp      NZ,DIGTXT       ; Not zero - Do number
4593+ 308B 36 2E                ld      (HL),'.'        ; Save point
4594+ 308D 23                   inc     HL              ; Move on
4595+ 308E 36 30                ld      (HL),'0'        ; Save zero
4596+ 3090 23                   inc     HL              ; Move on
4597+ 3091 05           DIGTXT: dec     B               ; Count digits before point
4598+ 3092 36 2E                ld      (HL),'.'        ; Save point in case
4599+ 3094 CC DA 2E             call    Z,INCHL         ; Last digit - move on
4600+ 3097 C5                   push    BC              ; Save digits before point
4601+ 3098 E5                   push    HL              ; Save buffer address
4602+ 3099 D5                   push    DE              ; Save powers of ten
4603+ 309A CD D0 2E             call    BCDEFP          ; Move FPREG to BCDE
4604+ 309D E1                   pop     HL              ; Powers of ten table
4605+ 309E 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4606+ 30A0 04           TRYAGN: inc     B               ; Count subtractions
4607+ 30A1 7B                   ld      A,E             ; Get LSB
4608+ 30A2 96                   sub     (HL)            ; Subtract LSB
4609+ 30A3 5F                   ld      E,A             ; Save LSB
4610+ 30A4 23                   inc     HL
4611+ 30A5 7A                   ld      A,D             ; Get NMSB
4612+ 30A6 9E                   sbc     A,(HL)          ; Subtract NMSB
4613+ 30A7 57                   ld      D,A             ; Save NMSB
4614+ 30A8 23                   inc     HL
4615+ 30A9 79                   ld      A,C             ; Get MSB
4616+ 30AA 9E                   sbc     A,(HL)          ; Subtract MSB
4617+ 30AB 4F                   ld      C,A             ; Save MSB
4618+ 30AC 2B                   dec     HL              ; Point back to start
4619+ 30AD 2B                   dec     HL
4620+ 30AE D2 A0 30             jp      NC,TRYAGN       ; No overflow - Try again
4621+ 30B1 CD 92 2C             call    PLUCDE          ; Restore number
4622+ 30B4 23                   inc     HL              ; Start of next number
4623+ 30B5 CD C5 2E             call    FPBCDE          ; Move BCDE to FPREG
4624+ 30B8 EB                   ex      DE,HL           ; Save point in table
4625+ 30B9 E1                   pop     HL              ; Restore buffer address
4626+ 30BA 70                   ld      (HL),B          ; Save digit in buffer
4627+ 30BB 23                   inc     HL              ; And move on
4628+ 30BC C1                   pop     BC              ; Restore digit count
4629+ 30BD 0D                   dec     C               ; Count digits
4630+ 30BE C2 91 30             jp      NZ,DIGTXT       ; More - Do them
4631+ 30C1 05                   dec     B               ; Any decimal part?
4632+ 30C2 CA D1 30             jp      Z,DOEBIT        ; No - Do 'E' bit
4633+ 30C5 2B           SUPTLZ: dec     HL              ; Move back through buffer
4634+ 30C6 7E                   ld      A,(HL)          ; Get character
4635+ 30C7 FE 30                cp      '0'             ; '0' character?
4636+ 30C9 CA C5 30             jp      Z,SUPTLZ        ; Yes - Look back for more
4637+ 30CC FE 2E                cp      '.'             ; A decimal point?
4638+ 30CE C4 DA 2E             call    NZ,INCHL        ; Move back over digit
4639+ 30D1
4640+ 30D1 F1           DOEBIT: pop     AF              ; Get 'E' flag
4641+ 30D2 CA F0 30             jp      Z,NOENED        ; No 'E' needed - End buffer
4642+ 30D5 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4643+ 30D7 23                   inc     HL              ; And move on
4644+ 30D8 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4645+ 30DA F2 E1 30             jp      P,OUTEXP        ; Positive - Output exponent
4646+ 30DD 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4647+ 30DF 2F                   cpl                     ; Negate exponent
4648+ 30E0 3C                   inc     A
4649+ 30E1 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4650+ 30E3 04           EXPTEN: inc     B               ; Count subtractions
4651+ 30E4 D6 0A                sub     $0A             ; Tens digit
4652+ 30E6 D2 E3 30             jp      NC,EXPTEN       ; More to do
4653+ 30E9 C6 3A                add     A,'0'+10        ; Restore and make ASCII
4654+ 30EB 23                   inc     HL              ; Move on
4655+ 30EC 70                   ld      (HL),B          ; Save MSB of exponent
4656+ 30ED 23           JSTZER: inc     HL              ;
4657+ 30EE 77                   ld      (HL),A          ; Save LSB of exponent
4658+ 30EF 23                   inc     HL
4659+ 30F0 71           NOENED: ld      (HL),C          ; Mark end of buffer
4660+ 30F1 E1                   pop     HL              ; Restore code string address
4661+ 30F2 C9                   ret
4662+ 30F3
4663+ 30F3 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4664+ 30F6 11 F7 23             ld      DE,$23F7
4665+ 30F9 CD FF 2E             call    CMPNUM          ; Compare numbers
4666+ 30FC B7                   or      A
4667+ 30FD E1                   pop     HL              ; Return address to HL
4668+ 30FE E2 5B 30             jp      PO,GTSIXD       ; Too big - Divide by ten
4669+ 3101 E9                   jp      (HL)            ; Otherwise return to caller
4670+ 3102
4671+ 3102 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4672+ 3106
4673+ 3106 A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4674+ 3109 10 27 00             defb    $10,$27,$00  ;  10000
4675+ 310C E8 03 00             defb    $E8,$03,$00  ;   1000
4676+ 310F 64 00 00             defb    $64,$00,$00  ;    100
4677+ 3112 0A 00 00             defb    $0A,$00,$00  ;     10
4678+ 3115 01 00 00             defb    $01,$00,$00  ;      1
4679+ 3118
4680+ 3118 21 AD 2E     NEGAFT: ld      HL,INVSGN       ; Negate result
4681+ 311B E3                   ex      (SP),HL         ; To be done after caller
4682+ 311C E9                   jp      (HL)            ; Return to caller
4683+ 311D
4684+ 311D CD B5 2E     SQR:    call    STAKFP          ; Put value on stack
4685+ 3120 21 02 31             ld      HL,HALF         ; Set power to 1/2
4686+ 3123 CD C2 2E             call    PHLTFP          ; Move 1/2 to FPREG
4687+ 3126
4688+ 3126 C1           POWER:  pop     BC              ; Get base
4689+ 3127 D1                   pop     DE
4690+ 3128 CD 84 2E             call    TSTSGN          ; Test sign of power
4691+ 312B 78                   ld      A,B             ; Get exponent of base
4692+ 312C CA 6B 31             jp      Z,EXP           ; Make result 1 if zero
4693+ 312F F2 36 31             jp      P,POWER1        ; Positive base - Ok
4694+ 3132 B7                   or      A               ; Zero to negative power?
4695+ 3133 CA CE 16             jp      Z,DZERR         ; Yes - ?/0 Error
4696+ 3136 B7           POWER1: or      A               ; Base zero?
4697+ 3137 CA 54 2C             jp      Z,SAVEXP        ; Yes - Return zero
4698+ 313A D5                   push    DE              ; Save base
4699+ 313B C5                   push    BC
4700+ 313C 79                   ld      A,C             ; Get MSB of base
4701+ 313D F6 7F                or      %01111111       ; Get sign status
4702+ 313F CD D0 2E             call    BCDEFP          ; Move power to BCDE
4703+ 3142 F2 53 31             jp      P,POWER2        ; Positive base - Ok
4704+ 3145 D5                   push    DE              ; Save power
4705+ 3146 C5                   push    BC
4706+ 3147 CD 57 2F             call    INT             ; Get integer of power
4707+ 314A C1                   pop     BC              ; Restore power
4708+ 314B D1                   pop     DE
4709+ 314C F5                   push    AF              ; MSB of base
4710+ 314D CD FF 2E             call    CMPNUM          ; Power an integer?
4711+ 3150 E1                   pop     HL              ; Restore MSB of base
4712+ 3151 7C                   ld      A,H             ; but don't affect flags
4713+ 3152 1F                   rra                     ; Exponent odd or even?
4714+ 3153 E1           POWER2: pop     HL              ; Restore MSB and exponent
4715+ 3154 22 53 53             ld      (FPREG+2),HL    ; Save base in FPREG
4716+ 3157 E1                   pop     HL              ; LSBs of base
4717+ 3158 22 51 53             ld      (FPREG),HL      ; Save in FPREG
4718+ 315B DC 18 31             call    C,NEGAFT        ; Odd power - Negate result
4719+ 315E CC AD 2E             call    Z,INVSGN        ; Negative base - Negate it
4720+ 3161 D5                   push    DE              ; Save power
4721+ 3162 C5                   push    BC
4722+ 3163 CD E7 2C             call    LOG             ; Get LOG of base
4723+ 3166 C1                   pop     BC              ; Restore power
4724+ 3167 D1                   pop     DE
4725+ 3168 CD 28 2D             call    FPMULT          ; Multiply LOG by power
4726+ 316B
4727+ 316B CD B5 2E     EXP:    call    STAKFP          ; Put value on stack
4728+ 316E 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4729+ 3171 11 3B AA             ld      DE,$AA3B
4730+ 3174 CD 28 2D             call    FPMULT          ; Multiply value by 1/LN(2)
4731+ 3177 3A 54 53             ld      A,(FPEXP)       ; Get exponent
4732+ 317A FE 88                cp      $80+8           ; Is it in range?
4733+ 317C D2 60 2E             jp      NC,OVTST1       ; No - Test for overflow
4734+ 317F CD 57 2F             call    INT             ; Get INT of FPREG
4735+ 3182 C6 80                add     A,$80           ; For excess 128
4736+ 3184 C6 02                add     A,$02           ; Exponent > 126?
4737+ 3186 DA 60 2E             jp      C,OVTST1        ; Yes - Test for overflow
4738+ 3189 F5                   push    AF              ; Save scaling factor
4739+ 318A 21 D6 2C             ld      HL,UNITY        ; Point to 1.
4740+ 318D CD DE 2B             call    ADDPHL          ; Add 1 to FPREG
4741+ 3190 CD 1F 2D             call    MULLN2          ; Multiply by LN(2)
4742+ 3193 F1                   pop     AF              ; Restore scaling factor
4743+ 3194 C1                   pop     BC              ; Restore exponent
4744+ 3195 D1                   pop     DE
4745+ 3196 F5                   push    AF              ; Save scaling factor
4746+ 3197 CD EA 2B             call    SUBCDE          ; Subtract exponent from FPREG
4747+ 319A CD AD 2E             call    INVSGN          ; Negate result
4748+ 319D 21 AB 31             ld      HL,EXPTAB       ; Coefficient table
4749+ 31A0 CD DB 31             call    SMSER1          ; Sum the series
4750+ 31A3 11 00 00             ld      DE,$0000        ; Zero LSBs
4751+ 31A6 C1                   pop     BC              ; Scaling factor
4752+ 31A7 4A                   ld      C,D             ; Zero MSB
4753+ 31A8 C3 28 2D             jp      FPMULT          ; Scale result to correct value
4754+ 31AB
4755+ 31AB 08           EXPTAB: defb    $08             ; Table used by EXP
4756+ 31AC 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4757+ 31B0 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4758+ 31B4 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4759+ 31B8 E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4760+ 31BC 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4761+ 31C0 FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4762+ 31C4 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4763+ 31C8 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4764+ 31CC
4765+ 31CC CD B5 2E     SUMSER: call    STAKFP          ; Put FPREG on stack
4766+ 31CF 11 26 2D             ld      DE,MULT         ; Multiply by "X"
4767+ 31D2 D5                   push    DE              ; To be done after
4768+ 31D3 E5                   push    HL              ; Save address of table
4769+ 31D4 CD D0 2E             call    BCDEFP          ; Move FPREG to BCDE
4770+ 31D7 CD 28 2D             call    FPMULT          ; Square the value
4771+ 31DA E1                   pop     HL              ; Restore address of table
4772+ 31DB CD B5 2E     SMSER1: call    STAKFP          ; Put value on stack
4773+ 31DE 7E                   ld      A,(HL)          ; Get number of coefficients
4774+ 31DF 23                   inc     HL              ; Point to start of table
4775+ 31E0 CD C2 2E             call    PHLTFP          ; Move coefficient to FPREG
4776+ 31E3 06                   defb    06H             ; Skip "pop AF"
4777+ 31E4 F1           SUMLP:  pop     AF              ; Restore count
4778+ 31E5 C1                   pop     BC              ; Restore number
4779+ 31E6 D1                   pop     DE
4780+ 31E7 3D                   dec     A               ; Cont coefficients
4781+ 31E8 C8                   ret     Z               ; All done
4782+ 31E9 D5                   push    DE              ; Save number
4783+ 31EA C5                   push    BC
4784+ 31EB F5                   push    AF              ; Save count
4785+ 31EC E5                   push    HL              ; Save address in table
4786+ 31ED CD 28 2D             call    FPMULT          ; Multiply FPREG by BCDE
4787+ 31F0 E1                   pop     HL              ; Restore address in table
4788+ 31F1 CD D3 2E             call    LOADFP          ; Number at HL to BCDE
4789+ 31F4 E5                   push    HL              ; Save address in table
4790+ 31F5 CD ED 2B             call    FPADD           ; Add coefficient to FPREG
4791+ 31F8 E1                   pop     HL              ; Restore address in table
4792+ 31F9 C3 E4 31             jp      SUMLP           ; More coefficients
4793+ 31FC
4794+ 31FC
4795+ 31FC              ; random number generator
4796+ 31FC              ; a negative argument is used as a seed for the RNG
4797+ 31FC              ; 0 is used to repeat the last random number
4798+ 31FC              ; a positive argument generates a new random number
4799+ 31FC CD 84 2E     RND:    call    TSTSGN          ; Test sign of FPREG
4800+ 31FF 21 99 51             ld      HL,SEED+2       ; Random number seed
4801+ 3202 FA 5D 32             jp      M,RESEED        ; Negative - Re-seed
4802+ 3205 21 BA 51             ld      HL,LSTRND       ; Last random number
4803+ 3208 CD C2 2E             call    PHLTFP          ; Move last RND to FPREG
4804+ 320B 21 99 51             ld      HL,SEED+2       ; Random number seed
4805+ 320E C8                   ret     Z               ; Return if RND(0)
4806+ 320F 86                   add     A,(HL)          ; Add (SEED)+2)
4807+ 3210 E6 07                and     %00000111       ; 0 to 7
4808+ 3212 06 00                ld      B,$00
4809+ 3214 77                   ld      (HL),A          ; Re-save seed
4810+ 3215 23                   inc     HL              ; Move to coefficient table
4811+ 3216 87                   add     A,A             ; 4 bytes
4812+ 3217 87                   add     A,A             ; per entry
4813+ 3218 4F                   ld      C,A             ; BC = Offset into table
4814+ 3219 09                   add     HL,BC           ; Point to coefficient
4815+ 321A CD D3 2E             call    LOADFP          ; Coefficient to BCDE
4816+ 321D CD 28 2D             call    FPMULT  ;       ; Multiply FPREG by coefficient
4817+ 3220 3A 98 51             ld      A,(SEED+1)      ; Get (SEED+1)
4818+ 3223 3C                   inc     A               ; Add 1
4819+ 3224 E6 03                and     %00000011       ; 0 to 3
4820+ 3226 06 00                ld      B,$00
4821+ 3228 FE 01                cp      $01             ; Is it zero?
4822+ 322A 88                   adc     A,B             ; Yes - Make it 1
4823+ 322B 32 98 51             ld      (SEED+1),A      ; Re-save seed
4824+ 322E 21 61 32             ld      HL,RNDTAB-4     ; Addition table
4825+ 3231 87                   add     A,A             ; 4 bytes
4826+ 3232 87                   add     A,A             ; per entry
4827+ 3233 4F                   ld      C,A             ; BC = Offset into table
4828+ 3234 09                   add     HL,BC           ; Point to value
4829+ 3235 CD DE 2B             call    ADDPHL          ; Add value to FPREG
4830+ 3238 CD D0 2E     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4831+ 323B 7B                   ld      A,E             ; Get LSB
4832+ 323C 59                   ld      E,C             ; LSB = MSB
4833+ 323D EE 4F                xor     %01001111       ; Fiddle around
4834+ 323F 4F                   ld      C,A             ; New MSB
4835+ 3240 36 80                ld      (HL),$80        ; Set exponent
4836+ 3242 2B                   dec     HL              ; Point to MSB
4837+ 3243 46                   ld      B,(HL)          ; Get MSB
4838+ 3244 36 80                ld      (HL),$80        ; Make value -0.5
4839+ 3246 21 97 51             ld      HL,SEED         ; Random number seed
4840+ 3249 34                   inc     (HL)            ; Count seed
4841+ 324A 7E                   ld      A,(HL)          ; Get seed
4842+ 324B D6 AB                sub     $AB             ; Do it modulo 171
4843+ 324D C2 54 32             jp      NZ,RND2         ; Non-zero - Ok
4844+ 3250 77                   ld      (HL),A          ; Zero seed
4845+ 3251 0C                   inc     C               ; Fillde about
4846+ 3252 15                   dec     D               ; with the
4847+ 3253 1C                   inc     E               ; number
4848+ 3254 CD 3E 2C     RND2:   call    BNORM           ; Normalise number
4849+ 3257 21 BA 51             ld      HL,LSTRND       ; Save random number
4850+ 325A C3 DC 2E             jp      FPTHL           ; Move FPREG to last and return
4851+ 325D
4852+ 325D 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4853+ 325E 2B                   dec     HL
4854+ 325F 77                   ld      (HL),A
4855+ 3260 2B                   dec     HL
4856+ 3261 77                   ld      (HL),A
4857+ 3262 C3 38 32             jp      RND1            ; Return RND seed
4858+ 3265
4859+ 3265 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4860+ 3269 99 E9 92 69          defb    $99,$E9,$92,$69
4861+ 326D 10 D1 75 68          defb    $10,$D1,$75,$68
4862+ 3271
4863+ 3271              ; COS and SIN functions
4864+ 3271 21 BB 32     COS:    ld      HL,HALFPI       ; Point to PI/2
4865+ 3274 CD DE 2B             call    ADDPHL          ; Add it to PPREG
4866+ 3277 CD B5 2E     SIN:    call    STAKFP          ; Put angle on stack
4867+ 327A 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4868+ 327D 11 DB 0F             ld      DE,$0FDB
4869+ 3280 CD C5 2E             call    FPBCDE          ; Move 2 PI to FPREG
4870+ 3283 C1                   pop     BC              ; Restore angle
4871+ 3284 D1                   pop     DE
4872+ 3285 CD DA 2D             call    DVBCDE          ; Divide angle by 2 PI
4873+ 3288 CD B5 2E             call    STAKFP          ; Put it on stack
4874+ 328B CD 57 2F             call    INT             ; Get INT of result
4875+ 328E C1                   pop     BC              ; Restore number
4876+ 328F D1                   pop     DE
4877+ 3290 CD EA 2B             call    SUBCDE          ; Make it 0 <= value < 1
4878+ 3293 21 BF 32             ld      HL,QUARTR       ; Point to 0.25
4879+ 3296 CD E4 2B             call    SUBPHL          ; Subtract value from 0.25
4880+ 3299 CD 84 2E             call    TSTSGN          ; Test sign of value
4881+ 329C 37                   scf                     ; Flag positive
4882+ 329D F2 A7 32             jp      P,SIN1          ; Positive - Ok
4883+ 32A0 CD DB 2B             call    ROUND           ; Add 0.5 to value
4884+ 32A3 CD 84 2E             call    TSTSGN          ; Test sign of value
4885+ 32A6 B7                   or      A               ; Flag negative
4886+ 32A7 F5           SIN1:   push    AF              ; Save sign
4887+ 32A8 F4 AD 2E             call    P,INVSGN        ; Negate value if positive
4888+ 32AB 21 BF 32             ld      HL,QUARTR       ; Point to 0.25
4889+ 32AE CD DE 2B             call    ADDPHL          ; Add 0.25 to value
4890+ 32B1 F1                   pop     AF              ; Restore sign
4891+ 32B2 D4 AD 2E             call    NC,INVSGN       ; Negative - Make positive
4892+ 32B5 21 C3 32             ld      HL,SINTAB       ; Coefficient table
4893+ 32B8 C3 CC 31             jp      SUMSER          ; Evaluate sum of series
4894+ 32BB
4895+ 32BB DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4896+ 32BF
4897+ 32BF 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4898+ 32C3
4899+ 32C3 05           SINTAB: defb    $05             ; Table used by SIN
4900+ 32C4 BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4901+ 32C8 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4902+ 32CC 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4903+ 32D0 E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4904+ 32D4 DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4905+ 32D8
4906+ 32D8 CD B5 2E     TAN:    call    STAKFP          ; Put angle on stack
4907+ 32DB CD 77 32             call    SIN             ; Get SIN of angle
4908+ 32DE C1                   pop     BC              ; Restore angle
4909+ 32DF E1                   pop     HL
4910+ 32E0 CD B5 2E             call    STAKFP          ; Save SIN of angle
4911+ 32E3 EB                   ex      DE,HL           ; BCDE = Angle
4912+ 32E4 CD C5 2E             call    FPBCDE          ; Angle to FPREG
4913+ 32E7 CD 71 32             call    COS             ; Get COS of angle
4914+ 32EA C3 D8 2D             jp      DIV             ; TAN = SIN / COS
4915+ 32ED
4916+ 32ED CD 84 2E     ATN:    call    TSTSGN          ; Test sign of value
4917+ 32F0 FC 18 31             call    M,NEGAFT        ; Negate result after if -ve
4918+ 32F3 FC AD 2E             call    M,INVSGN        ; Negate value if -ve
4919+ 32F6 3A 54 53             ld      A,(FPEXP)       ; Get exponent
4920+ 32F9 FE 81                cp      81H             ; Number less than 1?
4921+ 32FB DA 0A 33             jp      C,ATN1          ; Yes - Get arc tangnt
4922+ 32FE 01 00 81             ld      BC,$8100        ; BCDE = 1
4923+ 3301 51                   ld      D,C
4924+ 3302 59                   ld      E,C
4925+ 3303 CD DA 2D             call    DVBCDE          ; Get reciprocal of number
4926+ 3306 21 E4 2B             ld      HL,SUBPHL       ; Sub angle from PI/2
4927+ 3309 E5                   push    HL              ; Save for angle > 1
4928+ 330A 21 14 33     ATN1:   ld      HL,ATNTAB       ; Coefficient table
4929+ 330D CD CC 31             call    SUMSER          ; Evaluate sum of series
4930+ 3310 21 BB 32             ld      HL,HALFPI       ; PI/2 - angle in case > 1
4931+ 3313 C9                   ret                     ; Number > 1 - Sub from PI/2
4932+ 3314
4933+ 3314 09           ATNTAB: defb    $09             ; Table used by ATN
4934+ 3315 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
4935+ 3319 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
4936+ 331D FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
4937+ 3321 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
4938+ 3325 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
4939+ 3329 C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
4940+ 332D E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
4941+ 3331 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
4942+ 3335 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
4943+ 3339
4944+ 3339
4945+ 3339 C9           ARET:   ret                     ; A RETurn instruction
4946+ 333A
4947+ 333A D7           GETINP: rst     $10             ; input a character
4948+ 333B C9                   ret
4949+ 333C
4950+ 333C E5           CLS:    push    HL
4951+ 333D D5                   push    DE
4952+ 333E 3A EE 52             ld      A,(SCR_MODE)    ; check screen mode
4953+ 3341 FE 02                cp      $02             ; G2 mode?
4954+ 3343 CC CE 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
4955+ 3346 D1                   pop     DE
4956+ 3347 E1                   pop     HL
4957+ 3348 3E 0C                ld      A,CS            ; ASCII Clear screen
4958+ 334A CD EB 19             call    SND2VID         ; send to screen
4959+ 334D C3 91 3F             jp      MONOUT          ; Output character
4960+ 3350
4961+ 3350 CD FD 28     WIDTH:  call    GETINT          ; Get integer 0-255
4962+ 3353 7B                   ld      A,E             ; Width to A
4963+ 3354 32 C1 51             ld      (LWIDTH),A      ; Set width
4964+ 3357 C9                   ret
4965+ 3358
4966+ 3358
4967+ 3358              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
4968+ 3358              ; i.e., the first location is the LSB, while the second one is the MSB
4969+ 3358 CD A4 1C     DEEK:   call    DEINT           ; Get integer -32768 to 32767
4970+ 335B D5                   push    DE              ; Save number
4971+ 335C E1                   pop     HL              ; Number to HL
4972+ 335D 46           RECWRD: ld      B,(HL)          ; Get LSB of contents
4973+ 335E 23                   inc     HL
4974+ 335F 7E                   ld      A,(HL)          ; Get MSB of contents
4975+ 3360 C3 61 24             jp      ABPASS          ; Return integer AB
4976+ 3363
4977+ 3363              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
4978+ 3363              ; i.e., the LSB will go into the first location, while the MSB into the second one
4979+ 3363 CD 77 20     DOKE:   call    GETNUM          ; Get a number
4980+ 3366 CD A4 1C             call    DEINT           ; Get integer -32768 to 32767
4981+ 3369 D5                   push    DE              ; Save address
4982+ 336A CD AD 19             call    CHKSYN          ; Make sure ',' follows
4983+ 336D 2C                   defb    ','
4984+ 336E CD 77 20             call    GETNUM          ; Get a number
4985+ 3371 CD A4 1C             call    DEINT           ; Get integer -32768 to 32767
4986+ 3374 E3                   ex      (SP),HL         ; Save value,get address
4987+ 3375 73                   ld      (HL),E          ; Save LSB of value
4988+ 3376 23                   inc     HL
4989+ 3377 72                   ld      (HL),D          ; Save MSB of value
4990+ 3378 E1                   pop     HL              ; Restore code string address
4991+ 3379 C9                   ret
4992+ 337A
4993+ 337A              ; stop the execution of code for a certain bit of time. The pause
4994+ 337A              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
4995+ 337A CD 77 20     PAUSE:  call    GETNUM          ; Get a number
4996+ 337D CD A4 1C             call    DEINT           ; Get integer -32768 to 32767
4997+ 3380 7A                   ld      A,D             ; load D into A
4998+ 3381 B3                   or      E               ; are D & E equal to $00?
4999+ 3382 C8                   ret     Z               ; if yes, then return
5000+ 3383 C5           DIR_PAU:push    BC              ; store BC
5001+ 3384 3A DC 52             ld      A,(TMRCNT)      ; Load current value of system timer
5002+ 3387 47                   ld      B,A             ; move it into B
5003+ 3388 CD 19 1C     RPTPS:  call    TSTBRK          ; Test for break key
5004+ 338B 3A DC 52             ld      A,(TMRCNT)      ; Load current value of system timer
5005+ 338E B8                   cp      B               ; is it the same value?
5006+ 338F 28 F7                jr      Z,RPTPS         ; yes, so read again
5007+ 3391 47                   ld      B,A             ; no, so store the new value
5008+ 3392 1B                   dec     DE              ; decrement interval
5009+ 3393 7A                   ld      A,D             ; load D into A
5010+ 3394 B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5011+ 3395 20 F1                jr      NZ,RPTPS        ; no, repeat
5012+ 3397 C1                   pop     BC              ; yes, recover BC and continue
5013+ 3398 C9                   ret
5014+ 3399
5015+ 3399              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5016+ 3399              ; where X is graphic mode:
5017+ 3399              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5018+ 3399              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5019+ 3399              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5020+ 3399              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5021+ 3399              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5022+ 3399 AF           SCREEN: xor     A
5023+ 339A 32 FF 52             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5024+ 339D CD FD 28             call    GETINT          ; Get integer 0-255
5025+ 33A0 FE 05                cp      $05             ; is it a valid mode (0~4)?
5026+ 33A2 D2 B9 1C             jp      NC,FCERR        ; No - Illegal function call Error
5027+ 33A5 32 FD 52             ld      (TMPBFR1),A     ; store graphic mode
5028+ 33A8 A7                   and     A               ; is it 0 (text mode)?
5029+ 33A9 CA C5 33             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5030+ 33AC CD 04 34     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
5031+ 33AF DA B7 33             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5032+ 33B2 3E 02                ld      A,$02           ; no, so set sprite size
5033+ 33B4 32 FF 52             ld      (TMPBFR2),A     ; ...to 16x16
5034+ 33B7 CD 04 34     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5035+ 33BA DA C5 33             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5036+ 33BD 3A FF 52             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5037+ 33C0 F6 01                or      $01             ; ...set sprite magnification to 2x...
5038+ 33C2 32 FF 52             ld      (TMPBFR2),A     ; ...and save flags again
5039+ 33C5 F3           SCVDP:  di                      ; disable INTs
5040+ 33C6 D5                   push    DE              ; store DE
5041+ 33C7 E5                   push    HL              ; store HL
5042+ 33C8 3A FD 52             ld      A,(TMPBFR1)     ; recover graphic mode
5043+ 33CB 5F                   ld      E,A             ; and store it into E
5044+ 33CC 3A FF 52             ld      A,(TMPBFR2)     ; recover sprite flags
5045+ 33CF 57                   ld      D,A             ; and store them into D
5046+ 33D0 D5                   push    DE              ; store D & E
5047+ 33D1 CD D3 03             call    initVDP         ; initialize VDP with mode pointed by E
5048+ 33D4 D1                   pop     DE              ; retrieve D & E
5049+ 33D5 7B                   ld      A,E             ; move graphic mode into A
5050+ 33D6 87                   add     A,A
5051+ 33D7 87                   add     A,A
5052+ 33D8 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5053+ 33D9 5F                   ld      E,A             ; and pass it into E
5054+ 33DA D5                   push    DE              ; store sprite flags in E
5055+ 33DB 16 00                ld      D,$00           ; reset D
5056+ 33DD 21 16 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5057+ 33E0 19                   add     HL,DE           ; load correct reg#1 setting
5058+ 33E1 D1                   pop     DE              ; retrieve sprite flags from E
5059+ 33E2 7E                   ld      A,(HL)          ; load reg#1 setting
5060+ 33E3 E6 FC                and     %11111100       ; reset size & magn. bits
5061+ 33E5 B2                   or      D               ; set size & magn. bits
5062+ 33E6 5F                   ld      E,A             ; value into E
5063+ 33E7 3E 01                ld      A,$01           ; reg #1
5064+ 33E9 CD A7 06             call    WRITE_VREG      ; send setting to reg #1
5065+ 33EC 2A CE 51             ld      HL,(LINEAT)     ; Get current line number
5066+ 33EF 23                   inc     HL              ; -1 means direct statement
5067+ 33F0 7C                   ld      A,H
5068+ 33F1 B5                   or      L
5069+ 33F2 CC 1A 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5070+ 33F5 FB                   ei                      ; re-enable interrupts
5071+ 33F6 E1                   pop     HL              ; restore HL
5072+ 33F7 D1                   pop     DE              ; restore DE
5073+ 33F8 3A ED 52             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5074+ 33FB FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5075+ 33FD D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5076+ 33FE 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5077+ 3400 32 F9 52             ld      (PRNTVIDEO),A   ; ...video buffer...
5078+ 3403 C9                   ret                     ; ...and return to caller
5079+ 3404
5080+ 3404              ; check an additional argument for SCREEN - There are 2 ways of working:
5081+ 3404              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5082+ 3404              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5083+ 3404 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5084+ 3405 CD EE 1B             call    GETCHR          ; Get next character
5085+ 3408 37                   scf                     ; set carry flag
5086+ 3409 C8                   ret     Z               ; return if nothing follows with Carry=1
5087+ 340A CD AD 19             call    CHKSYN          ; Make sure ',' follows
5088+ 340D 2C                   defb    ','
5089+ 340E CD FD 28             call    GETINT          ; get value
5090+ 3411 1F                   rra                     ; Carry=bit #0
5091+ 3412 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5092+ 3413 C9                   ret                     ; return
5093+ 3414
5094+ 3414
5095+ 3414              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5096+ 3414              ; a=foreground color / b=background color / c=border color
5097+ 3414              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5098+ 3414              ; the number of arguments is based on the current screen mode
5099+ 3414 CD FD 28     COLOR:  call    GETINT          ; get first value
5100+ 3417 CD BD 34             call    CHKCLR1         ; check if it's in range 1~15
5101+ 341A 32 FD 52             ld      (TMPBFR1),A     ; store it
5102+ 341D 3A EE 52             ld      A,(SCR_MODE)    ; check screen mode
5103+ 3420 FE 03                cp      $03             ; is it multicolor mode?
5104+ 3422 20 0D                jr      NZ,CNTCKCL      ; no, continue
5105+ 3424 3E 0F                ld      A,$0F           ; white for...
5106+ 3426 32 FB 52             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5107+ 3429 3A FD 52             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5108+ 342C 32 01 53             ld      (TMPBFR3),A     ; move color into temp buffer 3
5109+ 342F 18 31                jr      CLRMC           ; jump to set color
5110+ 3431 CD AD 19     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5111+ 3434 2C                   defb    ','
5112+ 3435 CD FD 28             call    GETINT          ; get second value
5113+ 3438 CD BD 34             call    CHKCLR1         ; check if it's in range 1~15
5114+ 343B 32 FF 52             ld      (TMPBFR2),A     ; store it
5115+ 343E 3A EE 52             ld      A,(SCR_MODE)    ; check screen mode
5116+ 3441 A7                   and     A               ; is it text mode?
5117+ 3442 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5118+ 3444 CD AD 19             call    CHKSYN          ; Make sure ',' follows
5119+ 3447 2C                   defb    ','
5120+ 3448 CD FD 28             call    GETINT          ; get third value
5121+ 344B CD BD 34             call    CHKCLR1         ; check if it's in range 1~15
5122+ 344E 32 01 53             ld      (TMPBFR3),A     ; store it
5123+ 3451 D5                   push    DE              ; store DE
5124+ 3452 3A EE 52             ld      A,(SCR_MODE)    ; check screen mode
5125+ 3455 FE 01                cp      $01             ; is it G1 mode?
5126+ 3457 28 10                jr      Z,CLRG1         ; yes, jump over
5127+ 3459 FE 02                cp      $02             ; is it G2 mode?
5128+ 345B 28 15                jr      Z,CLRG2         ; yes, jump over
5129+ 345D 18 1C                jr      CLREX2          ; last case can only be ExG2
5130+ 345F CD B0 34     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5131+ 3462 32 01 53     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5132+ 3465 D5                   push    DE              ; store DE
5133+ 3466 F3                   di                      ; disable INTs
5134+ 3467 18 2E                jr      SETBRCL         ; set colors and exit
5135+ 3469 CD B0 34     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5136+ 346C 16 01                ld      D,$01           ; repeat 1 time
5137+ 346E 06 20                ld      B,$20           ; 32 bytes of colors
5138+ 3470 18 10                jr      LOADCLR         ; load colors
5139+ 3472 CD B0 34     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5140+ 3475 16 18                ld      D,$18           ; 18 pages of...
5141+ 3477 06 00                ld      B,$00           ; ...256 bytes each
5142+ 3479 18 07                jr      LOADCLR         ; load colors
5143+ 347B CD B0 34     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5144+ 347E 16 08                ld      D,$08           ; 8 pages of...
5145+ 3480 06 00                ld      B,$00           ; ...256 bytes each
5146+ 3482 E5           LOADCLR:push    HL              ; store HL
5147+ 3483 21 00 20             ld      HL,$2000        ; color table start: $2000
5148+ 3486 F3                   di                      ; disable INTs
5149+ 3487 CD 5D 06             call    SETVDPADRS
5150+ 348A 0E 30                ld      C,VDP_DAT       ; VDP data mode
5151+ 348C ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5152+ 348E 00                   nop
5153+ 348F 00                   nop
5154+ 3490 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5155+ 3492 15                   dec     D               ; did we fill up all the pages?
5156+ 3493 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5157+ 3495 FB                   ei
5158+ 3496 E1                   pop     HL              ; retrieve HL
5159+ 3497 3A FD 52     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5160+ 349A 32 FB 52             ld      (FRGNDCLR),A    ; store it
5161+ 349D 3A FF 52             ld      A,(TMPBFR2)     ; retrieve background color
5162+ 34A0 32 FC 52             ld      (BKGNDCLR),A    ; store it
5163+ 34A3 3A 01 53             ld      A,(TMPBFR3)     ; recover border color
5164+ 34A6 5F                   ld      E,A             ; move it into E
5165+ 34A7 3E 07                ld      A,$07           ; set VDP register 7
5166+ 34A9 F3                   di
5167+ 34AA CD A7 06             call    WRITE_VREG      ; send value to VDP: set border color
5168+ 34AD FB                   ei                      ; re-enable INTs
5169+ 34AE D1                   pop     DE              ; retrieve DE
5170+ 34AF C9                   ret                     ; return to caller
5171+ 34B0
5172+ 34B0
5173+ 34B0              ; mix 2 color nibbles in 1 byte
5174+ 34B0 3A FF 52     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5175+ 34B3 47                   ld      B,A             ; move it into B
5176+ 34B4 3A FD 52             ld      A,(TMPBFR1)     ; retrieve foreground color
5177+ 34B7 87                   add     A,A             ; move foreground color into the high nibble of A
5178+ 34B8 87                   add     A,A
5179+ 34B9 87                   add     A,A
5180+ 34BA 87                   add     A,A
5181+ 34BB B0                   or      B               ; put background color into the low nibble of A
5182+ 34BC C9                   ret                     ; return to caller
5183+ 34BD
5184+ 34BD
5185+ 34BD              ; check if the color is not 0 and into the range 1~15
5186+ 34BD A7           CHKCLR1:and     A               ; is it 0?
5187+ 34BE CA CB 16             jp      Z,SNERR         ; yes, raise a SN error
5188+ 34C1 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5189+ 34C3 D2 CB 16             jp      NC,SNERR        ; no, raise a SN error
5190+ 34C6 C9                   ret                     ; param is OK, can return
5191+ 34C7
5192+ 34C7
5193+ 34C7              ; check if in graphics 2 mode
5194+ 34C7 3A EE 52     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5195+ 34CA FE 02                cp      $02             ; actually, we can paint only in G2
5196+ 34CC C2 CB 3A             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5197+ 34CF C9                   ret                     ; return to caller
5198+ 34D0
5199+ 34D0
5200+ 34D0              ; print a text in screen 2
5201+ 34D0              ; GPRINT text,x,y[,fc[,bc]]
5202+ 34D0              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5203+ 34D0              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5204+ 34D0              ; colors (1~15), resp.
5205+ 34D0              ; (portions of code are from nippur72)
5206+ 34D0              GX      equ     TMPBFR3
5207+ 34D0              GY      equ     TMPBFR4
5208+ 34D0              TMPCLR  equ     TMPBFR2
5209+ 34D0              MIXCOL  equ     TMPBFR1
5210+ 34D0              TMPADR  equ     VIDEOBUFF
5211+ 34D0              CHRPNT  equ     VIDEOBUFF+$02
5212+ 34D0              NUMCHR  equ     VIDEOBUFF+$04
5213+ 34D0              TMPHL   equ     VIDEOBUFF+$06
5214+ 34D0 CD C7 34     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5215+ 34D3 2B                   dec     HL              ; dec 'cos GETCHR INCs
5216+ 34D4 CD EE 1B             call    GETCHR          ; check if something follows
5217+ 34D7 CA CB 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
5218+ 34DA 22 05 53             ld      (VIDEOBUFF),HL  ; save current code string pointer
5219+ 34DD CD 89 20             call    EVAL            ; Evaluate expression
5220+ 34E0 CD 7B 20             call    TSTSTR          ; Make sure it's a string
5221+ 34E3 22 0B 53             ld      (TMPHL),HL      ; store code string pointer
5222+ 34E6 CD C2 26             call    GSTRCU          ; Current string to pool
5223+ 34E9 CD D3 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5224+ 34EC ED 43 07 53          ld      (CHRPNT),BC     ; store string pointer
5225+ 34F0 ED 53 09 53          ld      (NUMCHR),DE     ; store string lenght
5226+ 34F4 2A 0B 53             ld      HL,(TMPHL)      ; store code string pointer
5227+ 34F7 CD AD 19             call    CHKSYN          ; Make sure ',' follows
5228+ 34FA 2C                   defb    ','
5229+ 34FB CD FD 28             call    GETINT          ; get X coord.
5230+ 34FE FE 20                cp      $20             ; is it in rage 0~31?
5231+ 3500 D2 B9 1C             jp      NC,FCERR        ; Illegal function call error
5232+ 3503 32 01 53             ld      (GX),A          ; store into temp. buffer
5233+ 3506 CD AD 19             call    CHKSYN          ; Make sure ',' follows
5234+ 3509 2C                   defb    ','
5235+ 350A CD FD 28             call    GETINT          ; get Y coord.
5236+ 350D FE 18                cp      $18             ; is it in range 0~23?
5237+ 350F D2 B9 1C             jp      NC,FCERR        ; Illegal function call error
5238+ 3512 32 03 53             ld      (GY),A          ; store into temp. buffer
5239+ 3515 11 FF 52             ld      DE,TMPCLR
5240+ 3518 3A FC 52             ld      A,(BKGNDCLR)    ; load background color
5241+ 351B 12                   ld      (DE),A          ; store into temp buff
5242+ 351C 3A FB 52             ld      A,(FRGNDCLR)    ; load foreground color
5243+ 351F 1B                   dec     DE
5244+ 3520 1B                   dec     DE
5245+ 3521 12                   ld      (DE),A          ; store into temp buff
5246+ 3522 CD AC 35             call    CKCOL           ; check color
5247+ 3525 CA 2D 35             jp      Z,CNTGPT2       ; if anything follows, jump over
5248+ 3528 13                   inc     DE
5249+ 3529 13                   inc     DE
5250+ 352A CD AC 35             call    CKCOL           ; check background color
5251+ 352D CD B0 34     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5252+ 3530 32 FD 52             ld      (MIXCOL),A      ; store mixed colors
5253+ 3533 E5                   push    HL              ; store code string address
5254+ 3534 ED 4B 07 53          ld      BC,(CHRPNT)     ; retrieve string pointer
5255+ 3538 ED 5B 09 53          ld      DE,(NUMCHR)     ; retrieve string lenght
5256+ 353C 1C                   inc     E               ; Length + 1
5257+ 353D CD 42 35             call    GPNT            ; print on G2
5258+ 3540 E1                   pop     HL              ; recover HL
5259+ 3541 C9                   ret                     ; return to caller
5260+ 3542 D5           GPNT:   push    DE              ; store string lenght (E)
5261+ 3543                      ; calculate VRAM address of first char
5262+ 3543 3A 01 53             LD      A,(GX)          ; load X
5263+ 3546 6F                   ld      L,A             ;
5264+ 3547 26 00                ld      H,0             ; HL = X
5265+ 3549 29                   add     HL,HL           ;
5266+ 354A 29                   add     HL,HL           ;
5267+ 354B 29                   add     HL,HL           ; X=X*8
5268+ 354C 3A 03 53             ld      A,(GY)          ; load Y
5269+ 354F 57                   ld      D,A             ; move it into D
5270+ 3550 1E 00                ld      E,0             ; DE =Y*256
5271+ 3552 19                   add     HL,DE           ; address = X*8 + Y*256
5272+ 3553 22 05 53             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5273+ 3556 D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5274+ 3557 1D           RPGPNT: dec     E               ; Count characters
5275+ 3558 C8                   ret     Z               ; End of string - return
5276+ 3559 D5                   push    DE              ; store chars counter
5277+ 355A                      ; calculate dest address in color vram
5278+ 355A 2A 05 53             ld      HL,(TMPADR)     ; recover VRAM address
5279+ 355D 11 00 20             ld      DE,$2000        ; color map address
5280+ 3560 19                   add     HL,DE           ; HL = $2000 + XY address
5281+ 3561 F3                   di                      ; disable INTs
5282+ 3562                      ; send color settings
5283+ 3562 CD 5D 06     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
5284+ 3565 3A FD 52             ld      A,(MIXCOL)      ; load color settings
5285+ 3568 06 08                ld      B,$08           ; repeat for 8 rows
5286+ 356A 0D                   dec     C              ; VDP data mode
5287+ 356B ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5288+ 356D 00                   nop                     ; wait...
5289+ 356E 00                   nop                     ; ...a...
5290+ 356F 00                   nop                     ; ...while
5291+ 3570 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5292+ 3572                      ; calculate source address
5293+ 3572 2A 07 53             ld      HL,(CHRPNT)     ; load char pointer
5294+ 3575 7E                   ld      A,(HL)          ; get char
5295+ 3576 23                   inc     HL              ; increment char pointer
5296+ 3577 22 07 53             ld      (CHRPNT),HL     ; store char pointer
5297+ 357A 6F                   ld      L,A             ;
5298+ 357B 26 00                ld      H,$00           ; char into HL
5299+ 357D 29                   add     HL,HL           ;
5300+ 357E 29                   add     HL,HL           ;
5301+ 357F 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5302+ 3580 11 1B 48             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5303+ 3583 19                   add     HL,DE           ; HL = start of characters in ROM
5304+ 3584 EB                   ex      DE,HL           ; store address into DE
5305+ 3585 2A 05 53     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
5306+ 3588 CD 5D 06             call    SETVDPADRS      ; send it to VDP
5307+ 358B EB                   ex      DE,HL           ; restore address into HL
5308+ 358C 06 08                ld      B,$08           ; repeat for 8 rows
5309+ 358E 0D                   dec     C              ; VDP data mode
5310+ 358F ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5311+ 3591 00                   nop                     ; wait...
5312+ 3592 00                   nop                     ; ...a...
5313+ 3593 00                   nop                     ; ...while
5314+ 3594 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5315+ 3596 FB                   ei                      ; re-enable INTs
5316+ 3597 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5317+ 359A 2A 05 53             ld      HL,(TMPADR)     ; load VRAM address
5318+ 359D 19                   add     HL,DE           ; get address of next VRAM cell
5319+ 359E 22 05 53             ld      (TMPADR),HL     ; store new VRAM address
5320+ 35A1 11 00 18             ld      DE,$1800        ; forbidden address
5321+ 35A4 CD B8 3F             call    CMP16           ; check if the printing has gone out of the screen
5322+ 35A7 D1                   pop     DE              ; retrieve number of chars to be printed
5323+ 35A8 D0                   ret     NC              ; if HL>=$1800 then leave
5324+ 35A9 C3 57 35             jp      RPGPNT          ; otherwise, check if more chars to output
5325+ 35AC
5326+ 35AC              ; used by GPRINT to get a color argument (if present)
5327+ 35AC 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5328+ 35AD CD EE 1B             call    GETCHR          ; Get next character
5329+ 35B0 C8                   ret     Z               ; return if nothing follows
5330+ 35B1 CD AD 19             call    CHKSYN          ; Make sure ',' follows
5331+ 35B4 2C                   defb    ','
5332+ 35B5 D5                   push    DE              ; store DE
5333+ 35B6 CD FD 28             call    GETINT          ; get value
5334+ 35B9 CD BD 34             call    CHKCLR1         ; check if color is in range 1~15
5335+ 35BC D1                   pop     DE              ; retrieve DE
5336+ 35BD 12                   ld      (DE),A          ; store color into temp buffer
5337+ 35BE C9                   ret                     ; return to caller
5338+ 35BF
5339+ 35BF
5340+ 35BF              ; paint X,Y[,C]: in graphics mode, fills an area starting
5341+ 35BF              ; at point X,Y, using default color or, if used, with
5342+ 35BF              ; color set by C
5343+ 35BF              ; TMPBFR1       X
5344+ 35BF              ; TMPBFR2       Y
5345+ 35BF              ; TMPBFR3       COLOR
5346+ 35BF              PNT     equ     VIDEOBUFF
5347+ 35BF              SPA     equ     VIDEOBUFF+$02
5348+ 35BF              SPB     equ     VIDEOBUFF+$03
5349+ 35BF              ORGSP   equ     VIDEOBUFF+$04
5350+ 35BF CD C7 34     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5351+ 35C2 CD FD 28             call    GETINT          ; get X
5352+ 35C5 32 FD 52             ld      (TMPBFR1),A     ; store X
5353+ 35C8 CD AD 19             call    CHKSYN          ; Make sure ',' follows
5354+ 35CB 2C                   defb    ','
5355+ 35CC CD FD 28             call    GETINT          ; get Y coords,
5356+ 35CF FE C0                cp      $C0             ; check if Y is in range 0~191
5357+ 35D1 D2 B9 1C             jp      NC,FCERR        ; no, raise an FC error
5358+ 35D4 32 FF 52             ld      (TMPBFR2),A     ; store Y
5359+ 35D7 CD B2 3A             call    CLRPRM          ; check if color has been passed
5360+ 35DA 3A 01 53             ld      A,(TMPBFR3)     ; load color
5361+ 35DD A7                   and     A               ; check if 0
5362+ 35DE CA B9 1C             jp      Z,FCERR         ; yes, raise an error
5363+ 35E1 E5                   push    HL              ; store HL
5364+ 35E2 C5                   push    BC              ; store BC
5365+ 35E3 D5                   push    DE              ; store DE
5366+ 35E4                      ; start algorithm
5367+ 35E4 CD F7 36             call    PNTRTN          ; check if pixel is already set
5368+ 35E7 C2 9B 36             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5369+ 35EA ED 73 09 53          ld      (ORGSP),SP      ; no, store current Stack Pointer
5370+ 35EE 21 01 00             ld      HL,$0001        ; HL=1
5371+ 35F1 22 05 53             ld      (PNT),HL        ; set PNT
5372+ 35F4 3A FD 52             ld      A,(TMPBFR1)     ; load starting X...
5373+ 35F7 47                   ld      B,A             ; ...into B
5374+ 35F8 3A FF 52             ld      A,(TMPBFR2)     ; load starting Y...
5375+ 35FB 4F                   ld      C,A             ; ...into C
5376+ 35FC C5                   push    BC              ; store starting X,Y into stack
5377+ 35FD                      ; main loop
5378+ 35FD 2A 05 53     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5379+ 3600 7C                   ld      A,H             ; check if PNT=0
5380+ 3601 B5                   or      L
5381+ 3602 CA 97 36             jp      Z,EXITPAI       ; yes, no more points to process - exit
5382+ 3605 2B                   dec     HL              ; no, so decrement PNT...
5383+ 3606 22 05 53             ld      (PNT),HL        ; ...and store it
5384+ 3609 C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5385+ 360A CD 9F 36     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5386+ 360D 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5387+ 360F 78                   ld      A,B             ; pixel is reset, check if X1=0
5388+ 3610 A7                   and     A               ; (reached the limit of the screen)
5389+ 3611 CA 19 36             jp      Z,PAINT1        ; yes, jump over
5390+ 3614 05                   dec     B               ; no, decrement X1...
5391+ 3615 C3 0A 36             jp      PAINT0          ; ...and repeat
5392+ 3618 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5393+ 3619 AF           PAINT1: xor     A               ; reset A
5394+ 361A 57                   ld      D,A             ; set SA=0
5395+ 361B 5F                   ld      E,A             ; set SB=0
5396+ 361C CD 9F 36     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5397+ 361F 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5398+ 3621 78                   ld      A,B             ; copy X1
5399+ 3622 32 FD 52             ld      (TMPBFR1),A     ; into buffer
5400+ 3625 79                   ld      A,C             ; copy Y
5401+ 3626 32 FF 52             ld      (TMPBFR2),A     ; into buffer
5402+ 3629 CD 1D 37             call    CNTPLOT         ; plot pixel X1,Y
5403+ 362C 7A                   ld      A,D             ; load SA into A
5404+ 362D A7                   and     A               ; SA=0?
5405+ 362E 20 1C                jr      NZ,PAINT2       ; no, jump over
5406+ 3630 79                   ld      A,C             ; load Y
5407+ 3631 FE 01                cp      $01             ; Y>0?
5408+ 3633 DA 4C 36             jp      C,PAINT2        ; no, jump over
5409+ 3636 3D                   dec     A               ; yes, Y=Y-1
5410+ 3637 CD A0 36             call    CHECKPY         ; check pixel X1,Y-1
5411+ 363A 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5412+ 363C 0D                   dec     C               ; Y=Y-1
5413+ 363D C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5414+ 363E 0C                   inc     C               ; retrieve original Y
5415+ 363F 2A 05 53             ld      HL,(PNT)        ; load PNT
5416+ 3642 23                   inc     HL              ; increment PNT
5417+ 3643 22 05 53             ld      (PNT),HL        ; store new PNT
5418+ 3646 3E 01                ld      A,$01           ; set SA=1 and...
5419+ 3648 57                   ld      D,A             ; ...store SA into memory
5420+ 3649 C3 5F 36             jp      PAINT3          ; jump over
5421+ 364C 7A           PAINT2: ld      A,D             ; load SA into A
5422+ 364D 1F                   rra                     ; check if SA=1
5423+ 364E 30 0F                jr      NC,PAINT3       ; no, jump over
5424+ 3650 79                   ld      A,C             ; load Y
5425+ 3651 FE 01                cp      $01             ; Y>0?
5426+ 3653 DA 5F 36             jp      C,PAINT3        ; no, jump over
5427+ 3656 3D                   dec     A               ; Y=Y-1
5428+ 3657 CD A0 36             call    CHECKPY         ; check pixel X1,Y-1
5429+ 365A CA 5F 36             jp      Z,PAINT3        ; if pixel is off, jump over
5430+ 365D AF                   xor     A               ; pixel is on, so...
5431+ 365E 57                   ld      D,A             ; ...set SA=0
5432+ 365F 7B           PAINT3: ld      A,E             ; check if...
5433+ 3660 A7                   and     A               ; SB=0
5434+ 3661 20 1B                jr      NZ,PAINT4       ; no, jump over
5435+ 3663 79                   ld      A,C             ; load Y
5436+ 3664 FE BF                cp      $BF             ; Y<191?
5437+ 3666 30 16                jr      NC,PAINT4       ; no, jump over
5438+ 3668 3C                   inc     A               ; Y=Y+1
5439+ 3669 CD A0 36             call    CHECKPY         ; check pixel X1,Y+1
5440+ 366C 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5441+ 366E 0C                   inc     C               ; Y=Y+1
5442+ 366F C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5443+ 3670 0D                   dec     C               ; retrieve original Y
5444+ 3671 2A 05 53             ld      HL,(PNT)        ; PNT
5445+ 3674 23                   inc     HL              ; PNT=PNT+1
5446+ 3675 22 05 53             ld      (PNT),HL        ; store PNT
5447+ 3678 3E 01                ld      A,$01           ; SB=1
5448+ 367A 5F                   ld      E,A             ; set SB
5449+ 367B C3 90 36             jp      PAINT5          ; jump over
5450+ 367E 7B           PAINT4: ld      A,E             ; load SB
5451+ 367F 1F                   rra                     ; check if SB=1
5452+ 3680 30 0E                jr      NC,PAINT5       ; no, jump over
5453+ 3682 79                   ld      A,C             ; load Y
5454+ 3683 FE BF                cp      $BF             ; Y<191?
5455+ 3685 30 09                jr      NC,PAINT5       ; no, jump over
5456+ 3687 3C                   inc     A               ; Y=Y+1
5457+ 3688 CD A0 36             call    CHECKPY         ; check pixel X1,Y+1
5458+ 368B CA 90 36             jp      Z,PAINT5        ; if pixel is off, jump over
5459+ 368E AF                   xor     A               ; pixel is on, so...
5460+ 368F 5F                   ld      E,A             ; ...set SB=0
5461+ 3690 04           PAINT5: inc     B               ; X1=X1+1
5462+ 3691 CA FD 35             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5463+ 3694 C3 1C 36             jp      MNPAINT         ; otherwise, repeat for next X
5464+ 3697 ED 7B 09 53  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5465+ 369B D1           EXITPA2:pop     DE              ; retrieve DE
5466+ 369C C1                   pop     BC              ; retrieve BC
5467+ 369D E1                   pop     HL              ; retrieve HL
5468+ 369E C9                   ret                     ; return to caller
5469+ 369F 79           CHECKPA:ld      A,C             ; copy Y into A
5470+ 36A0 32 FF 52     CHECKPY:ld      (TMPBFR2),A     ; store Y
5471+ 36A3 78                   ld      A,B             ; copy X1 into A
5472+ 36A4 32 FD 52             ld      (TMPBFR1),A     ; store X1
5473+ 36A7 C5                   push    BC              ; save X1,Y
5474+ 36A8 D5                   push    DE
5475+ 36A9 CD F7 36             call    PNTRTN          ; check if pixel is set/reset
5476+ 36AC D1                   pop     DE
5477+ 36AD C1                   pop     BC              ; retrieve X1,Y
5478+ 36AE C9                   ret                     ; return to caller
5479+ 36AF
5480+ 36AF
5481+ 36AF              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5482+ 36AF CD C7 34     POINT:  call    CHKG2M          ; check if in graphic mode 2
5483+ 36B2 CD AD 19             call    CHKSYN          ; make sure "(" follows
5484+ 36B5 28                   defb    '('
5485+ 36B6 CD FD 28             call    GETINT          ; get X coords.
5486+ 36B9 32 FD 52             ld      (TMPBFR1),A     ; store it into a temp buffer
5487+ 36BC CD AD 19             call    CHKSYN          ; Make sure ',' follows
5488+ 36BF 2C                   defb    ','
5489+ 36C0 CD FD 28             call    GETINT          ; get Y coords,
5490+ 36C3 FE C0                cp      $C0             ; check if Y is in range 0~191
5491+ 36C5 D2 B9 1C             jp      NC,FCERR        ; no, raise an FC error
5492+ 36C8 32 FF 52             ld      (TMPBFR2),A     ; store into a temp buffer
5493+ 36CB CD AD 19             call    CHKSYN          ; make sure ")" follows
5494+ 36CE 29                   defb    ')'
5495+ 36CF E5                   push    HL              ; store current string address - the point after the ")" - ...
5496+ 36D0 FD E1                pop     IY              ; ...into IY
5497+ 36D2 CD F7 36             call    PNTRTN          ; check if pixel is set or reset
5498+ 36D5 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5499+ 36D7 AF                   xor     A               ; no, it's OFF. make sure to reset A...
5500+ 36D8 47                   ld      B,A             ; ...and B
5501+ 36D9 E1           PNTEND: pop     HL              ; drop original return point
5502+ 36DA FD E5                push    IY              ; load current string address from IY into stack
5503+ 36DC 11 62 21             ld      DE,RETNUM       ; Address of Return number from function...
5504+ 36DF D5                   push    DE              ; ...saved on stack
5505+ 36E0 C3 61 24             jp      ABPASS          ; return AB
5506+ 36E3 CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5507+ 36E5 F3                   di
5508+ 36E6 CD 7D 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5509+ 36E9 FB                   ei
5510+ 36EA CB 3F                srl     A               ; shift A...
5511+ 36EC CB 3F                srl     A               ; ...4 times...
5512+ 36EE CB 3F                srl     A               ; ...to move foreground color...
5513+ 36F0 CB 3F                srl     A               ; ...into lowest nibble
5514+ 36F2 47                   ld      B,A             ; color into B
5515+ 36F3 AF                   xor     A               ; reset MSB
5516+ 36F4 C3 D9 36             jp      PNTEND          ; return AB
5517+ 36F7 CD 6A 37     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5518+ 36FA 57                   ld      D,A             ; store pixel index
5519+ 36FB F3                   di                      ; disable INTs
5520+ 36FC CD 7D 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5521+ 36FF FB                   ei                      ; re-enable INTs
5522+ 3700 A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5523+ 3701 C9                   ret                     ; return to caller
5524+ 3702
5525+ 3702
5526+ 3702              ; PLOT X,Y[,color]
5527+ 3702              ; plot a pixel in graphic mode 2
5528+ 3702 CD C7 34     PLOT:   call    CHKG2M          ; check if in G2 mode
5529+ 3705 CD FD 28             call    GETINT          ; get X coords.
5530+ 3708 32 FD 52             ld      (TMPBFR1),A     ; store it into a temp buffer
5531+ 370B CD AD 19             call    CHKSYN          ; Make sure ',' follows
5532+ 370E 2C                   defb    ','
5533+ 370F CD FD 28             call    GETINT          ; get Y coords,
5534+ 3712 FE C0                cp      $C0             ; check if Y is in range 0~191
5535+ 3714 D2 B9 1C             jp      NC,FCERR        ; no, raise an FC error
5536+ 3717 32 FF 52             ld      (TMPBFR2),A     ; store into a temp buffer
5537+ 371A CD B2 3A             call    CLRPRM          ; check if param "color" has been passed
5538+ 371D E5           CNTPLOT:push    HL              ; store HL
5539+ 371E C5                   push    BC              ; store BC
5540+ 371F D5                   push    DE              ; store DE
5541+ 3720 CD 6A 37             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5542+ 3723 D2 5E 37             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5543+ 3726 57                   ld      D,A             ; move pixel value into D
5544+ 3727 3A 01 53             ld      A,(TMPBFR3)     ; retrieve color
5545+ 372A A7                   and     A               ; is it 0? (background, or reset pixel)
5546+ 372B 20 11                jr      NZ,CNTPLT1      ; no, continue
5547+ 372D F3                   di                      ; yes - so, disable INTs
5548+ 372E CD 7D 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5549+ 3731 FB                   ei                      ; re-enable INTs
5550+ 3732 5F                   ld      E,A             ; store value of cell
5551+ 3733 7A                   ld      A,D             ; retrieve pixel
5552+ 3734 2F                   cpl                     ; revert bits
5553+ 3735 A3                   and     E               ; set video pixel to off
5554+ 3736 F3                   di                      ; disable INTs
5555+ 3737 CD 92 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5556+ 373A FB                   ei                      ; re-enable INTs
5557+ 373B C3 5E 37             jp      NOGD            ; leave
5558+ 373E 87           CNTPLT1:add     A,A             ; now we move low nibble
5559+ 373F 87                   add     A,A             ; in the high nibble
5560+ 3740 87                   add     A,A             ; by adding A to itself
5561+ 3741 87                   add     A,A             ; 4 times (this is a shift left 4)
5562+ 3742 5F                   ld      E,A             ; move it into E
5563+ 3743 F3                   di                      ; disable INTs
5564+ 3744 CD 7D 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5565+ 3747 FB                   ei
5566+ 3748 B2                   or      D               ; merge new pixel preserving original pattern
5567+ 3749 F3                   di
5568+ 374A CD 92 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5569+ 374D FB                   ei
5570+ 374E CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5571+ 3750 F3                   di
5572+ 3751 CD 7D 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5573+ 3754 FB                   ei
5574+ 3755 E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5575+ 3757 B3                   or      E               ; set new foreground color
5576+ 3758 F3                   di
5577+ 3759 CD 92 06             call    WRITE_VIDEO_LOC ; write new color settings
5578+ 375C FB                   ei                      ; re-enable INTs
5579+ 375D 00                   nop                     ; wait for INTs to be enabled again
5580+ 375E D1           NOGD:   pop     DE              ; retrieve DE
5581+ 375F C1                   pop     BC              ; retrieve BC
5582+ 3760 E1                   pop     HL              ; retrieve HL
5583+ 3761 C9                   ret                     ; return to caller
5584+ 3762 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5584+ 3766 08 04 02 01
5585+ 376A                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5586+ 376A
5587+ 376A
5588+ 376A              ; compute the VRAM address of the byte containing the pixel
5589+ 376A              ; being pointed by X,Y (TMPBFR1,TMPBFR1)
5590+ 376A              ; byte address is returned into HL
5591+ 376A              ; pixel is returned into A
5592+ 376A              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5593+ 376A                      ; where R(Y/8) is the remainder of (Y/8)
5594+ 376A                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5595+ 376A 3A FF 52             ld      A,(TMPBFR2)     ; retrieve Y
5596+ 376D FE C0                cp      $C0             ; Y>=192?
5597+ 376F D0                   ret     NC              ; yes, so leave
5598+ 3770 1E 08                ld      E,$08           ; load E with divisor
5599+ 3772 57                   ld      D,A             ; and store into D (dividend)
5600+ 3773 CD E7 3F             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5601+ 3776 4F                   ld      C,A             ; store remainder into C
5602+ 3777 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5603+ 3778 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5604+ 377A 3A FD 52             ld      A,(TMPBFR1)     ; retrieve X
5605+ 377D 57                   ld      D,A             ; and move it into D (dividend)
5606+ 377E CD E7 3F             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5607+ 3781 4F                   ld      C,A             ; store remainder into C
5608+ 3782 7A                   ld      A,D             ; move quotient into A
5609+ 3783 87                   add     A,A             ; multiply quotient by 8
5610+ 3784 87                   add     A,A
5611+ 3785 87                   add     A,A
5612+ 3786 5F                   ld      E,A             ; store result into E
5613+ 3787 16 00                ld      D,$00           ; reset D
5614+ 3789 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5615+ 378A EB                   ex      DE,HL           ; move VRAM address into DE
5616+ 378B 21 62 37             ld      HL,PXLSET       ; starting address of table for pixel to draw
5617+ 378E 06 00                ld      B,$00           ; reset B
5618+ 3790 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5619+ 3791 7E                   ld      A,(HL)          ; load pixel data
5620+ 3792 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5621+ 3793 37                   scf                     ; set Carry for normal exit
5622+ 3794 C9                   ret                     ; return to caller
5623+ 3795
5624+ 3795
5625+ 3795              ; DRAW X1,Y1,X2,Y2[,color]
5626+ 3795              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5627+ 3795              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5628+ 3795              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5629+ 3795              ; the values. If color is not specified, the foreground color set
5630+ 3795              ; with COLOR will be used
5631+ 3795              X1      equ     TMPBFR1
5632+ 3795              Y1      equ     TMPBFR2
5633+ 3795              X2      equ     VIDEOBUFF
5634+ 3795              Y2      equ     VIDEOBUFF+$02
5635+ 3795              ER      equ     VIDEOBUFF+$04
5636+ 3795              E2      equ     VIDEOBUFF+$06
5637+ 3795              SX      equ     VIDEOBUFF+$08
5638+ 3795              SY      equ     VIDEOBUFF+$0A
5639+ 3795              DX      equ     VIDEOBUFF+$0C
5640+ 3795              DY      equ     VIDEOBUFF+$0E
5641+ 3795 CD C7 34     DRAW:   call    CHKG2M          ; check if in G2 mode
5642+ 3798 CD 9A 3A             call    CLRVDBF         ; clear VIDEOBUFF
5643+ 379B CD FD 28             call    GETINT          ; get X1 coords.
5644+ 379E 32 FD 52             ld      (X1),A          ; store it into a temp buffer
5645+ 37A1 CD AD 19             call    CHKSYN          ; Make sure ',' follows
5646+ 37A4 2C                   defb    ','
5647+ 37A5 CD FD 28             call    GETINT          ; get Y1 coords.
5648+ 37A8 FE C0                cp      $C0             ; check if Y1 is in range 0~191
5649+ 37AA D2 B9 1C             jp      NC,FCERR        ; no, raise an FC error
5650+ 37AD 32 FF 52             ld      (Y1),A          ; store into a temp buffer
5651+ 37B0 CD AD 19             call    CHKSYN          ; Make sure ',' follows
5652+ 37B3 2C                   defb    ','
5653+ 37B4 CD FD 28             call    GETINT          ; get X2 coords.
5654+ 37B7 32 05 53             ld      (X2),A          ; store it into a temp buffer
5655+ 37BA CD AD 19             call    CHKSYN          ; Make sure ',' follows
5656+ 37BD 2C                   defb    ','
5657+ 37BE CD FD 28             call    GETINT          ; get Y2 coords
5658+ 37C1 FE C0                cp      $C0             ; check if Y2 is in range 0~191
5659+ 37C3 D2 B9 1C             jp      NC,FCERR        ; no, raise an FC error
5660+ 37C6 32 07 53             ld      (Y2),A          ; store it into a temp buffer
5661+ 37C9 CD B2 3A             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5662+ 37CC E5                   push    HL              ; store register we'll use
5663+ 37CD D5                   push    DE
5664+ 37CE C5                   push    BC
5665+ 37CF ED 5B FD 52          ld      DE,(X1)         ; load X1 and
5666+ 37D3 2A 05 53             ld      HL,(X2)         ; X2
5667+ 37D6 B7                   or      A               ; clear CARRY
5668+ 37D7 ED 52                sbc     HL,DE           ; DX=X2-X1
5669+ 37D9 CD DD 3F             call    absHL           ; DX=ABS(DX)
5670+ 37DC 22 11 53             ld      (DX),HL         ; store DX
5671+ 37DF 01 FF FF             ld      BC,$FFFF        ; SX=-1
5672+ 37E2 2A FD 52             ld      HL,(X1)
5673+ 37E5 ED 5B 05 53          ld      DE,(X2)
5674+ 37E9 CD B8 3F             call    CMP16           ; X1<X2?
5675+ 37EC CA F5 37             jp      Z,X1GR          ; no, X1=X2
5676+ 37EF F2 F5 37             jp      P,X1GR          ; no, X1>X2
5677+ 37F2 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5678+ 37F5 ED 43 0D 53  X1GR:   ld      (SX),BC         ; store SX
5679+ 37F9 ED 5B FF 52          ld      DE,(Y1)
5680+ 37FD 2A 07 53             ld      HL,(Y2)
5681+ 3800 B7                   or      A               ; clear Carry
5682+ 3801 ED 52                sbc     HL,DE           ; DY=Y2-Y1
5683+ 3803 CD DD 3F             call    absHL           ; DY=ABS(DY)
5684+ 3806 22 13 53             ld      (DY),HL         ; store DY
5685+ 3809 01 FF FF             ld      BC,$FFFF        ; SY=-1
5686+ 380C 2A FF 52             ld      HL,(Y1)
5687+ 380F ED 5B 07 53          ld      DE,(Y2)
5688+ 3813 CD B8 3F             call    CMP16           ; is Y1<Y2?
5689+ 3816 CA 1F 38             jp      Z,Y1GR          ; no, Y1=Y2
5690+ 3819 F2 1F 38             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5691+ 381C 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5692+ 381F ED 43 0F 53  Y1GR:   ld      (SY),BC         ; store SY
5693+ 3823 2A 13 53             ld      HL,(DY)         ; ER=DY
5694+ 3826 CD E0 3F             call    negHL           ; ER=-DY
5695+ 3829 22 09 53             ld      (ER),HL         ; store ER
5696+ 382C 2A 11 53             ld      HL,(DX)
5697+ 382F ED 5B 13 53          ld      DE,(DY)
5698+ 3833 CD B8 3F             call    CMP16           ; DX>DY?
5699+ 3836 CA 42 38             jp      Z,ER2           ; no, DX=DY
5700+ 3839 FA 42 38             jp      M,ER2           ; no, DX<DY
5701+ 383C 2A 11 53             ld      HL,(DX)         ; reload DX
5702+ 383F 22 09 53             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5703+ 3842 2A 09 53     ER2:    ld      HL,(ER)         ; load ER
5704+ 3845 CB 2C                sra     H               ; right shift (and preserve sign)...
5705+ 3847 CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5706+ 3849 CB 7C                bit     7,H             ; is the number negative?
5707+ 384B CA 4F 38             jp      Z,STRE2         ; no, jump over
5708+ 384E 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5709+ 384F 22 09 53     STRE2:  ld      (ER),HL         ; store ER
5710+ 3852 CD 1D 37     RPTDRW: call    CNTPLOT         ; plot first pixel
5711+ 3855 2A FD 52             ld      HL,(X1)
5712+ 3858 ED 5B 05 53          ld      DE,(X2)
5713+ 385C CD B8 3F             call    CMP16           ; X1=X2?
5714+ 385F 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5715+ 3861 2A FF 52             ld      HL,(Y1)         ; yes, so check
5716+ 3864 ED 5B 07 53          ld      DE,(Y2)         ; also Y
5717+ 3868 CD B8 3F             call    CMP16           ; Y1=Y2?
5718+ 386B CA C7 38             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5719+ 386E ED 5B 09 53  CNTDRW: ld      DE,(ER)
5720+ 3872 ED 53 0B 53          ld      (E2),DE         ; E2=ER
5721+ 3876 2A 11 53             ld      HL,(DX)
5722+ 3879 CD E0 3F             call    negHL           ; DX=-DX
5723+ 387C EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5724+ 387D CD B8 3F             call    CMP16           ; E2>-DX?
5725+ 3880 CA 9E 38             jp      Z,DXGR          ; no, E2=-DX: jump
5726+ 3883 FA 9E 38             jp      M,DXGR          ; no, E2<-DX: jump
5727+ 3886 2A 09 53             ld      HL,(ER)         ; yes
5728+ 3889 ED 5B 13 53          ld      DE,(DY)
5729+ 388D B7                   or      A               ; clear CARRY
5730+ 388E ED 52                sbc     HL,DE           ; ER=ER-DY
5731+ 3890 22 09 53             ld      (ER),HL
5732+ 3893 2A FD 52             ld      HL,(X1)
5733+ 3896 ED 5B 0D 53          ld      DE,(SX)
5734+ 389A 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5735+ 389B 22 FD 52             ld      (X1),HL
5736+ 389E 2A 0B 53     DXGR:   ld      HL,(E2)
5737+ 38A1 ED 5B 13 53          ld      DE,(DY)
5738+ 38A5 CD B8 3F             call    CMP16           ; E2<DY?
5739+ 38A8 CA 52 38             jp      Z,RPTDRW        ; no, E2=DY: jump
5740+ 38AB F2 52 38             jp      P,RPTDRW        ; no, E2>DY: jump
5741+ 38AE 2A 09 53             ld      HL,(ER)         ; yes
5742+ 38B1 ED 5B 11 53          ld      DE,(DX)
5743+ 38B5 19                   add     HL,DE           ; ER=ER+DX
5744+ 38B6 22 09 53             ld      (ER),HL
5745+ 38B9 2A FF 52             ld      HL,(Y1)
5746+ 38BC ED 5B 0F 53          ld      DE,(SY)
5747+ 38C0 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5748+ 38C1 22 FF 52             ld      (Y1),HL
5749+ 38C4 C3 52 38             jp      RPTDRW          ; repeat
5750+ 38C7 C1           ENDDRAW:pop     BC              ; retrieve BC
5751+ 38C8 D1                   pop     DE              ; retrieve DE
5752+ 38C9 E1                   pop     HL              ; retrieve HL
5753+ 38CA C9                   ret                     ; return to caller
5754+ 38CB
5755+ 38CB
5756+ 38CB              ; CIRCLE X,Y,R[,C]
5757+ 38CB              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5758+ 38CB              ; and radius R, with optional color C. If color is not specified, the
5759+ 38CB              ; foreground color set with COLOR will be used
5760+ 38CB              XC      equ     VIDEOBUFF
5761+ 38CB              YC      equ     VIDEOBUFF+$02
5762+ 38CB              RADIUS  equ     VIDEOBUFF+$04
5763+ 38CB              XI      equ     VIDEOBUFF+$06
5764+ 38CB              YI      equ     VIDEOBUFF+$08
5765+ 38CB              DC      equ     VIDEOBUFF+$0A
5766+ 38CB CD C7 34     CIRCLE: call    CHKG2M          ; check if in G2 mode
5767+ 38CE CD 9A 3A             call    CLRVDBF         ; clear VIDEOBUFF
5768+ 38D1 CD FD 28             call    GETINT          ; get X coords.
5769+ 38D4 32 05 53             ld      (XC),A          ; store it into a temp buffer
5770+ 38D7 CD AD 19             call    CHKSYN          ; Make sure ',' follows
5771+ 38DA 2C                   defb    ','
5772+ 38DB CD FD 28             call    GETINT          ; get Y coords,
5773+ 38DE 32 07 53             ld      (YC),A          ; store it into a temp buffer
5774+ 38E1 CD AD 19             call    CHKSYN          ; Make sure ',' follows
5775+ 38E4 2C                   defb    ','
5776+ 38E5 CD FD 28             call    GETINT          ; get radius
5777+ 38E8 32 09 53             ld      (RADIUS),A      ; store it into a temp buffer
5778+ 38EB CD B2 3A             call    CLRPRM          ; check if param "color" has been passed
5779+ 38EE C5                   push    BC              ; store BC
5780+ 38EF D5                   push    DE              ; store DE
5781+ 38F0 E5                   push    HL              ; store HL
5782+ 38F1 AF                   xor     A               ; clear A,
5783+ 38F2 47                   ld      B,A             ; B,
5784+ 38F3 4F                   ld      C,A             ; C,
5785+ 38F4 57                   ld      D,A             ; D,
5786+ 38F5 67                   ld      H,A             ; and H
5787+ 38F6 ED 43 0B 53          ld      (XI),BC         ; clear XI
5788+ 38FA 3A 09 53             ld      A,(RADIUS)      ; load RADIUS into A
5789+ 38FD 6F                   ld      L,A             ; HL now contains R
5790+ 38FE 22 0D 53             ld      (YI),HL         ; YI=RADIUS
5791+ 3901 29                   add     HL,HL           ; R*2
5792+ 3902 EB                   ex      DE,HL           ; put HL into DE
5793+ 3903 21 03 00             ld      HL,$0003        ; HL = 3
5794+ 3906 AF                   xor     A               ; clear Carry
5795+ 3907 ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5796+ 3909 22 0F 53             ld      (DC),HL         ; store D
5797+ 390C CD 6B 39             call    DRWCRL          ; draw initial point
5798+ 390F ED 5B 0B 53  RPTCRL: ld      DE,(XI)         ; load XI
5799+ 3913 2A 0D 53             ld      HL,(YI)         ; load YI
5800+ 3916 CD B8 3F             call    CMP16           ; is YI<DI?
5801+ 3919 CA 22 39             jp      Z,RPTCL1        ; no, YI=XI
5802+ 391C F2 22 39             jp      P,RPTCL1        ; no, YI>XI
5803+ 391F C3 67 39             jp      ENDCRL          ; yes, so we've finished
5804+ 3922 21 0B 53     RPTCL1: ld      HL,XI
5805+ 3925 34                   inc     (HL)            ; XI=XI+1
5806+ 3926 2A 0F 53             ld      HL,(DC)         ; load D
5807+ 3929 7C                   ld      A,H
5808+ 392A B5                   or      L               ; is D=0? Yes, jump over
5809+ 392B CA 4F 39             jp      Z,DLSZ
5810+ 392E CB 7C                bit     7,H             ; is D<0?
5811+ 3930 20 1D                jr      NZ,DLSZ         ; yes, jump over
5812+ 3932 ED 5B 0D 53          ld      DE,(YI)         ; D>0
5813+ 3936 1B                   dec     DE              ; so, YI=YI-1
5814+ 3937 ED 53 0D 53          ld      (YI),DE         ; store YI
5815+ 393B AF                   xor     A               ; clear Carry
5816+ 393C 2A 0B 53             ld      HL,(XI)
5817+ 393F ED 52                sbc     HL,DE           ; HL=XI-YI
5818+ 3941 29                   add     HL,HL
5819+ 3942 29                   add     HL,HL           ; HL=HL*4
5820+ 3943 11 0A 00             ld      DE,10
5821+ 3946 19                   add     HL,DE           ; HL=HL+10
5822+ 3947 ED 5B 0F 53          ld      DE,(DC)         ; load D
5823+ 394B EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5824+ 394C 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5825+ 394D 18 0F                jr      PLTCRL          ; plot next pixel
5826+ 394F 2A 0B 53     DLSZ:   ld      HL,(XI)         ; load XI
5827+ 3952 29                   add     HL,HL
5828+ 3953 29                   add     HL,HL           ; XI=XI*4
5829+ 3954 11 06 00             ld      DE,$0006
5830+ 3957 19                   add     HL,DE
5831+ 3958 ED 5B 0F 53          ld      DE,(DC)
5832+ 395C EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5833+ 395D 19                   add     HL,DE           ; D=D+4*XI+6
5834+ 395E 22 0F 53     PLTCRL: ld      (DC),HL         ; store new D
5835+ 3961 CD 6B 39             call    DRWCRL          ; plot pixel
5836+ 3964 C3 0F 39             jp      RPTCRL          ; repeat
5837+ 3967 E1           ENDCRL: pop     HL
5838+ 3968 D1                   pop     DE
5839+ 3969 C1                   pop     BC
5840+ 396A C9                   ret                     ; return to caller
5841+ 396B 2A 05 53     DRWCRL: ld      HL,(XC)
5842+ 396E ED 5B 0B 53          ld      DE,(XI)
5843+ 3972 19                   add     HL,DE           ; X=XC+XI
5844+ 3973 22 FD 52             ld      (X1),HL         ; store X
5845+ 3976 CD 8A 3A             call    VALIDX          ; check if X is valid (0~255)
5846+ 3979 DA 8D 39             jp      C,CNTCL1        ; if Carry is set, X is not valid
5847+ 397C 2A 07 53             ld      HL,(YC)
5848+ 397F ED 5B 0D 53          ld      DE,(YI)
5849+ 3983 19                   add     HL,DE           ; Y=YC+YI
5850+ 3984 22 FF 52             ld      (Y1),HL         ; store Y
5851+ 3987 CD 8F 3A             call    VALIDY          ; check if Y is valid (0~191)
5852+ 398A D4 1D 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5853+ 398D AF           CNTCL1: xor     A               ; clear Carry
5854+ 398E 2A 05 53             ld      HL,(XC)
5855+ 3991 ED 5B 0B 53          ld      DE,(XI)
5856+ 3995 ED 52                sbc     HL,DE           ; X=XC-XI
5857+ 3997 22 FD 52             ld      (X1),HL         ; store X
5858+ 399A CD 8A 3A             call    VALIDX          ; check if X is valid (0~255)
5859+ 399D DA B1 39             jp      C,CNTCL2        ; if Carry is set, X is not valid
5860+ 39A0 2A 07 53             ld      HL,(YC)
5861+ 39A3 ED 5B 0D 53          ld      DE,(YI)
5862+ 39A7 19                   add     HL,DE           ; Y=YC+YI
5863+ 39A8 22 FF 52             ld      (Y1),HL         ; store Y
5864+ 39AB CD 8F 3A             call    VALIDY          ; check if Y is valid (0~191)
5865+ 39AE D4 1D 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5866+ 39B1 2A 05 53     CNTCL2: ld      HL,(XC)
5867+ 39B4 ED 5B 0B 53          ld      DE,(XI)
5868+ 39B8 19                   add     HL,DE           ; X=XC+XI
5869+ 39B9 22 FD 52             ld      (X1),HL         ; store X
5870+ 39BC CD 8A 3A             call    VALIDX          ; check if X is valid (0~255)
5871+ 39BF DA D5 39             jp      C,CNTCL3        ; if Carry is set, X is not valid
5872+ 39C2 AF                   xor     A               ; clear Carry
5873+ 39C3 2A 07 53             ld      HL,(YC)
5874+ 39C6 ED 5B 0D 53          ld      DE,(YI)
5875+ 39CA ED 52                sbc     HL,DE           ; Y=YC-YI
5876+ 39CC 22 FF 52             ld      (Y1),HL         ; store Y
5877+ 39CF CD 8F 3A             call    VALIDY          ; check if Y is valid (0~191)
5878+ 39D2 D4 1D 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5879+ 39D5 AF           CNTCL3: xor     A               ; clear Carry
5880+ 39D6 2A 05 53             ld      HL,(XC)
5881+ 39D9 ED 5B 0B 53          ld      DE,(XI)
5882+ 39DD ED 52                sbc     HL,DE           ; X=XC-XI
5883+ 39DF 22 FD 52             ld      (X1),HL         ; store X
5884+ 39E2 CD 8A 3A             call    VALIDX          ; check if X is valid (0~255)
5885+ 39E5 DA FB 39             jp      C,CNTCL4        ; if Carry is set, X is not valid
5886+ 39E8 AF                   xor     A               ; clear Carry
5887+ 39E9 2A 07 53             ld      HL,(YC)
5888+ 39EC ED 5B 0D 53          ld      DE,(YI)
5889+ 39F0 ED 52                sbc     HL,DE           ; Y=YC-YI
5890+ 39F2 22 FF 52             ld      (Y1),HL         ; store Y
5891+ 39F5 CD 8F 3A             call    VALIDY          ; check if Y is valid (0~191)
5892+ 39F8 D4 1D 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5893+ 39FB 2A 05 53     CNTCL4: ld      HL,(XC)
5894+ 39FE ED 5B 0D 53          ld      DE,(YI)
5895+ 3A02 19                   add     HL,DE           ; X=XC+YI
5896+ 3A03 22 FD 52             ld      (X1),HL         ; store X
5897+ 3A06 CD 8A 3A             call    VALIDX          ; check if X is valid (0~255)
5898+ 3A09 DA 1D 3A             jp      C,CNTCL5        ; if Carry is set, X is not valid
5899+ 3A0C 2A 07 53             ld      HL,(YC)
5900+ 3A0F ED 5B 0B 53          ld      DE,(XI)
5901+ 3A13 19                   add     HL,DE           ; Y=YC+XI
5902+ 3A14 22 FF 52             ld      (Y1),HL         ; store Y
5903+ 3A17 CD 8F 3A             call    VALIDY          ; check if Y is valid (0~191)
5904+ 3A1A D4 1D 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5905+ 3A1D AF           CNTCL5: xor     A               ; clear Carry
5906+ 3A1E 2A 05 53             ld      HL,(XC)
5907+ 3A21 ED 5B 0D 53          ld      DE,(YI)
5908+ 3A25 ED 52                sbc     HL,DE           ; X=XC-YI
5909+ 3A27 22 FD 52             ld      (X1),HL         ; store X
5910+ 3A2A CD 8A 3A             call    VALIDX          ; check if X is valid (0~255)
5911+ 3A2D DA 41 3A             jp      C,CNTCL6        ; if Carry is set, X is not valid
5912+ 3A30 2A 07 53             ld      HL,(YC)
5913+ 3A33 ED 5B 0B 53          ld      DE,(XI)
5914+ 3A37 19                   add     HL,DE           ; Y=YC+XI
5915+ 3A38 22 FF 52             ld      (Y1),HL         ; store Y
5916+ 3A3B CD 8F 3A             call    VALIDY          ; check if Y is valid (0~191)
5917+ 3A3E D4 1D 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5918+ 3A41 2A 05 53     CNTCL6: ld      HL,(XC)
5919+ 3A44 ED 5B 0D 53          ld      DE,(YI)
5920+ 3A48 19                   add     HL,DE           ; X=XC+YI
5921+ 3A49 22 FD 52             ld      (X1),HL         ; store X
5922+ 3A4C CD 8A 3A             call    VALIDX          ; check if X is valid (0~255)
5923+ 3A4F DA 65 3A             jp      C,CNTCL7        ; if Carry is set, X is not valid
5924+ 3A52 AF                   xor     A               ; clear Carry
5925+ 3A53 2A 07 53             ld      HL,(YC)
5926+ 3A56 ED 5B 0B 53          ld      DE,(XI)
5927+ 3A5A ED 52                sbc     HL,DE           ; Y=YC-XI
5928+ 3A5C 22 FF 52             ld      (Y1),HL         ; store Y
5929+ 3A5F CD 8F 3A             call    VALIDY          ; check if Y is valid (0~191)
5930+ 3A62 D4 1D 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5931+ 3A65 AF           CNTCL7: xor     A               ; clear Carry
5932+ 3A66 2A 05 53             ld      HL,(XC)
5933+ 3A69 ED 5B 0D 53          ld      DE,(YI)
5934+ 3A6D ED 52                sbc     HL,DE           ; X=XC-YI
5935+ 3A6F 22 FD 52             ld      (X1),HL         ; store X
5936+ 3A72 CD 8A 3A             call    VALIDX          ; check if X is valid (0~255)
5937+ 3A75 D8                   ret     C               ; if Carry is set, X is not valid
5938+ 3A76 AF                   xor     A               ; clear Carry
5939+ 3A77 2A 07 53             ld      HL,(YC)
5940+ 3A7A ED 5B 0B 53          ld      DE,(XI)
5941+ 3A7E ED 52                sbc     HL,DE           ; Y=YC-XI
5942+ 3A80 22 FF 52             ld      (Y1),HL         ; store Y
5943+ 3A83 CD 8F 3A             call    VALIDY          ; check if Y is valid (0~191)
5944+ 3A86 D4 1D 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5945+ 3A89 C9                   ret                     ; return to caller
5946+ 3A8A
5947+ 3A8A              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
5948+ 3A8A              ; input: HL (value to check), can be negative
5949+ 3A8A              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
5950+ 3A8A              ; destroys: A
5951+ 3A8A AF           VALIDX: xor     A               ; reset A
5952+ 3A8B B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
5953+ 3A8C C8                   ret     Z               ; yes, we can return (C is clear)
5954+ 3A8D 37                   scf                     ; set Carry flag to raise error
5955+ 3A8E C9                   ret                     ; return to caller
5956+ 3A8F
5957+ 3A8F AF           VALIDY: xor     A               ; reset A
5958+ 3A90 B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
5959+ 3A91 28 02                jr      Z,CNTVALY       ; yes, continue checking
5960+ 3A93 37                   scf                     ; no, raise error by setting Carry flag
5961+ 3A94 C9                   ret                     ; return to caller
5962+ 3A95 7D           CNTVALY:ld      A,L
5963+ 3A96 FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
5964+ 3A98 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
5965+ 3A99 C9                   ret                     ; return to caller
5966+ 3A9A
5967+ 3A9A
5968+ 3A9A              ; clear VIDEOBUFF before using it as temp buffer
5969+ 3A9A AF           CLRVDBF:xor     A               ; clear A
5970+ 3A9B C5                   push    BC              ; store BC
5971+ 3A9C E5                   push    HL              ; store HL
5972+ 3A9D 21 FD 52             ld      HL,TMPBFR1      ; address of 1st cell
5973+ 3AA0 06 06                ld      B,$06           ; 6 cells
5974+ 3AA2 77           RPTCVB1:ld      (HL),A          ; clear cell
5975+ 3AA3 23                   inc     HL              ; next cell
5976+ 3AA4 10 FC                djnz    RPTCVB1         ; repeat
5977+ 3AA6 06 28                ld      B,$28           ; 40 cells
5978+ 3AA8 21 05 53             ld      HL,VIDEOBUFF    ; address of 1st cell
5979+ 3AAB 77           RPTCVB2:ld      (HL),A          ; clear cell
5980+ 3AAC 23                   inc     HL              ; next cell
5981+ 3AAD 10 FC                djnz    RPTCVB2         ; repeat
5982+ 3AAF E1                   pop     HL              ; retrieve HL
5983+ 3AB0 C1                   pop     BC              ; retrieve BC
5984+ 3AB1 C9                   ret                     ; return to caller
5985+ 3AB2
5986+ 3AB2
5987+ 3AB2              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
5988+ 3AB2              ; commands. If not present, the default foreground color will be used
5989+ 3AB2 3A FB 52     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
5990+ 3AB5 32 01 53             ld      (TMPBFR3),A     ; store into temp buffer
5991+ 3AB8 2B                   dec     HL              ; dec 'cos GETCHR INCs
5992+ 3AB9 CD EE 1B             call    GETCHR          ; Get next character
5993+ 3ABC C8                   ret     Z               ; return foreground color if nothing follows
5994+ 3ABD CD AD 19             call    CHKSYN          ; Make sure ',' follows
5995+ 3AC0 2C                   defb    ','
5996+ 3AC1 CD FD 28             call    GETINT          ; get value
5997+ 3AC4 CD C1 34             call    CHKCLR0         ; check if color is in range 0~15
5998+ 3AC7 32 01 53             ld      (TMPBFR3),A     ; store color into temp buffer
5999+ 3ACA C9                   ret                     ; return to caller
6000+ 3ACB
6001+ 3ACB
6002+ 3ACB              ; no graphics mode error: raised when a graphics command is invoked
6003+ 3ACB              ; out of graphic 2 mode.
6004+ 3ACB 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6005+ 3ACD C3 DF 16             jp      ERROR           ; print error
6006+ 3AD0
6007+ 3AD0
6008+ 3AD0              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6009+ 3AD0              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6010+ 3AD0              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6011+ 3AD0              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6012+ 3AD0              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6013+ 3AD0              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6014+ 3AD0              ; they are assumed to be 8,0,1 resp.
6015+ 3AD0              PRTNUM  equ     VIDEOBUFF
6016+ 3AD0              BPS     equ     VIDEOBUFF+$01
6017+ 3AD0              DATABT  equ     BPS+$02
6018+ 3AD0              PARBT   equ     DATABT+$01
6019+ 3AD0              STPBT   equ     PARBT+$01
6020+ 3AD0              SIOBFR  equ     STPBT+$01
6021+ 3AD0 CD FD 28     SERIAL: call    GETINT          ; get port #
6022+ 3AD3 A7                   and     A               ; is it zero?
6023+ 3AD4 CA B9 1C             jp      Z,FCERR         ; yes, error
6024+ 3AD7 FE 03                cp      $03             ; is it 1 or 2?
6025+ 3AD9 D2 F9 3C             jp      NC,SCERR        ; no, error
6026+ 3ADC 32 05 53             ld      (PRTNUM),A      ; store port number into a temp buffer
6027+ 3ADF CD AD 19             call    CHKSYN          ; Make sure ',' follows
6028+ 3AE2 2C                   defb    ','
6029+ 3AE3 2B                   dec     HL
6030+ 3AE4 CD EE 1B             call    GETCHR          ; check what's following
6031+ 3AE7 CA CB 16             jp      Z,SNERR         ; error if nothing follows
6032+ 3AEA 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6033+ 3AEC CD BE 1C             call    ATOH            ; get bps (returned into DE)
6034+ 3AEF 18 0F                jr      CHKZSER         ; jump over
6035+ 3AF1 CD 77 20     SERVAR: call    GETNUM          ; get number
6036+ 3AF4 CD 84 2E             call    TSTSGN          ; check value
6037+ 3AF7 FA B9 1C             jp      M,FCERR         ; negative - illegal function call
6038+ 3AFA 3A 54 53             ld      A,(FPEXP)       ; Get integer value to DE
6039+ 3AFD CD 2C 2F             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6040+ 3B00 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6041+ 3B01 B3                   or      E               ; check if bps=0
6042+ 3B02 20 3A                jr      NZ,CNTSER       ; no, continue checking
6043+ 3B04                      ; if baud rate is 0, then close the serial comm.
6044+ 3B04 3A 05 53     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6045+ 3B07 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6046+ 3B08 C6 22                add     SIO_CA          ; find correct channel
6047+ 3B0A 4F                   ld      C,A             ; store serial channel
6048+ 3B0B F3                   di                      ; disable INTs
6049+ 3B0C AF                   xor     A               ; reset A
6050+ 3B0D 16 01                ld      D,$01           ; start from WR1
6051+ 3B0F 06 05                ld      B,$05           ; 5 registers
6052+ 3B11 ED 51        RPTRSSR:out     (C),D           ; select register
6053+ 3B13 ED 79                out     (C),A           ; reset register
6054+ 3B15 14                   inc     D               ; next register
6055+ 3B16 10 F9                djnz    RPTRSSR         ; repeat
6056+ 3B18 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6057+ 3B1A ED 79                out     (C),A           ; send command to serial channel
6058+ 3B1C 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6059+ 3B1E ED 79                out     (C),A           ; send command to serial channel
6060+ 3B20 FB                   ei                      ; re-enable INTs
6061+ 3B21 E5                   push    HL              ; store HL
6062+ 3B22 21 3F 53             ld      HL,SERIALS_EN   ; serials enabled status byte
6063+ 3B25 DB 01                in      A,(PIO_DB)      ; read status LEDs
6064+ 3B27 CB 41                bit     0,C             ; check serial port
6065+ 3B29 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6066+ 3B2B CB B7                res     6,A             ; it's port 1
6067+ 3B2D CB A7                res     4,A             ; remove possible error LED
6068+ 3B2F CB 86                res     0,(HL)          ; disable port 1
6069+ 3B31 C3 3A 3B             jp      SERLED          ; jump over
6070+ 3B34 CB BF        SRPT2:  res     7,A             ; it's port 2
6071+ 3B36 CB AF                res     5,A             ; remove possible error LED
6072+ 3B38 CB 8E                res     1,(HL)          ; disable port 2
6073+ 3B3A D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6074+ 3B3C E1                   pop     HL              ; retrieve HL
6075+ 3B3D C9                   ret                     ; return to caller
6076+ 3B3E                      ; check if bps=1, meaning reactivate RX on serial
6077+ 3B3E 7A           CNTSER: ld      A,D
6078+ 3B3F B2                   or      D               ; check if bps<>1 by first checking D=0
6079+ 3B40 20 36                jr      NZ,CNTSER2      ; if not, jump over
6080+ 3B42 7B                   ld      A,E             ; then by checking that
6081+ 3B43 FE 01                cp      $01             ; E=1
6082+ 3B45 20 31                jr      NZ,CNTSER2      ; if not, jump over
6083+ 3B47 3A 05 53             ld      A,(PRTNUM)      ; load port number
6084+ 3B4A 57                   ld      D,A             ; store port on D
6085+ 3B4B 3A 3F 53             ld      A,(SERIALS_EN)  ; load address of serial status cell
6086+ 3B4E A2                   and     D               ; check status
6087+ 3B4F CA F9 3C             jp      Z,SCERR         ; port not open, raise error
6088+ 3B52 F3                   di                      ; disable INTs
6089+ 3B53 7A                   ld      A,D             ; move port # into A
6090+ 3B54 5F                   ld      E,A             ; and also into E
6091+ 3B55 87                   add     A
6092+ 3B56 87                   add     A               ; move A to left times 2
6093+ 3B57 57                   ld      D,A             ; move value into D
6094+ 3B58 3A 3F 53             ld      A,(SERIALS_EN)  ; load serial status byte
6095+ 3B5B B2                   or      D               ; re-enable RX
6096+ 3B5C 32 3F 53             ld      (SERIALS_EN),A  ; store new serial status
6097+ 3B5F 7B                   ld      A,E             ; recover port #
6098+ 3B60 3D                   dec     A               ; check port
6099+ 3B61 20 0A                jr      NZ,CNTRX2       ; port is #2
6100+ 3B63 CD DA 01             call    SIO_A_EI        ; re-enable RX on port 1
6101+ 3B66 DB 01                in      A,(PIO_DB)      ; load status LEDs
6102+ 3B68 CB A7                res     4,A             ; remove error LED
6103+ 3B6A C3 74 3B             jp      RXEND           ; terminate setting
6104+ 3B6D CD E2 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6105+ 3B70 DB 01                in      A,(PIO_DB)      ; load status LEDs
6106+ 3B72 CB AF                res     5,A             ; remove error LED
6107+ 3B74 D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6108+ 3B76 FB                   ei                      ; re-enable INTs
6109+ 3B77 C9                   ret                     ; return to caller
6110+ 3B78                      ; set serial port comm.
6111+ 3B78 D5           CNTSER2:push    DE              ; store BPS
6112+ 3B79 3A 05 53             ld      A,(PRTNUM)      ; load port number
6113+ 3B7C 57                   ld      D,A             ; move port # into D
6114+ 3B7D 3A 3F 53             ld      A,(SERIALS_EN)  ; check if serial port is already open
6115+ 3B80 A2                   and     D               ; by ANDing A with D
6116+ 3B81 D1                   pop     DE              ; retrieve BPS
6117+ 3B82 CA 8A 3B             jp      Z,CNTSER3       ; not open, continue
6118+ 3B85 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6119+ 3B87 C3 DF 16             jp      ERROR           ; and leave
6120+ 3B8A E5           CNTSER3:push    HL              ; store HL
6121+ 3B8B 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6122+ 3B8E CD B8 3F             call    CMP16           ; is bps<=57,600?
6123+ 3B91 E1                   pop     HL              ; but first, recover HL
6124+ 3B92 DA F9 3C             jp      C,SCERR         ; no (bps>57,600) then error
6125+ 3B95 ED 53 06 53          ld      (BPS),DE        ; store bps
6126+ 3B99 2B                   dec     HL              ; dec 'cos GETCHR INCs
6127+ 3B9A CD EE 1B             call    GETCHR          ; Get next character
6128+ 3B9D CA D5 3B             jp      Z,DEFSER        ; defaults if nothing follows
6129+ 3BA0 CD AD 19             call    CHKSYN          ; Make sure ',' follows
6130+ 3BA3 2C                   defb    ','
6131+ 3BA4 CD FD 28             call    GETINT          ; get data bits
6132+ 3BA7 FE 05                cp      $05             ; is it <5?
6133+ 3BA9 DA F9 3C             jp      C,SCERR         ; yes, error
6134+ 3BAC FE 09                cp      $09             ; is it >=9?
6135+ 3BAE D2 B9 1C             jp      NC,FCERR        ; yes, error
6136+ 3BB1 32 08 53             ld      (DATABT),A      ; store data bits
6137+ 3BB4 CD AD 19             call    CHKSYN          ; Make sure ',' follows
6138+ 3BB7 2C                   defb    ','
6139+ 3BB8 CD FD 28             call    GETINT          ; get parity bits
6140+ 3BBB BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6141+ 3BBE D2 F9 3C             jp      NC,SCERR        ; no, error
6142+ 3BC1 32 09 53             ld      (PARBT),A       ; store parity
6143+ 3BC4 CD AD 19             call    CHKSYN          ; Make sure ',' follows
6144+ 3BC7 2C                   defb    ','
6145+ 3BC8 CD FD 28             call    GETINT          ; get stop bits
6146+ 3BCB FE 03                cp      $03             ; is it >=3?
6147+ 3BCD D2 F9 3C             jp      NC,SCERR        ; yes, error
6148+ 3BD0 32 0A 53             ld      (STPBT),A       ; store stop bits
6149+ 3BD3 18 0D                jr      SETSER          ; jump to set serial
6150+ 3BD5 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6151+ 3BD7 32 08 53             ld      (DATABT),A
6152+ 3BDA AF                   xor     A               ; no parity bit
6153+ 3BDB 32 09 53             ld      (PARBT),A
6154+ 3BDE 3C                   inc     A               ; 1 bit for stop
6155+ 3BDF 32 0A 53             ld      (STPBT),A
6156+ 3BE2                      ; check if bps are legal
6157+ 3BE2 E5           SETSER: push    HL              ; store HL
6158+ 3BE3 D5                   push    DE              ; store DE
6159+ 3BE4 DD E5                push    IX              ; store IX
6160+ 3BE6 DD 21 D4 3C          ld      IX,SUP_BPS      ; allowed BPSs
6161+ 3BEA 06 0B                ld      B,$0B           ; 11 items
6162+ 3BEC 0E 00                ld      C,$00           ; reset pointer
6163+ 3BEE 2A 06 53     CKBPS:  ld      HL,(BPS)        ; load BPS
6164+ 3BF1 DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6165+ 3BF4 DD 56 01             ld      D,(IX+1)        ; load MSB of item
6166+ 3BF7 CD B8 3F             call    CMP16           ; is it equal?
6167+ 3BFA CA 07 3C             jp      Z,SET_PT        ; yes, found a correspondance
6168+ 3BFD DD 23                inc     IX
6169+ 3BFF DD 23                inc     IX              ; no, go to next entry
6170+ 3C01 0C                   inc     C               ; increment pointer
6171+ 3C02 10 EA                djnz    CKBPS           ; repeat for 10 entries
6172+ 3C04 C3 F5 3C             jp      SCERR1          ; if nothing found, raise an error
6173+ 3C07              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6174+ 3C07                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6175+ 3C07                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6176+ 3C07                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6177+ 3C07 F3                   di                      ; disable INTs
6178+ 3C08 06 00                ld      B,$00           ; reset B
6179+ 3C0A 21 EA 3C             ld      HL,CTC_CFG      ; address of first CTC divider
6180+ 3C0D 09                   add     HL,BC           ; adjust for correct CTC divider
6181+ 3C0E 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6182+ 3C10 3A 05 53             ld      A,(PRTNUM)      ; load port number
6183+ 3C13 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6184+ 3C14 DA 18 3C             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6185+ 3C17 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6186+ 3C18 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6187+ 3C1A                                              ; start upon loading time constant, time constant follows, sw reset, command word
6188+ 3C1A ED 79                out     (C),A           ; configure CTC channel
6189+ 3C1C 7E                   ld      A,(HL)          ; load CTC divider
6190+ 3C1D ED 79                out     (C),A           ; send divider
6191+ 3C1F                      ; configure SIO
6192+ 3C1F 21 38 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6193+ 3C22 11 0B 53             ld      DE,SIOBFR       ; into a temp buffer
6194+ 3C25 01 0A 00             ld      BC,$000A        ; 10 items to copy
6195+ 3C28 ED B0                ldir                    ; copy SIO settings into TEMP buffer
6196+ 3C2A 3A 10 53             ld      A,(SIOBFR+5)    ; load WR5 setting
6197+ 3C2D 47                   ld      B,A             ; move it into B
6198+ 3C2E 3A 08 53             ld      A,(DATABT)      ; load DATA bits
6199+ 3C31 FE 05                cp      $05             ; is it 5 bits?
6200+ 3C33 20 06                jr      NZ,BITS6        ; no, jump over
6201+ 3C35 CB B0                res     6,B
6202+ 3C37 CB A8                res     5,B             ; set D6 & D5 to 0
6203+ 3C39 18 19                jr      SETPAR          ; jump to set parity
6204+ 3C3B FE 06        BITS6:  cp      $06             ; is it 6 bits?
6205+ 3C3D 20 06                jr      NZ,BITS7        ; no, jump over
6206+ 3C3F CB F0                set     6,B
6207+ 3C41 CB A8                res     5,B             ; set D6 & D5 to 1,0
6208+ 3C43 18 0F                jr      SETPAR          ; jump to set parity
6209+ 3C45 FE 07        BITS7:  cp      $07             ; is it 7 bits?
6210+ 3C47 20 07                jr      NZ,BITS8        ; no, jump over
6211+ 3C49 CB B0                res     6,B
6212+ 3C4B CB E8                set     5,B             ; set D6 & D5 to 0,1
6213+ 3C4D C3 54 3C             jp      SETPAR          ; jump to set parity
6214+ 3C50 CB F0        BITS8:  set     6,B
6215+ 3C52 CB E8                set     5,B             ; set D6 & D5 to 1,1
6216+ 3C54 21 40 53     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6217+ 3C57 3A 05 53             ld      A,(PRTNUM)      ; check serial port number
6218+ 3C5A 3D                   dec     A               ; is it port #1?
6219+ 3C5B CA 5F 3C             jp      Z,SETPAR2       ; yes, jump over
6220+ 3C5E 23                   inc     HL              ; port #2, use SERBBITS instead
6221+ 3C5F 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6222+ 3C60 32 10 53             ld      (SIOBFR+5),A    ; save DATA bits
6223+ 3C63 E6 60                and     %01100000       ; filter only D5&D6 bits
6224+ 3C65 87                   add     A,A             ; shift left times 1
6225+ 3C66 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6226+ 3C67 3A 0A 53             ld      A,(STPBT)       ; load STOP bits
6227+ 3C6A 87                   add     A,A
6228+ 3C6B 87                   add     A,A             ; 2 left shifts
6229+ 3C6C 47                   ld      B,A             ; move forming byte into B
6230+ 3C6D 3A 09 53             ld      A,(PARBT)       ; load PARITY setting
6231+ 3C70 A7                   and     A               ; is it 0?
6232+ 3C71 CA 7C 3C             jp      Z,STRPAR        ; yes, jump over
6233+ 3C74 CB C0                set     0,B             ; set PARITY on
6234+ 3C76 3D                   dec     A               ; is parity ODD?
6235+ 3C77 CA 7C 3C             jp      Z,STRPAR        ; yes, so jump over
6236+ 3C7A CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6237+ 3C7C 3A 0E 53     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6238+ 3C7F E6 F0                and     %11110000       ; reset STOP & PARITY bits
6239+ 3C81 B0                   or      B               ; set new STOP & PARITY bits
6240+ 3C82 32 0E 53             ld      (SIOBFR+3),A    ; store new value
6241+ 3C85                      ;set up TX and RX:
6242+ 3C85                      ; the followings are settings for channel A
6243+ 3C85 21 0B 53             ld      HL,SIOBFR       ; settings for SIO ch. A
6244+ 3C88 06 06                ld      B,$06           ; 6 bytes to send
6245+ 3C8A 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6246+ 3C8C 3A 05 53             ld      A,(PRTNUM)      ; load port number
6247+ 3C8F 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6248+ 3C90 DA 94 3C             jp      C,SRLCNT        ; port 1, continue
6249+ 3C93 0C                   inc     C               ; port 2, increment address port into C
6250+ 3C94 ED B3        SRLCNT: otir                    ; send bytes to SIO
6251+ 3C96                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6252+ 3C96 06 04                ld      B,$04           ; other 4 bytes to send
6253+ 3C98 51                   ld      D,C             ; store port address into D
6254+ 3C99 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6255+ 3C9B ED B3                otir                    ; send bytes to SIO
6256+ 3C9D                      ; the following are settings for selected channel
6257+ 3C9D 3E 01                ld      A,$01           ; write into WR0: select WR1
6258+ 3C9F 4A                   ld      C,D             ; retrieve port address
6259+ 3CA0 ED 79                out     (C),A
6260+ 3CA2 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6261+ 3CA4                                              ; buffer overrun is special condition
6262+ 3CA4 ED 79                out     (C),A
6263+ 3CA6 21 3F 53             ld      HL,SERIALS_EN
6264+ 3CA9 3A 05 53             ld      A,(PRTNUM)      ; retrieve serial channel
6265+ 3CAC 3D                   dec     A               ; channel A?
6266+ 3CAD 20 10                jr      NZ,ENCHB        ; no, jump over
6267+ 3CAF CD DA 01             call    SIO_A_EI        ; enable RX on SIO channel A
6268+ 3CB2 CB C6                set     0,(HL)          ; set serial port 1 status ON
6269+ 3CB4 CB D6                set     2,(HL)          ; set serial port 1 RX ON
6270+ 3CB6                      ; back to normal running
6271+ 3CB6 FB                   ei                      ; re-enable INTs
6272+ 3CB7 DB 01                in      A,(PIO_DB)      ; load status LEDs
6273+ 3CB9 CB F7                set     6,A             ; set status LED on
6274+ 3CBB CB A7                res     4,A             ; set error LED off
6275+ 3CBD 18 0E                jr      EXNRM           ; leave
6276+ 3CBF CD E2 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6277+ 3CC2 CB CE                set     1,(HL)          ; set serial port 2 status ON
6278+ 3CC4 CB DE                set     3,(HL)          ; set serial port 2 RX ON
6279+ 3CC6                      ; back to normal running
6280+ 3CC6 FB                   ei                      ; re-enable INTs
6281+ 3CC7 DB 01                in      A,(PIO_DB)      ; load status LEDs
6282+ 3CC9 CB FF                set     7,A             ; set status LED on
6283+ 3CCB CB AF                res     5,A             ; set error LED off
6284+ 3CCD D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6285+ 3CCF DD E1                pop     IX              ; retrieve IX
6286+ 3CD1 D1                   pop     DE              ; retrieve DE
6287+ 3CD2 E1                   pop     HL              ; retrieve HL
6288+ 3CD3 C9                   ret                     ; return to caller
6289+ 3CD4
6290+ 3CD4              ; allowed bps (Bauds per second)
6291+ 3CD4 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6291+ 3CD8 80 70 00 4B
6291+ 3CDC 40 38 80 25
6291+ 3CE0 C0 12 10 0E
6291+ 3CE4 60 09 B0 04
6291+ 3CE8 58 02
6292+ 3CEA              ; corresponding CTC divider
6293+ 3CEA 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6293+ 3CEE 08 0C 18 20
6293+ 3CF2 30 60 C0
6294+ 3CF5
6295+ 3CF5
6296+ 3CF5              ; serial configuration error
6297+ 3CF5 DD E1        SCERR1: pop     IX              ; retrieve IX
6298+ 3CF7 D1                   pop     DE              ; retrieve DE
6299+ 3CF8 E1                   pop     HL              ; retrieve HL
6300+ 3CF9 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6301+ 3CFB C3 DF 16             jp      ERROR           ; print error
6302+ 3CFE
6303+ 3CFE
6304+ 3CFE              ; serial buffer overrun
6305+ 3CFE CD BB 1E     SOERR:  call    PRNTCRLF
6306+ 3D01 1E 30                ld      E,SO            ; Serial Buffer Overrun
6307+ 3D03 C3 DF 16             jp      ERROR
6308+ 3D06
6309+ 3D06
6310+ 3D06              ; check for direct mode
6311+ 3D06 E5           DIRMOD: push    HL              ; Save code string address
6312+ 3D07 2A CE 51             ld      HL,(LINEAT)     ; Get current line number
6313+ 3D0A 23                   inc     HL              ; -1 means direct statement
6314+ 3D0B 7C                   ld      A,H
6315+ 3D0C B5                   or      L
6316+ 3D0D E1                   pop     HL              ; Restore code string address
6317+ 3D0E C2 28 3D             jp      NZ,HLPERR       ; raise error if in indirect mode
6318+ 3D11 C9                   ret
6319+ 3D12
6320+ 3D12
6321+ 3D12              ; HELP lists the line program where an error occured
6322+ 3D12 CD 06 3D     HELP:   call    DIRMOD          ; check if in direct mode
6323+ 3D15 E5                   push    HL              ; store HL
6324+ 3D16 2A D0 51             ld      HL,(HLPLN)      ; load HELP line
6325+ 3D19 23                   inc     HL              ; increment HL
6326+ 3D1A 7C                   ld      A,H
6327+ 3D1B B5                   or      L               ; check if there is a line into the HELP reg.
6328+ 3D1C E1                   pop     HL
6329+ 3D1D CA 28 3D             jp      Z,HLPERR        ; no line found, raise error
6330+ 3D20 ED 5B D0 51          ld      DE,(HLPLN)      ; recover line
6331+ 3D24 C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6332+ 3D25 C3 3B 1A             jp      LST01H          ; jump to list line
6333+ 3D28 1E 32        HLPERR: ld      E,HP            ; HELP call error
6334+ 3D2A C3 DF 16             jp      ERROR           ; raise error
6335+ 3D2D
6336+ 3D2D
6337+ 3D2D              ; KEY command to list/modify function keys and auto-repeat
6338+ 3D2D 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6339+ 3D2E CD EE 1B             call    GETCHR          ; Get next character
6340+ 3D31 CA B1 3D             jp      Z,LSTKEYS       ; jump if nothing follows
6341+ 3D34                      ; change FN keys
6342+ 3D34 CD FD 28             call    GETINT          ; get a number
6343+ 3D37 A7                   and     A               ; is it 0?
6344+ 3D38 20 10                jr      NZ,KEYCH        ; no, jump over
6345+ 3D3A E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6346+ 3D3B D5                   push    DE              ; store HL & DE
6347+ 3D3C 21 B9 15             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6348+ 3D3F 11 D2 51             ld      DE,KEYDEL       ; pointer to destination
6349+ 3D42 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6350+ 3D45 ED B0                ldir                    ; restore default texts
6351+ 3D47 D1                   pop     DE              ; retrieve DE
6352+ 3D48 E1                   pop     HL              ; retrieve HL
6353+ 3D49 C9                   ret                     ; return to caller
6354+ 3D4A FE 09        KEYCH:  cp      $09             ; is it >= 9?
6355+ 3D4C D2 64 3E             jp      NC,SETREP       ; yes - jump over
6356+ 3D4F 3D                   dec     A               ; FN key in range 0~7
6357+ 3D50 87                   add     A,A             ; multiply A...
6358+ 3D51 87                   add     A,A             ; ... times 4...
6359+ 3D52 87                   add     A,A             ; ... to get the correct...
6360+ 3D53 87                   add     A,A             ; ... offset fo FN key text
6361+ 3D54 32 FD 52             ld      (TMPBFR1),A     ; store FN key offset...
6362+ 3D57 AF                   xor     A               ; ...in a...
6363+ 3D58 32 FE 52             ld      (TMPBFR1+1),A   ; ...16-bit register
6364+ 3D5B CD AD 19             call    CHKSYN          ; Make sure ',' follows
6365+ 3D5E 2C                   defb    ','
6366+ 3D5F 44 4D                ld      BC,HL           ; copy address into BC
6367+ 3D61 CD 89 20             call    EVAL            ; Evaluate expression (in E there is the length)
6368+ 3D64 E5                   push    HL              ; store string pointer
6369+ 3D65 3A B3 52             ld      A,(TYPE)        ; Get variable type
6370+ 3D68 B7                   or      A               ; Is it a string variable?
6371+ 3D69 CA CB 16             jp      Z,SNERR         ; no - syntax error
6372+ 3D6C CD C2 26             call    GSTRCU          ; Current string to pool
6373+ 3D6F CD D3 2E             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6374+ 3D72 7B                   ld      A,E             ; copy length into A
6375+ 3D73 FE 11                cp      $11             ; is length > 16?
6376+ 3D75 DA 7A 3D             jp      C,DECLN1        ; no, jump over
6377+ 3D78 1E 10                ld      E,$10           ; yes, so set length to 16
6378+ 3D7A 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6379+ 3D7C 93                   sub     E               ; ...null chars needed to fill up...
6380+ 3D7D 57                   ld      D,A             ; ...the FN key text
6381+ 3D7E C5                   push    BC              ; store address of string
6382+ 3D7F ED 4B FD 52          ld      BC,(TMPBFR1)    ; load FN key offset
6383+ 3D83 21 D4 51             ld      HL,FNKEYS       ; load address of FN keys texts
6384+ 3D86 09                   add     HL,BC           ; get corrected address
6385+ 3D87 C1                   pop     BC              ; retrieve address of string chars
6386+ 3D88 0A           CPKEY:  ld      A,(BC)          ; load char from string
6387+ 3D89 FE 0D                cp      CR              ; return?
6388+ 3D8B CA 98 3D             jp      Z,CPKEY2        ; yes, store char
6389+ 3D8E FE 7B                cp      $7B             ; if char > "z" ?
6390+ 3D90 D2 CB 16             jp      NC,SNERR        ; yes - syntax error
6391+ 3D93 FE 20                cp      $20             ; is char < space?
6392+ 3D95 DA CB 16             jp      C,SNERR         ; yes - syntax error
6393+ 3D98 FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6394+ 3D9A DA 9F 3D             jp      C,CPKEY3        ; no, continue
6395+ 3D9D E6 5F                and     %01011111       ; set letters to uppercase
6396+ 3D9F 77           CPKEY3: ld      (HL),A          ; store char
6397+ 3DA0 23                   inc     HL              ; next string char
6398+ 3DA1 03                   inc     BC              ; next free cell
6399+ 3DA2 1D                   dec     E               ; decrement E
6400+ 3DA3 20 E3                jr      NZ,CPKEY        ; repeat until 0
6401+ 3DA5 AF                   xor     A               ; null char
6402+ 3DA6 14                   inc     D               ; +1 to decrement below
6403+ 3DA7 15           CPKEY1: dec     D               ; how many null chars to insert?
6404+ 3DA8 CA AF 3D             jp      Z,CPKYEND       ; no more nulls, so exit
6405+ 3DAB 77                   ld      (HL),A          ; store it
6406+ 3DAC 23                   inc     HL              ; next cell
6407+ 3DAD 18 F8                jr      CPKEY1          ; repeat
6408+ 3DAF E1           CPKYEND:pop     HL              ; retrieve pointer to string
6409+ 3DB0 C9                   ret                     ; return to caller
6410+ 3DB1                                              ; list FN keys
6411+ 3DB1 E5           LSTKEYS:push    HL              ; Save code string address
6412+ 3DB2 2A CE 51             ld      HL,(LINEAT)     ; Get current line number
6413+ 3DB5 23                   inc     HL              ; -1 means direct statement
6414+ 3DB6 7C                   ld      A,H
6415+ 3DB7 B5                   or      L
6416+ 3DB8 E1                   pop     HL              ; Restore code string address
6417+ 3DB9 C2 CB 16             jp      NZ,SNERR        ; raise error if in indirect mode
6418+ 3DBC E5                   push    HL              ; store HL
6419+ 3DBD D5                   push    DE              ; store DE
6420+ 3DBE 21 D4 51             ld      HL,FNKEYS       ; load starting address of FN keys text
6421+ 3DC1 0E 01                ld      C,$01           ; 8 function keys
6422+ 3DC3 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6423+ 3DC5 11 86 3E     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
6424+ 3DC8 CD 55 3E             call    PRTCKEY         ; print it
6425+ 3DCB 79                   ld      A,C             ; load FN key
6426+ 3DCC C6 30                add     $30             ; get number in ASCI code
6427+ 3DCE CD B8 19             call    OUTC            ; print it
6428+ 3DD1 11 8B 3E             ld      DE,CHKEY2       ; message ": ""
6429+ 3DD4 CD 55 3E             call    PRTCKEY         ; print it
6430+ 3DD7 3E 01                ld      A,$01           ; " opened
6431+ 3DD9 32 FD 52             ld      (TMPBFR1),A
6432+ 3DDC 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6433+ 3DDD A7                   and     A               ; is it zero?
6434+ 3DDE CA F1 3D             jp      Z,CNTLTK        ; yes, go next char
6435+ 3DE1 CD 3D 3E             call    OPNQT           ; check if quotes are opened
6436+ 3DE4 FE 22                cp      $22             ; check if char is "?
6437+ 3DE6 CA 06 3E             jp      Z,PRTCHR        ; yes, print "chr$("
6438+ 3DE9 FE 0D                cp      CR              ; is it a CR?
6439+ 3DEB CA 06 3E             jp      Z,PRTCHR        ; yes, print "chr$("
6440+ 3DEE CD B8 19     PRTK3:  call    OUTC            ; no, just print it
6441+ 3DF1 23           CNTLTK: inc     HL              ; next char
6442+ 3DF2 10 E8                djnz    LDKEY           ; continue until finished
6443+ 3DF4 CD 2B 3E             call    CLSQT           ; check if quotes are still open
6444+ 3DF7 3E 0D                ld      A,CR            ; go next line
6445+ 3DF9 CD B8 19             call    OUTC            ; print it
6446+ 3DFC 0C                   inc     C               ; next FN key
6447+ 3DFD 79                   ld      A,C             ; check if...
6448+ 3DFE FE 09                cp      $09             ; finished keys?
6449+ 3E00 DA C3 3D             jp      C,PRTK4         ; no, repeat 1 more time
6450+ 3E03 D1                   pop     DE              ; retrieve DE
6451+ 3E04 E1                   pop     HL              ; retrieve HL
6452+ 3E05 C9                   ret                     ; return to caller
6453+ 3E06 E5           PRTCHR: push    HL              ; store HL
6454+ 3E07 CD 2B 3E             call    CLSQT           ; check if quotes are closed
6455+ 3E0A 3E 2B                ld      A,'+'           ; '+' char
6456+ 3E0C CD B8 19             call    OUTC            ; print it
6457+ 3E0F 11 8E 3E             ld      DE,CHKEY3       ; address of "CHR$("
6458+ 3E12 CD 55 3E             call    PRTCKEY         ; print it
6459+ 3E15 E1                   pop     HL              ; recover HL
6460+ 3E16 23                   inc     HL              ; next char
6461+ 3E17 05                   dec     B               ; increment char counter
6462+ 3E18 11 94 3E             ld      DE,CHKEY4       ; load address of RETURN
6463+ 3E1B 7E                   ld      A,(HL)          ; load char
6464+ 3E1C FE 0D                cp      CR              ; is it a RETURN?
6465+ 3E1E 20 03                jr      NZ,PTCHR1       ; no, jump over
6466+ 3E20 11 97 3E             ld      DE,CHKEY5       ; yes, load address of "
6467+ 3E23 CD 55 3E     PTCHR1: call    PRTCKEY         ; print it
6468+ 3E26 3E 29                ld      A,')'           ; char )
6469+ 3E28 C3 EE 3D             jp      PRTK3           ; continue
6470+ 3E2B F5           CLSQT:  push    AF              ; store A
6471+ 3E2C 3A FD 52             ld      A,(TMPBFR1)     ; quote status
6472+ 3E2F A7                   and     A               ; are they closed?
6473+ 3E30 28 09                jr      Z,CLSQT1        ; if yes, return
6474+ 3E32 3E 22                ld      A,$22           ; no, so close them
6475+ 3E34 CD B8 19             call    OUTC            ; print "
6476+ 3E37 AF                   xor     A               ; set quotes
6477+ 3E38 32 FD 52             ld      (TMPBFR1),A     ; as closed
6478+ 3E3B F1           CLSQT1: pop     AF              ; retrieve A
6479+ 3E3C C9                   ret                     ; return to caller
6480+ 3E3D F5           OPNQT:  push    AF              ; store A
6481+ 3E3E 3A FD 52             ld      A,(TMPBFR1)     ; quote status
6482+ 3E41 A7                   and     A               ; are they open?
6483+ 3E42 20 0F                jr      NZ,OPNQT1       ; if yes, return
6484+ 3E44 3E 2B                ld      A,'+'           ; no, so add '+
6485+ 3E46 CD B8 19             call    OUTC            ; print it
6486+ 3E49 3E 22                ld      A,$22           ; and then open quotes
6487+ 3E4B CD B8 19             call    OUTC            ; print them
6488+ 3E4E 3E 01                ld      A,$01           ; set quotes
6489+ 3E50 32 FD 52             ld      (TMPBFR1),A     ; as opened
6490+ 3E53 F1           OPNQT1: pop     AF              ; retrieve A
6491+ 3E54 C9                   ret                     ; return to caller
6492+ 3E55 F5           PRTCKEY:push    AF              ; store original char
6493+ 3E56 1A           PRTK1:  ld      A,(DE)          ; load char
6494+ 3E57 A7                   and     A               ; is it 0?
6495+ 3E58 CA 62 3E             jp      Z,PRTEND        ; yes, finished printing
6496+ 3E5B CD B8 19             call    OUTC            ; no, print char
6497+ 3E5E 13                   inc     DE              ; next char
6498+ 3E5F C3 56 3E             jp      PRTK1           ; repeat
6499+ 3E62 F1           PRTEND: pop     AF              ; retrieve AF
6500+ 3E63 C9                   ret                     ; return to caller
6501+ 3E64 FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6502+ 3E66 C2 CB 16             jp      NZ,SNERR        ; no, raise an error
6503+ 3E69 CD AD 19             call    CHKSYN          ; Check for comma
6504+ 3E6C 2C                   defb    ','
6505+ 3E6D CD FD 28             call    GETINT          ; get a number
6506+ 3E70 32 FD 52             ld      (TMPBFR1),A     ; store it
6507+ 3E73 CD AD 19             call    CHKSYN          ; Check for comma
6508+ 3E76 2C                   defb    ','
6509+ 3E77 CD FD 28             call    GETINT          ; get another number
6510+ 3E7A E5                   push    HL              ; store HL
6511+ 3E7B 21 D3 51             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6512+ 3E7E 77                   ld      (HL),A          ; store auto-repeat delay
6513+ 3E7F 2B                   dec     HL              ; previous cell
6514+ 3E80 3A FD 52             ld      A,(TMPBFR1)     ; retrieve value
6515+ 3E83 77                   ld      (HL),A          ; store delay for auto-repeat
6516+ 3E84 E1                   pop     HL              ; retrieve HL
6517+ 3E85 C9                   ret
6518+ 3E86 4B 45 59 20  CHKEY1: defb    "KEY ",0
6518+ 3E8A 00
6519+ 3E8B 3A 22 00     CHKEY2: defb    ":",34,0
6520+ 3E8E 63 68 72 24  CHKEY3: defb    "chr$(",0
6520+ 3E92 28 00
6521+ 3E94 31 33 00     CHKEY4: defb    "13",0
6522+ 3E97 33 34 00     CHKEY5: defb    "34",0
6523+ 3E9A
6524+ 3E9A
6525+ 3E9A              ; LOAD "filename"
6526+ 3E9A              ; load a BASIC program from disk
6527+ 3E9A C9           LOAD:   ret                     ; currently a stub for LOAD
6528+ 3E9B
6529+ 3E9B
6530+ 3E9B              ; SAVE "filename"
6531+ 3E9B              ; save a BASIC program on disk
6532+ 3E9B C9           SAVE:   ret                     ; currently a stub for SAVE
6533+ 3E9C
6534+ 3E9C
6535+ 3E9C              ; FILES
6536+ 3E9C              ; list files on disk
6537+ 3E9C C9           FILES:  ret                     ; currently a stub for FILES
6538+ 3E9D
6539+ 3E9D
6540+ 3E9D              ; ERASE "filename"
6541+ 3E9D              ; erase a file from disk
6542+ 3E9D C9           ERASE:  ret                     ; currently a stub for ERASE
6543+ 3E9E
6544+ 3E9E
6545+ 3E9E              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6546+ 3E9E CD 7A 20     HEX: 	call	TSTNUM          ; Verify it's a number
6547+ 3EA1 CD A4 1C             call	DEINT           ; Get integer -32768 to 32767
6548+ 3EA4 C5                   push	BC              ; Save contents of BC
6549+ 3EA5 21 56 53             ld      HL,PBUFF        ; load address of PBUFF into HL
6550+ 3EA8 7A                   ld      A,D             ; Get MSB into A
6551+ 3EA9 B7                   or      A               ; OR with LSB to see if param=0
6552+ 3EAA 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6553+ 3EAC CD D4 3E             call    BYT2ASC         ; Convert D to ASCII
6554+ 3EAF 78                   ld      A,B             ; cechk if B
6555+ 3EB0 FE 30                cp      '0'             ; is 0
6556+ 3EB2 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6557+ 3EB4 70                   ld      (HL),B          ; Store it to PBUFF
6558+ 3EB5 23                   inc     HL              ; Next location
6559+ 3EB6 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6560+ 3EB7 23                   inc     HL              ; Next location
6561+ 3EB8 7B           HEX2:   ld      A,E             ; Get lower byte
6562+ 3EB9 CD D4 3E             call    BYT2ASC         ; Convert E to ASCII
6563+ 3EBC 7A                   ld      A,D
6564+ 3EBD B7                   or      A
6565+ 3EBE 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6566+ 3EC0 78                   ld      A,B
6567+ 3EC1 FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6568+ 3EC3 28 02                jr      Z,HEX4
6569+ 3EC5 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6570+ 3EC6 23                   inc     HL              ; Next location
6571+ 3EC7 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6572+ 3EC8 23                   inc     HL              ; PBUFF+4 to zero
6573+ 3EC9 AF                   xor     A               ; Terminating character
6574+ 3ECA 77                   ld      (HL),A          ; Store zero to terminate
6575+ 3ECB 23                   inc     HL              ; Make sure PBUFF is terminated
6576+ 3ECC 77                   ld      (HL),A          ; Store the double zero there
6577+ 3ECD C1                   pop     BC              ; Get BC back
6578+ 3ECE 21 56 53             ld      HL,PBUFF        ; Reset to start of PBUFF
6579+ 3ED1 C3 0F 25             jp      STR1            ; Convert the PBUFF to a string and return it
6580+ 3ED4 47           BYT2ASC:ld      B,A             ; Save original value
6581+ 3ED5 E6 0F                and     $0F             ; Strip off upper nybble
6582+ 3ED7 FE 0A                cp      $0A             ; 0-9?
6583+ 3ED9 38 02                jr      C,ADD30         ; If A-F, add 7 more
6584+ 3EDB C6 07                add     A,$07           ; Bring value up to ASCII A-F
6585+ 3EDD C6 30        ADD30:  add     A,$30           ; And make ASCII
6586+ 3EDF 4F                   ld      C,A             ; Save converted char to C
6587+ 3EE0 78                   ld      A,B             ; Retrieve original value
6588+ 3EE1 0F                   rrca                    ; and Rotate it right
6589+ 3EE2 0F                   rrca
6590+ 3EE3 0F                   rrca
6591+ 3EE4 0F                   rrca
6592+ 3EE5 E6 0F                and     $0F             ; Mask off upper nybble
6593+ 3EE7 FE 0A                cp      $0A             ; 0-9? < A hex?
6594+ 3EE9 38 02                jr      C,ADD301        ; Skip Add 7
6595+ 3EEB C6 07                add     A,$07           ; Bring it up to ASCII A-F
6596+ 3EED C6 30        ADD301: add     A,$30           ; And make it full ASCII
6597+ 3EEF 47                   ld      B,A             ; Store high order byte
6598+ 3EF0 C9                   ret
6599+ 3EF1
6600+ 3EF1              ; Convert "&Hnnnn" to FPREG
6601+ 3EF1              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6602+ 3EF1              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6603+ 3EF1 EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6604+ 3EF2 21 00 00             ld      HL,$0000        ; Zero out the value
6605+ 3EF5 CD 0A 3F             call    GETHEX          ; Check the number for valid hex
6606+ 3EF8 DA 2A 3F             jp      C,HXERR         ; First value wasn't hex, HX error
6607+ 3EFB 18 05                jr      HEXLP1          ; Convert first character
6608+ 3EFD CD 0A 3F     HEXLP:  call    GETHEX          ; Get second and addtional characters
6609+ 3F00 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6610+ 3F02 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6611+ 3F03 29                   add     HL,HL
6612+ 3F04 29                   add     HL,HL
6613+ 3F05 29                   add     HL,HL
6614+ 3F06 B5                   or      L               ; Add in D0-D3 into L
6615+ 3F07 6F                   ld      L,A             ; Save new value
6616+ 3F08 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6617+ 3F0A
6618+ 3F0A 13           GETHEX: inc     DE              ; Next location
6619+ 3F0B 1A                   ld      A,(DE)          ; Load character at pointer
6620+ 3F0C FE 20                cp      SPC
6621+ 3F0E CA 0A 3F             jp      Z,GETHEX        ; Skip spaces
6622+ 3F11 D6 30                sub     $30             ; Get absolute value
6623+ 3F13 D8                   ret     C               ; < "0", error
6624+ 3F14 FE 0A                cp      $0A
6625+ 3F16 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6626+ 3F18 D6 07                sub     $07             ; Reduce to A-F
6627+ 3F1A FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6628+ 3F1C D8                   ret     C               ; CY set if was :            ; < = > ? @
6629+ 3F1D FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6630+ 3F1F 3F                   ccf
6631+ 3F20 C9                   ret                     ; CY set if it wasn't valid hex
6632+ 3F21
6633+ 3F21 EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6634+ 3F22 7A                   ld      A,D             ; Load DE into AC
6635+ 3F23 4B                   ld      C,E             ; For prep to
6636+ 3F24 E5                   push    HL
6637+ 3F25 CD 60 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6638+ 3F28 E1                   pop     HL
6639+ 3F29 C9                   ret
6640+ 3F2A
6641+ 3F2A DD 5C        HXERR:  ld      E,HX            ; ?HEX Error
6642+ 3F2C C3 DF 16             jp      ERROR
6643+ 3F2F
6644+ 3F2F              ; BIN$(NN) Convert integer to a 1-16 char binary string
6645+ 3F2F CD 7A 20     BIN:    call    TSTNUM          ; Verify it's a number
6646+ 3F32 CD A4 1C             call    DEINT           ; Get integer -32768 to 32767
6647+ 3F35 C5           BIN2:   push    BC              ; Save contents of BC
6648+ 3F36 21 56 53             ld      HL,PBUFF
6649+ 3F39 06 11                ld      B,$11           ; One higher than max char count (16+1)
6650+ 3F3B              ZEROSUP:                        ; Suppress leading zeros
6651+ 3F3B 05                   dec     B               ; Max 16 chars
6652+ 3F3C 78                   ld      A,B
6653+ 3F3D FE 01                cp      $01
6654+ 3F3F 28 08                jr      Z,BITOUT        ; Always output at least one character
6655+ 3F41 CB 13                rl      E
6656+ 3F43 CB 12                rl      D
6657+ 3F45 30 F4                jr      NC,ZEROSUP
6658+ 3F47 18 04                jr      BITOUT2
6659+ 3F49 CB 13        BITOUT: rl      E
6660+ 3F4B CB 12                rl      D               ; Top bit now in carry
6661+ 3F4D 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6662+ 3F4F CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6663+ 3F51 77                   ld      (HL),A
6664+ 3F52 23                   inc     HL
6665+ 3F53 05                   dec     B
6666+ 3F54 20 F3                jr      NZ,BITOUT
6667+ 3F56 AF                   xor     A               ; Terminating character
6668+ 3F57 77                   ld      (HL),A          ; Store zero to terminate
6669+ 3F58 23                   inc     HL              ; Make sure PBUFF is terminated
6670+ 3F59 77                   ld      (HL),A          ; Store the double zero there
6671+ 3F5A C1                   pop     BC
6672+ 3F5B 21 56 53             ld      HL,PBUFF
6673+ 3F5E C3 0F 25             jp      STR1
6674+ 3F61
6675+ 3F61              ; Convert "&Bnnnn" to FPREG
6676+ 3F61              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6677+ 3F61 EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6678+ 3F62 21 00 00             ld      HL,$0000        ; Zero out the value
6679+ 3F65 CD 7E 3F             call    CHKBIN          ; Check the number for valid bin
6680+ 3F68 DA 8C 3F             jp      C,BINERR        ; First value wasn't bin, HX error
6681+ 3F6B D6 30        BINIT:  sub     '0'
6682+ 3F6D 29                   add     HL,HL           ; Rotate HL left
6683+ 3F6E B5                   or      L
6684+ 3F6F 6F                   ld      L,A
6685+ 3F70 CD 7E 3F             call    CHKBIN          ; Get second and addtional characters
6686+ 3F73 30 F6                jr      NC,BINIT        ; Process if a bin character
6687+ 3F75 EB                   ex      DE,HL           ; Value into DE, Code string into HL
6688+ 3F76 7A                   ld      A,D             ; Load DE into AC
6689+ 3F77 4B                   ld      C,E             ; For prep to
6690+ 3F78 E5                   push    HL
6691+ 3F79 CD 60 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6692+ 3F7C E1                   pop     HL
6693+ 3F7D C9                   ret
6694+ 3F7E
6695+ 3F7E              ; Char is in A, NC if char is 0 or 1
6696+ 3F7E 13           CHKBIN: inc     DE
6697+ 3F7F 1A                   ld      A,(DE)
6698+ 3F80 FE 20                cp      SPC
6699+ 3F82 CA 7E 3F             jp      Z,CHKBIN        ; Skip spaces
6700+ 3F85 FE 30                cp      '0'             ; Set C if < '0'
6701+ 3F87 D8                   ret     C
6702+ 3F88 FE 32                cp      '2'
6703+ 3F8A 3F                   ccf                     ; Set C if > '1'
6704+ 3F8B C9                   ret
6705+ 3F8C
6706+ 3F8C 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6707+ 3F8E C3 DF 16             jp      ERROR
6708+ 3F91
6709+ 3F91
6710+ 3F91 C3 08 00     MONOUT: jp      $0008           ; output a char
6711+ 3F94
6712+ 3F94
6713+ 3F94 3A 3F 53     RESET:  ld      A,(SERIALS_EN)
6714+ 3F97 E6 11                and     $11             ; are serial ports open?
6715+ 3F99 C4 04 3B             call    NZ,RSTSERS      ; yes, reset serials
6716+ 3F9C CD 18 29             call    DISNMI          ; disable NMI vector
6717+ 3F9F F3                   di                      ; disable INTs
6718+ 3FA0                  IFDEF LM80C64K
6719+ 3FA0 C3 F0 50             jp      ROM2RAM         ; Restart
6720+ 3FA3                  ELSE
6721+ 3FA3 ~                    jp      $0000           ; Restart
6722+ 3FA3                  ENDIF
6723+ 3FA3
6724+ 3FA3
6725+ 3FA3 3E 00        INITST: ld      A,$00           ; Clear break flag
6726+ 3FA5 32 C8 51             ld      (BRKFLG),A
6727+ 3FA8 C3 F7 11             jp      INIT
6728+ 3FAB
6729+ 3FAB
6730+ 3FAB F5           TSTBIT: push    AF              ; Save bit mask
6731+ 3FAC A0                   and     B               ; Get common bits
6732+ 3FAD C1                   pop     BC              ; Restore bit mask
6733+ 3FAE B8                   cp      B               ; Same bit set?
6734+ 3FAF 3E 00                ld      A,$00           ; Return 0 in A
6735+ 3FB1 C9                   ret
6736+ 3FB2
6737+ 3FB2 CD B8 19     OUTNCR: call    OUTC            ; Output character in A
6738+ 3FB5 C3 BB 1E             jp      PRNTCRLF        ; Output CRLF
6739+ 3FB8
# file closed: ../include/basic/basic-1.03.asm
  79  3FB8
  80  3FB8              ; include utils
  81  3FB8                  INCLUDE "../include/utils/utils-r11.asm"
# file opened: ../include/utils/utils-r11.asm
   1+ 3FB8              ; ------------------------------------------------------------------------------
   2+ 3FB8              ; LM80C - UTILITY ROUTINES - R1.1
   3+ 3FB8              ; ------------------------------------------------------------------------------
   4+ 3FB8              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 3FB8              ; designed by Leonardo Miliani. More info at
   6+ 3FB8              ; www DOT leonardomiliani DOT com
   7+ 3FB8              ;
   8+ 3FB8              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 3FB8              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 3FB8              ;
  11+ 3FB8              ; * WKT are routines from WikiTI:
  12+ 3FB8              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 3FB8              ;
  14+ 3FB8              ; * LAC are routines from Learn@Cemetch
  15+ 3FB8              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 3FB8              ;
  17+ 3FB8              ; ------------------------------------------------------------------------------
  18+ 3FB8              ; Code Revision:
  19+ 3FB8              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 3FB8              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 3FB8              ;
  22+ 3FB8              ; ------------------------------------------------------------------------------
  23+ 3FB8
  24+ 3FB8              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  25+ 3FB8              ; values can be both signed or unsigned words
  26+ 3FB8              ; inputs: HL, DE
  27+ 3FB8              ; destroys: A,F,HL
  28+ 3FB8              ;
  29+ 3FB8              ; returns: Z=1 if HL = DE
  30+ 3FB8              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  31+ 3FB8              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  32+ 3FB8              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  33+ 3FB8              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  34+ 3FB8              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  35+ 3FB8              ; Source: ALS
  36+ 3FB8
  37+ 3FB8 B7           CMP16:  or      A           ; clear CARRY
  38+ 3FB9 ED 52                sbc     HL,DE       ; subtract DE from HL
  39+ 3FBB E0                   ret     PO          ; return if no overflow
  40+ 3FBC 7C                   ld      A,H         ; overflow - invert SIGN flag
  41+ 3FBD 1F                   rra                 ; save CARRY flag in bit 7
  42+ 3FBE EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  43+ 3FC0 37                   scf                 ; ensure a Non-Zero result
  44+ 3FC1 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  45+ 3FC2                                          ; ZERO flag = 0 for sure
  46+ 3FC2 C9                   ret                 ; return
  47+ 3FC3
  48+ 3FC3              ; ----------------------------------------------------------------------
  49+ 3FC3
  50+ 3FC3              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  51+ 3FC3              ; signed/unsigned product
  52+ 3FC3              ; inputs: HL (multiplicand); DE (multiplier)
  53+ 3FC3              ; destroys: A,F
  54+ 3FC3              ; returns: HL (product)
  55+ 3FC3              ; Source: ALS
  56+ 3FC3
  57+ 3FC3              ; initialize partial product, bit count
  58+ 3FC3 C5           MUL16:  push    BC
  59+ 3FC4 4D                   ld      C,L         ; BC = multiplier
  60+ 3FC5 44                   ld      B,H
  61+ 3FC6 21 00 00             ld      HL,0        ; product = 0
  62+ 3FC9 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  63+ 3FCB                      ; shift-and-add algorithm
  64+ 3FCB                      ; if MSB of multiplier is 1, add multiplicand to partial product
  65+ 3FCB                      ; shift partial product, multiplier left 1 bit
  66+ 3FCB CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  67+ 3FCD CB 12                rl      D
  68+ 3FCF 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  69+ 3FD1 09                   add     HL,BC       ; add multiplicand to partial product
  70+ 3FD2 29           MLP1:   add     HL,HL       ; shift partial product left
  71+ 3FD3 3D                   dec     A
  72+ 3FD4 20 F5                jr      NZ,MLP      ; continue until count = 0
  73+ 3FD6                      ; add multiplicand one last time if MSB of multiplier is 1
  74+ 3FD6 B2                   or      D           ; sign flag = MSB of multiplier
  75+ 3FD7 F2 DB 3F             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  76+ 3FDA 09                   add     HL,BC       ; add multiplicand to product
  77+ 3FDB C1           EXMUL16:pop     BC
  78+ 3FDC C9                   ret
  79+ 3FDD
  80+ 3FDD              ; ----------------------------------------------------------------------
  81+ 3FDD              ; absolute value of HL (same applies to other 16-bit register pairs)
  82+ 3FDD              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
  83+ 3FDD              ;
  84+ 3FDD              ; inputs: HL
  85+ 3FDD              ; destroys: A
  86+ 3FDD              ; operation: ABS(HL)
  87+ 3FDD              ; returns: HL with no sign or negated
  88+ 3FDD              ; Source: WKT
  89+ 3FDD
  90+ 3FDD CB 7C        absHL:  bit     7,H
  91+ 3FDF C8                   ret     Z
  92+ 3FE0 AF           negHL:  xor     A
  93+ 3FE1 95                   sub     L
  94+ 3FE2 6F                   ld      L,A
  95+ 3FE3 9F                   sbc     A,A
  96+ 3FE4 94                   sub     H
  97+ 3FE5 67                   ld      H,A
  98+ 3FE6 C9                   ret
  99+ 3FE7
 100+ 3FE7              ; ------------------------------------------------------------------------------
 101+ 3FE7
 102+ 3FE7              ; 8/8 division
 103+ 3FE7              ; INPUT: D (dividend), E (divisor)
 104+ 3FE7              ; OPERATION: D/E
 105+ 3FE7              ; OUTPUT: D (quotient), A (remainder)
 106+ 3FE7 AF           DIV_8_8:    xor     A
 107+ 3FE8 C5                       push    BC
 108+ 3FE9 06 08                    ld      B,08h
 109+ 3FEB CB 22        DIV_8_8LOOP:sla     D
 110+ 3FED 17                       rla
 111+ 3FEE BB                       cp      E
 112+ 3FEF 38 02                    jr      C,$+4
 113+ 3FF1 93                       sub     E
 114+ 3FF2 14                       inc     D
 115+ 3FF3 10 F6                    djnz    DIV_8_8LOOP
 116+ 3FF5 C1                       pop     BC
 117+ 3FF6 C9                       ret
 118+ 3FF7
 119+ 3FF7              ; ----------------------------------------------------------------------
 120+ 3FF7              ; divide a 16-bit number by an 8-bit number
 121+ 3FF7              ; (16/8 division)
 122+ 3FF7              ;
 123+ 3FF7              ; inputs: HL (Dividend), C (divisor)
 124+ 3FF7              ; destroys: A
 125+ 3FF7              ; OPERATION: HL/C
 126+ 3FF7              ; returns: HL (quotient), A (remainder)
 127+ 3FF7              ; source: WKT
 128+ 3FF7
 129+ 3FF7 AF           DIV_16_8:   xor     A
 130+ 3FF8 06 10                    ld      B,16
 131+ 3FFA 29           DIV_16_8LP: add     HL,HL
 132+ 3FFB 17                       rla
 133+ 3FFC 38 03                    jr      C,$+5
 134+ 3FFE B9                       cp      C
 135+ 3FFF 38 02                    jr      C,$+4
 136+ 4001 91                       sub     C
 137+ 4002 2C                       inc     L
 138+ 4003 10 F5                    djnz    DIV_16_8LP
 139+ 4005 C9                       ret
 140+ 4006
 141+ 4006              ; ----------------------------------------------------------------------
 142+ 4006              ; divide a 16-bit number by a 16-bit number
 143+ 4006              ; (16/16 division)
 144+ 4006              ;
 145+ 4006              ; inputs: AC (Dividend), DE (divisor)
 146+ 4006              ; destroys: HL,A,C
 147+ 4006              ; OPERATION: AC/DE
 148+ 4006              ; returns: AC (quotient), HL (remainder)
 149+ 4006              ; source: WKT
 150+ 4006 21 00 00     DIV_16_16:  ld      HL, 0
 151+ 4009 06 10                    ld      B, 16
 152+ 400B CB 21        DV16_16_LP: sla     C
 153+ 400D CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 154+ 400F 17                       rla
 155+ 4010 ED 6A                    adc     HL,HL
 156+ 4012 ED 52                    sbc     HL,DE
 157+ 4014 30 02                    jr      NC, $+4
 158+ 4016 19                       add     HL,DE
 159+ 4017 0D                       dec     C
 160+ 4018 10 F1                    djnz    DV16_16_LP
 161+ 401A C9                       ret
# file closed: ../include/utils/utils-r11.asm
  82  401B
  83  401B              ; include the latest version of the font sets
  84  401B                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 401B              ; ------------------------------------------------------------------------------
   2+ 401B              ; LM80C - 6x8 CHARSET - R1.6
   3+ 401B              ; ------------------------------------------------------------------------------
   4+ 401B              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 401B              ; designed by Leonardo Miliani. More info at
   6+ 401B              ; www DOT leonardomiliani DOT com
   7+ 401B              ; ------------------------------------------------------------------------------
   8+ 401B              ; Code Revision:
   9+ 401B              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 401B              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 401B              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 401B              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 401B              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 401B              ; R1.5 - 20200524 - New style for char #252
  15+ 401B              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 401B              ; ------------------------------------------------------------------------------
  17+ 401B              ;
  18+ 401B              ;-------------------------------------------------------------------------------
  19+ 401B              ;
  20+ 401B              ;               6 x 8    C  H  A  R  S  E  T
  21+ 401B              ;
  22+ 401B              ;-------------------------------------------------------------------------------
  23+ 401B              ;
  24+ 401B              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 401B              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 401B
  27+ 401B              CHRST68 equ $
  28+ 401B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 401F 00 00 00 00
  29+ 4023 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 4027 00 00 00 00
  30+ 402B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 402F 00 00 00 00
  31+ 4033 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 4037 00 00 00 00
  32+ 403B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 403F 00 00 00 00
  33+ 4043 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 4047 00 00 00 00
  34+ 404B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 404F 00 00 00 00
  35+ 4053 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 4057 00 00 00 00
  36+ 405B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 405F 00 00 00 00
  37+ 4063 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 4067 00 00 00 00
  38+ 406B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 406F 00 00 00 00
  39+ 4073 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 4077 00 00 00 00
  40+ 407B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 407F 00 00 00 00
  41+ 4083 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 4087 00 00 00 00
  42+ 408B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 408F 00 00 00 00
  43+ 4093 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 4097 00 00 00 00
  44+ 409B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 409F 00 00 00 00
  45+ 40A3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 40A7 00 00 00 00
  46+ 40AB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 40AF 00 00 00 00
  47+ 40B3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 40B7 00 00 00 00
  48+ 40BB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 40BF 00 00 00 00
  49+ 40C3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 40C7 00 00 00 00
  50+ 40CB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 40CF 00 00 00 00
  51+ 40D3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 40D7 00 00 00 00
  52+ 40DB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 40DF 00 00 00 00
  53+ 40E3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 40E7 00 00 00 00
  54+ 40EB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 40EF 00 00 00 00
  55+ 40F3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 40F7 00 00 00 00
  56+ 40FB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 40FF 00 00 00 00
  57+ 4103 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 4107 00 00 00 00
  58+ 410B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 410F 00 00 00 00
  59+ 4113 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 4117 00 00 00 00
  60+ 411B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 411F 00 00 00 00
  61+ 4123 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 4127 20 00 20 00
  62+ 412B 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 412F 00 00 00 00
  63+ 4133 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 4137 F8 50 50 00
  64+ 413B 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 413F 28 F0 20 00
  65+ 4143 C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 4147 40 98 18 00
  66+ 414B 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 414F A8 90 68 00
  67+ 4153 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 4157 00 00 00 00
  68+ 415B 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 415F 40 20 10 00
  69+ 4163 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 4167 10 20 40 00
  70+ 416B 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 416F A8 20 00 00
  71+ 4173 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 4177 20 20 00 00
  72+ 417B 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 417F 60 20 40 00
  73+ 4183 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 4187 00 00 00 00
  74+ 418B 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 418F 00 60 60 00
  75+ 4193 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 4197 40 80 00 00
  76+ 419B 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 419F C8 88 70 00
  77+ 41A3 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 41A7 20 20 70 00
  78+ 41AB 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 41AF 20 40 F8 00
  79+ 41B3 F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 41B7 08 88 70 00
  80+ 41BB 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 41BF F8 10 10 00
  81+ 41C3 F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 41C7 08 88 70 00
  82+ 41CB 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 41CF 88 88 70 00
  83+ 41D3 F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 41D7 40 40 40 00
  84+ 41DB 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 41DF 88 88 70 00
  85+ 41E3 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 41E7 08 10 60 00
  86+ 41EB 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 41EF 30 30 00 00
  87+ 41F3 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 41F7 30 10 20 00
  88+ 41FB 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 41FF 40 20 10 00
  89+ 4203 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 4207 F8 00 00 00
  90+ 420B 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 420F 10 20 40 00
  91+ 4213 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 4217 20 00 20 00
  92+ 421B 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 421F A8 A8 70 00
  93+ 4223 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 4227 F8 88 88 00
  94+ 422B F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 422F 88 88 F0 00
  95+ 4233 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 4237 80 88 70 00
  96+ 423B E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 423F 88 90 E0 00
  97+ 4243 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 4247 80 80 F8 00
  98+ 424B F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 424F 80 80 80 00
  99+ 4253 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 4257 88 88 78 00
 100+ 425B 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 425F 88 88 88 00
 101+ 4263 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 4267 20 20 70 00
 102+ 426B 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 426F 10 90 60 00
 103+ 4273 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 4277 A0 90 88 00
 104+ 427B 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 427F 80 80 F8 00
 105+ 4283 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 4287 88 88 88 00
 106+ 428B 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 428F 88 88 88 00
 107+ 4293 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 4297 88 88 70 00
 108+ 429B F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 429F 80 80 80 00
 109+ 42A3 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 42A7 A8 90 68 00
 110+ 42AB F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 42AF A0 90 88 00
 111+ 42B3 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 42B7 08 08 F0 00
 112+ 42BB F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 42BF 20 20 20 00
 113+ 42C3 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 42C7 88 88 70 00
 114+ 42CB 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 42CF 88 50 20 00
 115+ 42D3 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 42D7 A8 A8 50 00
 116+ 42DB 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 42DF 50 88 88 00
 117+ 42E3 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 42E7 20 20 20 00
 118+ 42EB F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 42EF 40 80 F8 00
 119+ 42F3 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 42F7 40 40 70 00
 120+ 42FB 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 42FF 10 08 00 00
 121+ 4303 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 4307 10 10 70 00
 122+ 430B 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 430F 00 00 00 00
 123+ 4313 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 4317 00 00 00 FC
 124+ 431B 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 431F 00 00 00 00
 125+ 4323 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 4327 78 88 78 00
 126+ 432B 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 432F C8 88 F0 00
 127+ 4333 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 4337 80 88 70 00
 128+ 433B 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 433F 98 88 78 00
 129+ 4343 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 4347 F8 80 70 00
 130+ 434B 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 434F 40 40 40 00
 131+ 4353 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 4357 78 08 70 00
 132+ 435B 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 435F 88 88 88 00
 133+ 4363 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 4367 20 20 20 00
 134+ 436B 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 436F 08 88 70 00
 135+ 4373 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 4377 C0 A0 90 00
 136+ 437B 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 437F 20 20 70 00
 137+ 4383 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 4387 A8 88 88 00
 138+ 438B 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 438F 88 88 88 00
 139+ 4393 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 4397 88 88 70 00
 140+ 439B 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 439F F0 80 80 00
 141+ 43A3 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 43A7 78 08 08 00
 142+ 43AB 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 43AF 80 80 80 00
 143+ 43B3 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 43B7 70 08 F0 00
 144+ 43BB 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 43BF 40 48 30 00
 145+ 43C3 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 43C7 88 98 68 00
 146+ 43CB 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 43CF 88 50 20 00
 147+ 43D3 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 43D7 A8 A8 50 00
 148+ 43DB 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 43DF 20 50 88 00
 149+ 43E3 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 43E7 68 08 70 00
 150+ 43EB 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 43EF 20 40 F8 00
 151+ 43F3 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 43F7 20 20 10 00
 152+ 43FB 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 43FF 20 20 20 00
 153+ 4403 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 4407 10 10 20 00
 154+ 440B 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 440F 00 00 00 00
 155+ 4413 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 4417 00 00 00 00
 156+ 441B 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 441F B4 84 78 00
 157+ 4423 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 4427 B4 CC 78 00
 158+ 442B 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 442F FC 78 30 00
 159+ 4433 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 4437 F8 70 20 00
 160+ 443B 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 443F A8 20 70 00
 161+ 4443 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 4447 A8 20 70 00
 162+ 444B 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 444F FC 30 30 30
 163+ 4453 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 4457 3C 30 30 30
 164+ 445B 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 445F F0 30 30 30
 165+ 4463 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 4467 F0 00 00 00
 166+ 446B 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 446F 3C 00 00 00
 167+ 4473 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 4477 FC 00 00 00
 168+ 447B 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 447F 3C 30 30 30
 169+ 4483 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 4487 FC 30 30 30
 170+ 448B 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 448F F0 30 30 30
 171+ 4493 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 4497 FC 00 00 00
 172+ 449B 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 449F 30 30 30 30
 173+ 44A3 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 44A7 70 60 E0 C0
 174+ 44AB C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 44AF 38 18 1C 0C
 175+ 44B3 CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 44B7 30 78 CC CC
 176+ 44BB 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 44BF 20 20 20 20
 177+ 44C3 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 44C7 20 20 20 20
 178+ 44CB 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 44CF 20 20 20 20
 179+ 44D3 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 44D7 00 00 00 00
 180+ 44DB 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 44DF 00 00 00 00
 181+ 44E3 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 44E7 00 00 00 00
 182+ 44EB 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 44EF 20 20 20 20
 183+ 44F3 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 44F7 20 20 20 20
 184+ 44FB 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 44FF 20 20 20 20
 185+ 4503 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 4507 00 00 00 00
 186+ 450B 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 450F 20 20 20 20
 187+ 4513 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 4517 20 40 40 80
 188+ 451B 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 451F 10 08 08 04
 189+ 4523 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 4527 30 48 48 84
 190+ 452B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 452F 00 00 FC FC
 191+ 4533 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 4537 FC FC FC FC
 192+ 453B 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 453F FC FC FC FC
 193+ 4543 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 4547 00 00 00 00
 194+ 454B FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 454F 00 00 00 00
 195+ 4553 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 4557 FC FC 00 00
 196+ 455B 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 455F 80 80 80 80
 197+ 4563 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 4567 E0 E0 E0 E0
 198+ 456B F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 456F F8 F8 F8 F8
 199+ 4573 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 4577 04 04 04 04
 200+ 457B 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 457F 1C 1C 1C 1C
 201+ 4583 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 4587 7C 7C 7C 7C
 202+ 458B FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 458F 84 84 84 FC
 203+ 4593 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 4597 E0 E0 E0 E0
 204+ 459B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 459F 1C 1C 1C 1C
 205+ 45A3 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 45A7 00 00 00 00
 206+ 45AB E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 45AF 00 00 00 00
 207+ 45B3 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 45B7 1C 1C 1C 1C
 208+ 45BB 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 45BF E0 E0 E0 E0
 209+ 45C3 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 45C7 78 78 78 78
 210+ 45CB CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 45CF CC CC CC CC
 211+ 45D3 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 45D7 00 00 FC FC
 212+ 45DB 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 45DF FC FC 00 00
 213+ 45E3 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 45E7 30 30 CC CC
 214+ 45EB 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 45EF 54 A8 54 A8
 215+ 45F3 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 45F7 64 30 98 CC
 216+ 45FB CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 45FF CC 64 30 98
 217+ 4603 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 4607 30 98 CC 64
 218+ 460B 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 460F 64 CC 98 30
 219+ 4613 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 4617 20 00 F8 00
 220+ 461B C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 461F C0 00 F8 00
 221+ 4623 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 4627 18 00 F8 00
 222+ 462B 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 462F A0 60 20 00
 223+ 4633 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 4637 00 00 00 00
 224+ 463B 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 463F 70 00 00 00
 225+ 4643 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 4647 00 FC 00 00
 226+ 464B 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 464F 54 A8 00 00
 227+ 4653 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 4657 E0 C0 80 00
 228+ 465B FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 465F 00 00 00 00
 229+ 4663 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 4667 1C 0C 04 00
 230+ 466B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 466F 00 30 78 FC
 231+ 4673 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 4677 20 20 20 00
 232+ 467B 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 467F 40 80 00 00
 233+ 4683 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 4687 18 10 00 00
 234+ 468B 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 468F 24 1C 1C 3C
 235+ 4693 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 4697 20 F8 70 20
 236+ 469B 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 469F 90 E0 E0 F0
 237+ 46A3 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 46A7 60 20 00 00
 238+ 46AB F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 46AF 08 04 00 00
 239+ 46B3 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 46B7 F0 44 38 00
 240+ 46BB 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 46BF 28 28 28 00
 241+ 46C3 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 46C7 1C 20 20 20
 242+ 46CB 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 46CF E0 10 10 10
 243+ 46D3 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 46D7 00 00 00 00
 244+ 46DB 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 46DF 00 00 00 00
 245+ 46E3 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 46E7 3C 30 30 30
 246+ 46EB 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 46EF F0 30 30 30
 247+ 46F3 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 46F7 E0 00 00 00
 248+ 46FB 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 46FF 1C 00 00 00
 249+ 4703 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 4707 48 30 00 00
 250+ 470B 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 470F 78 30 00 00
 251+ 4713 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 4717 FC 78 30 00
 252+ 471B FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 471F E0 C0 80 80
 253+ 4723 FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 4727 1C 0C 04 04
 254+ 472B 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 472F 1C 3C 7C FC
 255+ 4733 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 4737 E0 F0 F8 FC
 256+ 473B 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 473F F0 E0 C0 00
 257+ 4743 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 4747 78 CC 00 00
 258+ 474B 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 474F 70 20 70 20
 259+ 4753 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 4757 90 90 60 00
 260+ 475B F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 475F 84 84 84 FC
 261+ 4763 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 4767 84 84 84 FC
 262+ 476B 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 476F 48 48 48 78
 263+ 4773 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 4777 FC B4 B4 FC
 264+ 477B 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 477F D4 D4 00 00
 265+ 4783 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 4787 78 48 48 48
 266+ 478B 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 478F B4 84 78 00
 267+ 4793 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 4797 A8 80 00 00
 268+ 479B 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 479F A0 88 70 00
 269+ 47A3 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 47A7 84 84 FC 00
 270+ 47AB 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 47AF F0 F0 F0 00
 271+ 47B3 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 47B7 F0 F0 F0 00
 272+ 47BB FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 47BF 94 94 84 FC
 273+ 47C3 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 47C7 68 70 80 00
 274+ 47CB 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 47CF 6C 18 08 00
 275+ 47D3 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 47D7 20 60 E0 40
 276+ 47DB 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 47DF E4 68 20 00
 277+ 47E3 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 47E7 E0 60 20 00
 278+ 47EB 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 47EF F8 FC F0 90
 279+ 47F3 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 47F7 B4 84 78 00
 280+ 47FB 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 47FF 40 48 B0 00
 281+ 4803 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 4807 48 3C 84 78
 282+ 480B 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 480F F8 00 20 00
 283+ 4813 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 4817 FC FC FC FC
 284+ 481B                      ; here ends the ASCII table
 285+ 481B
# file closed: ../include/vdp/6x8fonts-r16.asm
  85  481B                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 481B              ; ------------------------------------------------------------------------------
   2+ 481B              ; LM80C - 8x8 CHARSET - R1.8
   3+ 481B              ; ------------------------------------------------------------------------------
   4+ 481B              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 481B              ; designed by Leonardo Miliani. More info at
   6+ 481B              ; www DOT leonardomiliani DOT com
   7+ 481B              ; ------------------------------------------------------------------------------
   8+ 481B              ; Code Revision:
   9+ 481B              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 481B              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 481B              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 481B              ; R1.3 - 20191015 - More graphic chars
  13+ 481B              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 481B              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 481B              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 481B              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 481B              ; R1.8 - 20200524 - New style for char #252
  18+ 481B              ; ------------------------------------------------------------------------------
  19+ 481B              ;
  20+ 481B              ;-------------------------------------------------------------------------------
  21+ 481B              ;
  22+ 481B              ;               8 x 8    C  H  A  R  S  E  T
  23+ 481B              ;
  24+ 481B              ;-------------------------------------------------------------------------------
  25+ 481B              ;
  26+ 481B              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 481B
  28+ 481B              CHRST88 equ $
  29+ 481B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 481F 00 00 00 00
  30+ 4823 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 4827 00 00 00 00
  31+ 482B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 482F 00 00 00 00
  32+ 4833 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 4837 00 00 00 00
  33+ 483B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 483F 00 00 00 00
  34+ 4843 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 4847 00 00 00 00
  35+ 484B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 484F 00 00 00 00
  36+ 4853 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 4857 00 00 00 00
  37+ 485B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 485F 00 00 00 00
  38+ 4863 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 4867 00 00 00 00
  39+ 486B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 486F 00 00 00 00
  40+ 4873 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 4877 00 00 00 00
  41+ 487B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 487F 00 00 00 00
  42+ 4883 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 4887 00 00 00 00
  43+ 488B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 488F 00 00 00 00
  44+ 4893 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 4897 00 00 00 00
  45+ 489B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 489F 00 00 00 00
  46+ 48A3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 48A7 00 00 00 00
  47+ 48AB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 48AF 00 00 00 00
  48+ 48B3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 48B7 00 00 00 00
  49+ 48BB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 48BF 00 00 00 00
  50+ 48C3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 48C7 00 00 00 00
  51+ 48CB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 48CF 00 00 00 00
  52+ 48D3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 48D7 00 00 00 00
  53+ 48DB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 48DF 00 00 00 00
  54+ 48E3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 48E7 00 00 00 00
  55+ 48EB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 48EF 00 00 00 00
  56+ 48F3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 48F7 00 00 00 00
  57+ 48FB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 48FF 00 00 00 00
  58+ 4903 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 4907 00 00 00 00
  59+ 490B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 490F 00 00 00 00
  60+ 4913 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 4917 00 00 00 00
  61+ 491B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 491F 00 00 00 00
  62+ 4923 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 4927 10 00 10 00
  63+ 492B 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 492F 00 00 00 00
  64+ 4933 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 4937 FE 28 28 00
  65+ 493B 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 493F 14 78 10 00
  66+ 4943 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 4947 10 26 46 00
  67+ 494B 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 494F 4A 44 3A 00
  68+ 4953 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 4957 00 00 00 00
  69+ 495B 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 495F 20 10 08 00
  70+ 4963 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 4967 08 10 20 00
  71+ 496B 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 496F 38 54 10 00
  72+ 4973 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 4977 10 10 00 00
  73+ 497B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 497F 00 18 08 10
  74+ 4983 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 4987 00 00 00 00
  75+ 498B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 498F 00 18 18 00
  76+ 4993 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 4997 10 20 40 00
  77+ 499B 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 499F 64 44 38 00
  78+ 49A3 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 49A7 10 10 7C 00
  79+ 49AB 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 49AF 10 20 7C 00
  80+ 49B3 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 49B7 04 44 38 00
  81+ 49BB 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 49BF 7C 08 08 00
  82+ 49C3 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 49C7 04 44 38 00
  83+ 49CB 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 49CF 44 44 38 00
  84+ 49D3 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 49D7 20 20 20 00
  85+ 49DB 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 49DF 44 44 38 00
  86+ 49E3 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 49E7 04 44 38 00
  87+ 49EB 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 49EF 18 18 00 00
  88+ 49F3 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 49F7 18 08 10 00
  89+ 49FB 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 49FF 10 08 04 00
  90+ 4A03 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 4A07 7E 00 00 00
  91+ 4A0B 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 4A0F 08 10 20 00
  92+ 4A13 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 4A17 10 00 10 00
  93+ 4A1B 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 4A1F B8 80 84 78
  94+ 4A23 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 4A27 7C 44 44 00
  95+ 4A2B 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 4A2F 44 44 78 00
  96+ 4A33 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4A37 40 44 38 00
  97+ 4A3B 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4A3F 44 44 78 00
  98+ 4A43 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4A47 40 40 7C 00
  99+ 4A4B 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4A4F 40 40 40 00
 100+ 4A53 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4A57 5C 44 38 00
 101+ 4A5B 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4A5F 44 44 44 00
 102+ 4A63 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4A67 10 10 38 00
 103+ 4A6B 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4A6F 04 44 38 00
 104+ 4A73 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4A77 48 44 44 00
 105+ 4A7B 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4A7F 40 40 7C 00
 106+ 4A83 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4A87 42 42 42 00
 107+ 4A8B 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4A8F 44 44 44 00
 108+ 4A93 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4A97 44 44 38 00
 109+ 4A9B 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4A9F 78 40 40 00
 110+ 4AA3 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4AA7 54 48 34 00
 111+ 4AAB 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4AAF 78 48 44 00
 112+ 4AB3 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4AB7 04 04 78 00
 113+ 4ABB 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4ABF 10 10 10 00
 114+ 4AC3 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4AC7 44 44 38 00
 115+ 4ACB 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4ACF 44 28 10 00
 116+ 4AD3 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4AD7 5A 5A 24 00
 117+ 4ADB 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4ADF 28 44 44 00
 118+ 4AE3 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4AE7 10 10 10 00
 119+ 4AEB 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4AEF 20 40 7C 00
 120+ 4AF3 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4AF7 20 20 38 00
 121+ 4AFB 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4AFF 08 04 02 00
 122+ 4B03 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4B07 08 08 38 00
 123+ 4B0B 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4B0F 00 00 00 00
 124+ 4B13 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4B17 00 00 7E 00
 125+ 4B1B 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4B1F 00 00 00 00
 126+ 4B23 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4B27 3C 44 3C 00
 127+ 4B2B 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4B2F 44 44 78 00
 128+ 4B33 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4B37 40 44 38 00
 129+ 4B3B 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4B3F 44 44 3C 00
 130+ 4B43 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4B47 7C 40 38 00
 131+ 4B4B 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4B4F 20 20 20 00
 132+ 4B53 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4B57 44 3C 04 38
 133+ 4B5B 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4B5F 44 44 44 00
 134+ 4B63 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4B67 10 10 10 00
 135+ 4B6B 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4B6F 08 08 48 30
 136+ 4B73 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4B77 60 50 48 00
 137+ 4B7B 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4B7F 10 10 38 00
 138+ 4B83 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4B87 4A 42 42 00
 139+ 4B8B 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4B8F 44 44 44 00
 140+ 4B93 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4B97 44 44 38 00
 141+ 4B9B 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4B9F 44 78 40 40
 142+ 4BA3 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4BA7 44 3C 04 04
 143+ 4BAB 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4BAF 40 40 40 00
 144+ 4BB3 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4BB7 38 04 78 00
 145+ 4BBB 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4BBF 20 24 18 00
 146+ 4BC3 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4BC7 44 4C 34 00
 147+ 4BCB 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4BCF 44 28 10 00
 148+ 4BD3 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4BD7 54 54 28 00
 149+ 4BDB 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4BDF 10 28 44 00
 150+ 4BE3 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4BE7 4C 34 04 38
 151+ 4BEB 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4BEF 10 20 7C 00
 152+ 4BF3 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4BF7 20 20 18 00
 153+ 4BFB 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4BFF 10 10 10 00
 154+ 4C03 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4C07 08 08 30 00
 155+ 4C0B 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4C0F 00 00 00 00
 156+ 4C13 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4C17 00 00 00 00
 157+ 4C1B 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4C1F A5 99 42 3C
 158+ 4C23 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4C27 DB E7 7E 3C
 159+ 4C2B 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4C2F 7C 38 10 00
 160+ 4C33 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4C37 7C 38 10 00
 161+ 4C3B 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4C3F 54 10 7C 00
 162+ 4C43 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4C47 D6 10 7C 00
 163+ 4C4B 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4C4F FF 18 18 18
 164+ 4C53 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4C57 1F 18 18 18
 165+ 4C5B 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4C5F F8 18 18 18
 166+ 4C63 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4C67 F8 00 00 00
 167+ 4C6B 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4C6F 1F 00 00 00
 168+ 4C73 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4C77 FF 00 00 00
 169+ 4C7B 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4C7F 1F 18 18 18
 170+ 4C83 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4C87 FF 18 18 18
 171+ 4C8B 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4C8F F8 18 18 18
 172+ 4C93 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4C97 FF 00 00 00
 173+ 4C9B 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4C9F 18 18 18 18
 174+ 4CA3 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4CA7 38 70 E0 C0
 175+ 4CAB C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4CAF 1C 0E 07 03
 176+ 4CB3 C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4CB7 3C 7E E7 C3
 177+ 4CBB 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4CBF 10 10 10 10
 178+ 4CC3 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4CC7 10 10 10 10
 179+ 4CCB 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4CCF 10 10 10 10
 180+ 4CD3 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4CD7 00 00 00 00
 181+ 4CDB 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4CDF 00 00 00 00
 182+ 4CE3 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4CE7 00 00 00 00
 183+ 4CEB 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4CEF 10 10 10 10
 184+ 4CF3 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4CF7 10 10 10 10
 185+ 4CFB 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4CFF 10 10 10 10
 186+ 4D03 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4D07 00 00 00 00
 187+ 4D0B 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4D0F 10 10 10 10
 188+ 4D13 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4D17 10 20 40 80
 189+ 4D1B 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4D1F 08 04 02 01
 190+ 4D23 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4D27 18 24 42 81
 191+ 4D2B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4D2F 00 00 FF FF
 192+ 4D33 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4D37 FF FF FF FF
 193+ 4D3B 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4D3F FF FF FF FF
 194+ 4D43 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4D47 00 00 00 00
 195+ 4D4B FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4D4F 00 00 00 00
 196+ 4D53 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4D57 FF FF 00 00
 197+ 4D5B C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4D5F C0 C0 C0 C0
 198+ 4D63 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4D67 F0 F0 F0 F0
 199+ 4D6B FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4D6F FC FC FC FC
 200+ 4D73 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4D77 03 03 03 03
 201+ 4D7B 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4D7F 0F 0F 0F 0F
 202+ 4D83 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 4D87 3F 3F 3F 3F
 203+ 4D8B FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 4D8F 81 81 81 FF
 204+ 4D93 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 4D97 F0 F0 F0 F0
 205+ 4D9B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 4D9F 0F 0F 0F 0F
 206+ 4DA3 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 4DA7 00 00 00 00
 207+ 4DAB F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 4DAF 00 00 00 00
 208+ 4DB3 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 4DB7 0F 0F 0F 0F
 209+ 4DBB 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 4DBF F0 F0 F0 F0
 210+ 4DC3 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 4DC7 3C 3C 3C 3C
 211+ 4DCB C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 4DCF C3 C3 C3 C3
 212+ 4DD3 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 4DD7 00 00 FF FF
 213+ 4DDB 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 4DDF FF FF 00 00
 214+ 4DE3 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 4DE7 33 33 CC CC
 215+ 4DEB 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 4DEF 55 AA 55 AA
 216+ 4DF3 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 4DF7 66 33 99 CC
 217+ 4DFB CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 4DFF CC 99 33 66
 218+ 4E03 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 4E07 33 99 CC 66
 219+ 4E0B 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 4E0F 66 CC 99 33
 220+ 4E13 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 4E17 10 00 7C 00
 221+ 4E1B 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 4E1F 60 00 7E 00
 222+ 4E23 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 4E27 06 00 7E 00
 223+ 4E2B 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 4E2F A0 60 20 00
 224+ 4E33 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 4E37 00 00 00 00
 225+ 4E3B 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 4E3F 70 00 00 00
 226+ 4E43 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 4E47 00 7E 00 00
 227+ 4E4B 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 4E4F 54 A8 00 00
 228+ 4E53 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 4E57 E0 C0 80 00
 229+ 4E5B FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 4E5F 00 00 00 00
 230+ 4E63 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 4E67 07 03 01 00
 231+ 4E6B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 4E6F 10 38 7C FE
 232+ 4E73 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 4E77 10 10 10 00
 233+ 4E7B 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 4E7F 20 40 00 00
 234+ 4E83 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 4E87 0C 08 00 00
 235+ 4E8B 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 4E8F 0E 0E 1E 00
 236+ 4E93 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 4E97 7C 38 10 00
 237+ 4E9B 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 4E9F E0 E0 F0 00
 238+ 4EA3 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 4EA7 60 20 00 00
 239+ 4EAB F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 4EAF 08 04 00 00
 240+ 4EB3 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 4EB7 F0 44 38 00
 241+ 4EBB 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 4EBF 28 28 28 00
 242+ 4EC3 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 4EC7 08 10 10 10
 243+ 4ECB 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 4ECF 20 10 10 10
 244+ 4ED3 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 4ED7 00 00 00 00
 245+ 4EDB 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 4EDF 00 00 00 00
 246+ 4EE3 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 4EE7 0F 1C 18 18
 247+ 4EEB 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 4EEF F0 38 18 18
 248+ 4EF3 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 4EF7 E0 00 00 00
 249+ 4EFB 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 4EFF 07 00 00 00
 250+ 4F03 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 4F07 42 42 3C 00
 251+ 4F0B 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 4F0F 7E 7E 3C 00
 252+ 4F13 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 4F17 7E 3C 18 00
 253+ 4F1B FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 4F1F F0 E0 C0 80
 254+ 4F23 FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 4F27 0F 07 03 01
 255+ 4F2B 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 4F2F 1F 3F 7F FF
 256+ 4F33 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 4F37 F8 FC FE FF
 257+ 4F3B 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 4F3F 78 70 60 00
 258+ 4F43 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 4F47 3C 66 00 00
 259+ 4F4B 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 4F4F 38 10 38 10
 260+ 4F53 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 4F57 44 44 38 00
 261+ 4F5B 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 4F5F 42 42 42 7E
 262+ 4F63 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 4F67 81 81 81 FF
 263+ 4F6B 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 4F6F 54 54 54 7C
 264+ 4F73 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 4F77 BD AD AD FF
 265+ 4F7B 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 4F7F AC AA EA 00
 266+ 4F83 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 4F87 7E 66 66 66
 267+ 4F8B 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 4F8F 9D 81 42 3C
 268+ 4F93 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 4F97 A5 A2 00 00
 269+ 4F9B 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 4F9F 48 42 42 3C
 270+ 4FA3 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 4FA7 99 81 FF 00
 271+ 4FAB 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 4FAF 7C 7C 7C 00
 272+ 4FB3 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 4FB7 F8 F8 F8 00
 273+ 4FBB FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 4FBF A5 A5 81 FF
 274+ 4FC3 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 4FC7 52 24 58 80
 275+ 4FCB 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 4FCF 81 76 0C 04
 276+ 4FD3 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 4FD7 08 18 38 10
 277+ 4FDB 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 4FDF F5 F5 31 12
 278+ 4FE3 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 4FE7 F0 F0 30 10
 279+ 4FEB 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 4FEF 7C 7E 78 48
 280+ 4FF3 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 4FF7 A1 99 42 3C
 281+ 4FFB 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 4FFF 20 22 5C 00
 282+ 5003 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 5007 24 1E 42 3C
 283+ 500B 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 500F 7C 00 10 00
 284+ 5013 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 5017 FF FF FF FF
 285+ 501B
# file closed: ../include/vdp/8x8fonts-r18.asm
  86  501B                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 501B              ; ------------------------------------------------------------------------------
   2+ 501B              ; LM80C - LOGO CHARSET - R1.1
   3+ 501B              ; ------------------------------------------------------------------------------
   4+ 501B              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 501B              ; designed by Leonardo Miliani. More info at
   6+ 501B              ; www DOT leonardomiliani DOT com
   7+ 501B              ; ------------------------------------------------------------------------------
   8+ 501B              ; Code Revision:
   9+ 501B              ; R1.0 - 20200124 - First revision: logo chars
  10+ 501B              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 501B              ; ------------------------------------------------------------------------------
  12+ 501B
  13+ 501B              LOGOFONT:   equ $
  14+ 501B 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 501F 00 00 00 00
  15+ 5023 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 5027 FF FF FF FF
  16+ 502B FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 502F 00 00 00 00
  17+ 5033 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 5037 0F 0F 0F 0F
  18+ 503B 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 503F FF FF FF FF
  19+ 5043 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 5047 F0 F0 F0 F0
  20+ 504B 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 504F 0F 0F 0F 0F
  21+ 5053 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 5057 F0 F0 F0 F0
  22+ 505B F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 505F 00 00 00 00
  23+ 5063 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 5067 00 00 00 00
  24+ 506B 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 506F FF 07 03 00
  25+ 5073 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 5077 FF E0 C0 00
  26+ 507B 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 507F 19 1F 18 18
  27+ 5083 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 5087 98 F8 18 18
  28+ 508B 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 508F 0F 00 00 00
  29+ 5093 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 5097 1F 1C 18 18
  30+ 509B 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 509F F8 38 18 18
  31+ 50A3 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 50A7 F0 00 00 00
  32+ 50AB 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 50AF FF 00 00 00
  33+ 50B3 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 50B7 FF FF FF FF
  34+ 50BB F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 50BF FF FF FF FF
  35+ 50C3 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 50C7 F0 F0 F0 F0
  36+ 50CB FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 50CF 0F 0F 0F 0F
  37+ 50D3 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 50D7 30 00 00 00
  38+ 50DB
# file closed: ../include/vdp/logo-fonts.asm
  87  50DB
  88  50DB              ; include ROM/RAM switcher
  89  50DB                  INCLUDE "../include/switcher/switcher-r11.asm"
# file opened: ../include/switcher/switcher-r11.asm
   1+ 50DB              ; ------------------------------------------------------------------------------
   2+ 50DB              ; LM80C - ROM/RAM SWITCHER - R1.1
   3+ 50DB              ; ------------------------------------------------------------------------------
   4+ 50DB              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 50DB              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 50DB              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 50DB              ; kind of warranty: you can use them at your own risk.
   8+ 50DB              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 50DB              ; maintain the copyright notices, include this advice and the note to the
  10+ 50DB              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 50DB              ; redistribuite them.
  12+ 50DB              ; https://www.leonardomiliani.com
  13+ 50DB              ;
  14+ 50DB              ; Please support me by visiting the following links:
  15+ 50DB              ; Main project page: https://www.leonardomiliani.com
  16+ 50DB              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 50DB              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 50DB              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 50DB              ; ------------------------------------------------------------------------------
  20+ 50DB              ; Code Revision:
  21+ 50DB              ; R1.0   - 20200718 - First version
  22+ 50DB              ; R1.1   - 20200827 - PIO settings now are part of the file
  23+ 50DB              ;-------------------------------------------------------------------------------
  24+ 50DB
  25+ 50DB              TMP_FW_LOC:     equ     $8000           ; address from where to make a temporary copy of the FW
  26+ 50DB              ;-------------------------------------------------------------------------------
  27+ 50DB              ; THIS CODE WILL BE EXECUTED FROM RAM
  28+ 50DB 3E FC        RAMRUN:         ld      A,%11111100     ; set ROM off and RAM on..
  29+ 50DD D3 01                        out     (PIO_DB),A      ; ...by setting bit #0 to 0 (and leave VRAM bank #0)
  30+ 50DF 01 1F 51                     ld      BC,END_OF_FW    ; let's copy back FW into low RAM - bytes to copy
  31+ 50E2 21 00 80                     ld      HL,TMP_FW_LOC   ; source address
  32+ 50E5 11 00 00                     ld      DE,$0000        ; dest. address
  33+ 50E8 ED B0                        ldir                    ; copy!
  34+ 50EA AF                           xor     A
  35+ 50EB D3 01                        out     (PIO_DB),A      ; all LEDs off - finished copying
  36+ 50ED C3 B0 02                     jp      INIT_HW         ; return control to old init (now into RAM)
  37+ 50F0
  38+ 50F0              ;-------------------------------------------------------------------------------
  39+ 50F0              ; copy the whole contents of ROM into RAM then disable the first memory
  40+ 50F0 3A 7C 51     ROM2RAM:        ld      A,(basicStarted); check if BASIC is already started
  41+ 50F3 FE 59                        cp      'Y'             ; to see if this is a power-up
  42+ 50F5 20 0F                        jr      NZ,CNTCP2RAM    ; no, continue copy to RAM
  43+ 50F7                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  44+ 50F7 3E CF                        ld      A,%11001111     ; set mode 3 ("control mode")
  45+ 50F9 D3 03                        out     (PIO_CB),A      ; for PIO port B
  46+ 50FB AF                           xor     A               ; set LEDs off, RAM on, VRAM on bank #0
  47+ 50FC D3 01                        out     (PIO_DB),A      ; send settings to PIO register
  48+ 50FE D3 03                        out     (PIO_CB),A      ; set pins following register's status
  49+ 5100 21 AE 52                     ld      HL,TEMPSTACK    ; temporary stack
  50+ 5103 C3 B3 02                     jp      INIT_HW2        ; jump to re-init HW
  51+ 5106
  52+ 5106                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  53+ 5106 3E CF        CNTCP2RAM:      ld      A,%11001111     ; set mode 3 (mode control)
  54+ 5108 D3 03                        out     (PIO_CB),A      ; for PIO port B
  55+ 510A 3E FD                        ld      A,%11111101     ; set pin #0 as HIGH to enable ROM
  56+ 510C D3 01                        out     (PIO_DB),A      ; store the value into the internal register
  57+ 510E AF                           xor     A               ; set pins to OUTPUT
  58+ 510F D3 03                        out     (PIO_CB),A      ; for port B, activating the RAM
  59+ 5111 01 1F 51                     ld      BC,END_OF_FW    ; copy FW from ROM to high RAM
  60+ 5114 21 00 00                     ld      HL,$0000        ; source address
  61+ 5117 11 00 80                     ld      DE,TMP_FW_LOC   ; dest. address
  62+ 511A ED B0                        ldir                    ; copy!
  63+ 511C C3 DB D0                     jp      RAMRUN+TMP_FW_LOC; jump to execute code into RAM
  64+ 511F
  65+ 511F              ;-------------------------------------------------------------------------------
  66+ 511F              END_OF_FW:      equ     $   ; this is the last cell of the firmware
# file closed: ../include/switcher/switcher-r11.asm
  90  511F
  91  511F              ; include workspace equates
  92  511F                  INCLUDE "../include/workspace/workspace-r1.0.asm"
# file opened: ../include/workspace/workspace-r1.0.asm
   1+ 511F              ; ------------------------------------------------------------------------------
   2+ 511F              ; LM80C 64K - WORKSPACE EQUATES - R1.0
   3+ 511F              ; ------------------------------------------------------------------------------
   4+ 511F              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 511F              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 511F              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 511F              ; kind of warranty: you can use them at your own risk.
   8+ 511F              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 511F              ; maintain the copyright notices, include this advice and the note to the
  10+ 511F              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 511F              ; redistribuite them.
  12+ 511F              ; https://www.leonardomiliani.com
  13+ 511F              ;
  14+ 511F              ; Please support me by visiting the following links:
  15+ 511F              ; Main project page: https://www.leonardomiliani.com
  16+ 511F              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 511F              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 511F              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 511F              ; ------------------------------------------------------------------------------
  20+ 511F
  21+ 511F              ; set starting of RAM based on computer model
  22+ 511F                  IFDEF LM80C64K
  23+ 511F              SERBUF_START    equ     END_OF_FW       ; RAM starts here
  24+ 511F                  ELSE
  25+ 511F ~            SERBUF_START    equ     $8000           ; RAM starts here
  26+ 511F                  ENDIF
  27+ 511F
  28+ 511F              ;-------------------------------------------------------------------------------
  29+ 511F              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  30+ 511F              serRdPtr        equ     serInPtr+2
  31+ 511F              serBufUsed      equ     serRdPtr+2
  32+ 511F              basicStarted    equ     serBufUsed+1
  33+ 511F              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  34+ 511F              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  35+ 511F
  36+ 511F              ; BASIC WORK SPACE LOCATIONS
  37+ 511F              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  38+ 511F              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  39+ 511F              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  40+ 511F              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  41+ 511F              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  42+ 511F              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  43+ 511F              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  44+ 511F              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  45+ 511F              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  46+ 511F              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  47+ 511F              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  48+ 511F              DIV2            equ     DIV1+$04        ; (4) <-   to
  49+ 511F              DIV3            equ     DIV2+$04        ; (3) <-   be
  50+ 511F              DIV4            equ     DIV3+$03        ; (2) <-inserted
  51+ 511F              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  52+ 511F              LSTRND          equ     SEED+$23        ; (4) Last random number
  53+ 511F              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  54+ 511F              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  55+ 511F              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  56+ 511F              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  57+ 511F              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  58+ 511F              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  59+ 511F              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  60+ 511F              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  61+ 511F              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  62+ 511F              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  63+ 511F              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  64+ 511F              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  65+ 511F              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  66+ 511F              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  67+ 511F              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  68+ 511F              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  69+ 511F              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  70+ 511F              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  71+ 511F              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  72+ 511F              STACK           equ     BUFFER+$05      ; (85) Initial stack
  73+ 511F              CURPOS          equ     STACK+$55       ; (1) Character position on line
  74+ 511F              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  75+ 511F              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  76+ 511F              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  77+ 511F              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location usable by BASIC
  78+ 511F              TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
  79+ 511F              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  80+ 511F              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  81+ 511F              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  82+ 511F              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  83+ 511F              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  84+ 511F              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  85+ 511F              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  86+ 511F              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  87+ 511F              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  88+ 511F              BRKLIN          equ     READFG+$01      ; (2) Line of break
  89+ 511F              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  90+ 511F              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  91+ 511F              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  92+ 511F              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  93+ 511F              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  94+ 511F              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  95+ 511F              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  96+ 511F              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  97+ 511F              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  98+ 511F              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  99+ 511F              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
 100+ 511F              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
 101+ 511F              SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
 102+ 511F              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 103+ 511F              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 104+ 511F              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 105+ 511F              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 106+ 511F              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 107+ 511F              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 108+ 511F              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 109+ 511F              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 110+ 511F              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 111+ 511F              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 112+ 511F              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 113+ 511F              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 511F              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 511F              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 116+ 511F              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 117+ 511F              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 118+ 511F              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 119+ 511F              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 120+ 511F              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 121+ 511F                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 122+ 511F              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 123+ 511F              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 124+ 511F              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 125+ 511F              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 126+ 511F              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 127+ 511F              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 128+ 511F              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 129+ 511F              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 130+ 511F              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 131+ 511F              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 132+ 511F              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 133+ 511F              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 134+ 511F                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 135+ 511F              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 136+ 511F              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 137+ 511F              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 138+ 511F              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 139+ 511F              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 140+ 511F                                                      ; from here there are the RAM locations that
 141+ 511F                                                      ; are saved during SAVE
 142+ 511F              PROGND          equ     DOS_EN+$01      ; (2) End of program
 143+ 511F              VAREND          equ     PROGND+$02      ; (2) End of variables
 144+ 511F              ARREND          equ     VAREND+$02      ; (2) End of arrays
 145+ 511F              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 146+ 511F              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 147+ 511F              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 148+ 511F              FPREG           equ     FNARG+$04       ; (3) Floating point register
 149+ 511F              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 150+ 511F              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 151+ 511F              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 152+ 511F              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 153+ 511F              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 154+ 511F              STLOOK          equ     PROGST+$64      ; Start of memory test
 155+ 511F
# file closed: ../include/workspace/workspace-r1.0.asm
  93  511F
  94  511F              ; END OF ASSEMBLY SOURCE
  95  511F              ;-------------------------------------------------------------------------------
  96  511F
# file closed: LM80C_64K-firmware-r1.04.asm

Value    Label
------ - -----------------------------------------------------------
0x5335   CHCSNDDTN
0x5333   CHBSNDDTN
0x51C7   NMIFLG
0x5106   CNTCP2RAM
0x511F   END_OF_FW
0x50DB   RAMRUN
0x8000   TMP_FW_LOC
0x400B   DV16_16_LP
0x4006 X DIV_16_16
0x3FFA   DIV_16_8LP
0x3FEB   DIV_8_8LOOP
0x3FDB   EXMUL16
0x3FD2   MLP1
0x3FCB   MLP
0x3FAB X TSTBIT
0x3F6B   BINIT
0x3F7E   CHKBIN
0x3F4D   BITOUT2
0x3F49   BITOUT
0x3F3B   ZEROSUP
0x3F35 X BIN2
0x3F1D   NOSUB7
0x3F21   HEXIT
0x3EFD   HEXLP
0x3F02   HEXLP1
0x3F2A   HXERR
0x3F0A   GETHEX
0x3EED   ADD301
0x3EDD   ADD30
0x3EC7   HEX4
0x3EC5   HEX3
0x3EB6   HEX1
0x3EB8   HEX2
0x3E62   PRTEND
0x3E56   PRTK1
0x3E53   OPNQT1
0x3E3B   CLSQT1
0x3E97   CHKEY5
0x3E23   PTCHR1
0x3E94   CHKEY4
0x3E2B   CLSQT
0x3DEE   PRTK3
0x3E06   PRTCHR
0x3E3D   OPNQT
0x3DF1   CNTLTK
0x3DDC   LDKEY
0x3E8B   CHKEY2
0x3E55   PRTCKEY
0x3E86   CHKEY1
0x3DC5 X PRTK2
0x3DC3   PRTK4
0x3DAF   CPKYEND
0x3DA7   CPKEY1
0x3D9F   CPKEY3
0x3D98   CPKEY2
0x3D88   CPKEY
0x3D7A   DECLN1
0x3E64   SETREP
0x3D4A   KEYCH
0x3DB1   LSTKEYS
0x3D28   HLPERR
0x3D06   DIRMOD
0x3CCD   EXNRM
0x3CBF   ENCHB
0x3C94   SRLCNT
0x3C7C   STRPAR
0x3C5F   SETPAR2
0x3C50   BITS8
0x3C45   BITS7
0x3C54   SETPAR
0x3C3B   BITS6
0x3C18   SET_CTC
0x3CEA   CTC_CFG
0x3CF5   SCERR1
0x3C07   SET_PT
0x3BEE   CKBPS
0x3CD4   SUP_BPS
0x3BE2   SETSER
0x3BD5   DEFSER
0x3B8A   CNTSER3
0x3B6D   CNTRX2
0x3B78   CNTSER2
0x3B3A   SERLED
0x3B34   SRPT2
0x3B11   RPTRSSR
0x3B04   RSTSERS
0x3B3E   CNTSER
0x3B00   CHKZSER
0x3AF1   SERVAR
0x3CF9   SCERR
0x530B   SIOBFR
0x530A   STPBT
0x5309   PARBT
0x5308   DATABT
0x5306   BPS
0x5305   PRTNUM
0x3AAB   RPTCVB2
0x3AA2   RPTCVB1
0x3A95   CNTVALY
0x3A65   CNTCL7
0x3A41   CNTCL6
0x3A1D   CNTCL5
0x39FB   CNTCL4
0x39D5   CNTCL3
0x39B1   CNTCL2
0x3A8F   VALIDY
0x398D   CNTCL1
0x3A8A   VALIDX
0x395E   PLTCRL
0x394F   DLSZ
0x3967   ENDCRL
0x3922   RPTCL1
0x390F   RPTCRL
0x396B   DRWCRL
0x530F   DC
0x530D   YI
0x530B   XI
0x5309   RADIUS
0x5307   YC
0x5305   XC
0x389E   DXGR
0x38C7   ENDDRAW
0x386E   CNTDRW
0x3852   RPTDRW
0x384F   STRE2
0x3842   ER2
0x3FE0   negHL
0x381F   Y1GR
0x37F5   X1GR
0x3FDD   absHL
0x3A9A   CLRVDBF
0x5311   DX
0x530F   SY
0x530D   SX
0x530B   E2
0x5309   ER
0x5307   Y2
0x5305   X2
0x52FF   Y1
0x52FD   X1
0x3FE7   DIV_8_8
0x3762   PXLSET
0x373E   CNTPLT1
0x375E   NOGD
0x376A   XY2HL
0x36D9   PNTEND
0x36E3   CTPOINT
0x3690   PAINT5
0x365F   PAINT3
0x36A0   CHECKPY
0x364C   PAINT2
0x371D   CNTPLOT
0x361C   MNPAINT
0x3619   PAINT1
0x3618   PAINT11
0x369F   CHECKPA
0x360A   PAINT0
0x3697   EXITPAI
0x35FD   NXTLOOP
0x369B   EXITPA2
0x36F7   PNTRTN
0x3AB2   CLRPRM
0x5309   ORGSP
0x5308 X SPB
0x5307 X SPA
0x5305   PNT
0x358F   GPCPCH1
0x3585 X GPCPCHR
0x356B   GPNTCO1
0x3562 X GPNTCOL
0x3557   RPGPNT
0x3542   GPNT
0x352D   CNTGPT2
0x35AC   CKCOL
0x530B   TMPHL
0x5309   NUMCHR
0x5307   CHRPNT
0x5305   TMPADR
0x52FD   MIXCOL
0x52FF   TMPCLR
0x5303   GY
0x5301   GX
0x3ACB   GMERR
0x34C7   CHKG2M
0x34C1   CHKCLR0
0x348C   RPTLDCL
0x3482   LOADCLR
0x3497   SETBRCL
0x34B0   MIXCLRS
0x347B   CLREX2
0x3472   CLRG2
0x3469   CLRG1
0x345F   CLRTXT
0x3462   CLRMC
0x34BD   CHKCLR1
0x33B7   CKMAGN
0x3404   CHKSCAR
0x33AC X SETVDP
0x33C5   SCVDP
0x3388   RPTPS
0x3383 X DIR_PAU
0x335D X RECWRD
0x3339 X ARET
0x3314   ATNTAB
0x330A   ATN1
0x32C3   SINTAB
0x32A7   SIN1
0x32BF   QUARTR
0x32BB   HALFPI
0x3254   RND2
0x3238   RND1
0x3265   RNDTAB
0x51BA   LSTRND
0x325D   RESEED
0x5197   SEED
0x31E4   SUMLP
0x31DB   SMSER1
0x31AB   EXPTAB
0x3153   POWER2
0x3136   POWER1
0x3118   NEGAFT
0x30E3   EXPTEN
0x30E1   OUTEXP
0x30F0   NOENED
0x30C5   SUPTLZ
0x30D1   DOEBIT
0x30A0   TRYAGN
0x3091   DIGTXT
0x3106   POWERS
0x3080   MAKNUM
0x305B   GTSIXD
0x3064   INRNG
0x3046   SIXDIG
0x30F3   RNGTST
0x30ED   JSTZER
0x3037   SPCFST
0x5356   PBUFF
0x2FE1   MULTEN
0x2FD6   ENDCON
0x2FE0   SCALPL
0x2FCA   SCALMI
0x300A   EDIGIT
0x2FB5   EXPLP
0x2FC7   CONEXP
0x2FC3   DPOINT
0x2FE8   ADDIG
0x2F9F   MANLP
0x2F97   CNVNUM
0x2F86   NOMLAD
0x2F78   MLDBLP
0x2F50   DCBCDE
0x2F19   CMPFP
0x2EE1   DETHLB
0x2EDA   INCHL
0x2E8D   RETREL
0x2E6D   MLSP10
0x2E60   OVTST1
0x2E65   OVTST2
0x2E66   OVTST3
0x2E12   RESDIV
0x5189   DIVSUP
0x2DFF   DIVLP
0x5195   DIV4
0x518A   DIV1
0x518E   DIV2
0x5192   DIV3
0x2DCC   DIV10
0x2D64   NOMADD
0x2D53   MUL8LP
0x2D76   BYTSFT
0x2D4A   MULT8
0x5363   MULVAL
0x2E42   ADDEXP
0x2D28   FPMULT
0x2D1F   MULLN2
0x2FFF   RSCALE
0x31CC   SUMSER
0x2DDA   DVBCDE
0x2CDA   LOGTAB
0x2CD6   UNITY
0x2CC4   SHRLP
0x2CC1   SHRITE
0x2CB4   SCALLP
0x5355   SGNRES
0x2C85   FPROND
0x2C74   RONDB
0x2C58   NORMAL
0x2C54   SAVEXP
0x2C60   PNORM
0x2C3B   CONPOS
0x2CC8   SHRT1
0x2C73   RONDUP
0x2C92   PLUCDE
0x2C2D   MINCDE
0x2CB2   SCALE
0x2EEA   SIGNS
0x2C07   NOSWAP
0x2BEA   SUBCDE
0x2BE4   SUBPHL
0x2BED   FPADD
0x3102   HALF
0x2BDB   ROUND
0x2BD8 X ENDINK2
0x2BBD   CHKINK
0x2BB9   SRTINK
0x2BCF   ENDINK
0x2BA5   INKEY2
0x2B96   CMP_A
0x2B44   NOS3
0x2B2B   NOS2
0x2B18   NOS1
0x2AE8   SNDOVR
0x2B3B   WRTSND
0x2AB3   SND1
0x2A45   RPVOLCG
0x2A51   VOLCH
0x29AA   PKEPRMS
0x2994   SYSRET
0x2986   NOSYSPR
0x2948   NMIINT
0x2954   NMIVR1
0x293E   NMIEINT
0x293A   NMI2
0x2945   NMIDINT
0x2918   DISNMI
0x2929   NM1
0x5187   OTPORT
0x28E1   WAITLP
0x28E0   NOXOR
0x5186   OUTSUB
0x28EA   SETIO
0x51BE   INPSUB
0x51BF   INPORT
0x28A9   VAL2
0x28AC   VAL3
0x289F   VAL1
0x2C53   RESZER
0x286A   RSTSTR
0x28B5   MIDNUM
0x2836   LVINSTR
0x2840   CNTZIN
0x27E0   RP2INST
0x2809   CNT1INS
0x27B9   RPTINST
0x282B   RZINSTR
0x5313   DY
0x27A8   EMPTINS
0x530D   TF
0x530B   TP
0x5309   PT2
0x5305   PT
0x5303   ADRS2
0x5301   LNS2
0x52FF   ADRS1
0x52FD   LNS1
0x272F   ALLFOL
0x2727   MID1
0x3F8C   BINERR
0x2725   RIGHT1
0x28B0   LFRGNM
0x2900   MAKINT
0x2704 X GTFLNM
0x26F5   GETLEN
0x26DE   POPHL
0x26BF   GETSTR
0x26B6   TSALP
0x26AC   SSTSA
0x26C5   GSTRHL
0x2619   GRBARY
0x2650   SCNEND
0x25F9   GNXARY
0x262A   STRADD
0x25FA   ARRLP
0x25E4   SMPVAR
0x2627   STPOOL
0x25D3   GRBLP
0x25C5   GARBLP
0x25B6   TESTOS
0x259A   GRBDON
0x2589   PRSLP
0x257E   PRNUMS
0x255F   TSTOPL
0x2553   CRTSTE
0x2544   QTSTLP
0x252E   MKTMST
0x26B5   TOSTRA
0x2531   CRTMST
0x2598   TESTR
0x271D   TOPOOL
0x250F   STR1
0x2537   SVSTAD
0x24F8   CHEKFN
0x2470   PASSA
0x2E9B   RETINT
0x25C2   GARBGE
0x245B   FRENUM
0x243A   ENDTMR
0x2406   FNDELP
0x2425   ENDDIM
0x23E4   ZERARY
0x2F70   MLDEBC
0x23C6   DEFSIZ
0x23BE   CRARLP
0x239E   BSERR
0x2401   FINDEL
0x2385   NXTARY
0x23A3   CREARY
0x2371   FNDARY
0x2349   SCPTLP
0x2327   ZEROLP
0x2338   RETNUL
0x2335   RETADR
0x22F6   FNTHR
0x2301   CFEVAL
0x22E8   FNDVAR
0x2D74   POPHRT
0x534D   FNARG
0x2343   SBSCPT
0x22CE   NSCFOR
0x236B   ARLDSV
0x22BE   NOTSTR
0x22A3   ENDNAM
0x22AF   CHARTY
0x22A2   SVNAM2
0x228B   GTFNAM
0x52B2   LCRFLG
0x2278   DIMRET
0x2E96   FLGREL
0x2E8F   FLGDIF
0x223F   CMPSTR
0x26C6   GSTRDE
0x26C2   GSTRCU
0x2257   CMPRES
0x2215   CMPLG1
0x2213   CMPLOG
0x21FC   PXOR1
0x21EF X PAND1
0x21F4   POR1
0x2460   ACPASS
0x2EC5   FPBCDE
0x21D4   CNTLGC
0x21BA   SGNEXP
0x21B1   GOFUNC
0x21A9   FNVAL
0x216A   FRMEVL
0x2162   RETNUM
0x2EAD   INVSGN
0x214E   EVLPAR
0x2178   FNOFST
0x24A2   DOFN
0x2261   EVNOT
0x2156   MINUS
0x3F61   BINTFP
0x3EF1   HEXTFP
0x212B   NOTAMP
0x2167   CONVAR
0x2EB5   STAKFP
0x20E9   STKTHS
0x2675   CONCAT
0x2201   TSTRED
0x52CB   CUROPR
0x20C1   FOPRND
0x20A5   RLTLP
0x2098   EVAL3
0x52D6   NXTOPR
0x2095   EVAL2
0x2100   OPRND
0x208C   EVAL1
0x2085   OPNPAR
0x207B   TSTSTR
0x2067   KILFOR
0x2ED3   LOADFP
0x2BDE   ADDPHL
0x2EC2   PHLTFP
0x202F   NEXT1
0x2021   FANDT
0x1FF8   EXTIG
0x1FDD   MORDT
0x2F8B   ASCTFP
0x1FD1   LTSTND
0x2541   DTSTR
0x1FB7   ITMSEP
0x1FBA   STRENT
0x1FC6   INPBIN
0x2008   FDTLP
0x1F9C   ANTVLU
0x1F70   NEDMOR
0x1F74   GTVLUS
0x1F68   NXTITM
0x1F4B   NOPMPT
0x24EA   IDTEST
0x52D3   READFG
0x1F20   BADINP
0x1F0E   REDO
0x1EFF   SPCLP
0x1EF8   DOSPC
0x28FA   FNDNUM
0x1ED8   ZONELP
0x1EC5   CNTEND
0x2582   PRS1
0x253D   CRTST
0x3029   NUMASC
0x1EA2   PRNTST
0x1F07   NEXITM
0x1ECA   DOCOM
0x1EE3   DOTAB
0x1E5B   PRNTLP
0x1E54   MRPRNT
0x1E3D   IF0
0x1E46   IF1
0x1E34   IFGO
0x1E18   ONGOLP
0x1E17   ONGO
0x28FD   GETINT
0x2EDC   FPTHL
0x2EDF   DETHL4
0x2519   SAVSTR
0x26E0   BAKTMP
0x52C5   TMPSTR
0x1DF8   MVSTPT
0x1DF0   CRESTR
0x5351   FPREG
0x1DC9   LETSTR
0x1E01   LETNUM
0x207C   CHKTYP
0x2089   EVAL
0x52B3   TYPE
0x2286   GETVAR
0x1DA0   NXTSTT
0x1D9D   NXTSTL
0x1D96   NXTDTA
0x1D91   RETLIN
0x1D53   RUNLIN
0x1D0C   STORED
0x1CC2   GTLNLP
0x1CBF   GETLN
0x2EFF   CMPNUM
0x2F2C   FPINT
0x5354   FPEXP
0x1C9E   DEPINT
0x1C9B X POSINT
0x2AEE   NOISUP
0x1C98   FPSINT
0x1C90   CHKLTR
0x51C5   CHKSUM
0x1C83 X ACCSUM
0x1C64   ERRINT
0x52D8   ERRLIN
0x1C53   NOLIN
0x1C3D   INPBRK
0x51C8   BRKFLG
0x1C27   STALL
0x1C31   BRK
0x5349   NXTDAT
0x1C14   UPDATA
0x1C13   RESTNL
0x1BD6   ONJMP
0x1BD5   IFJMP
0x1C40   ENDPRG
0x1BAE   RUNCNT
0x1BAA   PUTFID
0x2E84   TSTSGN
0x1BA1   SAVSTP
0x2ED0   BCDEFP
0x2077   GETNUM
0x207A   TSTNUM
0x1B65   FORFND
0x1B49   FORSLP
0x52CD   LOOPST
0x1B2E   CNTWTSP
0x1B22   WTSPC
0x1B1A   LVSRLN
0x1B0F   SRCLN1
0x1AEC   OUTWRD
0x1AFA   NXTLN
0x1AD3   LSTLP3
0x1AD0   LSTLP2
0x1AC4   LST07
0x1AC1   LST08
0x1B1C   TSTSPC
0x1C19   TSTBRK
0x367E   PAINT4
0x1A96   LST02
0x1A93   LST05
0x1A56   LST06
0x1A7F   LST03
0x1A5A   LSTNOT
0x1A3B   LST01H
0x1A9F   LISTLP
0x1B0E   SRCLN
0x1B08   SRCHLIN
0x1A38   LST01
0x1A67   LSTALL
0x333A   GETINP
0x3F91   MONOUT
0x19EB   SND2VID
0x19D8   INCLEN
0x52B1   CURPOS
0x51C1   LWIDTH
0x19DC   DINPOS
0x25B4   POPAF
0x19AD   CHKSYN
0x199E   OUTIT
0x19A1   OUTNBS
0x3FB2   OUTNCR
0x198A   PUTBUF
0x1EB1   ENDINP
0x1984   GMNCR
0x198F   PUTCTL
0x194F   PROCES
0x19F9   CLOTST
0x1927   KILIN
0x191C   DELCHR
0x1936   MORINP
0x1924   OTKLN
0x1910   ECHDEL
0x51C3   NULFLG
0x18FC   DODEL
0x18E3   NXTCHR
0x18DD   TSTREM
0x18DA   SETLIT
0x18BC   NOCHNG
0x18B3   NOSPC
0x18C4   MATCH
0x18A2   NXTBYT
0x1892   GETNXT
0x1890   SEARCH
0x18C8   RETNAD
0x1877   FNDWRD
0x18F3   ENDBUF
0x18EC   CPYLIT
0x18CC   MOVDIR
0x184D   CRNCLP
0x52B4   DATFLG
0x51C9   RINPUT
0x1830   DOAGN
0x534B   FNRGNM
0x52D1   FORFLG
0x52DA   CONTAD
0x52B7   TMSTPT
0x52B9   TMSTPL
0x5345   VAREND
0x52C9   STRBOT
0x52D4   BRKLIN
0x1801   INTVAR
0x17D4   SRCHLP
0x5254   BASTXT
0x17C5   FNDEND
0x17B9   PTRLP
0x17FD   RUNFST
0x17AC   MOVBUF
0x17B4   SETPTR
0x177E   SFTPRG
0x5343   PROGND
0x178D   INEWLN
0x1D6D   ULERR
0x1776   LINFND
0x17D1   SRCHLN
0x52D2   LSTBIN
0x1BCE   EXCUTE
0x1844   CRUNCH
0x192D   GETLIN
0x1732   GETCMD
0x1724   POPNOK
0x3016   LINEIN
0x51D0   HLPLN
0x1720   PTLN
0x1703   ERRIN
0x19B8   OUTC
0x1EA9   STTLIN
0x51C4   CTLOFG
0x16DD   TMERR
0x16DA   OVERR
0x16D7   UFERR
0x16D4   DDERR
0x16D1   NFERR
0x16CE   DZERR
0x52CF   DATLIN
0x16C5   DATSNR
0x16C3   LDG1ND
0x16B2   LDG1
0x16A5   EXITGM
0x16DF   ERROR
0x16A0   OMERR
0x5347   ARREND
0x1688   CHKSTK
0x167D   MOVLP
0x167A   MOVSTR
0x1691   ENFMEM
0x1677   MOVUP
0x166E   INDFND
0x1658   LOKFOR
0x1654   BAKSTK
0x164E   BRKMSG
0x1649   OKMSG
0x1648   ZERBYT
0x1644   INMSG
0x163D   ERRMSG
0x15BB X DEFFNKS
0x15B9   AUTORP
0x192D   TTYLIN
0x1CB9   FCERR
0x21CD   POR
0x21D2   PXOR
0x21CA   PAND
0x2C3E   BNORM
0x3126   POWER
0x2D7B   DINT
0x2D83   MOD
0x2DD8   DIV
0x2D26   MULT
0x2BE8   PSUB
0x3005   PADD
0x1546   PRITAB
0x00E9   ZLEFT
0x00E1   ZINSTR
0x00E0   ZPOINT
0x00CA   ZSGN
0x00C9   ZLTH
0x00C8   ZEQUAL
0x00C7   ZGTR
0x00C6   ZOR
0x00C2 X ZDINT
0x00C1 X ZMOD
0x00C0 X ZDIV
0x00BF X ZTIMES
0x00BE   ZMINUS
0x00BD   ZPLUS
0x00BC   ZSTEP
0x00BB   ZNOT
0x00BA   ZTHEN
0x00B9   ZSPC
0x00B8   ZFN
0x00B7   ZTO
0x00B6   ZTAB
0x00B5   ZNEW
0x00AF   ZPRINT
0x00AE   ZELSE
0x008E   ZREM
0x008C   ZGOSUB
0x0088   ZGOTO
0x0083   ZDATA
0x0081   ZFOR
0x0080   ZEND
0x17F1   NEW
0x3E9B   SAVE
0x3E9A   LOAD
0x1CE3   CLEAR
0x1A0C   LIST
0x1C6A   CONT
0x1E58   PRINT
0x3F94   RESET
0x2968   SYS
0x3350   WIDTH
0x34D0   GPRINT
0x290E   NMI
0x3D2D   KEY
0x333C   CLS
0x3D12   HELP
0x3AD0   SERIAL
0x35BF   PAINT
0x38CB   CIRCLE
0x3795   DRAW
0x3702   PLOT
0x3414   COLOR
0x337A   PAUSE
0x2A23   VOLUME
0x2A5C   SOUND
0x29D0   LOCATE
0x2B50   VREG
0x2A02   SREG
0x29C5   VPOKE
0x3363   DOKE
0x29C0   POKE
0x2475   DEF
0x28CC   WAIT
0x3E9D   ERASE
0x3E9C   FILES
0x1E08   ON
0x28C6   POUT
0x1C36   STOP
0x1D99   REM
0x1D72   RETURN
0x1D43   GOSUB
0x1BFE   RESTOR
0x1E26   IF
0x1D2F   RUN
0x1D54   GOTO
0x1DAE   LET
0x1F63   READ
0x2281   DIM
0x1F31   INPUT
0x1D97   DATA
0x202C   NEXT
0x1B35   FOR
0x1C38   PEND
0x14DA   WORDTB
0x134D   WORDS
0x2851   MID
0x2847   RIGHT
0x2721   LEFT
0x3F2F   BIN
0x3E9E   HEX
0x2711   CHR
0x2700   ASC
0x2881   VAL
0x2509   STR
0x3B74   RXEND
0x26F1   LEN
0x2751   INSTR
0x36AF   POINT
0x2B8B   INKEY
0x2B77   SSTAT
0x2B6C   VSTAT
0x299D   VPEEK
0x3358   DEEK
0x2996   PEEK
0x32ED   ATN
0x32D8   TAN
0x3399   SCREEN
0x3277   SIN
0x3271   COS
0x316B   EXP
0x2CE7   LOG
0x31FC   RND
0x311D   SQR
0x246D   POS
0x28BA   INP
0x243F   FRE
0x5307   PT1
0x5183   USR
0x2EA9   ABS_
0x2F57   INT
0x2429   TMR
0x2E93   SGN
0x1309   FNCTAB
0x1725   PRNTOK
0x3D3A   RESFN
0x129A   BRKRET
0x525C   STACK
0x12AF   BFREE
0x301E   PRNTHL
0x12A6   BLNSPC
0x17F2   CLRPTR
0x51CC   STRSPC
0x52B5   LSTRAM
0x1263   NODOS
0x19A7   CPDEHL
0x16CB   SNERR
0x1CBE   ATOH
0x124C   SETTOP
0x1228   MLOOP
0x53CA   STLOOK
0x123A   TSTMEM
0x1BEE   GETCHR
0x1834   PROMPT
0x257F   PRS
0x12FE   MEMMSG
0x1212   MSIZE
0x1225   MNOASK
0x2A6A   CTSNDC
0x5366   PROGST
0x5257   BUFFER
0x1EBB   PRNTCRLF
0x1817   CLREG
0x1AE2   FNDTOK
0x163D   INITBE
0x1564   INITAB
0x11F7   INIT
0x517D   WRKSPC
0x2461   ABPASS
0x1E9E   PRNTNB
0x1CA4   DEINT
0x11F0   CSTART
0x1297   WARMST
0x11E9   STARTB
0x1033 X ERRORS
0x11D9   HPMSG
0x1031 X HPPTR
0x11C3   SOMSG
0x11AA   SAMSG
0x102D X SAPTR
0x1195   SCMSG
0x102B X SCPTR
0x1029 X GMPRT
0x1179   BNMSG
0x1027 X BNPTR
0x116E   HXMSG
0x1025 X HXPTR
0x115E   MOMSG
0x1023 X MOPTR
0x3ED4   BYT2ASC
0x1148   UFMSG
0x1021 X UFPTR
0x1139   CNMSG
0x101F X CNPTR
0x111E   STMSG
0x101D X STPTR
0x102F X SOPTR
0x110E   LSMSG
0x101B X LSPTR
0x10FA   OSMSG
0x1019 X OSPTR
0x10EB   TMMSG
0x1017 X TMPTR
0x10DC   IDMSG
0x1015 X IDPTR
0x10CB   DZMSG
0x1013 X DZPTR
0x10B6   DDMSG
0x1011 X DDPTR
0x10A8   BSMSG
0x100F X BSPTR
0x1099   ULMSG
0x3E8E   CHKEY3
0x100D X ULPTR
0x108B   OMMSG
0x100B X OMPTR
0x1082   OVMSG
0x1009 X OVPTR
0x106C   FCMSG
0x1007 X FCPTR
0x1060   ODMSG
0x1005 X ODPTR
0x104B   RGMSG
0x1003 X RGPTR
0x1044   SNMSG
0x1001 X SNPTR
0x1033   NFMSG
0x0FFF X NFPTR
0x0FFF   ERRTBL
0x0032   HP
0x0030   SO
0x002E   SA
0x002C   SC
0x002A   GM
0x0028   BN
0x0026 X HX
0x0024   MO
0x0022   UF
0x0020   CN
0x001E   ST
0x1EFD   ASPCS
0x001C   LS
0x001A   OS
0x0018   TM
0x0016   ID
0x0014   DZ
0x0012   DD
0x0010   BS
0x000E   UL
0x000C   OM
0x000A   OV
0x0008   FC
0x0006   OD
0x0004   RG
0x0002   SN
0x0000   NF
0x007F   DEL
0x001B   ESC
0x0015   CTRLU
0x0013   CTRLS
0x0012   CTRLR
0x0011   CTRLQ
0x000F   CTRLO
0x0007   CTRLG
0x0ED7   CNTFNK
0x0EEA   PRNTFNK
0x0EDD   PUTCHRBUF1
0x0EC3   LDFNKEYCHR
0x51D4   FNKEYS
0x51CE   LINEAT
0x12BD   SIGNON
0x0EAA X LVKBRDCHK
0x0EA3   PNT2VD
0x0E96   PUTCHRBUF
0x0E84   SNDKEYTOBFR
0x0EAB   PRNTFNKEY
0x0E7C   CHKFNK
0x0EF7   FNKEYSORD
0x0E76   CNTKBCK
0x0003   CTRLC
0x51D3   AUTOKE
0x2C41   BNRMLP
0x0E63   SENDKEY
0x0E34   SETNEWAUTO
0x0EA6   LVKBRDCHK2
0x51D2   KEYDEL
0x0E44   CHKAUTO
0x533C   KEYTMR
0x0E56   NEWKEY
0x0F7F   KBMAP_ALT
0x0FBF   KBMAP_CTRL
0x0DFB   CHKALT
0x0E02   LOADMAP
0x0F3F   KBMAP_SFT
0x0DF2   CHKCTRL
0x0EFF   KBMAP
0x0DDE   CHKLN
0x533B   STATUSKEY
0x533A   LASTKEYPRSD
0x0DC6   ENDCTRLCK
0x0DC0   TESTCTRL
0x0DDC   FINDKEY
0x0DB3   TESTALT
0x5338   KBTMP
0x0DCA   NOKEYPRSD
0x0D84   RPTKBDRD
0x0D80   CHECKKBD
0x0D72   CHECKCTRL
0x533E   CONTROLKEYS
0x0D64   CHECKALT
0x0D24   CNTCHKSND
0x0CE9   CHKSNDCH
0x0CB7   RPTWLCMBP
0x0CCD   NOBPDAT
0x0CB4   SENDSND
0x0CC5   WLCBPDAT
0x0CDA   WRTSNDREG
0x0CD5   SETSNDREG
0x0C9B   SNDREGCFG
0x0C87   CLRPSGREGS
0x0C83   EMPTSNDBFR
0x0B35 X VDPMODESETEX2
0x0B2D X VDPMODESETMC
0x0B25 X VDPMODESET2
0x253E   QTSTR
0x0B1D X VDPMODESET1
0x0B0B   SENDCHRPTRNS
0x481B   CHRST88
0x0B09   NXTCHAR
0x401B   CHRST68
0x0AEB   LDREGVLS
0x0B15   VDPMODESET
0x0AD4   RSTVDPRAMREG
0x5331   CHASNDDTN
0x0AC5   EMPTVRM
0x0A5A X CNTNULL2
0x0A4D   RPTNLLSRC2
0x3FC3   MUL16
0x0A28   ADDNEWLINE
0x09F5   SNDCHRTOBFR
0x09DC   CNTNULL
0x09CC   RPTNLLSRC
0x0A14   PRNTRETURN
0x5303   TMPBFR4
0x5301   TMPBFR3
0x52FF   SRTTXT
0x52FF   TMPBFR2
0x09A2   RPTEMPTYROW
0x0988   WRITEBUF
0x0960   LOADNEXTCOL
0x5305   VIDEOBUFF
0x094F   SCROLLNXTRW
0x532F   VIDTMP2
0x532D   VIDTMP1
0x092D   EXITCURSOR_ON
0x0917   EXITCURSORDOWN
0x08F7   EXITCURSORRGHT
0x08F1   CONTCRSRGT
0x08DE   CHCKYPOS2
0x08C3   EXITCURSORUP
0x089A   CHKYPOS
0x0887   EXITCURSORLEFT
0x0884   CONTCRSLFT
0x0873   CHCKYPOS
0x0889   MVCRS2LFT
0x0844   MVBKSP
0x0857   LVBKSP
0x0020   SPC
0x080F X ENDINSRT
0x080A   NXTINST
0x3FB8   CMP16
0x07F9   CHKHL
0x5301   ENDTXT
0x0A35   ENDOFLN
0x52FD   CUR_POS
0x07D7   PUTCRSCHR
0x0936   SCROLLUP
0x0797   SETCRSRY
0x0798   SETCSRCOORDS
0x07AA   EXITCHAR2VID
0x076E   NXTCPCK
0x0761   RPTCPCK
0x07B7   PLACEHOLDER
0x000A   LF
0x07DB   INSERTKEY
0x001A   INSRT
0x08FA   CURSORDOWN
0x001F   CRSDN
0x08C5   CURSORRIGHT
0x001D   CRSRGT
0x08AC   CURSORUP
0x001E   CRSUP
0x0860   CURSORLEFT
0x001C   CRSLFT
0x081D   BACKSPACE
0x3431   CNTCKCL
0x0008   BKSP
0x09AE   CRGRETURN
0x000C   CS
0x0019   HOME
0x0730   CHRTBL
0x3FF7   DIV_16_8
0x071F   HL2XY
0x0A5B   POS_TB_CRS_32
0x0711   CONT_POS_CURS
0x0A8B   POS_TB_CRS_40
0x52F8   LSTCSRSTA
0x06C9   MOVSHOWCRS
0x06DE   NEWCRSRCOORD
0x06F3   RSTCHRCRS
0x06FC   LOAD_CRSR_POS
0x06B2   READ_VSTAT
0x06A7   WRITE_VREG
0x0692   WRITE_VIDEO_LOC
0x067D   READ_VIDEO_LOC
0x06C3   MOVCRS
0x52F4   SCR_CUR_NX
0x0000   NLLCR
0x52F5   SCR_CUR_NY
0x0673   ATHOME
0x06B9   POS_CURSOR
0x0666   CLEARVIDBUF
0x0653   RPTFLL1
0x0641   SNDCLRSET
0x063D   STARTEMPTY
0x0607   CLRG2PTNTBL
0x05ED   RPTEMPTYBUF
0x05E7   LDCOLSTOEMPTY
0x0626   EMPTYMC
0x05F6   EMPTYG2
0x05CC   LVCKSPLK
0x0D2F   READKBLN
0x05AF   SNDLOGPT
0x2C9E   COMPL
0x501B   LOGOFONT
0x0CB1   NOBEEP
0x0CAB   WLCMBEEP
0x057B   RPT100
0x05BE   CHKSPCK
0x0591   BEEPOFF
0x0585   SETBEEP
0x054F   DEC_D
0x5342   DOS_EN
0x52FD   TMPBFR1
0x053D   RPT104
0x0599   LOADLOGOCHRS
0x0535   RPT103
0x0B3D   LM80CLOGO
0x051F   RPT102
0x0C8E   RSTPSG
0x051C   RPT101
0x05B9   CLRTABLE
0x056E   ERASECLRTBL
0x064B   SETNAMETABLE
0x0AE1   SET_GFX_MODE2
0x52F6   SCR_ORG_CHR
0x05CE   EMPTYVIDBUF
0x0459   LDCLRTBMD1
0x52FB   FRGNDCLR
0x065D   SETVDPADRS
0x04E9   ENDVDPSET
0x52F0   SCR_NAM_TB
0x51C2   COMMAN
0x52ED   SCR_SIZE_H
0x52EC   SCR_SIZE_W
0x52FC   BKGNDCLR
0x52F3   SCR_CURS_Y
0x04E0   LDCLRTBEX2
0x52F2   SCR_CURS_X
0x0AF5   LOADCHARSET
0x03F8 X TXTMD
0x04A7   EXG2MD
0x0484   MCMD
0x0462   G2MD
0x0422   G1MD
0x52EE   SCR_MODE
0x0ACE   CLR_RAM_REG
0x0AD9   SET_GFX_MODE
0x0ABB   EMPTY_VRAM
0x0367   RESTMR
0x036C   CTCCONF
0x033E X SIO_B_SETS
0x0338   SIO_A_SETS
0x11E6   WARM
0x11E3   COLD
0x092F   CURSOR_OFF
0x031E   ECHO_CHAR
0x0311   CHECKWARM
0x02FA   CORW
0x091A   CURSOR_ON
0x03B6   MSGTXT2
0x0306   COLDSTART
0x517C   basicStarted
0x0378   MSGTXT1
0x52F9   PRNTVIDEO
0x3FA3   INITST
0x03D3   initVDP
0x04F4   SHOW_LOGO
0x0C7D   initPSG
0x0342   initCTC
0x02B3   INIT_HW2
0x52AE   TEMPSTACK
0x02B0   INIT_HW
0x0D44   KEYBOARD
0x0CDF   MNGSNDS
0x07B8   FLASHCURSOR
0x029C   CHKCRSR
0x0296   INCTMR3
0x52DC   TMRCNT
0x028D   CH3_TIMER
0x027F   RAWPRINT
0x026B   EXTXA
0x026E   TX_EMP
0x0266   TXA_EXIT
0x0257   CNTTXA
0x0249   RXA_EXIT
0x0238   NOTRDWRAP
0x5179   serRdPtr
0x511F   SERBUF_START
0x020B   NOTWRAP
0x0077   bufWrap
0x5177   serInPtr
0x01FF   NOTFULL
0x517B   serBufUsed
0x01E2   SIO_B_EI
0x01E8   SIO_RXEN
0x01DA   SIO_A_EI
0x01D0   SIO_RXDI
0x01B0 X B_RTS_ON
0x01B6   SIO_RTS_ON
0x01A8   A_RTS_ON
0x5341   SERBBITS
0x019C   SIO_RTS_OFF
0x5340   SERABITS
0x0180   EMPTYCHBBFR
0x01CA   SIO_B_DI
0x0196   B_RTS_OFF
0x3CFE   SOERR
0x015C   CHABFREMPTY
0x014E   EMPTYCHABFR
0x533F   SERIALS_EN
0x01C2   SIO_A_DI
0x1184   GMMSG
0x074E   CHAR2VID
0x52F7   CRSR_STATE
0x5337   KBDNPT
0x0120   CNTRXCHA
0x000D   CR
0x52FA   CHR4VID
0x0130   LVRXCHA
0x01F4   CHARINTOBFR
0x5339   TMPKEYBFR
0x018E   A_RTS_OFF
0x00EC   FMVEREND
0x00D0 X FWVER
0x5180   NMIUSR
0x52E9   CTC3IV
0x52E6   CTC2IV
0x52E3   CTC1IV
0x52E0   CTC0IV
0x027A   CKINCHAR
0x0018 X RST18
0x0223   RXA
0x0010 X RST10
0x0135   SPEC_RXA_CNDT
0x0100   RX_CHA_AVAIL
0x024D   TXA
0x0008 X RST08
0x0167   SPEC_RXB_CNDT
0x0164   RX_CHB_AVAIL
0x50F0   ROM2RAM
0x0000 X RST00
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x0058   SER_BUFSIZE
0x0041   PSG_DAT
0x0040   PSG_REG
0x0032   VDP_SET
0x0030   VDP_DAT
0x0021   SIO_DB
0x0020   SIO_DA
0x0023   SIO_CB
0x0022   SIO_CA
0x0013   CTC_CH3
0x0012   CTC_CH2
0x0011   CTC_CH1
0x0010   CTC_CH0
0x0003   PIO_CB
0x0002 X PIO_CA
0x0001   PIO_DB
0x0000 X PIO_DA
