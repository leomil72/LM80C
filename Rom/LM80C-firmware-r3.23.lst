# file opened: LM80C-firmware-r3.23.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C - FIRMWARE - R3.23
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.0
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; output binary file
  55  0000                  OUTPUT "LM80C-firmware-r3.23.bin"
  56  0000
  57  0000              ; set computer model
  58  0000                  DEFINE LM80C
  59  0000
  60  0000              ; set firmware version
  61  0000                  DEFINE VERSION "3.23"
  62  0000
  63  0000              ; set DOS version
  64  0000                  DEFINE  DOS_VER "1.03"
  65  0000
  66  0000              ; define shorter VDP_DAT load instruction and additional delay for VDP access
  67  0000                  DEFINE LD_VDP_DAT ld      C,VDP_DAT
  68  0000                  DEFINE LM64K_NOP
  69  0000
  70  0000              ; ------------------------------------------------------------------------------
  71  0000              ; include the latest version of the bootloader: this sets up the address aliases,
  72  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  73  0000                  INCLUDE "../include/bootloader/bootloader-1.06.asm"
# file opened: ../include/bootloader/bootloader-1.06.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.06
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000                  IFDEF LM80C64K
  54+ 0000 ~            VDP_SET         equ %00110001
  55+ 0000                  ELSE
  56+ 0000              VDP_SET         equ %00110010
  57+ 0000                  ENDIF
  58+ 0000
  59+ 0000              ; label defining for PSG (Programmable Sound Generator)
  60+ 0000              PSG_REG         equ %01000000
  61+ 0000              PSG_DAT         equ %01000001
  62+ 0000
  63+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  64+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  65+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  66+ 0000              SER_BUFSIZE     equ     $58
  67+ 0000              SER_FULLSIZE    equ     $50
  68+ 0000              SER_EMPTYSIZE   equ     $05
  69+ 0000
  70+ 0000
  71+ 0000              ;------------------------------------------------------------------------------
  72+ 0000              ;                                F I R M W A R E
  73+ 0000              ;------------------------------------------------------------------------------
  74+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  75+ 0000                              org     $0000
  76+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  77+ 0001                  IFDEF LM80C64K
  78+ 0001 ~                            jp      ROM2RAM         ; jump to ROM/RAM switcher
  79+ 0001                  ELSE
  80+ 0001 C3 AE 02                     jp      INIT_HW         ; jump to system initialization
  81+ 0004                  ENDIF
  82+ 0004
  83+ 0004              ;------------------------------------------------------------------------------
  84+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  85+ 0004                              ;$0004
  86+ 0004 65 01                        defw    RX_CHB_AVAIL
  87+ 0006
  88+ 0006              ;------------------------------------------------------------------------------
  89+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  90+ 0006                              ;$0006
  91+ 0006 68 01                        defw    SPEC_RXB_CNDT
  92+ 0008
  93+ 0008              ;------------------------------------------------------------------------------
  94+ 0008              ; send a character over serial ch. A
  95+ 0008                              ;$0008
  96+ 0008 C3 59 02     RST08:          jp      TXA
  97+ 000B FF                           BLOCK   1,$FF   ; filler
  98+ 000C
  99+ 000C              ;------------------------------------------------------------------------------
 100+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
 101+ 000C                              ;$000C
 102+ 000C 00 01                        defw    RX_CHA_AVAIL
 103+ 000E
 104+ 000E              ;------------------------------------------------------------------------------
 105+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
 106+ 000E                              ;$000E
 107+ 000E 36 01                        defw    SPEC_RXA_CNDT
 108+ 0010
 109+ 0010              ;------------------------------------------------------------------------------
 110+ 0010              ; receive a character over serial ch. A
 111+ 0010                              ;$0010
 112+ 0010 C3 2A 02     RST10:          jp      RXA
 113+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 114+ 0018              ;------------------------------------------------------------------------------
 115+ 0018              ; check buffer state
 116+ 0018
 117+ 0018                              ;$0018
 118+ 0018 C3 78 02     RST18:          jp      CKINCHAR
 119+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 120+ 0040              ;------------------------------------------------------------------------------
 121+ 0040              ; interrupt vectors for CTC
 122+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 123+ 0040 EA 81                        defw    CTC0IV
 124+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 125+ 0042 ED 81                        defw    CTC1IV
 126+ 0044                              ;$0044               ; for CH2 timer - unused
 127+ 0044 F0 81                        defw    CTC2IV
 128+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 129+ 0046 F3 81                        defw    CTC3IV
 130+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 131+ 0066              ;------------------------------------------------------------------------------
 132+ 0066              ; interrupt routine for NMI
 133+ 0066                              ;$0066
 134+ 0066 C3 61 80                     jp      NMIUSR              ; jump to execute NMI service routine
 135+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 136+ 0090              ;------------------------------------------------------------------------------
 137+ 0090
 138+ 0090                              ;$0090
 139+ 0090                  IFDEF LM80C
 140+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
 140+ 0094 43 20 43 4F
 141+ 0098 4C 4F 52 00                  defb    $4C,$4F,$52,$00,$00,$00,$00,$00
 141+ 009C 00 00 00 00
 142+ 00A0                  ELSE
 143+ 00A0 ~                            defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 144+ 00A0 ~                            defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 145+ 00A0                  ENDIF
 146+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 146+ 00A4 55 54 45 52
 147+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$31,$29,$00
 147+ 00AC 32 31 29 00
 148+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 148+ 00B4 67 6E 65 64
 149+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 149+ 00BC 00 00 00 00
 150+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 150+ 00C4 61 72 64 6F
 151+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 151+ 00CC 69 61 6E 69
 152+ 00D0 46 57 20 33  FWVER:          defm    "FW ","3.23",$20,"2021-03-16",$20,"18:21:11",$00
 152+ 00D4 2E 32 33 20
 152+ 00D8 32 30 32 31
 152+ 00DC 2D 30 33 2D
 152+ 00E0 31 36 20 31
 152+ 00E4 38 3A 32 31
 152+ 00E8 3A 31 31 00
 153+ 00EC              FMVEREND:       equ     $
 154+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 155+ 0100              ;------------------------------------------------------------------------------
 156+ 0100
 157+ 0100              ;-------------------------------------------------------------------------------
 158+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 159+ 0100              ;-------------------------------------------------------------------------------
 160+ 0100
 161+ 0100              ;-------------------------------------------------------------------------------
 162+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 163+ 0100              ; this is the only serial channel that can print received chars onto the screen
 164+ 0100                              ;$0100
 165+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 166+ 0101 E5                           push    HL              ; and HL
 167+ 0102 CD 8F 01                     call    A_RTS_OFF       ; disable RTS line
 168+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 169+ 0107 32 42 82                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 170+ 010A CD FD 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 171+ 010D D2 31 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 172+ 0110 3A 42 82                     ld      A,(TMPKEYBFR)   ; retrieve char
 173+ 0113 32 03 82                     ld      (CHR4VID),A     ; write into buffer for video printing
 174+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 175+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 176+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 177+ 011D DA 31 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 178+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 179+ 0121 AF                           xor     A
 180+ 0122 32 40 82                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 181+ 0125 3A 02 82                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 182+ 0128 FE 01                        cp      $01             ; is the print on video on?
 183+ 012A CC 78 07                     call    Z,CHAR2VID      ; yes, print on screen
 184+ 012D F1                           pop     AF              ; retrieve char
 185+ 012E CD 59 02                     call    TXA             ; send back to serial
 186+ 0131 E1           LVRXCHA:        pop     HL              ; retrieve HL
 187+ 0132 F1                           pop     AF              ; and A
 188+ 0133 FB                           ei                      ; re-enable interrupts
 189+ 0134 ED 4D                        reti                    ; and exit
 190+ 0136
 191+ 0136              ;-------------------------------------------------------------------------------
 192+ 0136              ; special SIO ch.A condition (i.e., buffer overrun)
 193+ 0136              ; if buffer overruns then show an error, empty the RX buffer and send
 194+ 0136              ; a break char
 195+ 0136 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 196+ 0137 CD 8F 01                     call    A_RTS_OFF       ; disable RTS
 197+ 013A CD CB 01                     call    SIO_A_DI        ; disable RX on ch. A
 198+ 013D 3A 48 82                     ld      A,(SERIALS_EN)  ; load serial status
 199+ 0140 CB 97                        res     2,A             ; disable RX on port 1
 200+ 0142 32 48 82                     ld      (SERIALS_EN),A  ; store new serial status
 201+ 0145 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 202+ 0147 CB E7                        set     4,A             ; set 5th pin ON
 203+ 0149 D3 01                        out     (PIO_DB),A      ; send new setting
 204+ 014B 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 205+ 014D D3 22                        out     (SIO_CA),A      ; send command to SIO
 206+ 014F AF           EMPTYCHABFR:    xor     A
 207+ 0150 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 208+ 0152 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 209+ 0154 E6 01                        and     $01             ; check if input buffer if empty
 210+ 0156 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 211+ 0159 DB 20                        in      A,(SIO_DA)      ; read chars
 212+ 015B 18 F2                        jr      EMPTYCHABFR     ; repeat
 213+ 015D F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 214+ 015E 21 2E 47                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 215+ 0161 E3                           ex      (SP),HL         ; store onto stack
 216+ 0162 FB                           ei                      ; re-enable interrupts
 217+ 0163 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 218+ 0165
 219+ 0165              ;-------------------------------------------------------------------------------
 220+ 0165              ;               Z80 SIO CH. A MANAGEMENT
 221+ 0165              ;-------------------------------------------------------------------------------
 222+ 0165
 223+ 0165              ;-------------------------------------------------------------------------------
 224+ 0165              ; interrupt driven routine to get chars from Z80 SIO ch.B
 225+ 0165 FB           RX_CHB_AVAIL:   ei
 226+ 0166 ED 4D                        reti
 227+ 0168
 228+ 0168              ;-------------------------------------------------------------------------------
 229+ 0168              ; special SIO ch.A condition (i.e., buffer overrun)
 230+ 0168              ; if buffer overruns then show an error, empty the RX buffer and send
 231+ 0168              ; a break char
 232+ 0168 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 233+ 0169 CD 97 01                     call    B_RTS_OFF       ; disable RTS
 234+ 016C CD D3 01                     call    SIO_B_DI        ; disable RX on ch.B
 235+ 016F 3A 48 82                     ld      A,(SERIALS_EN)  ; load serial status
 236+ 0172 CB 9F                        res     3,A             ; disable RX on port 2
 237+ 0174 32 48 82                     ld      (SERIALS_EN),A  ; store new serial status
 238+ 0177 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 239+ 0179 CB EF                        set     5,A             ; set 5th pin ON
 240+ 017B D3 01                        out     (PIO_DB),A      ; send new setting
 241+ 017D 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 242+ 017F D3 23                        out     (SIO_CB),A      ; send command to SIO
 243+ 0181 AF           EMPTYCHBBFR:    xor     A
 244+ 0182 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 245+ 0184 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 246+ 0186 E6 01                        and     $01             ; check if input buffer if empty
 247+ 0188 CA 5D 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 248+ 018B DB 21                        in      A,(SIO_DB)      ; read chars
 249+ 018D 18 F2                        jr      EMPTYCHBBFR     ; repeat
 250+ 018F
 251+ 018F
 252+ 018F              ;-------------------------------------------------------------------------------
 253+ 018F              ;               Z80 SIO MANAGEMENT
 254+ 018F              ;-------------------------------------------------------------------------------
 255+ 018F              ; disable RTS:
 256+ 018F              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 257+ 018F C5           A_RTS_OFF:      push    BC              ; store BC
 258+ 0190 0E 22                        ld      C,SIO_CA        ; select channel A
 259+ 0192 3A 49 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 260+ 0195 18 06                        jr      SIO_RTS_OFF
 261+ 0197 C5           B_RTS_OFF:      push    BC              ; store BC
 262+ 0198 0E 23                        ld      C,SIO_CB        ; select channel B
 263+ 019A 3A 4A 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 264+ 019D CB 3F        SIO_RTS_OFF:    srl     A               ; position data bits in bits #5&6
 265+ 019F E6 60                        and     %01100000       ; get only bits #5&6
 266+ 01A1 47                           ld      B,A             ; store data bits
 267+ 01A2 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 268+ 01A4 ED 79                        out     (C),A
 269+ 01A6 3E 88                        ld      A,%10001000     ; enable DTR (b7) and TX (b4), disable RTS (b1)
 270+ 01A8 B0                           or      B               ; set data bits
 271+ 01A9 ED 79                        out     (C),A           ; send setting
 272+ 01AB C1                           pop     BC              ; retrieve BC
 273+ 01AC C9                           ret                     ; exit
 274+ 01AD
 275+ 01AD              ;-------------------------------------------------------------------------------
 276+ 01AD              ; enable RTS
 277+ 01AD              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 278+ 01AD C5           A_RTS_ON:       push    BC              ; store BC
 279+ 01AE 0E 22                        ld      C,SIO_CA        ; select channel A
 280+ 01B0 3A 49 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 281+ 01B3 18 06                        jr      SIO_RTS_ON
 282+ 01B5 C5           B_RTS_ON:       push    BC              ; store BC
 283+ 01B6 0E 23                        ld      C,SIO_CB        ; select channel B
 284+ 01B8 3A 4A 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 285+ 01BB CB 3F        SIO_RTS_ON:     srl     A               ; position data bits in bits #5&6
 286+ 01BD E6 60                        and     %01100000       ; get only bits #5&6
 287+ 01BF 47                           ld      B,A             ; store data bits
 288+ 01C0 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 289+ 01C2 ED 79                        out     (C),A
 290+ 01C4 3E 8A                        ld      A,%10001010     ; enable DTR (b7), TX (b4), and RTS (b1)
 291+ 01C6 B0                           or      B               ; set data bits
 292+ 01C7 ED 79                        out     (C),A           ; send setting
 293+ 01C9 C1                           pop     BC              ; retrieve BC
 294+ 01CA C9                           ret                     ; return
 295+ 01CB
 296+ 01CB              ;-------------------------------------------------------------------------------
 297+ 01CB              ; disable SIO RX channel
 298+ 01CB C5           SIO_A_DI:       push    BC              ; store BC
 299+ 01CC 0E 22                        ld      C,SIO_CA        ; SIO channel A
 300+ 01CE 3A 49 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 301+ 01D1 18 06                        jr      SIO_RXDI        ; jump to disable RX
 302+ 01D3 C5           SIO_B_DI:       push    BC              ; store BC
 303+ 01D4 0E 23                        ld      C,SIO_CB        ; SIO channel B
 304+ 01D6 3A 4A 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 305+ 01D9 47           SIO_RXDI:       ld      B,A             ; store data bits
 306+ 01DA 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 307+ 01DC ED 79                        out     (C),A
 308+ 01DE 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 309+ 01DF ED 79                        out     (C),A
 310+ 01E1 C1                           pop     BC              ; retrieve BC
 311+ 01E2 C9                           ret                     ; return
 312+ 01E3
 313+ 01E3              ;-------------------------------------------------------------------------------
 314+ 01E3              ; enable SIO RX channel
 315+ 01E3 C5           SIO_A_EI:       push    BC              ; store BC
 316+ 01E4 0E 22                        ld      C,SIO_CA
 317+ 01E6 3A 49 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 318+ 01E9 18 06                        jr      SIO_RXEN
 319+ 01EB C5           SIO_B_EI:       push    BC              ; store BC
 320+ 01EC 0E 23                        ld      C,SIO_CB
 321+ 01EE 3A 4A 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 322+ 01F1 47           SIO_RXEN:       ld      B,A             ; store data bits
 323+ 01F2 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 324+ 01F4 ED 79                        out     (C),A           ; select register
 325+ 01F6 78                           ld      A,B             ; retrieve data bits
 326+ 01F7 CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 327+ 01F9 ED 79                        out     (C),A           ; send settings to SIO
 328+ 01FB C1                           pop     BC              ; retrieve BC
 329+ 01FC C9                           ret
 330+ 01FD
 331+ 01FD              ;------------------------------------------------------------------------------
 332+ 01FD              ; put a char into the input buffer, char is into A
 333+ 01FD              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 334+ 01FD              ; the RETURN key is pressed on the keyboard
 335+ 01FD F5           CHARINTOBFR:    push    AF              ; store it
 336+ 01FE 3A 5C 80                     ld      A,(serBufUsed)  ; load buffer size
 337+ 0201 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 338+ 0203 DA 08 02                     jp      C,NOTFULL       ; then store the char
 339+ 0206 F1                           pop     AF              ; else drop it
 340+ 0207 C9                           ret                     ; and exit
 341+ 0208 2A 58 80     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 342+ 020B 23                           inc     HL              ; load pointer to find first free cell
 343+ 020C 7D                           ld      A,L             ; only check low byte because buffer<256
 344+ 020D FE 58                        cp      bufWrap         ; check if the pointer is at the last cell
 345+ 020F 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 346+ 0211 21 00 80                     ld      HL,SERBUF_START ; else load the address of the first cell
 347+ 0214 22 58 80     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 348+ 0217 F1                           pop     AF              ; then retrieve the char...
 349+ 0218 77                           ld      (HL),A          ; ...and store it in the appropriate cell
 350+ 0219 21 5C 80                     ld      HL,serBufUsed   ; size of the input buffer
 351+ 021C 34                           inc     (HL)            ; increment it
 352+ 021D 3E 50                        ld      A,SER_FULLSIZE  ; input buffer capacity
 353+ 021F BE                           cp      (HL)            ; check if input buffer is full
 354+ 0220 D8                           ret     C               ; exit if buffer is not full
 355+ 0221 3A 48 82                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 356+ 0224 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 357+ 0225 DC 8F 01                     call    C,A_RTS_OFF     ; ...receiving further chars must be stopped
 358+ 0228 37                           scf                     ; set Carry flag, because  we must inform that the char has been added before to disable RTS
 359+ 0229 C9                           ret
 360+ 022A
 361+ 022A
 362+ 022A              ;-------------------------------------------------------------------------------
 363+ 022A              ; retrieve a char from the input buffer
 364+ 022A 3A 5C 80     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 365+ 022D A7                           and     A               ; check if it's 0 (empty)
 366+ 022E CA 2A 02                     jp      Z,RXA           ; if it's empty, wait for a char
 367+ 0231 F3                           di                      ; disable interrupts
 368+ 0232 E5                           push    HL              ; store HL
 369+ 0233 2A 5A 80                     ld      HL,(serRdPtr)   ; load pointer to first available char
 370+ 0236 23                           inc     HL              ; increment it (go to the next char)
 371+ 0237 7D                           ld      A,L             ; check if the end of the buffer has been reached
 372+ 0238 FE 58                        cp      bufWrap         ; (only check low byte because buffer<256)
 373+ 023A 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 374+ 023C 21 00 80                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 375+ 023F 22 5A 80     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 376+ 0242 3A 5C 80                     ld      A,(serBufUsed)  ; load buffer size
 377+ 0245 3D                           dec     A               ; decrement it
 378+ 0246 32 5C 80                     ld      (serBufUsed),A  ; and store the new size
 379+ 0249 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 380+ 024B 30 08                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 381+ 024D 3A 48 82                     ld      A,(SERIALS_EN)  ; load serial state
 382+ 0250 EE 05                        xor     %00000101       ; check if serial 1 is open and RX enabled
 383+ 0252 CC AD 01                     call    Z,A_RTS_ON      ; yes, set RTS on
 384+ 0255 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 385+ 0256 E1                           pop     HL              ; retrieve HL
 386+ 0257 FB                           ei                      ; re-enable interrupts
 387+ 0258 C9                           ret                     ; return
 388+ 0259
 389+ 0259              ;------------------------------------------------------------------------------
 390+ 0259              ; sends a char over the serial - char is into A
 391+ 0259 F5           TXA:            push    AF              ; store AF
 392+ 025A C5                           push    BC              ; store BC
 393+ 025B 47                           ld      B,A             ; store char
 394+ 025C 3A 48 82                     ld      A,(SERIALS_EN)  ; load serial status
 395+ 025F EE 05                        xor     %00000101       ; check if serial 1 is open and RX is enabled
 396+ 0261 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 397+ 0263 78                           ld      A,B             ; retrieve char
 398+ 0264 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 399+ 0266 CD 6C 02                     call    TX_EMP          ; wait for outgoing char to be sent
 400+ 0269 C1           TXA_EXIT:       pop     BC              ; retrieve BC
 401+ 026A F1                           pop     AF              ; retrieve AF
 402+ 026B C9                           ret                     ; return
 403+ 026C
 404+ 026C              ;------------------------------------------------------------------------------
 405+ 026C              ; wait until outgoing serial has been sent
 406+ 026C 97           TX_EMP:         sub     A               ; set A to 0
 407+ 026D 3C                           inc     A               ; set A to 1
 408+ 026E D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 409+ 0270 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 410+ 0272 CB 47                        bit     0,A             ; check if all chars have been sent
 411+ 0274 CA 6C 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 412+ 0277 C9                           ret                     ; else exit
 413+ 0278
 414+ 0278
 415+ 0278              ;------------------------------------------------------------------------------
 416+ 0278              ; check if there is some chars into the buffer
 417+ 0278 3A 5C 80     CKINCHAR:       ld      A,(serBufUsed)  ; load buffer size
 418+ 027B A7                           and     A               ; compare to 0
 419+ 027C C9                           ret                     ; return
 420+ 027D
 421+ 027D              ;------------------------------------------------------------------------------
 422+ 027D              ; print a text from memory, and terminate when $00 is found
 423+ 027D 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 424+ 027E B7                           or      A               ; is it $00 (end string)?
 425+ 027F C8                           ret     Z               ; Yes, then return
 426+ 0280 32 03 82                     ld      (CHR4VID),A     ; store char
 427+ 0283 F3                           di
 428+ 0284 CD 78 07                     call    CHAR2VID        ; and send it to screen
 429+ 0287 FB                           ei
 430+ 0288 23                           inc     HL              ; and select the next one
 431+ 0289 18 F2                        jr      RAWPRINT        ; repeat
 432+ 028B
 433+ 028B              ;-------------------------------------------------
 434+ 028B              ; Interrupt service routine (ISR) for CH3 timer
 435+ 028B              ; this is used to increment the 100ths of a second counter and for cursor flashing
 436+ 028B F5           CH3_TIMER:      push    AF              ; save regs. A,
 437+ 028C C5                           push    BC              ; BC,
 438+ 028D D5                           push    DE              ; DE,
 439+ 028E E5                           push    HL              ; HL
 440+ 028F 21 E6 81                     ld      HL,TMRCNT       ; load starting address of the timer
 441+ 0292 06 04                        ld      B,$04           ; 4 bytes to check
 442+ 0294 34           INCTMR3:        inc     (HL)            ; increment timer
 443+ 0295 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 444+ 0297 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 445+ 0298 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 446+ 029A CD E2 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 447+ 029D CD 0D 0D                     call    MNGSNDS         ; call the tone managemenet
 448+ 02A0 3A E6 81                     ld      A,(TMRCNT)      ; check for keyboard management
 449+ 02A3 1F                           rra                     ; bit 0 = 1 ?
 450+ 02A4 D4 72 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 451+ 02A7 E1                           pop     HL              ; retrieve HL,
 452+ 02A8 D1                           pop     DE              ; DE,
 453+ 02A9 C1                           pop     BC              ; BC,
 454+ 02AA F1                           pop     AF              ; and A
 455+ 02AB FB                           ei                      ; re-enable interrupts
 456+ 02AC ED 4D                        reti                    ; exit from ISR
 457+ 02AE
 458+ 02AE              ;------------------------------------------------------------------------------
 459+ 02AE              ;               HARDWARE INITIALISATION
 460+ 02AE              ;------------------------------------------------------------------------------
 461+ 02AE              ; first run - setup HW & SW
 462+ 02AE              ; (on LN80C 64K runs from RAM)
 463+ 02AE 21 8F 81     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 464+ 02B1 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 465+ 02B2 21 00 80                     ld      HL,SERBUF_START ; set beginning of input buffer
 466+ 02B5 22 58 80                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 467+ 02B8 22 5A 80                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 468+ 02BB AF                           xor     A               ; reset A
 469+ 02BC 32 5C 80                     ld      (serBufUsed),A  ; actual buffer size is 0
 470+ 02BF 32 48 82                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 471+ 02C2                  IFDEF LM80C
 472+ 02C2 CD 39 03                     call    HELLOWRLD       ; little serial blink with LEDs
 473+ 02C5                  ENDIF
 474+ 02C5 CD 5E 03                     call    initCTC         ; configure CTC, then...
 475+ 02C8 CD AB 0C                     call    initPSG         ; ...configure PSG
 476+ 02CB CD 10 05                     call    SHOW_LOGO       ; show computer logo
 477+ 02CE 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 478+ 02D0 CD ED 03                     call    initVDP         ; set video display
 479+ 02D3 AF                           xor     A
 480+ 02D4 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 481+ 02D6 ED 5E                        im      2               ; interrupt mode 2
 482+ 02D8 FB                           ei                      ; enable interrupts
 483+ 02D9                              ; print system messages
 484+ 02D9 AF                           xor     A               ; A=0 so...
 485+ 02DA 32 40 82                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 486+ 02DD 3C                           inc     A               ; A=1...
 487+ 02DE 32 02 82                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 488+ 02E1 21 94 03                     ld      HL,MSGTXT1      ; sign-on message
 489+ 02E4 CD 7D 02                     call    RAWPRINT        ; print message
 490+ 02E7 3A 5D 80                     ld      A,(basicStarted); check if BASIC is already started
 491+ 02EA FE 59                        cp      'Y'             ; to see if this is a power-up
 492+ 02EC 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 493+ 02EE 21 D0 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 494+ 02F1 CD 7D 02                     call    RAWPRINT        ; print message
 495+ 02F4 CD 44 09                     call    CURSOR_ON       ; enable cursor
 496+ 02F7 AF                           xor     A
 497+ 02F8 32 02 82                     ld      (PRNTVIDEO),A   ; disable print-on-video
 498+ 02FB CD 2A 02     CORW:           call    RXA             ; look for a pressed key
 499+ 02FE E6 DF                        and     %11011111       ; only UPPERCASE char
 500+ 0300 FE 43                        cp      'C'             ; cold start?
 501+ 0302 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 502+ 0304 CD 1F 03                     call    ECHO_CHAR       ; echoes the char
 503+ 0307 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 504+ 0309 32 5D 80                     ld      (basicStarted),A
 505+ 030C CD 59 09                     call    CURSOR_OFF      ; disable cursor
 506+ 030F C3 9D 1B                     jp      COLD            ; start BASIC COLD
 507+ 0312 FE 57        CHECKWARM:      cp      'W'
 508+ 0314 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 509+ 0316 CD 1F 03                     call    ECHO_CHAR       ; echoes the char
 510+ 0319 CD 59 09                     call    CURSOR_OFF      ; disable cursor
 511+ 031C C3 A0 1B                     jp      WARM            ; start BASIC WARM
 512+ 031F
 513+ 031F              ;-------------------------------------------------------------------------------
 514+ 031F              ; send back char received through ch. A
 515+ 031F 32 03 82     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 516+ 0322 AF                           xor     A
 517+ 0323 32 40 82                     ld      (KBDNPT),A      ; input is not from keyboard
 518+ 0326 F3                           di                      ; disable INTs
 519+ 0327 CD 78 07                     call    CHAR2VID        ; echoes back the pressed key,
 520+ 032A 3E 0D                        ld      A,CR            ; then set a CR
 521+ 032C 32 03 82                     ld      (CHR4VID),A     ; set char for video printing
 522+ 032F CD 78 07                     call    CHAR2VID        ; and send it to screen
 523+ 0332 FB                           ei                      ; re-enable INTs
 524+ 0333 3E 01                        ld      A,$01
 525+ 0335 32 02 82                     ld      (PRNTVIDEO),A   ; re-enable video printing
 526+ 0338 C9                           ret                     ; return to caller
 527+ 0339
 528+ 0339                  IFDEF LM80C
 529+ 0339              ;-------------------------------------------------------------------------------
 530+ 0339              ; little serial blink with LEDs
 531+ 0339 0E 09        HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
 532+ 033B 3E CF                        ld      A,%11001111     ; set mode 3 (mode control)
 533+ 033D D3 03                        out     (PIO_CB),A      ; for PIO port B
 534+ 033F AF                           xor     A               ; set pins to OUTPUT
 535+ 0340 D3 03                        out     (PIO_CB),A      ; for port B
 536+ 0342 3C                           inc     A               ; LSB on
 537+ 0343 D3 01        LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
 538+ 0345 1E 20                        ld      E,$20           ; little delay
 539+ 0347 06 00        DEC_E:          ld      B,$00           ; count to 256
 540+ 0349 10 FE        COUNTER:        djnz    COUNTER         ; decrement inner counter
 541+ 034B 1D                           dec     E               ; decrement outer counter
 542+ 034C 20 F9                        jr      NZ,DEC_E        ; finish delay
 543+ 034E CB 27                        sla     A               ; shift reg.A to left 1 bit
 544+ 0350 0D                           dec     C               ; next LED
 545+ 0351 20 F0                        jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
 546+ 0353 C9                           ret                     ; return to caller
 547+ 0354                  ENDIF
 548+ 0354              ;-------------------------------------------------------------------------------
 549+ 0354              ; Z80 SIO default settings for serial channels
 550+ 0354 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 551+ 0355 18                           defb    %00011000       ; write into WR0: channel reset
 552+ 0356 04                           defb    %00000100       ; write into WR0: select WR4
 553+ 0357 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 554+ 0358 05                           defb    %00000101       ; write into WR0: select WR5
 555+ 0359 E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 556+ 035A 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 557+ 035B 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 558+ 035C 02                           defb    %00000010       ; write into WR0: select WR2
 559+ 035D 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 560+ 035E                                                      ; will be affected by the channel & condition that raised the interrupt
 561+ 035E                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 562+ 035E                                                      ; for special conditions
 563+ 035E              ;------------------------------------------------------------------------------
 564+ 035E              ;               Z80 CTC SETTING UP
 565+ 035E              ;------------------------------------------------------------------------------
 566+ 035E              initCTC:
 567+ 035E 21 88 03                     ld      HL,CTCCONF      ; CTC configuration
 568+ 0361 11 EA 81                     ld      DE,CTC0IV       ; CTC interrupt vector table
 569+ 0364 01 0C 00                     ld      BC,$000C        ; 12 bytes
 570+ 0367 ED B0                        ldir                    ; copy data
 571+ 0369              ;CH0, CH1, & CH2 disabled
 572+ 0369 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 573+ 036B                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 574+ 036B D3 10                        out     (CTC_CH0),A     ; set CH0
 575+ 036D D3 11                        out     (CTC_CH1),A     ; set CH1
 576+ 036F D3 12                        out     (CTC_CH2),A     ; set CH2
 577+ 0371              ;init CH3
 578+ 0371              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 579+ 0371              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 580+ 0371 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 581+ 0373                                                      ; time constant follows; cont. operation; command word
 582+ 0373 D3 13                        out     (CTC_CH3),A     ; send to CH3
 583+ 0375 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 584+ 0377 D3 13                        out     (CTC_CH3),A     ; send to CH3
 585+ 0379 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 586+ 037B                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 587+ 037B                                                      ; so int vector is 01000xx00
 588+ 037B D3 10                        out     (CTC_CH0),A     ; send to CTC
 589+ 037D                              ; reset cells of 100ths of a second counter
 590+ 037D AF                           xor     A               ; reset A
 591+ 037E 21 E6 81                     ld      HL,TMRCNT       ; load TMR pointer
 592+ 0381 06 04                        ld      B,$04           ; 4 memory cells
 593+ 0383 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 594+ 0384 23                           inc     HL              ; next cell
 595+ 0385 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 596+ 0387 C9                           ret
 597+ 0388
 598+ 0388
 599+ 0388              ;------------------------------------------------------------------------------
 600+ 0388              ; jump table for CHx interrupts
 601+ 0388 FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 602+ 038B FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 603+ 038E FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 604+ 0391 C3 8B 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 605+ 0394
 606+ 0394
 607+ 0394              ;------------------------------------------------------------------------------
 608+ 0394              ; welcome messages
 609+ 0394              MSGTXT1:
 610+ 0394                  IFDEF LM80C64K
 611+ 0394 ~                            defm    "    LM80C 64K Color Computer",CR
 612+ 0394                  ELSE
 613+ 0394 20 20 20 20                  defm    "      LM80C Color Computer",CR
 613+ 0398 20 20 4C 4D
 613+ 039C 38 30 43 20
 613+ 03A0 43 6F 6C 6F
 613+ 03A4 72 20 43 6F
 613+ 03A8 6D 70 75 74
 613+ 03AC 65 72 0D
 614+ 03AF                  ENDIF
 615+ 03AF 20 62 79 20                  defm    " by Leonardo Miliani * FW R","3.23",CR,0
 615+ 03B3 4C 65 6F 6E
 615+ 03B7 61 72 64 6F
 615+ 03BB 20 4D 69 6C
 615+ 03BF 69 61 6E 69
 615+ 03C3 20 2A 20 46
 615+ 03C7 57 20 52 33
 615+ 03CB 2E 32 33 0D
 615+ 03CF 00
 616+ 03D0 0D           MSGTXT2:        defb    CR
 617+ 03D1 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 617+ 03D5 43 3E 6F 6C
 617+ 03D9 64 20 6F 72
 617+ 03DD 20 3C 57 3E
 617+ 03E1 61 72 6D 20
 617+ 03E5 73 74 61 72
 617+ 03E9 74 3F 20 00
 618+ 03ED
# file closed: ../include/bootloader/bootloader-1.06.asm
  74  03ED
  75  03ED              ; incude the latest version of the VDP module
  76  03ED                  INCLUDE "../include/vdp/vdp-1.5.asm"
# file opened: ../include/vdp/vdp-1.5.asm
   1+ 03ED              ; ------------------------------------------------------------------------------
   2+ 03ED              ; LM80C - VDP ROUTINES - 1.5
   3+ 03ED              ; ------------------------------------------------------------------------------
   4+ 03ED              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03ED              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03ED              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03ED              ; kind of warranty: you can use them at your own risk.
   8+ 03ED              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03ED              ; maintain the copyright notices, include this advice and the note to the
  10+ 03ED              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03ED              ; redistribuite them.
  12+ 03ED              ; https://www.leonardomiliani.com
  13+ 03ED              ;
  14+ 03ED              ; Please support me by visiting the following links:
  15+ 03ED              ; Main project page: https://www.leonardomiliani.com
  16+ 03ED              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03ED              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03ED              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03ED              ; ------------------------------------------------------------------------------
  20+ 03ED              ;
  21+ 03ED              ;------------------------------------------------------------------------------
  22+ 03ED              ; VDP INITIALISATION
  23+ 03ED              ; initialize VDP for a specific graphics mode
  24+ 03ED              ; INPUT: E -> contains the graphics mode:
  25+ 03ED              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03ED D5           initVDP:        push    DE              ; store E
  27+ 03EE CD E7 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03F1 CD 06 0B                     call    SET_GFX_MODE    ; load register settings
  29+ 03F4 CD FB 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03F7 D1                           pop     DE              ; restore reg. E
  31+ 03F8 AF                           xor     A               ; reset A
  32+ 03F9 47                           ld      B,A             ; reset B (will be used later)
  33+ 03FA 7B                           ld      A,E             ; move E into A
  34+ 03FB 32 F8 81                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03FE FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 0400 CA 3C 04                     jp      Z,G1MD          ; yes, jump over
  37+ 0403 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 0405 CA 7D 04                     jp      Z,G2MD          ; yes, jump over
  39+ 0408 FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 040A CA 9F 04                     jp      Z,MCMD          ; yes, jump over
  41+ 040D FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 040F CA C2 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 0412                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 0412
  45+ 0412              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 0412
  47+ 0412                              ; TEXT MODE (G0)
  48+ 0412                              ; load charset
  49+ 0412 60           TXTMD:          ld      H,B
  50+ 0413 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 0414 CD 22 0B                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 0417                              ; set cursor & video overlay
  53+ 0417 AF                           xor     A               ; reset A
  54+ 0418 32 FB 81                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 041B 32 FC 81                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 041E 3E 05                        ld      A,$05           ; light blue
  57+ 0420 32 05 82                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0423 3E 28                        ld      A,$28
  59+ 0425 32 F6 81                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 0428 3E 18                        ld      A,$18
  61+ 042A 32 F7 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 042D 3E 1E                        ld      A,$1E
  63+ 042F 32 A3 80                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0432 11 00 08                     ld      DE,$0800
  65+ 0435 ED 53 F9 81                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 0439 C3 05 05                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 043C
  68+ 043C                              ; GRAPHICS 1 MODE (G1)
  69+ 043C                              ; load pattern table
  70+ 043C 68           G1MD:           ld      L,B
  71+ 043D 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 043E CD 22 0B                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0441                              ; set cursor & video overlay
  74+ 0441 AF                           xor     A               ; position cursor
  75+ 0442 32 FB 81                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 0445 32 FC 81                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 0448 3E 20                        ld      A,$20
  78+ 044A 32 F6 81                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 044D 3E 18                        ld      A,$18
  80+ 044F 32 F7 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0452 3E 14                        ld      A,$14
  82+ 0454 32 A3 80                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 0457 11 00 18                     ld      DE,$1800
  84+ 045A ED 53 F9 81                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 045E                              ; load color table
  86+ 045E 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0461 CD 87 06                     call    SETVDPADRS
  88+ 0464 3E 01                        ld      A,$01           ; foreground color...
  89+ 0466 32 04 82                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 0469 3E 0F                        ld      A,$0F           ; background color...
  91+ 046B 32 05 82                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 046E 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0470 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0472 0E 30                        ld      C,VDP_DAT              ; VDP data mode
  95+ 0474 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 0476 00                           nop
  97+ 0477 00                           nop
  98+ 0478 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 047A C3 05 05                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 047D
 101+ 047D                              ; GRAPHICS 2 MODE (G2)
 102+ 047D AF           G2MD:           xor     A               ; position cursor
 103+ 047E 32 FB 81                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0481 32 FC 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0484 32 F6 81                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 0487 3C                           inc     A               ; black on...
 107+ 0488 32 04 82                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 048B 3E 0F                        ld      A,$0F           ; white on...
 109+ 048D 32 05 82                     ld      (BKGNDCLR),A    ; ...background
 110+ 0490 3E C0                        ld      A,$C0
 111+ 0492 32 F7 81                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 0495 11 00 18                     ld      DE,$1800
 113+ 0498 ED 53 F9 81                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 049C C3 05 05                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 049F
 116+ 049F                              ; MULTICOLOR MODE (G3)
 117+ 049F AF           MCMD:           xor     A               ; position cursor
 118+ 04A0 32 FB 81                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 04A3 32 FC 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 04A6 3E 0F                        ld      A,$0F           ; white color for...
 121+ 04A8 32 05 82                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 04AB 32 04 82                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 04AE 3E 40                        ld      A,$40
 124+ 04B0 32 F6 81                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 04B3 3E 30                        ld      A,$30
 126+ 04B5 32 F7 81                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 04B8 11 00 08                     ld      DE,$0800
 128+ 04BB ED 53 F9 81                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04BF C3 05 05                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04C2
 131+ 04C2                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04C2              EXG2MD:         ; load pattern table
 133+ 04C2 60                           ld      H,B
 134+ 04C3 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04C4 CD 22 0B                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04C7                              ; set cursor & video overlay
 137+ 04C7 AF                           xor     A               ; position cursor
 138+ 04C8 32 FB 81                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04CB 32 FC 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04CE 3E 20                        ld      A,$20
 141+ 04D0 32 F6 81                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04D3 3E 18                        ld      A,$18
 143+ 04D5 32 F7 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04D8 3E 14                        ld      A,$14
 145+ 04DA 32 A3 80                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04DD 11 00 38                     ld      DE,$3800
 147+ 04E0 ED 53 F9 81                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04E4                               ; load color table
 149+ 04E4 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04E7 CD 87 06                     call    SETVDPADRS
 151+ 04EA 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04EC 32 04 82                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04EF 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04F1 32 05 82                     ld      (BKGNDCLR),A    ; ...background
 155+ 04F4 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04F6 16 08                        ld      D,$08           ; 8 pages of
 157+ 04F8 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04FA 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 159+ 04FC ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 04FE 00                           nop
 161+ 04FF 00                           nop
 162+ 0500 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 0502 15                           dec     D               ; did we fill up all the cells?
 164+ 0503 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 0505                              ; LAST VDP SETTINGS
 166+ 0505 CD 59 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 0508 CD F5 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 050B AF                           xor     A
 169+ 050C 32 FF 81                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 050F C9                           ret                     ; return to caller
 171+ 0510
 172+ 0510
 173+ 0510              ; show initial logo
 174+ 0510 CD E7 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 0513                              ; set VDP for G2 mode
 176+ 0513 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 0515 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 0518 CD 0E 0B                     call    SET_GFX_MODE2   ; load register settings
 179+ 051B 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 051D ED 51                        out     (C),D           ; send data to VDP
 181+ 051F ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0521                              ; set name table
 183+ 0521 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0524 CD 74 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 0527 CD 87 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 052A                              ; set colors for logo
 187+ 052A 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 052D CD 87 06                     call    SETVDPADRS
 189+ 0530 06 05                        ld      B,$05           ; 5 bands
 190+ 0532 21 D4 05                     ld      HL,CLRTABLE
 191+ 0535 0E 30                        ld      C,VDP_DAT              ; set VDP_DAT
 192+ 0537 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 0539 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 053B 7E                           ld      A,(HL)          ; load data
 195+ 053C ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 053E 00                           nop                     ; little delay
 197+ 053F 1D                           dec     E               ; decrement counter
 198+ 0540 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0542 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0544 15                           dec     D               ; decrement char band counter
 201+ 0545 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 0547 23                           inc     HL              ; next pattern
 203+ 0548 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 054A                              ; set pattern table
 205+ 054A 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 054D 11 6B 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0550 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 208+ 0552 CD B3 05     RPT103:         call    LOADLOGOCHRS
 209+ 0555 13                           inc     DE              ; next logo pattern
 210+ 0556 10 FA                        djnz    RPT103
 211+ 0558 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 055A CD B3 05     RPT104:         call    LOADLOGOCHRS
 213+ 055D 13                           inc     DE              ; next logo pattern
 214+ 055E 10 FA                        djnz    RPT104
 215+ 0560                              ; show logo/message, play a beep, check for SHIFT pressure (to disable DOS), and wait a while
 216+ 0560 06 02                        ld      B,$02           ; two times
 217+ 0562 AF                           xor     A               ; reset A
 218+ 0563 57                           ld      D,A             ; 256 times
 219+ 0564 5F                           ld      E,A             ; x 256 times
 220+ 0565 32 06 82                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 0568                  IFDEF LM80C64K
 222+ 0568 ~                            inc     A               ; by default, I/O DOS buffer is enabled on LM80C 64K, disabled on LM80C
 223+ 0568                  ENDIF
 224+ 0568 32 4B 82                     ld      (DOS_EN),A      ; DOS enabled
 225+ 056B 00           DEC_D:          nop                     ; does nothing...
 226+ 056C 00                           nop
 227+ 056D 00                           nop
 228+ 056E 00                           nop
 229+ 056F 00                           nop
 230+ 0570 00                           nop                     ; ...until here
 231+ 0571 1D                           dec     E               ; decrement E
 232+ 0572 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 233+ 0574 7A                           ld      A,D
 234+ 0575 FE 40                        cp      $40             ; ...equal to 64
 235+ 0577 CC 9F 05                     call    Z,SETBEEP       ; if yes, start sound
 236+ 057A 15                           dec     D
 237+ 057B 20 EE                        jr      NZ,DEC_D        ; repeat
 238+ 057D 3A 06 82                     ld      A,(TMPBFR1)     ; sound state
 239+ 0580 FE 02                        cp      $02             ; check if sound is to be set off
 240+ 0582 C4 AB 05                     call    NZ,BEEPOFF      ; yes
 241+ 0585                  IFDEF LM80C64K
 242+ 0585 ~                            call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 243+ 0585 ~                                                    ; on LM80C 64K, you can disabled the I/O DOS buffer, on LM80C you can't
 244+ 0585                  ENDIF
 245+ 0585 10 E4                        djnz    DEC_D           ; repeat
 246+ 0587              ERASECLRTBL:    ; erase color table
 247+ 0587 3E 11                        ld      A,$11           ; foreground and background set to black
 248+ 0589 16 0A                        ld      D,$0A           ; 10 pages
 249+ 058B 06 00                        ld      B,$00           ; 256 color cells per page
 250+ 058D 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 251+ 0590 CD 87 06                     call    SETVDPADRS      ; send address
 252+ 0593 0E 30                        ld      C,VDP_DAT              ; VDP address for passing data
 253+ 0595 ED 79        RPT100:         out     (C),A           ; send data
 254+ 0597 00                           nop
 255+ 0598 00                           nop                     ; little delay
 256+ 0599 10 FA                        djnz    RPT100          ; repeat for entire page
 257+ 059B 15                           dec     D
 258+ 059C 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 259+ 059E C9                           ret                     ; return to caller
 260+ 059F
 261+ 059F              ; play a beep
 262+ 059F 3A 06 82     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 263+ 05A2 B7                           or      A               ; is it 0?
 264+ 05A3 C0                           ret     NZ              ; no, exit
 265+ 05A4 3C                           inc     A               ; flag to 1
 266+ 05A5 32 06 82                     ld      (TMPBFR1),A     ; set sound
 267+ 05A8 C3 D9 0C                     jp      WLCMBEEP        ; play a beep & return
 268+ 05AB
 269+ 05AB              ; beep off
 270+ 05AB 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 271+ 05AD 32 06 82                     ld      (TMPBFR1),A     ; set flag
 272+ 05B0 C3 DF 0C                     jp      NOBEEP          ; stop beep and return
 273+ 05B3
 274+ 05B3
 275+ 05B3              ; used to load the chars that will compose the logo of the splash screen
 276+ 05B3 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 277+ 05B4 87                           add     A,A
 278+ 05B5 87                           add     A,A
 279+ 05B6 87                           add     A,A             ; multiply times 8 to get the offset
 280+ 05B7 C5                           push    BC
 281+ 05B8 D5                           push    DE              ; store BC and DE
 282+ 05B9 E5                           push    HL              ; store VRAM address to write to
 283+ 05BA 21 83 5E                     ld      HL,LOGOFONT     ; start of logo font data
 284+ 05BD 5F                           ld      E,A
 285+ 05BE 16 00                        ld      D,$00           ; put offset (A) into DE
 286+ 05C0 19                           add     HL,DE           ; get address of pattern data
 287+ 05C1 EB                           ex      DE,HL           ; move address into DE
 288+ 05C2 E1                           pop     HL              ; retrieve VRAM address
 289+ 05C3 06 08                        ld      B,$08           ; 8 bytes per pattern
 290+ 05C5 CD 87 06                     call    SETVDPADRS      ; set VDP address
 291+ 05C8 0E 30                        ld      C,VDP_DAT              ; VDP_DAT
 292+ 05CA 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 293+ 05CB ED 79                        out     (C),A           ; and send to VRAM
 294+ 05CD 13                           inc     DE              ; next byte into RAM
 295+ 05CE 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 296+ 05CF 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 297+ 05D1 D1                           pop     DE
 298+ 05D2 C1                           pop     BC              ; retrieve BC & DE
 299+ 05D3 C9                           ret                     ; return to caller
 300+ 05D4              CLRTABLE:       equ $
 301+ 05D4 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 301+ 05D8 1D
 302+ 05D9
 303+ 05D9
 304+ 05D9              ; while showing the logo, check if special key (CTRL) is being pressed
 305+ 05D9              ; if yes, then disable DOS functions recovering RAM
 306+ 05D9 F5           CHKSPCK:        push    AF
 307+ 05DA 3E FE                        ld      A,%11111110     ; select CTRL row
 308+ 05DC CD 5D 0D                     call    READKBLN        ; read row
 309+ 05DF CB 5F                        bit     3,A             ; test for RUN/STOP
 310+ 05E1 CA EE 05                     jp      Z,DOCOLDRESET   ; yes, do a cold reset
 311+ 05E4 CB 57                        bit     2,A             ; test if CTRL key is pressed
 312+ 05E6 20 04                        jr      NZ,LVCKSPLK     ; no, leave
 313+ 05E8 AF                           xor     A               ; yes, so...
 314+ 05E9 32 4B 82                     ld      (DOS_EN),A      ; ...disable DOS
 315+ 05EC F1           LVCKSPLK:       pop     AF
 316+ 05ED C9                           ret
 317+ 05EE AF           DOCOLDRESET:    xor     A               ; reset A
 318+ 05EF 32 5D 80                     ld      (basicStarted),A; reset BASIC warm start
 319+ 05F2 C3 00 00                     jp      $0000           ; restart
 320+ 05F5
 321+ 05F5
 322+ 05F5              ; empty video buffer
 323+ 05F5 3A F8 81     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 324+ 05F8 FE 02                        cp      $02             ; is it G2 mode?
 325+ 05FA CA 1E 06                     jp      Z,EMPTYG2       ; yes, jump over
 326+ 05FD FE 03                        cp      $03             ; is it MC mode?
 327+ 05FF CA 4F 06                     jp      Z,EMPTYMC       ; yes, jump over
 328+ 0602 3A F7 81                     ld      A,(SCR_SIZE_H)  ; load height of screen
 329+ 0605 47                           ld      B,A             ; move rows into B
 330+ 0606 AF                           xor     A               ; filling char is $00
 331+ 0607 2A F9 81                     ld      HL,(SCR_NAM_TB) ; load the name table address
 332+ 060A CD 87 06                     call    SETVDPADRS      ; send address to VDP
 333+ 060D 0E 30                        ld      C,VDP_DAT              ; VDP address for passing data
 334+ 060F 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 335+ 0610 3A F6 81                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 336+ 0613 57                           ld      D,A             ; move A into D
 337+ 0614 7B                           ld      A,E             ; recover filling char
 338+ 0615 ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 339+ 0617 00                           nop
 340+ 0618 15                           dec     D               ; decr. D
 341+ 0619 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 342+ 061B 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 343+ 061D C9                           ret                     ; return to caller
 344+ 061E 2A F9 81     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 345+ 0621 CD 74 06                     call    SETNAMETABLE    ; set name table
 346+ 0624 21 00 00                     ld      HL,$0000        ; set pattern table
 347+ 0627 CD 87 06                     call    SETVDPADRS      ; send address to VDP
 348+ 062A AF                           xor     A               ; empty pattern
 349+ 062B 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 350+ 062D 47                           ld      B,A             ; 256 bytes for page
 351+ 062E 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 352+ 0630 ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 353+ 0632 00                           nop                     ; little delay
 354+ 0633 00                           nop
 355+ 0634 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 356+ 0636 15                           dec     D               ; next page
 357+ 0637 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 358+ 0639 21 00 20                     ld      HL,$2000        ; load the color table address
 359+ 063C CD 87 06                     call    SETVDPADRS      ; send address to VDP
 360+ 063F 3A 04 82                     ld      A,(FRGNDCLR)    ; load foreground
 361+ 0642 87                           add     A,A
 362+ 0643 87                           add     A,A
 363+ 0644 87                           add     A,A
 364+ 0645 87                           add     A,A             ; move to high nibble
 365+ 0646 57                           ld      D,A             ; store into D
 366+ 0647 3A 05 82                     ld      A,(BKGNDCLR)    ; load background color
 367+ 064A B2                           or      D               ; combine with background color
 368+ 064B 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 369+ 064D 18 17                        jr      STARTEMPTY
 370+ 064F 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 371+ 0652 CD 74 06                     call    SETNAMETABLE    ; set name table
 372+ 0655 21 00 00                     ld      HL,$0000        ; color table address
 373+ 0658 CD 87 06                     call    SETVDPADRS      ; send address to VDP
 374+ 065B 3A 05 82                     ld      A,(BKGNDCLR)    ; load background
 375+ 065E 57                           ld      D,A             ; store into D
 376+ 065F 87                           add     A,A
 377+ 0660 87                           add     A,A
 378+ 0661 87                           add     A,A
 379+ 0662 87                           add     A,A             ; move to high nibble
 380+ 0663 B2                           or      D               ; set background color for high and low nibble
 381+ 0664 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 382+ 0666 0E 30        STARTEMPTY:     ld      C,VDP_DAT              ; VDP address for passing data
 383+ 0668 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 384+ 066A ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 385+ 066C 00                           nop                     ; wait a while
 386+ 066D 00                           nop
 387+ 066E 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 388+ 0670 15                           dec     D               ; have we filled all the pages?
 389+ 0671 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 390+ 0673 C9                           ret                     ; return to caller
 391+ 0674
 392+ 0674              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 393+ 0674 CD 87 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 394+ 0677 0E 30                        ld      C,VDP_DAT              ; VDP address for passing data
 395+ 0679 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 396+ 067B AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 397+ 067C 47                           ld      B,A             ; reset B
 398+ 067D ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 399+ 067F 00                           nop
 400+ 0680 3C                           inc     A               ; increment # of name
 401+ 0681 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 402+ 0683 15                           dec     D               ; did we fill all the pages?
 403+ 0684 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 404+ 0686 C9                           ret                     ; return to caller
 405+ 0687
 406+ 0687              ; set an address into VRAM: address is in HL - HL is changed after it
 407+ 0687 0E 32        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 408+ 0689 CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 409+ 068B ED 69                        out     (C),L           ; send low and...
 410+ 068D ED 61                        out     (C),H           ; ...high byte of the first cell
 411+ 068F C9                           ret                     ; return to caller
 412+ 0690
 413+ 0690              ; clear the video buffer and position the cursor at 0,0
 414+ 0690 CD F5 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 415+ 0693 AF                           xor     A               ; reset A
 416+ 0694 32 FB 81                     ld      (SCR_CURS_X),A  ; cursor X to 0
 417+ 0697 32 FC 81                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 418+ 069A C3 E3 06                     jp      POS_CURSOR      ; position cursor & return to caller
 419+ 069D
 420+ 069D              ; HOME: position the cursor at coords. 0,0
 421+ 069D AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 422+ 069E 32 FE 81                     ld      (SCR_CUR_NY),A  ; ...new Y...
 423+ 06A1 32 FD 81                     ld      (SCR_CUR_NX),A  ; ...and new X
 424+ 06A4 C3 ED 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 425+ 06A7
 426+ 06A7              ; load the char or byte at the VRAM position set by HL
 427+ 06A7              ; value is returned into A
 428+ 06A7 C5           READ_VIDEO_LOC: push    BC              ; store BC
 429+ 06A8 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 430+ 06AA 44                           ld      B,H
 431+ 06AB CB B8                        res     7,B
 432+ 06AD CB B0                        res     6,B
 433+ 06AF ED 69                        out     (C),L           ; low byte then...
 434+ 06B1 ED 41                        out     (C),B           ; high byte
 435+ 06B3 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 436+ 06B5 ~                            LM64K_NOP               ; added to compensate shorter instruction
 437+ 06B5 00                           nop                     ; wait...
 438+ 06B6 00                           nop                     ; ...a while
 439+ 06B7 00                           nop
 440+ 06B8 ED 78                        in      A,(C)           ; read byte at current VRAM location
 441+ 06BA C1                           pop     BC              ; restore BC
 442+ 06BB C9                           ret                     ; return to caller
 443+ 06BC
 444+ 06BC              ; write a byte at the VRAM position pointed by HL
 445+ 06BC              ; value is in A
 446+ 06BC C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 447+ 06BD 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 448+ 06BF 44                           ld      B,H             ; copy H into B
 449+ 06C0 CB B8                        res     7,B
 450+ 06C2 CB F0                        set     6,B             ; write to VRAM
 451+ 06C4 ED 69                        out     (C),L           ; low byte then...
 452+ 06C6 ED 41                        out     (C),B           ; high byte of VRAM address
 453+ 06C8 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 454+ 06CA ~                            LM64K_NOP               ; added to compensate shorter instruction
 455+ 06CA 00                           nop                     ; wait...
 456+ 06CB 00                           nop                     ; ...a while
 457+ 06CC 00                           nop
 458+ 06CD ED 79                        out     (C),A           ; write byte into VRAM
 459+ 06CF C1                           pop     BC              ; restore BC
 460+ 06D0 C9                           ret                     ; return to caller
 461+ 06D1
 462+ 06D1              ; write a value into a specific VDP register
 463+ 06D1              ; value is in E, register is in A
 464+ 06D1 C5           WRITE_VREG:     push    BC              ; store BC
 465+ 06D2 C6 80                        add     A,$80           ; set VDP to write to registers
 466+ 06D4 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 467+ 06D6 ED 59                        out     (C),E           ; send data to VDP
 468+ 06D8 ED 79                        out     (C),A           ; select the destination register
 469+ 06DA C1                           pop     BC              ; restore BC
 470+ 06DB C9                           ret                     ; return to caller
 471+ 06DC
 472+ 06DC              ; read VDP status register and return value into A
 473+ 06DC C5           READ_VSTAT:     push    BC              ; store BC
 474+ 06DD 0E 32                        ld      C,VDP_SET       ; VDP register access
 475+ 06DF ED 78                        in      A,(C)           ; read status register
 476+ 06E1 C1                           pop     BC              ; restore BC
 477+ 06E2 C9                           ret                     ; return to caller
 478+ 06E3
 479+ 06E3              ; position the cursor at the current coordinates, preserving underlying char
 480+ 06E3 CD 26 07     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 481+ 06E6 CD A7 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 482+ 06E9 32 FF 81                     ld      (SCR_ORG_CHR),A ; store the current char
 483+ 06EC C9                           ret
 484+ 06ED
 485+ 06ED              ; move cursor to new X,Y coordinates
 486+ 06ED CD 1D 07     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 487+ 06F0 CD 08 07                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 488+ 06F3 CD E3 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 489+ 06F6 3A 00 82                     ld      A,(CRSR_STATE)  ; load status of cursor
 490+ 06F9 A7                           and     A               ; is cursor off?
 491+ 06FA C8                           ret     Z               ; yes, return
 492+ 06FB 3A 01 82                     ld      A,(LSTCSRSTA)   ; it's visible, so...
 493+ 06FE F6 20                        or      $20             ; ...set cursor on
 494+ 0700 32 01 82                     ld      (LSTCSRSTA),A   ; store the last cursor state
 495+ 0703 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 496+ 0705 C3 BC 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 497+ 0708
 498+ 0708
 499+ 0708              ; set new cursor's coordinates
 500+ 0708 3A FD 81     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 501+ 070B 32 FB 81                     ld      (SCR_CURS_X),A  ; write new X
 502+ 070E 3A FE 81                     ld      A,(SCR_CUR_NY)  ; load new Y
 503+ 0711 32 FC 81                     ld      (SCR_CURS_Y),A  ; write new Y
 504+ 0714 3E FF                        ld      A,$FF           ; delete new values
 505+ 0716 32 FD 81                     ld      (SCR_CUR_NX),A  ; of X
 506+ 0719 32 FE 81                     ld      (SCR_CUR_NY),A  ; and Y
 507+ 071C C9                           ret
 508+ 071D
 509+ 071D              ; recover char under the cursor and prints it onto the screen
 510+ 071D CD 26 07     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 511+ 0720 3A FF 81                     ld      A,(SCR_ORG_CHR) ; recover old char
 512+ 0723 C3 BC 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 513+ 0726
 514+ 0726              ; retrieve cursor position from either current coordinates or next place
 515+ 0726              ; return address position into HL
 516+ 0726 3A FC 81     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 517+ 0729 6F                           ld      L,A             ; move it into reg.L
 518+ 072A AF                           xor     A               ; reset A
 519+ 072B 67                           ld      H,A             ; reset H
 520+ 072C 47                           ld      B,A             ; reset B
 521+ 072D 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 522+ 072E 11 B7 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 523+ 0731 3A F6 81                     ld      A,(SCR_SIZE_W)  ; load screen width
 524+ 0734 FE 28                        cp      $28             ; is it 40 cols?
 525+ 0736 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 526+ 0738 11 87 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 527+ 073B 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 528+ 073C 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 529+ 073D 23                           inc     HL
 530+ 073E 56                           ld      D,(HL)
 531+ 073F 2A F9 81                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 532+ 0742 19                           add     HL,DE           ; starting address of the current row into name table
 533+ 0743 3A FB 81                     ld      A,(SCR_CURS_X)  ; load cursor X
 534+ 0746 4F                           ld      C,A             ; transfer A into C
 535+ 0747 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 536+ 0748 C9                           ret
 537+ 0749
 538+ 0749              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 539+ 0749              ; return them into L,A for X,Y
 540+ 0749 D5           HL2XY:          push    DE              ; store DE
 541+ 074A ED 5B F9 81                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 542+ 074E AF                           xor     A               ; clear Carry
 543+ 074F ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 544+ 0751 D1                           pop     DE
 545+ 0752 3A F6 81                     ld      A,(SCR_SIZE_W)  ; load screen width
 546+ 0755 4F                           ld      C,A             ; move it into C
 547+ 0756 CD A8 4D                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 548+ 0759 C9                           ret                     ; return to caller
 549+ 075A
 550+ 075A              ;-------------------------------------------------------------------------------
 551+ 075A              ; char table for jumps
 552+ 075A 19           CHRTBL:         defb    HOME
 553+ 075B 9D 06                        defw    ATHOME          ; move the cursor to 0,0
 554+ 075D
 555+ 075D 0C                           defb    CS
 556+ 075E 90 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 557+ 0760
 558+ 0760 0D                           defb    CR
 559+ 0761 DA 09                        defw    CRGRETURN       ; go to the beginning of the next line
 560+ 0763
 561+ 0763 08                           defb    BKSP
 562+ 0764 47 08                        defw    BACKSPACE       ; move cursor left 1 position
 563+ 0766
 564+ 0766 1C                           defb    CRSLFT
 565+ 0767 8A 08                        defw    CURSORLEFT      ; move cursor left
 566+ 0769
 567+ 0769 1E                           defb    CRSUP
 568+ 076A D6 08                        defw    CURSORUP        ; move cursor up
 569+ 076C
 570+ 076C 1D                           defb    CRSRGT
 571+ 076D EF 08                        defw    CURSORRIGHT     ; move cursor right
 572+ 076F
 573+ 076F 1F                           defb    CRSDN
 574+ 0770 24 09                        defw    CURSORDOWN      ; move cursor up
 575+ 0772
 576+ 0772 1A                           defb    INSRT
 577+ 0773 05 08                        defw    INSERTKEY       ; insert a space
 578+ 0775
 579+ 0775 0A                           defb    LF
 580+ 0776 E1 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 581+ 0778
 582+ 0778              ; send current char to video buffer
 583+ 0778 F5           CHAR2VID:       push    AF              ; store AF
 584+ 0779 C5                           push    BC              ; store BC
 585+ 077A D5                           push    DE              ; store DE
 586+ 077B E5                           push    HL              ; store HL
 587+ 077C 3A 00 82                     ld      A,(CRSR_STATE)  ; store cursor state...
 588+ 077F F5                           push    AF              ; into stack
 589+ 0780 CD 59 09                     call    CURSOR_OFF      ; cursor off
 590+ 0783 3A 03 82                     ld      A,(CHR4VID)     ; recover char
 591+ 0786 06 0A                        ld      B,$0A           ; 10 chars to check
 592+ 0788 21 5A 07                     ld      HL,CHRTBL       ; address of key table
 593+ 078B BE           RPTCPCK:        cp      (HL)            ; compare with char
 594+ 078C 23                           inc     HL              ; beginning of sub-routine address
 595+ 078D 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 596+ 078F 5E                           ld      E,(HL)          ; load addres into DE
 597+ 0790 23                           inc     HL
 598+ 0791 56                           ld      D,(HL)
 599+ 0792 EB                           ex      DE,HL           ; move user routine's address into HL
 600+ 0793 11 D4 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 601+ 0796 D5                           push    DE              ; store into stack
 602+ 0797 E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 603+ 0798 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 604+ 0799 23                           inc     HL              ; ...to the next char code
 605+ 079A 10 EF                        djnz    RPTCPCK         ; repeat
 606+ 079C                              ; it'a not a special char, just print it
 607+ 079C CD 26 07                     call    LOAD_CRSR_POS   ; recover position of cursor
 608+ 079F 3A 03 82                     ld      A,(CHR4VID)     ; recover char to print
 609+ 07A2 CD BC 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 610+ 07A5 3A FC 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 611+ 07A8 5F                           ld      E,A             ; store cursor Y into E
 612+ 07A9 3A FB 81                     ld      A,(SCR_CURS_X)  ; load cursor X
 613+ 07AC 3C                           inc     A               ; move 1 step to right
 614+ 07AD 21 F6 81                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 615+ 07B0 BE                           cp      (HL)            ; have we reached the most right position?
 616+ 07B1 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 617+ 07B3 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 618+ 07B4 7B                           ld      A,E             ; move cursor Y into A
 619+ 07B5 21 F7 81                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 620+ 07B8 BE                           cp      (HL)            ; have we reached the bottom of the screen?
 621+ 07B9 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 622+ 07BB D5                           push    DE
 623+ 07BC CD 60 09                     call    SCROLLUP        ; scroll screen up
 624+ 07BF D1                           pop     DE
 625+ 07C0 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 626+ 07C1 AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 627+ 07C2 32 FB 81     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 628+ 07C5 7B                           ld      A,E             ; recover Y
 629+ 07C6 32 FC 81                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 630+ 07C9 CD E3 06                     call    POS_CURSOR      ; position cursor into new location
 631+ 07CC 3A E6 81                     ld      A,(TMRCNT)      ; load status of cursor flashing
 632+ 07CF E6 20                        and     $20             ; check cursor state
 633+ 07D1 32 01 82                     ld      (LSTCSRSTA),A   ; store the last cursor state
 634+ 07D4 AF           EXITCHAR2VID:   xor     A               ; reset char
 635+ 07D5 32 03 82                     ld      (CHR4VID),A     ; to be sent to screen
 636+ 07D8 F1                           pop     AF              ; recover cursor state
 637+ 07D9 A7                           and     A               ; was it off (A=0)?
 638+ 07DA C4 44 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 639+ 07DD E1                           pop     HL              ; restore HL
 640+ 07DE D1                           pop     DE              ; restore DE
 641+ 07DF C1                           pop     BC              ; restore BC
 642+ 07E0 F1                           pop     AF              ; restore AF
 643+ 07E1 C9           PLACEHOLDER:    ret                     ; return to caller
 644+ 07E2
 645+ 07E2              ; flash the cursor at the current position
 646+ 07E2              ; (this sub-routine is called by CH3 timer ISR)
 647+ 07E2 3A 00 82     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 648+ 07E5 A7                           and     A               ; cursor off (A=0)?
 649+ 07E6 C8                           ret     Z               ; yes, return
 650+ 07E7 3A E6 81                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 651+ 07EA E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 652+ 07EC 21 01 82                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 653+ 07EF BE                           cp      (HL)            ; compare current state with last state
 654+ 07F0 C8                           ret     Z               ; same state, no change required - exit
 655+ 07F1 77                           ld      (HL),A          ; save new state
 656+ 07F2 F5                           push    AF              ; store A (keep state for later use)
 657+ 07F3 CD 26 07                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 658+ 07F6 F1                           pop     AF              ; recover current state
 659+ 07F7 06 FF                        ld      B,$FF           ; cursor char
 660+ 07F9 FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 661+ 07FB 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 662+ 07FD 3A FF 81                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 663+ 0800 47                           ld      B,A             ; move char into B
 664+ 0801 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 665+ 0802 C3 BC 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 666+ 0805
 667+ 0805
 668+ 0805              ; insert an empty space at the current position of the cursor, moving the following text
 669+ 0805              ; 1 cell straight
 670+ 0805 CD 1D 07     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 671+ 0808 CD 26 07                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 672+ 080B 22 06 82                     ld      (CUR_POS),HL    ; store it
 673+ 080E CD 61 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 674+ 0811                                                      ; DE is the address of the bottom right cell of the screen
 675+ 0811 22 0A 82                     ld      (ENDTXT),HL     ; store it
 676+ 0814 ED 4B 06 82                  ld      BC,(CUR_POS)    ; load starting address
 677+ 0818 AF                           xor     A
 678+ 0819 ED 42                        sbc     HL,BC           ; how many positions to move?
 679+ 081B CA F3 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 680+ 081E 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 681+ 0820 2A 0A 82                     ld      HL,(ENDTXT)     ; load address of the end of text
 682+ 0823 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 683+ 0824 E5                           push    HL
 684+ 0825 CD 4D 4D                     call    CMP16           ; is it the last cell (bottom right) of screen?
 685+ 0828 E1                           pop     HL
 686+ 0829 D2 34 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 687+ 082C CD A7 06                     call    READ_VIDEO_LOC  ; no, so read current char
 688+ 082F 23                           inc     HL              ; next cell
 689+ 0830 CD BC 06                     call    WRITE_VIDEO_LOC ; write into new position
 690+ 0833 2B                           dec     HL              ; decrement to old position
 691+ 0834 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 692+ 0835 79                           ld      A,C
 693+ 0836 B0                           or      B               ; finished?
 694+ 0837 20 EA                        jr      NZ,CHKHL        ; no, repeat
 695+ 0839 3E 20        ENDINSRT:       ld      A,SPC           ; load SPACE character
 696+ 083B 2A 06 82                     ld      HL,(CUR_POS)    ; get cursor position
 697+ 083E 32 FF 81                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 698+ 0841 CD BC 06                     call    WRITE_VIDEO_LOC ; empty current video location
 699+ 0844 C3 F3 06                     jp      MOVSHOWCRS      ; re-place cursor
 700+ 0847
 701+ 0847              ; delete the char at the left of the cursor
 702+ 0847 CD 1D 07     BACKSPACE:      call    RSTCHRCRS       ; restore char
 703+ 084A 2A F9 81                     ld      HL,(SCR_NAM_TB) ; address of origin of screen (location 0,0)
 704+ 084D 44 4D                        ld      BC,HL           ; store into BC
 705+ 084F CD 26 07                     call    LOAD_CRSR_POS   ; load address of current cursor pos.
 706+ 0852 54 5D                        ld      DE,HL           ; copy into DE
 707+ 0854 AF                           xor     A               ; reset Carry
 708+ 0855 ED 42                        sbc     HL,BC           ; check how many chars between
 709+ 0857 CA 81 08                     jp      Z,LVBKSP        ; none, so we are at the top left corner
 710+ 085A ED 53 06 82                  ld      (CUR_POS),DE    ; store current cursor position
 711+ 085E CD 61 0A                     call    ENDOFLN         ; check end of text
 712+ 0861 ED 5B 06 82                  ld      DE,(CUR_POS)    ; retrieve cursor position
 713+ 0865 AF                           xor     A               ; reset Carry
 714+ 0866 ED 52                        sbc     HL,DE           ; check if none follows
 715+ 0868 CA 81 08                     jp      Z,LVBKSP        ; no chars follow, so simply move the cursor
 716+ 086B 44 4D                        ld      BC,HL           ; save numbers of chars to move
 717+ 086D EB                           ex      DE,HL           ; copy starting position into HL
 718+ 086E CD A7 06     MVBKSP:         call    READ_VIDEO_LOC  ; read char
 719+ 0871 2B                           dec     HL              ; 1 position to left
 720+ 0872 CD BC 06                     call    WRITE_VIDEO_LOC ; write char
 721+ 0875 23                           inc     HL              ; goto next char to copy (2 steps to right)
 722+ 0876 23                           inc     HL
 723+ 0877 0B                           dec     BC              ; decrement # of chars
 724+ 0878 79                           ld      A,C
 725+ 0879 B0                           or      B               ; 0 chars?
 726+ 087A 20 F2                        jr      NZ,MVBKSP       ; not finished, continue
 727+ 087C 2B                           dec     HL
 728+ 087D AF                           xor     A
 729+ 087E CD BC 06                     call    WRITE_VIDEO_LOC ; reset last char
 730+ 0881 CD B3 08     LVBKSP:         call    MVCRS2LFT       ; move cursor to new position
 731+ 0884 CD 08 07                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 732+ 0887 C3 F3 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 733+ 088A
 734+ 088A
 735+ 088A              ; move cursor to left
 736+ 088A F5           CURSORLEFT:     push    AF              ; store A
 737+ 088B 3A FB 81                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 738+ 088E A7                           and     A               ; is it at the most left of the screen (X=0)?
 739+ 088F 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 740+ 0891 3D                           dec     A               ; no, decrement X
 741+ 0892 32 FD 81                     ld      (SCR_CUR_NX),A  ; store new X
 742+ 0895 3A FC 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 743+ 0898 32 FE 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 744+ 089B 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 745+ 089D 3A FC 81     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 746+ 08A0 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 747+ 08A1 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 748+ 08A3 3D                           dec     A               ; no, decrement Y
 749+ 08A4 32 FE 81                     ld      (SCR_CUR_NY),A  ; store new Y
 750+ 08A7 3A F6 81                     ld      A,(SCR_SIZE_W)  ; load current screen width
 751+ 08AA 3D                           dec     A               ; cursor to the most right position (width-0)
 752+ 08AB 32 FD 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 753+ 08AE CD ED 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 754+ 08B1 F1           EXITCURSORLEFT: pop     AF              ; restore A
 755+ 08B2 C9                           ret                     ; return to caller
 756+ 08B3
 757+ 08B3              ; move cursor 1 position to the left
 758+ 08B3 3A FB 81     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 759+ 08B6 A7                           and     A               ; is it at the most left of the screen (X=0)?
 760+ 08B7 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 761+ 08B9 3D                           dec     A               ; no, decrement X
 762+ 08BA 32 FD 81                     ld      (SCR_CUR_NX),A  ; store new X
 763+ 08BD 3A FC 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 764+ 08C0 32 FE 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 765+ 08C3 C9                           ret                     ; go on moving cursor
 766+ 08C4 3A FC 81     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 767+ 08C7 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 768+ 08C8 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 769+ 08CA 3D                           dec     A               ; no, decrement Y
 770+ 08CB 32 FE 81                     ld      (SCR_CUR_NY),A  ; store new Y
 771+ 08CE 3A F6 81                     ld      A,(SCR_SIZE_W)  ; load current screen width
 772+ 08D1 3D                           dec     A               ; cursor to the most right position (width-1)
 773+ 08D2 32 FD 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 774+ 08D5 C9                           ret                     ; return to caller
 775+ 08D6
 776+ 08D6              ; move cursor up
 777+ 08D6 F5           CURSORUP:       push    AF              ; store A
 778+ 08D7 3A FC 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 779+ 08DA A7                           and     A               ; is it at the most top of the screen (Y=0)?
 780+ 08DB 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 781+ 08DD 3D                           dec     A               ; no, decrement Y
 782+ 08DE 32 FE 81                     ld      (SCR_CUR_NY),A  ; store new Y
 783+ 08E1 3A FB 81                     ld      A,(SCR_CURS_X)  ; load current cursor X
 784+ 08E4 32 FD 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 785+ 08E7 CD 1D 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 786+ 08EA CD ED 06                     call    MOVCRS          ; move cursor into new position
 787+ 08ED F1           EXITCURSORUP:   pop     AF              ; restore A
 788+ 08EE C9                           ret                     ; return to caller
 789+ 08EF
 790+ 08EF
 791+ 08EF              ; move cursor to right
 792+ 08EF F5           CURSORRIGHT:    push    AF              ; store A
 793+ 08F0 C5                           push    BC              ; store B
 794+ 08F1 3A F6 81                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 795+ 08F4 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 796+ 08F5 47                           ld      B,A             ; move A into B
 797+ 08F6 3A FB 81                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 798+ 08F9 B8                           cp      B               ; is cursor at the most right position on the screen?
 799+ 08FA 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 800+ 08FC 3C                           inc     A               ; no, so increment X
 801+ 08FD 32 FD 81                     ld      (SCR_CUR_NX),A  ; store new X
 802+ 0900 3A FC 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 803+ 0903 32 FE 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 804+ 0906 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 805+ 0908 3A F7 81     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 806+ 090B 3D                           dec     A               ; decrement it (last row can only be 23)
 807+ 090C 47                           ld      B,A             ; move bottom into B
 808+ 090D 3A FC 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 809+ 0910 B8                           cp      B               ; is the cursor at the bottom of the screen?
 810+ 0911 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 811+ 0913 3C                           inc     A               ; no, increment Y
 812+ 0914 32 FE 81                     ld      (SCR_CUR_NY),A  ; store new Y
 813+ 0917 AF                           xor     A               ; move cursor to top left
 814+ 0918 32 FD 81                     ld      (SCR_CUR_NX),A  ; store new X
 815+ 091B CD 1D 07     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 816+ 091E CD ED 06                     call    MOVCRS          ; move cursor into new position
 817+ 0921 C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 818+ 0922 F1                           pop     AF              ; restore A
 819+ 0923 C9                           ret                     ; return to caller
 820+ 0924
 821+ 0924
 822+ 0924              ; move cursor down
 823+ 0924 F5           CURSORDOWN:     push    AF              ; store A
 824+ 0925 C5                           push    BC              ; store B
 825+ 0926 3A F7 81                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 826+ 0929 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 827+ 092A 47                           ld      B,A             ; move X into B
 828+ 092B 3A FC 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 829+ 092E B8                           cp      B               ; is current cursor position < 23?
 830+ 092F 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 831+ 0931 3C                           inc     A               ; yes, increment Y
 832+ 0932 32 FE 81                     ld      (SCR_CUR_NY),A  ; store new Y
 833+ 0935 3A FB 81                     ld      A,(SCR_CURS_X)  ; load current cursor X
 834+ 0938 32 FD 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 835+ 093B CD 1D 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 836+ 093E CD ED 06                     call    MOVCRS          ; move cursor into new position
 837+ 0941 C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 838+ 0942 F1                           pop     AF              ; retrieve A
 839+ 0943 C9                           ret                     ; return to caller
 840+ 0944
 841+ 0944
 842+ 0944              ; set cursor on (visible on screen)
 843+ 0944 F5           CURSOR_ON:      push    AF              ; store AF
 844+ 0945 3A 00 82                     ld      A,(CRSR_STATE)  ; load cursor state
 845+ 0948 B7                           or      A               ; is it on?
 846+ 0949 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 847+ 094B 3A F7 81                     ld      A,(SCR_SIZE_H)  ; check the video mode
 848+ 094E FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 849+ 0950 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 850+ 0952 3E 01                        ld      A,$01           ; cursor state ON
 851+ 0954 32 00 82                     ld      (CRSR_STATE),A  ; set state
 852+ 0957 F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 853+ 0958 C9                           ret                     ; return to caller
 854+ 0959
 855+ 0959              ; set cursor off (invisible on screen)
 856+ 0959 F5           CURSOR_OFF:     push    AF              ; store AF
 857+ 095A AF                           xor     A               ; cursor state OFF
 858+ 095B 32 00 82                     ld      (CRSR_STATE),A  ; set state
 859+ 095E F1                           pop     AF              ; restore AF
 860+ 095F C9                           ret
 861+ 0960
 862+ 0960              ; scroll the screen 1 row up
 863+ 0960 AF           SCROLLUP:       xor     A               ; reset A
 864+ 0961 57                           ld      D,A             ; reset D
 865+ 0962 32 02 82                     ld      (PRNTVIDEO),A   ; no print on screen while scrolling
 866+ 0965 2A F9 81                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 867+ 0968 22 36 82                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 868+ 096B 3A F6 81                     ld      A,(SCR_SIZE_W)  ; load the screen width
 869+ 096E 5F                           ld      E,A             ; move width into E
 870+ 096F 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 871+ 0970 22 38 82                     ld      (VIDTMP2),HL    ; store address of source row
 872+ 0973 3A F7 81                     ld      A,(SCR_SIZE_H)  ; load the screen height
 873+ 0976 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 874+ 0977 47                           ld      B,A             ; move # of rows into B
 875+ 0978 3A F6 81     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 876+ 097B 5F                           ld      E,A             ; move width into E
 877+ 097C 2A 38 82                     ld      HL,(VIDTMP2)    ; load source address
 878+ 097F 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 879+ 0981 ED 69                        out     (C),L           ; low byte of source
 880+ 0983 ED 61                        out     (C),H           ; high byte of source
 881+ 0985 21 0E 82                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 882+ 0988 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 883+ 098A ~                            LM64K_NOP               ; added to compensate shorter instruction
 884+ 098A ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 885+ 098C 77                           ld      (HL),A          ; store char
 886+ 098D 23                           inc     HL              ; next cell of the buffer
 887+ 098E 1D                           dec     E               ; count the chars to be read
 888+ 098F 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 889+ 0991 3A F6 81                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 890+ 0994 5F                           ld      E,A             ; move # of rows into E
 891+ 0995 16 00                        ld      D,$00           ; reset D
 892+ 0997 2A 36 82                     ld      HL,(VIDTMP1)    ; load address of destination row
 893+ 099A E5                           push    HL              ; store HL
 894+ 099B 2A 38 82                     ld      HL,(VIDTMP2)    ; current source will be..
 895+ 099E 22 36 82                     ld      (VIDTMP1),HL    ; ..new destination
 896+ 09A1 19                           add     HL,DE           ; address of new
 897+ 09A2 22 38 82                     ld      (VIDTMP2),HL    ; source row
 898+ 09A5 E1                           pop     HL              ; restore address of current destination row
 899+ 09A6 CB F4                        set     6,H             ; writing mode
 900+ 09A8 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 901+ 09AA ED 69                        out     (C),L           ; low byte
 902+ 09AC ED 61                        out     (C),H           ; high byte of address
 903+ 09AE 21 0E 82                     ld      HL,VIDEOBUFF    ; video buffer address
 904+ 09B1 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 905+ 09B3 7E           WRITEBUF:       ld      A,(HL)          ; load char
 906+ 09B4 ED 79                        out     (C),A           ; send char
 907+ 09B6 23                           inc     HL              ; increment buffer index
 908+ 09B7 1D                           dec     E               ; next row
 909+ 09B8 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 910+ 09BA 10 BC                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 911+ 09BC 3A F6 81                     ld      A,(SCR_SIZE_W)  ; reload screen width
 912+ 09BF 47                           ld      B,A             ; cells to empty into B
 913+ 09C0 AF                           xor     A               ; null char
 914+ 09C1 0E 32                        ld      C,VDP_SET       ; VDP set mode
 915+ 09C3 2A 36 82                     ld      HL,(VIDTMP1)    ; load address of the last row
 916+ 09C6 CB F4                        set     6,H             ; writing mode
 917+ 09C8 ED 69                        out     (C),L           ; low byte then..
 918+ 09CA ED 61                        out     (C),H           ; high byte of address
 919+ 09CC 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 920+ 09CE ~                            LM64K_NOP               ; delay
 921+ 09CE ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 922+ 09D0 00                           nop                     ; delay
 923+ 09D1 00                           nop
 924+ 09D2 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 925+ 09D4 3E 01                        ld      A,$01
 926+ 09D6 32 02 82                     ld      (PRNTVIDEO),A   ; set print-on-video on
 927+ 09D9 C9                           ret                     ; return to caller
 928+ 09DA
 929+ 09DA              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 930+ 09DA              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 931+ 09DA              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 932+ 09DA              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 933+ 09DA              CUR_POS         equ     TMPBFR1         ; cursor position
 934+ 09DA              SRTTXT          equ     TMPBFR2         ; start of text line
 935+ 09DA              ENDTXT          equ     TMPBFR3         ; end of text line
 936+ 09DA              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 937+ 09DA 3A 00 82                     ld      A,(CRSR_STATE)  ; recover cursor state
 938+ 09DD 32 0C 82                     ld      (TMPBFR4),A     ; store status
 939+ 09E0 A7                           and     A               ; is cursor on?
 940+ 09E1 C4 59 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 941+ 09E4 CD 1D 07                     call    RSTCHRCRS       ; restore char under it
 942+ 09E7                              ; first, check if cursor if off, so that we just interpret return as a new line command
 943+ 09E7 3A 40 82                     ld      A,(KBDNPT)      ; check if input from keyboad
 944+ 09EA A7                           and     A               ; if 0, input is not from keyboard...
 945+ 09EB CA 40 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 946+ 09EE                              ; first part: look for the beginning of the text line on screen
 947+ 09EE CD 26 07                     call    LOAD_CRSR_POS   ; load cursor position into HL
 948+ 09F1 22 06 82                     ld      (CUR_POS),HL    ; store it
 949+ 09F4 ED 5B F9 81                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 950+ 09F8 E5           RPTNLLSRC:      push    HL
 951+ 09F9 CD 4D 4D                     call    CMP16           ; check if at "home"
 952+ 09FC E1                           pop     HL
 953+ 09FD CA 08 0A                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 954+ 0A00 2B                           dec     HL              ; go 1 step back
 955+ 0A01 CD A7 06                     call    READ_VIDEO_LOC  ; read char of current position
 956+ 0A04 A7                           and     A               ; is it $00 (null char)?
 957+ 0A05 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 958+ 0A07 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 959+ 0A08                              ; second part: look for the ending of the text on screen
 960+ 0A08 22 08 82     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 961+ 0A0B CD 61 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 962+ 0A0E 22 0A 82                     ld      (ENDTXT),HL     ; store ending of text line
 963+ 0A11 ED 5B 08 82                  ld      DE,(SRTTXT)     ; load beginning of text line
 964+ 0A15 A7                           and     A               ; clear Carry
 965+ 0A16 ED 52                        sbc     HL,DE           ; how many chars?
 966+ 0A18 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 967+ 0A1A                              ;---    central part: send the text on the screen to the interpreter
 968+ 0A1A 2A 08 82                     ld      HL,(SRTTXT)     ; load beginning of text line
 969+ 0A1D ED 5B 0A 82                  ld      DE,(ENDTXT)     ; load ending of text line
 970+ 0A21 CD A7 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 971+ 0A24 E5                           push    HL
 972+ 0A25 CD FD 01                     call    CHARINTOBFR     ; send char to buffer
 973+ 0A28 E1                           pop     HL
 974+ 0A29 23                           inc     HL              ; go to next char
 975+ 0A2A E5                           push    HL              ; store HL
 976+ 0A2B CD 4D 4D                     call    CMP16           ; check if DE=HL (finish chars)
 977+ 0A2E E1                           pop     HL
 978+ 0A2F 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 979+ 0A31 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 980+ 0A33 CD FD 01                     call    CHARINTOBFR     ; send to buffer
 981+ 0A36 2A 0A 82                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 982+ 0A39 CD 49 07                     call    HL2XY           ; retrieve X,Y from address
 983+ 0A3C 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 984+ 0A3D 32 FC 81                     ld      (SCR_CURS_Y),A  ; store new Y
 985+ 0A40                              ;---    final part: go at the beginning of a new line on the screen
 986+ 0A40 AF           PRNTRETURN:     xor     A               ; move to col 0
 987+ 0A41 32 FB 81                     ld      (SCR_CURS_X),A  ; store new X
 988+ 0A44 3A FC 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 989+ 0A47 3C                           inc     A               ; new row
 990+ 0A48 21 F7 81                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 991+ 0A4B BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 992+ 0A4C 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 993+ 0A4E 3D                           dec     A               ; yes, so come back 1 row, then...
 994+ 0A4F F5                           push    AF              ; (store A)
 995+ 0A50 CD 60 09                     call    SCROLLUP        ; ...scroll the screen before to...
 996+ 0A53 F1                           pop     AF              ; (retrieve A)
 997+ 0A54 32 FC 81     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 998+ 0A57 3A 0C 82                     ld      A,(TMPBFR4)     ; retrieve cursor state
 999+ 0A5A A7                           and     A               ; was it off (A=0)?
1000+ 0A5B C4 44 09                     call    NZ,CURSOR_ON    ; no, set cursor on
1001+ 0A5E C3 E3 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
1002+ 0A61
1003+ 0A61              ; find end of text line
1004+ 0A61              ; destroys A, DE, and HL - store address of last char of text line into HL,
1005+ 0A61              ; while DE contains the address of the bottom right cell of the screen
1006+ 0A61 3A F7 81     ENDOFLN:        ld      A,(SCR_SIZE_H)
1007+ 0A64 5F                           ld      E,A             ; load screen height into DE
1008+ 0A65 3A F6 81                     ld      A,(SCR_SIZE_W)
1009+ 0A68 6F                           ld      L,A             ; load screen width into HL
1010+ 0A69 AF                           xor     A
1011+ 0A6A 67                           ld      H,A
1012+ 0A6B 57                           ld      D,A
1013+ 0A6C CD 58 4D                     call    MUL16           ; multiply HL times DE to get the screen size
1014+ 0A6F ED 5B F9 81                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
1015+ 0A73 19                           add     HL,DE           ; get the address...
1016+ 0A74 2B                           dec     HL              ; ...of the "last" video cell
1017+ 0A75 EB                           ex      DE,HL           ; store address into DE
1018+ 0A76 2A 06 82                     ld      HL,(CUR_POS)    ; retrieve original cursor position
1019+ 0A79 E5           RPTNLLSRC2:     push    HL
1020+ 0A7A CD 4D 4D                     call    CMP16           ; check if at last position on screen (bottom right corner)
1021+ 0A7D E1                           pop     HL
1022+ 0A7E C8                           ret     Z               ; if yes, exit because these is nothing after
1023+ 0A7F 23                           inc     HL              ; 1 more step forward
1024+ 0A80 CD A7 06                     call    READ_VIDEO_LOC  ; read char of current position
1025+ 0A83 A7                           and     A               ; is it $00 (null char)?
1026+ 0A84 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1027+ 0A86 C9           CNTNULL2:       ret                     ; yes: found end of text, return to caller
1028+ 0A87
1029+ 0A87
1030+ 0A87              ; ------------------------------------------------------------------------------
1031+ 0A87                              ; this table contains the values of the offsets to be added to
1032+ 0A87                              ; the starting address of the name table to find the correct
1033+ 0A87                              ; value of the first cell of the corresponding row
1034+ 0A87                              ; (by doing so, it's faster than doing a multipication)
1035+ 0A87                              ; table for graphics 1 text mode: 32 cols
1036+ 0A87 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1036+ 0A8B 40 00 60 00
1036+ 0A8F 80 00 A0 00
1036+ 0A93 C0 00 E0 00
1037+ 0A97 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1037+ 0A9B 40 01 60 01
1037+ 0A9F 80 01 A0 01
1037+ 0AA3 C0 01 E0 01
1038+ 0AA7 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1038+ 0AAB 40 02 60 02
1038+ 0AAF 80 02 A0 02
1038+ 0AB3 C0 02 E0 02
1039+ 0AB7                              ; table for pure text mode: 40 cols
1040+ 0AB7 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1040+ 0ABB 50 00 78 00
1040+ 0ABF A0 00 C8 00
1040+ 0AC3 F0 00 18 01
1041+ 0AC7 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1041+ 0ACB 90 01 B8 01
1041+ 0ACF E0 01 08 02
1041+ 0AD3 30 02 58 02
1042+ 0AD7 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1042+ 0ADB D0 02 F8 02
1042+ 0ADF 20 03 48 03
1042+ 0AE3 70 03 98 03
1043+ 0AE7
1044+ 0AE7              ; ------------------------------------------------------------------------------
1045+ 0AE7              ; reset VRAM
1046+ 0AE7 AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1047+ 0AE8 67                           ld      H,A
1048+ 0AE9 6F                           ld      L,A             ; reset HL
1049+ 0AEA CD 87 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1050+ 0AED 06 40                        ld      B,$40           ; $40 pages of RAM...
1051+ 0AEF 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1052+ 0AF0 0E 30                        ld      C,VDP_DAT              ; VDP data mode
1053+ 0AF2 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1054+ 0AF4 14                           inc     D               ; next cell
1055+ 0AF5 00                           nop
1056+ 0AF6 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1057+ 0AF8 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1058+ 0AFA C9                           ret                     ; return to caller
1059+ 0AFB
1060+ 0AFB              ; clear video registers in SRAM
1061+ 0AFB 21 F6 81     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1062+ 0AFE AF                           xor     A               ; $00 to clean the registers
1063+ 0AFF 06 44                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1064+ 0B01 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1065+ 0B02 23                           inc     HL              ; next register
1066+ 0B03 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1067+ 0B05 C9                           ret                     ; return to caller
1068+ 0B06
1069+ 0B06              ; ------------------------------------------------------------------------------
1070+ 0B06              ; set a specific graphics mode, passed into reg. E
1071+ 0B06 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1072+ 0B08 CB 23                        sla     E               ; multiply E by 8..
1073+ 0B0A CB 23                        sla     E               ; so that reg. E can point..
1074+ 0B0C CB 23                        sla     E               ; to the correct settings
1075+ 0B0E 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1076+ 0B10 21 43 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1077+ 0B13 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1078+ 0B14 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1079+ 0B16 0E 32                        ld      C,VDP_SET       ; VDP set
1080+ 0B18 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1081+ 0B19 ED 51                        out     (C),D           ; send data to VDP
1082+ 0B1B ED 79                        out     (C),A           ; indicate the register to send data to
1083+ 0B1D 3C                           inc     A               ; next register
1084+ 0B1E 23                           inc     HL              ; next value
1085+ 0B1F 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1086+ 0B21 C9                           ret
1087+ 0B22
1088+ 0B22              ; ------------------------------------------------------------------------------
1089+ 0B22              LOADCHARSET:    ; reg. A contains the video mode
1090+ 0B22                              ; reg. HL contains address of pattern table into VRAM
1091+ 0B22 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1092+ 0B24 CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1093+ 0B26 0E 32                        ld      C,VDP_SET       ; load VDP address into C
1094+ 0B28 ED 69                        out     (C),L           ; send low byte of address
1095+ 0B2A ED 61                        out     (C),H           ; send high byte
1096+ 0B2C 0E 30                        ld      C,VDP_DAT              ; VDP data mode
1097+ 0B2E 21 83 4E                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1098+ 0B31 A7                           and     A               ; is it text mode (A=0)?
1099+ 0B32 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1100+ 0B34 21 83 56                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1101+ 0B37 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1102+ 0B39 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1103+ 0B3A ED 79                        out     (C),A           ; write byte into VRAM
1104+ 0B3C 23                           inc     HL              ; inc byte pointer
1105+ 0B3D 15                           dec     D               ; 8 bytes sents (0 char)?
1106+ 0B3E 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1107+ 0B40 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1108+ 0B42 C9                           ret                     ; return to caller
1109+ 0B43
1110+ 0B43              ;------------------------------------------------------------------------------
1111+ 0B43              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1112+ 0B43              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1113+ 0B43              ; COLOR TABLE:      color settings for chars/tiles
1114+ 0B43
1115+ 0B43                              ; VDP register settings for a text display
1116+ 0B43 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1117+ 0B44 D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1118+ 0B45 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1119+ 0B46 00                           defb    $00             ; reg.3: not used in text mode
1120+ 0B47 00                           defb    $00             ; reg.4: pattern table set to $0000
1121+ 0B48 00                           defb    $00             ; reg.5: not used in text mode
1122+ 0B49 00                           defb    $00             ; reg.6: not used in text mode
1123+ 0B4A F5                           defb    $f5             ; reg.7: white text on light blue background
1124+ 0B4B
1125+ 0B4B              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1126+ 0B4B 00                           defb    %00000000       ; reg.0: ext. video off
1127+ 0B4C C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1128+ 0B4D 06                           defb    $06             ; reg.2: name table address: $1800
1129+ 0B4E 80                           defb    $80             ; reg.3: color table address: $2000
1130+ 0B4F 00                           defb    $00             ; reg.4: pattern table address: $0000
1131+ 0B50 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1132+ 0B51 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1133+ 0B52 05                           defb    $05             ; reg.7: backdrop color (light blue)
1134+ 0B53
1135+ 0B53              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1136+ 0B53 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1137+ 0B54 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1138+ 0B55 06                           defb    $06             ; reg.2: name table addr.: $1800
1139+ 0B56 FF                           defb    $FF             ; reg.3: color table addr.: $2000
1140+ 0B57 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1141+ 0B58 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1142+ 0B59 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1143+ 0B5A 05                           defb    $05             ; reg.7: backdrop color: light blue
1144+ 0B5B
1145+ 0B5B              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1146+ 0B5B 00                           defb    %00000000       ; reg.0: ext. video dis.
1147+ 0B5C CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1148+ 0B5D 02                           defb    $02             ; reg.2: name table addr.: $0800
1149+ 0B5E 00                           defb    $00             ; reg.3: don't care
1150+ 0B5F 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1151+ 0B60 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1152+ 0B61 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1153+ 0B62 0F                           defb    $0F             ; reg.7: backdrop color (white)
1154+ 0B63
1155+ 0B63              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1156+ 0B63 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1157+ 0B64 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1158+ 0B65 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1159+ 0B66 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1160+ 0B67 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1161+ 0B68 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1162+ 0B69 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1163+ 0B6A 05                           defb    $05             ; reg.7: backdrop color: light blue
1164+ 0B6B
1165+ 0B6B              LM80CLOGO:      ; patterns to compose the splash screen logo
1166+ 0B6B                              ; 1st band
1167+ 0B6B 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1167+ 0B6F 00 00 00 00
1167+ 0B73 00 00 00 00
1167+ 0B77 00 00 00 00
1167+ 0B7B 00 00 00 00
1167+ 0B7F 00 00 00 00
1167+ 0B83 00 00 00 00
1167+ 0B87 00 00 00 00
1168+ 0B8B 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1168+ 0B8F 0B 10 00 00
1168+ 0B93 00 00 00 00
1168+ 0B97 00 00 00 00
1168+ 0B9B 00 00 00 00
1168+ 0B9F 00 00 00 00
1168+ 0BA3 00 00 00 00
1168+ 0BA7 00 00 00 00
1169+ 0BAB                              ; 2nd band
1170+ 0BAB 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1170+ 0BAF 00 0C 00 00
1170+ 0BB3 00 01 00 00
1170+ 0BB7 00 14 00 00
1170+ 0BBB 06 05 06 15
1170+ 0BBF 16 07 06 15
1170+ 0BC3 16 07 06 01
1170+ 0BC7 01 07 00 00
1171+ 0BCB 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1171+ 0BCF 00 0C 00 00
1171+ 0BD3 00 01 00 00
1171+ 0BD7 00 01 14 06
1171+ 0BDB 01 05 03 05
1171+ 0BDF 03 05 03 05
1171+ 0BE3 03 05 03 05
1171+ 0BE7 03 05 00 00
1172+ 0BEB                              ; 3rd band
1173+ 0BEB 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1173+ 0BEF 00 0C 00 00
1173+ 0BF3 00 01 00 00
1173+ 0BF7 00 01 01 01
1173+ 0BFB 01 05 09 14
1173+ 0BFF 13 08 03 05
1173+ 0C03 13 05 03 05
1173+ 0C07 00 00 00 00
1174+ 0C0B 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1174+ 0C0F 00 0C 00 00
1174+ 0C13 00 01 00 00
1174+ 0C17 00 01 00 08
1174+ 0C1B 03 05 06 15
1174+ 0C1F 16 07 03 01
1174+ 0C23 16 05 03 05
1174+ 0C27 00 00 00 00
1175+ 0C2B                              ; 4th band
1176+ 0C2B 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1176+ 0C2F 00 0C 00 00
1176+ 0C33 00 01 00 00
1176+ 0C37 00 01 00 00
1176+ 0C3B 03 05 03 05
1176+ 0C3F 03 05 03 05
1176+ 0C43 03 05 03 05
1176+ 0C47 03 05 00 00
1177+ 0C4B 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1177+ 0C4F 00 0C 00 00
1177+ 0C53 00 01 04 04
1177+ 0C57 00 01 00 00
1177+ 0C5B 03 05 09 14
1177+ 0C5F 13 08 09 14
1177+ 0C63 13 08 09 01
1177+ 0C67 01 08 00 00
1178+ 0C6B                              ; 5th band
1179+ 0C6B 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1179+ 0C6F 12 11 00 00
1179+ 0C73 00 00 00 00
1179+ 0C77 00 00 00 00
1179+ 0C7B 00 00 00 00
1179+ 0C7F 00 00 00 00
1179+ 0C83 00 00 00 00
1179+ 0C87 00 00 00 00
1180+ 0C8B 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1180+ 0C8F 00 00 00 00
1180+ 0C93 00 00 00 00
1180+ 0C97 00 00 00 00
1180+ 0C9B 00 00 00 00
1180+ 0C9F 00 00 00 00
1180+ 0CA3 00 00 00 00
1180+ 0CA7 00 00 00 00
# file closed: ../include/vdp/vdp-1.5.asm
  77  0CAB
  78  0CAB              ; incude the latest version of the PSG module
  79  0CAB                  INCLUDE "../include/psg/psg-1.1.asm"
# file opened: ../include/psg/psg-1.1.asm
   1+ 0CAB              ; ------------------------------------------------------------------------------
   2+ 0CAB              ; LM80C - PSG ROUTINES - 1.1
   3+ 0CAB              ; ------------------------------------------------------------------------------
   4+ 0CAB              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0CAB              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0CAB              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0CAB              ; kind of warranty: you can use them at your own risk.
   8+ 0CAB              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0CAB              ; maintain the copyright notices, include this advice and the note to the
  10+ 0CAB              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0CAB              ; redistribuite them.
  12+ 0CAB              ; https://www.leonardomiliani.com
  13+ 0CAB              ;
  14+ 0CAB              ; Please support me by visiting the following links:
  15+ 0CAB              ; Main project page: https://www.leonardomiliani.com
  16+ 0CAB              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0CAB              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0CAB              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0CAB              ; ------------------------------------------------------------------------------
  20+ 0CAB              ;
  21+ 0CAB              ; ------------------------------------------------------------------------------
  22+ 0CAB
  23+ 0CAB              ;------------------------------------------------------------------------------
  24+ 0CAB
  25+ 0CAB              ; configure the PSG
  26+ 0CAB 21 3A 82     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0CAE 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0CB0 AF                           xor     A               ; reset A
  29+ 0CB1 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0CB2 23                           inc     HL              ; next register
  31+ 0CB3 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0CB5 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0CB7 21 C9 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0CBA 16 00                        ld      D,$00           ; first register
  35+ 0CBC 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0CBD CD 03 0D                     call    SETSNDREG       ; select register
  37+ 0CC0 7E                           ld      A,(HL)          ; load value
  38+ 0CC1 CD 08 0D                     call    WRTSNDREG       ; write to register
  39+ 0CC4 14                           inc     D               ; next register
  40+ 0CC5 23                           inc     HL              ; next value
  41+ 0CC6 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0CC8 C9                           ret                     ; return to caller
  43+ 0CC9
  44+ 0CC9 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0CCD 00 00 00 BF
  45+ 0CD1 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0CD5 00 00 FF FF
  46+ 0CD9                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0CD9
  48+ 0CD9
  49+ 0CD9              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0CD9 21 F3 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0CDC C3 E2 0C                     jp      SENDSND
  52+ 0CDF 21 FB 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0CE2 C5           SENDSND:        push    BC
  54+ 0CE3 06 04                        ld      B,$04           ; 4 pairs
  55+ 0CE5 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0CE6 CD 03 0D                     call    SETSNDREG
  57+ 0CE9 23                           inc     HL              ; next cell
  58+ 0CEA 7E                           ld      A,(HL)          ; read value
  59+ 0CEB CD 08 0D                     call    WRTSNDREG
  60+ 0CEE 23                           inc     HL
  61+ 0CEF 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CF1 C1                           pop     BC
  63+ 0CF2 C9                           ret                     ; return to caller
  64+ 0CF3
  65+ 0CF3 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CF7 05 00 0A 0F
  66+ 0CFB 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CFF 0A 00 07 BF
  67+ 0D03
  68+ 0D03
  69+ 0D03              ; select register on PSG
  70+ 0D03 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0D05 ED 79                        out     (C),A           ; set register
  72+ 0D07 C9                           ret                     ; return to caller
  73+ 0D08
  74+ 0D08              ; send data to PSG
  75+ 0D08 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0D0A ED 79                        out     (C),A           ; send data
  77+ 0D0C C9                           ret                     ; return to caller
  78+ 0D0D
  79+ 0D0D              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0D0D              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0D0D              ; shut off the audio channel whose counter has reached 0.
  82+ 0D0D              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0D0D DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0D0F DD 21 3A 82                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0D13 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0D15 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0D17 DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0D1A DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0D1D 7B                           ld      A,E             ; load E into A
  90+ 0D1E B2                           or      D               ; check that DE=0
  91+ 0D1F 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0D21 1B                           dec     DE              ; no, so decrement DE
  93+ 0D22 7B                           ld      A,E             ; reload E into A...
  94+ 0D23 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0D26 DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0D29 B2                           or      D               ; ...do another check to see if DE=0
  97+ 0D2A 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0D2C                                                      ; if yes, let's shut down the corresponding channel
  99+ 0D2C                                                      ; to shut down a tone we disable it into the mixer
 100+ 0D2C                                                      ; then set 0 into its tone registers
 101+ 0D2C 16 07                        ld      D,$07           ; mixer register
 102+ 0D2E 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0D30 ED 51                        out     (C),D           ; set mixer register
 104+ 0D32 ED 78                        in      A,(C)           ; load current value
 105+ 0D34 B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0D35 ED 51                        out     (C),D           ; select mixer register
 107+ 0D37 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0D39 ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0D3B 3E 03                        ld      A,$03           ; three channels
 110+ 0D3D 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0D3E 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0D3F 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0D41 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0D43 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0D45 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0D47 ED 69                        out     (C),L           ; write 0 into register
 117+ 0D49 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0D4B 3C                           inc     A               ; next tone register
 119+ 0D4C ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0D4E 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0D50 ED 69                        out     (C),L           ; write 0 into register
 122+ 0D52 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D54 DD 23                        inc     IX              ; ...next channel...
 124+ 0D56 CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D58 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D5A DD E1                        pop     IX              ; restore IX
 127+ 0D5C C9                           ret                     ; return to caller
 128+ 0D5D
 129+ 0D5D              ; read a specific row of the keyboard matrix, set by A
 130+ 0D5D              ; return read into A
 131+ 0D5D C5           READKBLN:       push    BC              ; store BC
 132+ 0D5E 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D60 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D62 ED 41                        out     (C),B           ; select reg #15
 135+ 0D64 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D66 ED 79                        out     (C),A           ; activate the row
 137+ 0D68 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D6A 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D6C ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D6E ED 78                        in      A,(C)           ; read register #14
 141+ 0D70 C1                           pop     BC              ; retrieve BC
 142+ 0D71 C9                           ret
 143+ 0D72
 144+ 0D72              ; read the keyboard matrix to look for a key pressure
 145+ 0D72 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D74 06 07                        ld      B,$07           ; set register #7...
 147+ 0D76 ED 41                        out     (C),B           ; ...to work with
 148+ 0D78 ED 78                        in      A,(C)           ; read register #7
 149+ 0D7A CB FF                        set     7,A             ; port A set to output
 150+ 0D7C CB B7                        res     6,A             ; port B set to input
 151+ 0D7E ED 41                        out     (C),B           ; set register #7
 152+ 0D80 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D82 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D84                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D84 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D86 CD 5D 0D                     call    READKBLN        ; read row
 157+ 0D89 CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D8B 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D8D 21 47 82                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D90 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D92 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D94 CD 5D 0D                     call    READKBLN        ; read ALT row
 163+ 0D97 CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D99 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D9B 21 47 82                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D9E 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0DA0 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0DA2 CD 5D 0D                     call    READKBLN        ; read CTRL row
 169+ 0DA5 CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0DA7 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0DA9 21 47 82                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0DAC 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0DAE 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0DB0 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0DB2 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0DB4 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0DB6 ED 51                        out     (C),D           ; select reg. #15
 178+ 0DB8 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0DBA ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0DBC 5F                           ld      E,A             ; save current line into E
 181+ 0DBD 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0DBF 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0DC1 ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0DC3 00                           nop
 185+ 0DC4 ED 78                        in      A,(C)           ; read register #14
 186+ 0DC6 FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0DC8 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0DCA                              ; check control keys
 189+ 0DCA 32 41 82                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0DCD 78                           ld      A,B             ; copy current row (B) into A
 191+ 0DCE FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0DD0 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0DD2 3A 41 82                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0DD5 CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0DD7 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0DD9 CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0DDB FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0DDD 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0DDF 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0DE1 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0DE3 3A 41 82                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0DE6 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0DE8 CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0DEA 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0DEC CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0DEE CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0DF0 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0DF2 CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0DF4 FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0DF6 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0DF8 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0DF9 0F                           rrca                    ; rotate right by 1
 213+ 0DFA 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0DFC AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0DFD 32 43 82                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0E00 32 47 82                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0E03 32 40 82                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0E06 32 44 82                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0E09 C9                           ret                     ; ...and leave
 220+ 0E0A 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0E0C 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0E0D CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0E0F 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0E11 3A 47 82                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0E14 21 2D 0F                     ld      HL,KBMAP        ; normal keymap
 226+ 0E17 FE 01                        cp      $01             ; SHIFT flag?
 227+ 0E19 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0E1B 21 6D 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0E1E 18 10                        jr      LOADMAP         ; and load it
 230+ 0E20 FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0E22 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0E24 21 ED 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0E27 18 07                        jr      LOADMAP         ; and load it
 234+ 0E29 FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0E2B 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0E2D 21 AD 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0E30 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0E31 48                           ld      C,B             ; move B into C and...
 239+ 0E32 CB 21                        sla     C               ; ...multiply it...
 240+ 0E34 CB 21                        sla     C               ; ...by 8 to find...
 241+ 0E36 CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0E38 06 00                        ld      B,$00           ; reset B
 243+ 0E3A 09                           add     HL,BC           ; find the address of the current row
 244+ 0E3B 50                           ld      D,B             ; reset D
 245+ 0E3C 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0E3D 3A 43 82                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0E40 BE                           cp      (HL)            ; is it the same key?
 248+ 0E41 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0E43 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0E45 2A E6 81                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0E48 ED 5B 45 82                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0E4C 3A 44 82                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0E4F FE 01                        cp      $01             ; is it initial pressure?
 254+ 0E51 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0E53 AF                           xor     A               ; clear Carry
 256+ 0E54 ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0E56 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0E58 3A B3 80                     ld      A,(KEYDEL)
 259+ 0E5B 5F                           ld      E,A
 260+ 0E5C CD 4D 4D                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E5F DA D4 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E62 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E64 32 44 82                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E67 2A E6 81                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E6A 22 45 82                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E6D 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E6F C3 91 0E                     jp      SENDKEY         ; send key
 268+ 0E72 AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E73 ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E75 16 00                        ld      D,$00
 271+ 0E77 3A B4 80                     ld      A,(AUTOKE)
 272+ 0E7A 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E7B CD 4D 4D                     call    CMP16           ; check if interval is greater than delay
 274+ 0E7E DA D4 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E81 C3 62 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E84 AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E85 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E86 32 44 82                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E89 ED 4B E6 81                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E8D ED 43 45 82                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E91 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E92 32 43 82                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E95 32 42 82                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E98 32 03 82                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E9B FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E9D 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E9F CD FD 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0EA2 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0EA4 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0EA7 21 25 0F                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0EAA BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0EAB CA D9 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0EAE 0C                           inc     C               ; next FN key
 294+ 0EAF 23                           inc     HL              ; next FN key code
 295+ 0EB0 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0EB2 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0EB4 32 40 82                     ld      (KBDNPT),A      ; to keyboard
 298+ 0EB7 3A 02 82                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0EBA B7                           or      A               ; is the print-on-video disabled?
 300+ 0EBB CA C4 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0EBE 3A 00 82                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0EC1 B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0EC2 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0EC4 AF           PUTCHRBUF:      xor     A
 305+ 0EC5 32 40 82                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0EC8 3A 42 82                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0ECB CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0ECE C3 D4 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0ED1 CD 78 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0ED4 AF           LVKBRDCHK2:     xor     A
 311+ 0ED5 32 47 82                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0ED8 C9           LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0ED9                              ; manage FN keys
 314+ 0ED9 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0EDA 2A AF 80                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0EDD 23                           inc     HL              ; -1 means direct statement
 317+ 0EDE 7C                           ld      A,H
 318+ 0EDF B5                           or      L
 319+ 0EE0 7A                           ld      A,D             ; retrieve char
 320+ 0EE1 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0EE3 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0EE4 87                           add     A,A
 323+ 0EE5 87                           add     A,A
 324+ 0EE6 87                           add     A,A
 325+ 0EE7 87                           add     A,A             ; FN key number * 16
 326+ 0EE8 4F                           ld      C,A             ; move it into C
 327+ 0EE9 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0EEB 21 B5 80                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0EEE 09                           add     HL,BC           ; get correct text address
 330+ 0EEF 06 10                        ld      B,$10           ; 16 chars
 331+ 0EF1 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0EF2 A7                           and     A               ; null char?
 333+ 0EF3 CA D4 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0EF6 57                           ld      D,A             ; pass char into D
 335+ 0EF7 3A 02 82                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0EFA B7                           or      A               ; is the print-on-video disabled?
 337+ 0EFB CA 0B 0F                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0EFE 3A 00 82                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0F01 B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0F02 C4 18 0F                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0F05 23           CNTFNK:         inc     HL              ; next char
 342+ 0F06 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0F08 C3 D4 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0F0B AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0F0C 32 40 82                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0F0F 7A                           ld      A,D             ; retrieve char
 347+ 0F10 E5                           push    HL              ; store HL
 348+ 0F11 CD FD 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0F14 E1                           pop     HL              ; retrieve HL
 350+ 0F15 C3 05 0F                     jp      CNTFNK          ; repeat
 351+ 0F18 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0F19 32 03 82                     ld      (CHR4VID),A     ; store char for printing
 353+ 0F1C 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0F1E 32 40 82                     ld      (KBDNPT),A      ; to keyboard
 355+ 0F21 CD 78 07                     call    CHAR2VID        ; print on screen
 356+ 0F24 C9                           ret                     ; return to caller
 357+ 0F25
 358+ 0F25
 359+ 0F25              ;-----------------------------------------------------------------------
 360+ 0F25 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0F29 06 16 17 18
 361+ 0F2D              ;-----------------------------------------------------------------------
 362+ 0F2D              ; key codes
 363+ 0F2D 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0F31 20 10 71 32
 364+ 0F35 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0F39 7A 73 65 34
 365+ 0F3D 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0F41 63 66 74 36
 366+ 0F45 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0F49 62 68 75 38
 367+ 0F4D 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0F51 6D 6B 6F 30
 368+ 0F55 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0F59 2E 3A 2D 1E
 369+ 0F5D 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F61 1B 3D 2B 1D
 370+ 0F65 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F69 01 02 04 18
 371+ 0F6D
 372+ 0F6D              ; shifted codes - not all the keys have the shifted version
 373+ 0F6D 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F71 20 10 51 22
 374+ 0F75 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F79 5A 53 45 24
 375+ 0F7D 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F81 43 46 54 26
 376+ 0F85 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F89 42 48 55 28
 377+ 0F8D 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F91 4D 4B 4F 5E
 378+ 0F95 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F99 3E 5B 5F 1E
 379+ 0F9D 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0FA1 1B C6 2B 1D
 380+ 0FA5 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0FA9 05 06 16 17
 381+ 0FAD
 382+ 0FAD              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0FAD 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0FB1 20 10 DE C4
 384+ 0FB5 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0FB9 83 82 A5 34
 385+ 0FBD 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0FC1 9D A3 A8 36
 386+ 0FC5 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0FC9 9E AC D5 38
 387+ 0FCD 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0FD1 A0 D7 87 C3
 388+ 0FD5 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0FD9 C0 7B 90 1E
 389+ 0FDD 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0FE1 1B D1 94 1D
 390+ 0FE5 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0FE9 05 06 16 17
 391+ 0FED
 392+ 0FED              ; CTRL codes - not all the keys have the control-ed version
 393+ 0FED 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0FF1 20 10 9A 32
 394+ 0FF5 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0FF9 98 96 99 34
 395+ 0FFD 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 1001 B1 AF A5 36
 396+ 1005 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 1009 B3 A9 A7 38
 397+ 100D 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 1011 AB B5 A4 30
 398+ 1015 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 1019 2E 3A BA 1E
 399+ 101D 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 1021 1B D4 B9 1D
 400+ 1025 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 1029 01 02 04 18
# file closed: ../include/psg/psg-1.1.asm
  80  102D
  81  102D              ; include the latest versions of the CF & DOS modules
  82  102D                  INCLUDE "../include/dos/bios-1.02.asm"
# file opened: ../include/dos/bios-1.02.asm
   1+ 102D              ; ------------------------------------------------------------------------------
   2+ 102D              ; LM80C 64K - BIOS ROUTINES - R1.02
   3+ 102D              ; ------------------------------------------------------------------------------
   4+ 102D              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 102D              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 102D              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 102D              ; kind of warranty: you can use them at your own risk.
   8+ 102D              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 102D              ; maintain the copyright notices, include this advice and the note to the
  10+ 102D              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 102D              ; redistribuite them.
  12+ 102D              ; https://www.leonardomiliani.com
  13+ 102D              ;
  14+ 102D              ; Please support me by visiting the following links:
  15+ 102D              ; Main project page: https://www.leonardomiliani.com
  16+ 102D              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 102D              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 102D              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 102D              ; ------------------------------------------------------------------------------
  20+ 102D              ;
  21+ 102D              ; ------------------------------------------------------------------------------
  22+ 102D              ; Code Revision:
  23+ 102D              ; R1.0  - 20210307 - first release
  24+ 102D              ; R1.01 - 20210310 - Code optimizing & better error handling
  25+ 102D              ; R1.02 - 2021xxxx - disk speed improvements with INIR and OTIR
  26+ 102D              ;
  27+ 102D              ;------------------------------------------------------------------------------
  28+ 102D
  29+ 102D              ; equates for CF at port $50
  30+ 102D              CF_DATA:        equ %01010000   ; ($50) Data register (R/W)
  31+ 102D              CF_ERR:         equ %01010001   ; ($51) Error (R)
  32+ 102D              CF_FTR:         equ %01010001   ; ($51) Features (W)
  33+ 102D              CF_SECCNT:      equ %01010010   ; ($52) Sector count register (R/W)
  34+ 102D              CF_LBA0:        equ %01010011   ; ($53) LBA register 0 (bits 0-7) (R/W)
  35+ 102D              CF_LBA1:        equ %01010100   ; ($54) LBA register 1 (bits 8-15) (R/W)
  36+ 102D              CF_LBA2:        equ %01010101   ; ($55) LBA register 2 (bits 16-23) (R/W)
  37+ 102D              CF_LBA3:        equ %01010110   ; ($56) LBA register 3 (bits 24-27) (R/W) - bits 28-31 must be set to 111 in LBA mode
  38+ 102D              CF_STAT:        equ %01010111   ; ($57) Status (R)
  39+ 102D              CF_CMD:         equ %01010111   ; ($57) Command register (W)
  40+ 102D
  41+ 102D
  42+ 102D              ;------------------------------------------------------------------------------
  43+ 102D              ; R O U T I N E S
  44+ 102D              ;------------------------------------------------------------------------------
  45+ 102D
  46+ 102D              ; initilialize CF to work with, wakeing it up from standby and setting it to work in 8-bit mode
  47+ 102D CD 43 10     CF_INIT:    call    CF_NOP          ; execute a NOP to wake up the CF
  48+ 1030 CD 91 10                 call    CR_DEV_RDY      ; wait for CF available and ready
  49+ 1033 D8                       ret     C               ; no card or I/O error, leave
  50+ 1034 3E 01                    ld      A,$01           ; 8-bit mode
  51+ 1036 D3 51                    out     (CF_FTR),A      ; set mode
  52+ 1038 CD 4C 10                 call    CF_BUSY         ; wait for CF being ready
  53+ 103B 3E EF                    ld      A,$EF           ; command to set mode
  54+ 103D D3 57                    out     (CF_CMD),A      ; execute command
  55+ 103F CD 4C 10                 call    CF_BUSY         ; wait for CF being ready
  56+ 1042 C9                       ret                     ; return to caller
  57+ 1043
  58+ 1043
  59+ 1043              ; a NOP command, just used to wake up the CF card
  60+ 1043 3E 69        CF_NOP:     ld      A,$69           ; NOP command
  61+ 1045 D3 51                    out     (CF_FTR),A      ; send it
  62+ 1047 3E EF                    ld      A,$EF           ; set mode command
  63+ 1049 D3 57                    out     (CF_CMD),A      ; execute NOP
  64+ 104B C9                       ret                     ; return to caller
  65+ 104C
  66+ 104C
  67+ 104C              ; wait until BUSY bit is 0 (means CF has executed the requested job)
  68+ 104C DB 57        CF_BUSY:    in      A,(CF_STAT)     ; read status register
  69+ 104E 07                       rlca                    ; copy bit #7 into the Carry
  70+ 104F DA 4C 10                 jp      C,CF_BUSY       ; loop while bit #7 is 1
  71+ 1052 C9                       ret                     ; bit #7 cleared - return to caller
  72+ 1053
  73+ 1053
  74+ 1053              ; check that CF is ready to get commands
  75+ 1053 DB 57        CF_CMDRDY:  in      A,(CF_STAT)     ; read status register
  76+ 1055 CB 47                    bit     0,A             ; any error?
  77+ 1057 20 07                    jr      NZ,RETERR       ; yes, return error
  78+ 1059 E6 C0                    and     %11000000       ; check only bits #6 & #7
  79+ 105B EE 40                    xor     %01000000       ; bit #7 (BUSY) must be 0 and bit #6 (DRVRDY) must be 1
  80+ 105D 20 F4                    jr      NZ,CF_CMDRDY    ; wait
  81+ 105F C9                       ret                     ; return to caller
  82+ 1060 37           RETERR:     scf                     ; set carry flag
  83+ 1061 C9                       ret                     ; return
  84+ 1062
  85+ 1062
  86+ 1062              ; wait until data is ready to be read
  87+ 1062 DB 57        CF_DAT_RDY: in      A,(CF_STAT)     ; read status register
  88+ 1064 CB 47                    bit     0,A             ; any error?
  89+ 1066 20 F8                    jr      NZ,RETERR       ; yes, return error
  90+ 1068 E6 88                    and     %10001000       ; check only bits #7 & #3
  91+ 106A EE 08                    xor     %00001000       ; bit #7 (BUSY) must be 0 and bit #3 (DRQ) must be 1
  92+ 106C 20 F4                    jr      NZ,CF_DAT_RDY   ; wait until data is ready
  93+ 106E C9                       ret                     ; return to caller
  94+ 106F
  95+ 106F
  96+ 106F              ; set sector to read from/write to - sector number is into DEBC (C=LSB, D=MSB)
  97+ 106F CD 53 10     CF_SETSTR:  call    CF_CMDRDY       ; Make sure drive is ready for command
  98+ 1072 3E 01                    ld      A,$01           ; 1 sector at a time
  99+ 1074 D3 52                    out     (CF_SECCNT),A   ; set number of sectors
 100+ 1076 CD 53 10                 call    CF_CMDRDY       ; Make sure drive is ready for command
 101+ 1079 79                       ld      A,C             ; load LBA0 byte
 102+ 107A D3 53                    out     (CF_LBA0),A     ; send it
 103+ 107C CD 53 10                 call    CF_CMDRDY       ; Make sure drive is ready for command
 104+ 107F 78                       ld      A,B             ; load LBA1 byte
 105+ 1080 D3 54                    out     (CF_LBA1),A     ; send it
 106+ 1082 CD 53 10                 call    CF_CMDRDY       ; Make sure drive is ready for command
 107+ 1085 7B                       ld      A,E             ; load LBA2 byte
 108+ 1086 D3 55                    out     (CF_LBA2),A     ; send it
 109+ 1088 CD 53 10                 call    CF_CMDRDY       ; Make sure drive is ready for command
 110+ 108B 3E E0                    ld      A,$E0           ; load LBA3 byte+master+LBA addressing
 111+ 108D B2                       or      D               ; add LBA sector
 112+ 108E D3 56                    out     (CF_LBA3),A     ; send it
 113+ 1090 C9                       ret                     ; return to caller
 114+ 1091
 115+ 1091
 116+ 1091              ; check if device is available & ready - try a bit of times, then exit with
 117+ 1091              ; error if no response, otherwise wait until device is ready
 118+ 1091              ; return Carry = 0 if device is available and ready, Carry = 1 if errors
 119+ 1091 C5           CR_DEV_RDY: push    BC              ; store HL
 120+ 1092 06 00                    ld      B,$00           ; 256 tries
 121+ 1094 0E 57                    ld      C,CF_STAT       ; address of status register
 122+ 1096 ED 78        CR_DV_RD_1: in      A,(C)           ; load status register (curiously, with no CF attached, in(CF_STAT) returns %01111000)
 123+ 1098 FE 40                    cp      %01000000       ; busy=0, rdy=1
 124+ 109A 28 07                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 125+ 109C FE 50                    cp      %01010000       ; busy=0, rdy=1, dsc=1
 126+ 109E 28 03                    jr      Z,CR_DV_RD_E    ; got a response, so leave
 127+ 10A0 10 F4                    djnz    CR_DV_RD_1      ; repeat until timeout (Carry=1 while HL<DE)
 128+ 10A2 37           CR_DV_ERR:  scf                     ; exit with Carry = 1 (device NOT ready)
 129+ 10A3 C1           CR_DV_RD_E: pop     BC              ; retrieve HL
 130+ 10A4 C9                       ret                     ; return to caller
 131+ 10A5
 132+ 10A5
 133+ 10A5              ; put the CF into stand-by mode
 134+ 10A5 3E E0        CF_STANDBY: ld 	    A,$E0   		; select CF as master, driver 0, LBA mode (bits #5-7=111)
 135+ 10A7 D3 56                    out 	(CF_LBA3),A     ; send configuration
 136+ 10A9 3E 92                    ld      A,$92           ; standby mode
 137+ 10AB D3 57                    out     (CF_CMD),A      ; send command
 138+ 10AD CD 4C 10                 call    CF_BUSY         ; wait for CF being ready
 139+ 10B0 C9                       ret                     ; return to caller
 140+ 10B1
 141+ 10B1
 142+ 10B1              ;***************************************************************************
 143+ 10B1              ; CF_RD_SEC
 144+ 10B1              ; Function: load a sector (512 bytes) into RAM buffer.
 145+ 10B1              ;***************************************************************************
 146+ 10B1 CD 53 10     CF_RD_SEC:  call    CF_CMDRDY       ; Make sure drive is ready for command
 147+ 10B4 D8                       ret     C               ; return if error
 148+ 10B5 3E 20                    ld      A,$20           ; Prepare read command
 149+ 10B7 D3 57                    out     (CF_CMD),A      ; Send read command
 150+ 10B9 CD 62 10                 call    CF_DAT_RDY      ; Wait until data is ready to be read
 151+ 10BC D8                       ret     C               ; return if error
 152+ 10BD DB 57                    in      A,(CF_STAT)     ; Read status
 153+ 10BF E6 01                    and     %00000001       ; mask off error bit
 154+ 10C1 C2 B1 10                 jp      NZ,CF_RD_SEC    ; Try again if error
 155+ 10C4              ; read CF buffer after it's been filled up by a previous command
 156+ 10C4              ; and store data into the I/O buffer
 157+ 10C4 C5           CF_RD_CMD:  push    BC              ; store BC
 158+ 10C5 E5                       push    HL              ; store HL
 159+ 10C6 CD 62 10                 call    CF_DAT_RDY	    ; wait for data from CF to be ready
 160+ 10C9 38 0A                    jr      C,CF_RD_EXIT    ; if error, leave
 161+ 10CB 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 162+ 10CE 2A 9A 81                 ld      HL,(IOBUFF)     ; get starting address of I/O buffer
 163+ 10D1 ED B2                    inir                    ; get 256 bytes
 164+ 10D3 ED B2                    inir                    ; get 256 bytes
 165+ 10D5 E1           CF_RD_EXIT: pop     HL              ; retrieve HL
 166+ 10D6 C1                       pop     BC              ; retrieve BC
 167+ 10D7 C9                       ret                     ; return to caller
 168+ 10D8
 169+ 10D8
 170+ 10D8              ;***************************************************************************
 171+ 10D8              ; CF_WR_SEC
 172+ 10D8              ; Function: write a sector to Compact Flash - sector address is into BCDE - source address is into HL
 173+ 10D8              ;***************************************************************************
 174+ 10D8 C5           CF_WR_SEC:  push    BC              ; store BC
 175+ 10D9 E5                       push    HL              ; store HL
 176+ 10DA CD 6F 10                 call    CF_SETSTR       ; set sector
 177+ 10DD CD 53 10                 call    CF_CMDRDY       ; Make sure drive is ready for command
 178+ 10E0 38 17                    jr      C,CF_WR_EXIT    ; return if error
 179+ 10E2 3E 30                    ld      A,$30           ; set write command
 180+ 10E4 D3 57                    out     (CF_CMD),A      ; send command
 181+ 10E6 CD 62 10                 call    CF_DAT_RDY      ; Make sure drive is ready to get data
 182+ 10E9 38 0E                    jr      C,CF_WR_EXIT    ; return if error
 183+ 10EB 2A 9A 81                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
 184+ 10EE 01 50 00                 ld      BC,CF_DATA      ; set 256 bytes per loop (B=$00) and CF port (C=CF_DATA)
 185+ 10F1 ED B3                    otir                    ; output 256 bytes
 186+ 10F3 ED B3                    otir                    ; output 256 bytes
 187+ 10F5 CD 4C 10                 call    CF_BUSY         ; wait for CF to complete the writing
 188+ 10F8 AF                       xor     A               ; clear Carry
 189+ 10F9 E1           CF_WR_EXIT: pop     HL              ; retrieve HL
 190+ 10FA C1                       pop     BC              ; retrieve BC
 191+ 10FB C9                       ret                     ; return to caller
 192+ 10FC
# file closed: ../include/dos/bios-1.02.asm
  83  10FC                  INCLUDE "../include/dos/dos-1.03.asm"
# file opened: ../include/dos/dos-1.03.asm
   1+ 10FC              ; ------------------------------------------------------------------------------
   2+ 10FC              ; LM80C 64K - DOS ROUTINES - R1.03
   3+ 10FC              ; ------------------------------------------------------------------------------
   4+ 10FC              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 10FC              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 10FC              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 10FC              ; kind of warranty: you can use them at your own risk.
   8+ 10FC              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 10FC              ; maintain the copyright notices, include this advice and the note to the
  10+ 10FC              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 10FC              ; redistribuite them.
  12+ 10FC              ; https://www.leonardomiliani.com
  13+ 10FC              ;
  14+ 10FC              ; Please support me by visiting the following links:
  15+ 10FC              ; Main project page: https://www.leonardomiliani.com
  16+ 10FC              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 10FC              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 10FC              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 10FC              ; ------------------------------------------------------------------------------
  20+ 10FC              ;
  21+ 10FC              ; ------------------------------------------------------------------------------
  22+ 10FC              ; Code Revision:
  23+ 10FC              ; R1.0  - 20210306 - first release
  24+ 10FC              ; R1.01 - 20210309 - code cleaning & optimization - new behaviour for ERASE (full erase everything)
  25+ 10FC              ; R1.02 - 20210310 - code optimization - new UNDELETE feature for DISK statement
  26+ 10FC              ; R1.03 - 2021xxxx - code size enhancements
  27+ 10FC              ;
  28+ 10FC              ;------------------------------------------------------------------------------
  29+ 10FC
  30+ 10FC
  31+ 10FC 4C 4D 38 30  DFSCT0      defb    "LM80C DOS",$00,"1.03",$00     ; disk header
  31+ 1100 43 20 44 4F
  31+ 1104 53 00 31 2E
  31+ 1108 30 33 00
  32+ 110B 00 01        DSKDIRADR:  defb    $00,$01                         ; 1st sector of directory ($0001)
  33+ 110D
  34+ 110D              DIR_STRT:   equ     TMPDBF          ; (2) start of directory
  35+ 110D              DAT_STRT:   equ     DIR_STRT+$02    ; (2) start of DATA area
  36+ 110D              DIR_SCT:    equ     DAT_STRT+$02    ; (2) sector of first free entry in the directory
  37+ 110D              NTR_NBR:    equ     DIR_SCT+$02     ; (2) number of free entry
  38+ 110D              BYT_SIZ:    equ     NTR_NBR+$02     ; (2) file size in bytes
  39+ 110D              SCT_SIZ:    equ     BYT_SIZ+$02     ; (1) file size in sectors
  40+ 110D              MSW_SCT:    equ     SCT_SIZ+$01     ; (2) MSW sector of file
  41+ 110D              LSW_SCT:    equ     MSW_SCT+$02     ; (2) LSW sector of file
  42+ 110D              RAM_PTR:    equ     LSW_SCT+$02     ; (2) pointer to RAM
  43+ 110D              TPBF1:      equ     RAM_PTR+$02     ; (2) temp. word
  44+ 110D              TPBF2:      equ     TPBF1+$02       ; (2) temp. word
  45+ 110D              TPBF3:      equ     TPBF2+$02       ; (2) temp. word
  46+ 110D              TPBF4:      equ     TPBF3+$02       ; (2) temp. word
  47+ 110D              SRTMEM:     equ     TPBF4+$02       ; (2) temp. word
  48+ 110D              ENDMEM:     equ     SRTMEM+$02      ; (2) temp. word
  49+ 110D
  50+ 110D
  51+ 110D              ; *****************************************************************************
  52+ 110D              ; D I S K    I N I T
  53+ 110D              ; Functions: format a disk creating a fresh new file system on disk or
  54+ 110D              ;            rewrite only the Master Sector
  55+ 110D              ; *****************************************************************************
  56+ 110D 3A B4 81     DSK_INIT:   ld      A,(TPBF4)       ; load type of formatting
  57+ 1110 32 06 82                 ld      (TMPBFR1),A     ; save onto another location for later use
  58+ 1113 CD E9 18                 call    CLRIOBF         ; clear I/O buffer
  59+ 1116 CD FE 18                 call    CLRDOSBF        ; clear DOS buffer
  60+ 1119 3E E0                    ld 	    A,$E0   		; select CF as master, driver 0, LBA mode (bits #5-7=111)
  61+ 111B D3 56                    out 	(CF_LBA3),A     ; send configuration
  62+ 111D 3E EC                    ld      A,$EC           ; select "drive ID" command
  63+ 111F D3 57                    out     (CF_CMD),A      ; send command
  64+ 1121 CD 62 10                 call	CF_DAT_RDY      ; wait until data is ready to be read
  65+ 1124 CD C4 10                 call	CF_RD_CMD       ; read data and store into I/O buffer
  66+ 1127 ED 5B 98 81              ld      DE,(DOSBFR)     ; address of default conf. buffer
  67+ 112B 2A 9A 81                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
  68+ 112E 01 0E 00                 ld      BC,$000E        ; position of current disk size in sectors
  69+ 1131 09                       add     HL,BC           ; set into HL
  70+ 1132 0E 04                    ld      C,$04           ; 4 bytes to copy
  71+ 1134 ED B0                    ldir                    ; copy (DE is auto-incremented)
  72+ 1136 2A 9A 81                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
  73+ 1139 01 02 00                 ld      BC,$0002        ; 2 bytes to copy and also address of number of cylinders
  74+ 113C 09                       add     HL,BC           ; get position of data
  75+ 113D ED B0                    ldir                    ; copy (DE is auto-incremented)
  76+ 113F 2A 9A 81                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
  77+ 1142 01 0C 00                 ld      BC,$000C        ; address of number of sectors per cylinder
  78+ 1145 09                       add     HL,BC           ; get position of data
  79+ 1146 0E 02                    ld      C,$02           ; 2 bytes to copy
  80+ 1148 ED B0                    ldir                    ; copy (DE is auto-incremented)
  81+ 114A 2A 9A 81                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
  82+ 114D 01 06 00                 ld      BC,$0006        ; address of number of heads
  83+ 1150 09                       add     HL,BC           ; get position of data
  84+ 1151 0E 02                    ld      C,$02           ; 2 bytes to copy
  85+ 1153 ED B0                    ldir                    ; copy (DE is auto-incremented)
  86+ 1155                          ; now we calculate the # of files allowed (1 file = 1 block = 64K)
  87+ 1155 ED 53 B4 81              ld      (TPBF4),DE      ; store current pointer to temp. default conf. buffer
  88+ 1159 2A 98 81                 ld      HL,(DOSBFR)     ; load number of sectors
  89+ 115C 4E                       ld      C,(HL)          ; MSW into AC
  90+ 115D 23                       inc     HL
  91+ 115E 7E                       ld      A,(HL)
  92+ 115F 23                       inc     HL
  93+ 1160 5E                       ld      E,(HL)          ; LSW into DE
  94+ 1161 23                       inc     HL
  95+ 1162 56                       ld      D,(HL)
  96+ 1163 D5                       push    DE              ; move DE into IX
  97+ 1164 DD E1                    pop     IX
  98+ 1166 11 80 00                 ld      DE,$0080        ; 128 sectors per block
  99+ 1169 CD CC 4D                 call    DIV_32_16       ; execute ACIX/DE; result is into ACIX, remainder into HL
 100+ 116C 47                       ld      B,A             ; now result is into BCIX
 101+ 116D B1                       or      C               ; BC=$0000?
 102+ 116E 28 05                    jr      Z,DOS_FTC       ; yes, but.....
 103+ 1170 11 FF FF                 ld      DE,$FFFF        ; ... no more than $FFFF files, so set limit
 104+ 1173 18 0E                    jr      DOS_FT1         ; jump over
 105+ 1175 DD E5        DOS_FTC:    push    IX              ; move IX into DE
 106+ 1177 D1                       pop     DE              ; now result is into BCDE
 107+ 1178 7C                       ld      A,H             ; remainder = zero?
 108+ 1179 B5                       or      L
 109+ 117A CA 83 11                 jp      Z,DOS_FT1       ; yes, jump over
 110+ 117D 13                       inc     DE              ; no, increment DE
 111+ 117E 7A                       ld      A,D             ; check if DE is zero
 112+ 117F B3                       or      E
 113+ 1180 20 01                    jr      NZ,DOS_FT1      ; no, jump over
 114+ 1182 1B           DOS_FT0:    dec     DE              ; yes, so set files to limit of $FFFF
 115+ 1183 2A B4 81     DOS_FT1:    ld      HL,(TPBF4)      ; retrieve current pointer to temp. def. conf. buffer
 116+ 1186 CD 7C 18                 call    DE2HL           ; store # of entries
 117+ 1189 D5                       push    DE              ; store entries
 118+ 118A EB                       ex      DE,HL           ; copy current pointer into DE
 119+ 118B 21 0B 11                 ld      HL,DSKDIRADR    ; address of directory start
 120+ 118E 01 02 00                 ld      BC,$0002        ; 2 bytes to copy
 121+ 1191 ED B0                    ldir                    ; copy into buffer
 122+ 1193                          ; now we calculate the starting sector of data area
 123+ 1193 E1                       pop     HL              ; entries into HL
 124+ 1194 0E 10                    ld      C,$10           ; 16 entries per sector
 125+ 1196 CD A8 4D                 call    DIV_16_8        ; calculare how many sectors for dir (HL/C)
 126+ 1199 B7                       or      A               ; remainder = 0?
 127+ 119A 28 01                    jr      Z,DOS_FT2       ; yes, jump over
 128+ 119C 23                       inc     HL              ; increment sectors
 129+ 119D E5           DOS_FT2:    push    HL              ; store size of directory
 130+ 119E FD E1                    pop     IY              ; into IY
 131+ 11A0 23                       inc     HL              ; data area is 1 sector bigger than directory's size
 132+ 11A1 EB                       ex      DE,HL           ; restore pointer into HL, and move sectors into DE
 133+ 11A2 73                       ld      (HL),E          ; store starting of
 134+ 11A3 23                       inc     HL              ; data area
 135+ 11A4 72                       ld      (HL),D          ; into buffer
 136+ 11A5                          ; now clean again the I/O buffer and copy the configuration into I/O buffer
 137+ 11A5 CD E9 18                 call    CLRIOBF         ; clear I/O buffer
 138+ 11A8 21 FC 10                 ld      HL,DFSCT0       ; address of disk header string
 139+ 11AB ED 5B 9A 81              ld      DE,(IOBUFF)     ; address of I/O buffer
 140+ 11AF 01 0F 00                 ld      BC,$000F        ; 15 chars
 141+ 11B2 ED B0                    ldir                    ; copy header into buffer
 142+ 11B4 2A 98 81                 ld      HL,(DOSBFR)     ; first part of configuration
 143+ 11B7 01 10 00                 ld      BC,$0010        ; composed by 16 chars
 144+ 11BA ED B0                    ldir                    ; copy (DE is auto-incremented)
 145+ 11BC AF                       xor     A               ; A=$0
 146+ 11BD 12                       ld      (DE),A          ; marker at $1F
 147+ 11BE 13                       inc     DE
 148+ 11BF CD 54 18                 call    CHKNMVAL        ; copy disk name into buffer
 149+ 11C2 DA 81 12                 jp      C,D1ERR         ; disk name error
 150+ 11C5 CD DC 17     DOS_FT5:    call    RND_ID          ; generate a semi-random disk ID
 151+ 11C8 2A 9A 81                 ld      HL,(IOBUFF)     ; get starting address of I/O buffer
 152+ 11CB 54                       ld      D,H             ; copy into DE...
 153+ 11CC 5D                       ld      E,L             ; ...for later use
 154+ 11CD 01 FE 01                 ld      BC,$01FE        ; get address of last 2 bytes...
 155+ 11D0 09                       add     HL,BC           ; ...of the I/O buffer
 156+ 11D1 3E 38                    ld      A,'8'           ; write marker "80"
 157+ 11D3 77                       ld      (HL),A          ; ...
 158+ 11D4 23                       inc     HL              ; ...
 159+ 11D5 3E 30                    ld      A,'0'           ; ...
 160+ 11D7 77                       ld      (HL),A          ; ...into last 2 locations
 161+ 11D8 EB                       ex      DE,HL           ; copy beginning of I/O buffer from DE into HL
 162+ 11D9 AF                       xor     A               ; reset A - set sector # to $00000000
 163+ 11DA 47                       ld      B,A             ; LBA0=0
 164+ 11DB 4F                       ld      C,A             ; LBA1=0
 165+ 11DC 57                       ld      D,A             ; LBA2=0
 166+ 11DD 5F                       ld      E,A             ; LBA3=0
 167+ 11DE CD D8 10                 call    CF_WR_SEC       ; write sector to CF
 168+ 11E1 DA 64 12                 jp      C,D2ERR
 169+ 11E4                          ; check if only re-writing of Master Sector was need
 170+ 11E4 3A 06 82                 ld      A,(TMPBFR1)     ; retrieve type of formatting
 171+ 11E7 3D                       dec     A               ; A=1?
 172+ 11E8 C8                       ret     Z               ; yes, finished job
 173+ 11E9                          ; erase directory -----------------------------
 174+ 11E9                          ; create a progress bar
 175+ 11E9 3E 0D                    ld      A,CR            ; no, full format - go to new line
 176+ 11EB CD CD 23                 call    OUTC
 177+ 11EE FD E5                    push    IY              ; copy directory's size...
 178+ 11F0 E1                       pop     HL              ; ...into HL
 179+ 11F1 01 18 00                 ld      BC,$0018        ; 24 steps
 180+ 11F4 CD A8 4D                 call    DIV_16_8        ; calculate HL/24 (remainder is ignored, here)
 181+ 11F7 E5                       push    HL              ; store result...
 182+ 11F8 DD E1                    pop     IX              ; ...into IX...
 183+ 11FA EB                       ex      DE,HL           ; ...and into DE
 184+ 11FB 3E 2D                    ld      A,'-'           ; print a progress bar
 185+ 11FD CD 39 12                 call    DOS_FT7         ; print it
 186+ 1200 3E 1C                    ld      A,CRSLFT        ; CURSOR left
 187+ 1202 CD 39 12                 call    DOS_FT7         ; come back to beginning of line
 188+ 1205 FD E5                    push    IY              ; copy directory's size
 189+ 1207 E1                       pop     HL              ; into HL
 190+ 1208 01 01 00                 ld      BC,$0001        ; first sector of directory
 191+ 120B CD E9 18                 call    CLRIOBF         ; clear I/O buffer
 192+ 120E D5           DOS_FTA:    push    DE              ; store counter
 193+ 120F 11 00 00                 ld      DE,$0000        ; reset MSW of sector pointer
 194+ 1212 CD D8 10                 call    CF_WR_SEC       ; write sector to CF
 195+ 1215 DA 35 12                 jp      C,DOS_FT10      ; error occured
 196+ 1218 03                       inc     BC              ; next sector
 197+ 1219 2B                       dec     HL              ; decrement HL
 198+ 121A D1                       pop     DE              ; retrieve counter
 199+ 121B 1B                       dec     DE              ; decrement counter
 200+ 121C 7B                       ld      A,E
 201+ 121D B2                       or      D               ; check if counter is zero
 202+ 121E 20 08                    jr      NZ,DOS_FT9      ; no, jump over
 203+ 1220 3E 2A                    ld      A,'*'           ; yes, print char
 204+ 1222 CD CD 23                 call    OUTC
 205+ 1225 DD E5                    push    IX              ; re-set counter
 206+ 1227 D1                       pop     DE
 207+ 1228 7C           DOS_FT9:    ld      A,H             ; check if...
 208+ 1229 B5                       or      L               ; ...HL = 0
 209+ 122A 20 E2                    jr      NZ,DOS_FTA      ; if not, repeat
 210+ 122C 3E 0D                    ld      A,CR            ; return
 211+ 122E CD CD 23                 call    OUTC            ; next line
 212+ 1231 CD A5 10                 call    CF_STANDBY      ; set CF into stand-by mode
 213+ 1234 C9                       ret
 214+ 1235 D1           DOS_FT10:   pop     DE
 215+ 1236 C3 64 12                 jp      D2ERR           ; disk geometry error
 216+ 1239
 217+ 1239              ; print a char 24 times
 218+ 1239 06 18        DOS_FT7:    ld      B,$18           ; 24 times
 219+ 123B CD CD 23     DOS_FT8:    call    OUTC            ; print char
 220+ 123E 10 FB                    djnz    DOS_FT8         ; repeat
 221+ 1240 C9                       ret                     ; return to caller
 222+ 1241
 223+ 1241
 224+ 1241              ; *****************************************************************************
 225+ 1241              ; D I S K    R E N A M E
 226+ 1241              ;******************************************************************************
 227+ 1241 CD E9 18     DSK_RNM:    call    CLRIOBF         ; clear I/O buffer
 228+ 1244 CD FE 18                 call    CLRDOSBF        ; clear DOS buff.
 229+ 1247 CD D0 17                 call    LDMSCT          ; load Master Sector
 230+ 124A 2A 9A 81                 ld      HL,(IOBUFF)     ; point to start of I/O buffer
 231+ 124D 01 20 00                 ld      BC,$0020        ; offset for disk name
 232+ 1250 09                       add     HL,BC           ; get pointer
 233+ 1251 EB                       ex      DE,HL           ; copy pointer into DE
 234+ 1252 CD 54 18                 call    CHKNMVAL        ; copy disk name into buffer
 235+ 1255 DA 81 12                 jp      C,D1ERR         ; disk name error
 236+ 1258 11 00 00                 ld      DE,$0000        ; reset MSW sector
 237+ 125B 42                       ld      B,D             ; reset LSW sector
 238+ 125C 4A                       ld      C,D
 239+ 125D CD D8 10                 call    CF_WR_SEC       ; write sector
 240+ 1260 DA C8 16                 jp      C,WRT_ERR       ; error?
 241+ 1263 C9                       ret                     ; no, return to caller
 242+ 1264
 243+ 1264
 244+ 1264              ; *****************************************************************************
 245+ 1264              ; DOS ERRORS
 246+ 1264              ; *****************************************************************************
 247+ 1264 3E 3C        D2ERR:      ld      A,D2            ; disk geometry error
 248+ 1266 18 1B                    jr      RET_ERR
 249+ 1268 3E 42        DSKFULL:    ld      A,D5            ; disk full error
 250+ 126A 18 17                    jr      RET_ERR
 251+ 126C 3E 44        DUPLERR:    ld      A,D6            ; duplicate file name
 252+ 126E 18 13                    jr      RET_ERR
 253+ 1270 3E 3A        NAMERR:     ld      A,D1            ; file name error
 254+ 1272 18 0F                    jr      RET_ERR
 255+ 1274 3E 48        FLNTFND:    ld      A,D8            ; file not found
 256+ 1276 18 0B                    jr      RET_ERR
 257+ 1278 3E 40        LODERR:     ld      A,D4            ; generic load error
 258+ 127A 18 07                    jr      RET_ERR
 259+ 127C 3E 46        DOSVERSERR: ld      A,D7            ; DOS version error
 260+ 127E C3 83 12                 jp      RET_ERR
 261+ 1281 3E 3A        D1ERR:      ld      A,D1            ; name string error
 262+ 1283 32 9C 81     RET_ERR:    ld      (DOSER),A       ; store DOS error
 263+ 1286 CD A5 10                 call    CF_STANDBY      ; set CF into stand-by
 264+ 1289 37                       scf                     ; set Carry for error
 265+ 128A C9                       ret                     ; return to caller
 266+ 128B
 267+ 128B              ; *****************************************************************************
 268+ 128B              ; L I S T    F I L E S
 269+ 128B              ; Function: print details of disk and list files
 270+ 128B              ; Input: D: $00=only disk details; $01=file list, too
 271+ 128B              ; *****************************************************************************
 272+ 128B 44 69 73 6B  DSKNMTX:    defb    "Disk name: ",0
 272+ 128F 20 6E 61 6D
 272+ 1293 65 3A 20 00
 273+ 1297 0D 53 65 63  TLSCTTX:    defb    CR,"Sectors: ",0
 273+ 129B 74 6F 72 73
 273+ 129F 3A 20 00
 274+ 12A2 0D 41 6C 6C  ALFLSTXT:   defb    CR,"Allowed files: ",0
 274+ 12A6 6F 77 65 64
 274+ 12AA 20 66 69 6C
 274+ 12AE 65 73 3A 20
 274+ 12B2 00
 275+ 12B3 20 66 69 6C  TLFLSTX:    defb    " file(s)",CR,0
 275+ 12B7 65 28 73 29
 275+ 12BB 0D 00
 276+ 12BD CD 1C 18     LST_FILES:  call    CHKDSKVAL       ; check DOS version & load disk details
 277+ 12C0 DA 7C 12                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 278+ 12C3 D5                       push    DE              ; store D
 279+ 12C4 CD D0 17                 call    LDMSCT          ; load Master Sector
 280+ 12C7 21 8B 12                 ld      HL,DSKNMTX      ; pointer to "Disk name" message
 281+ 12CA CD A4 2F                 call    PRS             ; print it
 282+ 12CD 2A 9A 81                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
 283+ 12D0 11 20 00                 ld      DE,$0020        ; position of disk name
 284+ 12D3 19                       add     HL,DE           ; get address
 285+ 12D4 06 10                    ld      B,$10           ; 16 chars
 286+ 12D6 7E           INPR1:      ld      A,(HL)          ; load char
 287+ 12D7 CD CD 23                 call    OUTC            ; print it
 288+ 12DA 23                       inc     HL
 289+ 12DB 10 F9                    djnz    INPR1           ; repeat
 290+ 12DD 3E 0D                    ld      A,CR
 291+ 12DF CD CD 23                 call    OUTC            ; carriage return
 292+ 12E2 DD 21 00 00              ld      IX,$0000        ; reset file counter (for use in formatting)
 293+ 12E6 D1                       pop     DE              ; retrieve D
 294+ 12E7 7A                       ld      A,D
 295+ 12E8 B7                       or      A               ; is D=0?
 296+ 12E9 CA 95 13                 jp      Z,PNTSTATS      ; yes, jump over
 297+ 12EC                          ; print list of files
 298+ 12EC 2A 9A 81                 ld      HL,(IOBUFF)     ; start of I/O buffer
 299+ 12EF 11 0F 00                 ld      DE,$000F        ; point to details of disk
 300+ 12F2 19                       add     HL,DE           ; find address
 301+ 12F3 ED 5B 98 81              ld      DE,(DOSBFR)     ; store into DOS buffer
 302+ 12F7 01 20 00                 ld      BC,$0020        ; 32 bytes
 303+ 12FA ED B0                    ldir                    ; copy
 304+ 12FC CD C1 17                 call    LDENTRIES       ; load entries
 305+ 12FF FD 2A A3 81              ld      IY,(NTR_NBR)    ; load max entries
 306+ 1303 D9                       exx
 307+ 1304 01 00 00                 ld      BC,$0000        ; reset file counter
 308+ 1307 D9                       exx
 309+ 1308 CD 88 17                 call    SETPTEN         ; point to 1st sector of dir
 310+ 130B CD 90 17     LSTFILES1:  call    PT2FSEN         ; point to 1st entry of a dir's sect
 311+ 130E CD 9B 17     LSTFILES2:  call    CKCREN          ; check current entry
 312+ 1311 28 5C                    jr      Z,LSTFILES6     ; if empty or deleted, ignore it
 313+ 1313 C5                       push    BC              ; this is a valid entry - so, store BC (LSW of sect)
 314+ 1314 FD E5                    push    IY              ; store IY (entries counter)
 315+ 1316 E5                       push    HL              ; store HL (sect entry counter)
 316+ 1317 D5                       push    DE              ; store DE (MSW of sector)
 317+ 1318 DD E5                    push    IX              ; store IX (pointer to first byte of entry)
 318+ 131A 06 10                    ld      B,$10           ; 16 chars to read and print
 319+ 131C DD 7E 00     LSTFILES3:  ld      A,(IX)          ; load char from name
 320+ 131F CD CD 23                 call    OUTC            ; print char
 321+ 1322 DD 23                    inc     IX              ; next char
 322+ 1324 10 F6                    djnz    LSTFILES3       ; repeat
 323+ 1326 3E 20                    ld      A,SPC
 324+ 1328 CD CD 23                 call    OUTC            ; print space
 325+ 132B DD 7E 00                 ld      A,(IX)          ; file type
 326+ 132E D6 80                    sub     $80             ; types start from $80
 327+ 1330 B7                       or      A               ; BAS type ($00)?
 328+ 1331 20 05                    jr      NZ,LSTFILES20   ; no, jump over
 329+ 1333 21 D9 13                 ld      HL,FILETP       ; print "BAS"
 330+ 1336 18 0B                    jr      LSTFILESPR
 331+ 1338 3D           LSTFILES20: dec     A               ; BIN type ($01)?
 332+ 1339 20 05                    jr      NZ,LSTFILES21   ; no, jump over
 333+ 133B 21 DE 13                 ld      HL,FILETP+5     ; print "BIN"
 334+ 133E 18 03                    jr      LSTFILESPR
 335+ 1340 21 E3 13     LSTFILES21: ld      HL,FILETP+10    ; print "???"
 336+ 1343 CD A4 2F     LSTFILESPR: call    PRS
 337+ 1346 01 08 00                 ld      BC,$0008
 338+ 1349 DD 09                    add     IX,BC           ; point to file size in bytes
 339+ 134B DD 4E 00                 ld      C,(IX)          ; load size in BC, first LSW
 340+ 134E DD 23                    inc     IX
 341+ 1350 DD 46 00                 ld      B,(IX)          ; then MSW
 342+ 1353 C5                       push    BC              ; copy...
 343+ 1354 DD E1                    pop     IX              ; ...into IX
 344+ 1356 11 00 00                 ld      DE,$0000        ; reset DE
 345+ 1359 FD E5                    push    IY
 346+ 135B CD 8F 18                 call    PRN16ASCIX      ; print size in bytes (DEIX)
 347+ 135E FD E1                    pop     IY
 348+ 1360 3E 0D                    ld      A,CR
 349+ 1362 CD CD 23                 call    OUTC            ; print carriage return
 350+ 1365 D9                       exx                     ; set shadow registers
 351+ 1366 03                       inc     BC              ; increment file counter
 352+ 1367 D9                       exx                     ; restore main registers
 353+ 1368 DD E1                    pop     IX              ; retrieve IX
 354+ 136A D1                       pop     DE              ; retrieve DE
 355+ 136B E1                       pop     HL              ; retrieve HL
 356+ 136C FD E1                    pop     IY              ; retrieve IY
 357+ 136E C1                       pop     BC              ; retrieve BC
 358+ 136F CD 36 26     LSTFILES6:  call    TSTBRK          ; Test for break key
 359+ 1372 CD 39 25                 call    TSTSPC          ; test for space
 360+ 1375 CD A3 17                 call    GTNXTEN         ; other entries in this sector?
 361+ 1378 20 94                    jr      NZ,LSTFILES2    ; yes, continue check
 362+ 137A CD AF 17     LSTFILES5:  call    CKLSTEN         ; go to next sector
 363+ 137D D2 0B 13                 jp      NC,LSTFILES1    ; more entries? repeat
 364+ 1380 D9                       exx                     ; set shadow registers
 365+ 1381 C5                       push    BC              ; store file counter
 366+ 1382 D9                       exx                     ; restore main registers
 367+ 1383 DD E1                    pop     IX              ; retrieve file counter
 368+ 1385 DD E5                    push    IX              ; store it again
 369+ 1387 11 00 00                 ld      DE,$0000        ; reset DE
 370+ 138A CD 8F 18                 call    PRN16ASCIX      ; print number of files from DEIX
 371+ 138D 21 B3 12                 ld      HL,TLFLSTX
 372+ 1390 CD A4 2F                 call    PRS             ; print "file(s)"
 373+ 1393 DD E1                    pop     IX
 374+ 1395 21 97 12     PNTSTATS:   ld      HL,TLSCTTX      ; Point to message "Tot. sectors"
 375+ 1398 CD A4 2F                 call    PRS             ; print message
 376+ 139B 2A 98 81                 ld      HL,(DOSBFR)     ; reload address of I/O buffer and point to disk size
 377+ 139E DD E5                    push    IX
 378+ 13A0 CD 86 18                 call    PRN32ASCII      ; print size
 379+ 13A3 3E 2F                    ld      A,'/'
 380+ 13A5 CD CD 23                 call    OUTC            ; print a "/""
 381+ 13A8 D1                       pop     DE              ; copy number of entries into DE
 382+ 13A9 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
 383+ 13AC CD 72 4D                 call    MUL_U32         ; multiply BC times DE: returns DEHL
 384+ 13AF ED 53 AE 81              ld      (TPBF1),DE      ; store results
 385+ 13B3 22 B0 81                 ld      (TPBF2),HL
 386+ 13B6 21 AE 81                 ld      HL,TPBF1        ; print results
 387+ 13B9 CD 86 18                 call    PRN32ASCII
 388+ 13BC 21 A2 12                 ld      HL,ALFLSTXT     ; Point to message "Allowed files"
 389+ 13BF CD A4 2F                 call    PRS             ; print message
 390+ 13C2 2A 98 81                 ld      HL,(DOSBFR)     ; reload address of I/O buffer
 391+ 13C5 01 0A 00                 ld      BC,$000A        ; address of allowed files
 392+ 13C8 09                       add     HL,BC           ; find pointer
 393+ 13C9 11 00 00                 ld      DE,$0000        ; MSW set to $0000
 394+ 13CC CD 89 18                 call    PRN16ASCII      ; print max files
 395+ 13CF 3E 0D                    ld      A,CR
 396+ 13D1 CD CD 23                 call    OUTC            ; print a carriage return
 397+ 13D4 CD A5 10     EXITFLS:    call    CF_STANDBY      ; put CF into standby
 398+ 13D7 AF                       xor     A               ; clear Carry flag
 399+ 13D8 C9                       ret                     ; return to caller
 400+ 13D9 42 41 53 20  FILETP:     defb    "BAS ",0        ; BASIC type
 400+ 13DD 00
 401+ 13DE 42 49 4E 20              defb    "BIN ",0        ; BINARY type
 401+ 13E2 00
 402+ 13E3 3F 3F 3F 20              defb    "??? ",0        ; unkown
 402+ 13E7 00
 403+ 13E8
 404+ 13E8
 405+ 13E8              ; *****************************************************************************
 406+ 13E8              ; S A V E    F I L E
 407+ 13E8              ; save current BASIC program onto a file
 408+ 13E8              ; *****************************************************************************
 409+ 13E8 CD 79 15     SAVFILE:    call    CHKFLEXT        ; file already exists?
 410+ 13EB DA 6C 12                 jp      C,DUPLERR       ; name is present - error
 411+ 13EE CD 60 17                 call    FNDFRENTR       ; find a free entry in the directory
 412+ 13F1 DA 68 12                 jp      C,DSKFULL       ; no entry, disk full error
 413+ 13F4 3A B4 81                 ld      A,(TPBF4)       ; check what to save
 414+ 13F7 FE 80                    cp      $80             ; BASIC program?
 415+ 13F9 C2 08 14                 jp      NZ,SAVFL3       ; no, jump over
 416+ 13FC                          ; BASIC area to save starts at PROGND and ends at (PROGND)
 417+ 13FC 2A 4C 82                 ld      HL,(PROGND)     ; load end of BASIC program <- WARNING: pay attention to (PROGND) and PROGND
 418+ 13FF 11 4C 82                 ld      DE,PROGND       ; start of RAM to be saved  <- WARNING: pay attention to (PROGND) and PROGND
 419+ 1402 ED 53 B6 81              ld      (SRTMEM),DE     ; copy DE
 420+ 1406 18 08                    jr      SAVFL1
 421+ 1408 2A B8 81     SAVFL3:     ld      HL,(ENDMEM)     ; save a portion of memory: HL <= end of portion
 422+ 140B 23                       inc     HL              ; we always need 1 more byte to store the portion of memory
 423+ 140C ED 5B B6 81              ld      DE,(SRTMEM)     ; DE <= start of portion
 424+ 1410                          ; compute how many sectors/blocks are needed to save file
 425+ 1410 AF           SAVFL1:     xor     A               ; reset Carry
 426+ 1411 ED 52                    sbc     HL,DE           ; get how many bytes to save
 427+ 1413 22 A5 81                 ld      (BYT_SIZ),HL    ; store into memory
 428+ 1416 11 00 02                 ld      DE,$0200        ; 512 bytes per sector
 429+ 1419 7C                       ld      A,H             ; move lenght...
 430+ 141A 4D                       ld      C,L             ; ...into AC
 431+ 141B CD B7 4D                 call    DIV_16_16       ; lenght/512 = nbr. of sectors: quotient in AC but A will be discarded
 432+ 141E 7C                       ld      A,H             ; check if...
 433+ 141F B5                       or      L               ; ...remainder (HL) is 0
 434+ 1420 28 01                    jr      Z,SAVFL6        ; yes, jump over
 435+ 1422 03                       inc     BC              ; no, so we need another sector
 436+ 1423 79           SAVFL6:     ld      A,C
 437+ 1424 32 A7 81                 ld      (SCT_SIZ),A     ; store into memory
 438+ 1427              SAVFL7:     ; start saving on disk
 439+ 1427 11 00 00                 ld      DE,$0000        ; directory is always from sector 0000-0001
 440+ 142A ED 4B A1 81              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
 441+ 142E CD 6F 10                 call    CF_SETSTR       ; set sector to read
 442+ 1431 CD B1 10                 call    CF_RD_SEC       ; read sector
 443+ 1434 3A A3 81                 ld      A,(NTR_NBR)     ; load entry number (ignoring MSB)
 444+ 1437 E6 0F                    and     %00001111       ; be sure to get only low nibble
 445+ 1439 87                       add     A,A             ; multiply...
 446+ 143A 87                       add     A,A             ; ...times 16 by...
 447+ 143B 87                       add     A,A             ; ...adding...
 448+ 143C 87                       add     A,A             ; ...4 times
 449+ 143D CB 27                    sla     A               ; left shift to multiply times 32 - Carry is set if results is > 255
 450+ 143F 5F                       ld      E,A             ; copy into C
 451+ 1440 CB 12                    rl      D               ; if Carry, then increment D (D was 0, see above)
 452+ 1442                          ; set name
 453+ 1442 2A 9A 81                 ld 	    HL,(IOBUFF)     ; get starting address of I/O buffer
 454+ 1445 19                       add     HL,DE           ; add offset to get address of entry
 455+ 1446 ED 5B 98 81              ld      DE,(DOSBFR)     ; pointer to file name
 456+ 144A 01 10 00                 ld      BC,$0010        ; 16 chars
 457+ 144D EB                       ex      DE,HL           ; move source into HL and destination into DE
 458+ 144E ED B0                    ldir                    ; copy file name
 459+ 1450 EB                       ex      DE,HL           ; move current buffer pointer into HL
 460+ 1451 3A B4 81                 ld      A,(TPBF4)       ; load the type of file
 461+ 1454 77                       ld      (HL),A          ; store it
 462+ 1455 23                       inc     HL
 463+ 1456 AF                       xor     A               ; file attributes - AT THE MOMENT, NO ATTRIBUTES
 464+ 1457 77                       ld      (HL),A
 465+ 1458 23                       inc     HL
 466+ 1459 ED 5B A3 81              ld      DE,(NTR_NBR)    ; reload entry number
 467+ 145D CD 7C 18                 call    DE2HL           ; store entry into buffer
 468+ 1460 E5                       push    HL              ; store pointer
 469+ 1461 01 80 00                 ld      BC,$0080        ; 128 sectors per entry block
 470+ 1464 CD 72 4D                 call    MUL_U32         ; multiply BC times DE: returns DEHL
 471+ 1467 ED 4B 9F 81              ld      BC,(DAT_STRT)   ; load start of data
 472+ 146B 09                       add     HL,BC           ; add sector of data area
 473+ 146C 30 01                    jr      NC,SAVFL9       ; overflow?
 474+ 146E 13                       inc     DE              ; yes, increment DE
 475+ 146F ED 53 A8 81  SAVFL9:     ld      (MSW_SCT),DE    ; store MSW of sector
 476+ 1473 22 AA 81                 ld      (LSW_SCT),HL    ; store LSW of sector
 477+ 1476 E1                       pop     HL              ; retrieve pointer
 478+ 1477 CD 7C 18                 call    DE2HL           ; also copy MSW of sector into entry
 479+ 147A ED 5B AA 81              ld      DE,(LSW_SCT)    ; retrieve LSW
 480+ 147E CD 7C 18                 call    DE2HL           ; also copy LSW of sector into entry
 481+ 1481 ED 5B A5 81              ld      DE,(BYT_SIZ)    ; retrieve file size in bytes
 482+ 1485 CD 7C 18                 call    DE2HL           ; copy file size into buffer
 483+ 1488 3A A7 81                 ld      A,(SCT_SIZ)     ; retrieve file size in sectors
 484+ 148B 77                       ld      (HL),A          ; copy into buffer
 485+ 148C 23                       inc     HL              ; next location
 486+ 148D ED 5B B6 81              ld      DE,(SRTMEM)     ; start of address of file in RAM
 487+ 1491 CD 7C 18                 call    DE2HL           ; copy into buffer
 488+ 1494 06 03                    ld      B,$03           ; remaining chars...
 489+ 1496 AF                       xor     A               ; ...set to $00
 490+ 1497 77           SAVFL2:     ld      (HL),A          ; reset byte
 491+ 1498 23                       inc     HL              ; next cell
 492+ 1499 10 FC                    djnz    SAVFL2          ; repeat
 493+ 149B                          ; save entry into directory
 494+ 149B 11 00 00                 ld      DE,$0000        ; block 0
 495+ 149E ED 4B A1 81              ld      BC,(DIR_SCT)    ; load sector of dir where to save file entry
 496+ 14A2 CD D8 10                 call    CF_WR_SEC       ; write new entry into directory
 497+ 14A5 DA 64 12                 jp      C,D2ERR         ; error occured
 498+ 14A8 CD E9 18                 call    CLRIOBF         ; clear I/O buffer
 499+ 14AB                          ; start saving RAM
 500+ 14AB ED 5B B6 81              ld      DE,(SRTMEM)     ; load start of RAM
 501+ 14AF ED 53 AC 81              ld      (RAM_PTR),DE    ; store
 502+ 14B3 CD E9 18     SAVFL10:    call    CLRIOBF         ; clear I/O buffer
 503+ 14B6 2A A5 81                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
 504+ 14B9 11 00 02                 ld      DE,$0200        ; are they < 512?
 505+ 14BC CD 4D 4D                 call    CMP16
 506+ 14BF 30 04                    jr      NC,SAVFL4       ; no, jump over
 507+ 14C1 ED 5B A5 81              ld      DE,(BYT_SIZ)    ; yes, so load remaining bytes
 508+ 14C5 4B           SAVFL4:     ld      C,E             ; bytes to copy
 509+ 14C6 42                       ld      B,D             ; into BC
 510+ 14C7 2A AC 81                 ld      HL,(RAM_PTR)    ; load pointer to RAM to be saved
 511+ 14CA ED 5B 9A 81              ld      DE,(IOBUFF)     ; load start of I/O buffer
 512+ 14CE ED B0                    ldir                    ; copy data
 513+ 14D0 ED 5B A8 81              ld      DE,(MSW_SCT)    ; load MSW of sector
 514+ 14D4 ED 4B AA 81              ld      BC,(LSW_SCT)    ; load LSW of sector
 515+ 14D8 CD D8 10                 call    CF_WR_SEC       ; write sector
 516+ 14DB DA C8 16                 jp      C,WRT_ERR       ; error?
 517+ 14DE 21 A7 81                 ld      HL,SCT_SIZ      ; sector counter
 518+ 14E1 35                       dec     (HL)            ; copied all the sectors?
 519+ 14E2 CA 11 15                 jp      Z,SAVFLEXT      ; yes, exit
 520+ 14E5 2A AC 81     SAVFL11:    ld      HL,(RAM_PTR)    ; pointer to RAM
 521+ 14E8 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
 522+ 14EB 19                       add     HL,DE           ; calculate next starting address
 523+ 14EC 22 AC 81                 ld      (RAM_PTR),HL    ; store next block
 524+ 14EF AF                       xor     A               ; reset Carry
 525+ 14F0 2A A5 81                 ld      HL,(BYT_SIZ)    ; load left bytes
 526+ 14F3 ED 52                    sbc     HL,DE           ; subtract copied bytes
 527+ 14F5 22 A5 81                 ld      (BYT_SIZ),HL    ; store left bytes
 528+ 14F8 ED 4B AA 81              ld      BC,(LSW_SCT)    ; load LSW of sector
 529+ 14FC 03                       inc     BC              ; next sector
 530+ 14FD 78                       ld      A,B             ; BC=$0000?
 531+ 14FE B1                       or      C
 532+ 14FF 20 09                    jr      NZ,SAVFL12      ; no, jump over
 533+ 1501 ED 5B A8 81              ld      DE,(MSW_SCT)    ; load MSW of sector
 534+ 1505 13                       inc     DE              ; increment DE
 535+ 1506 ED 53 A8 81              ld      (MSW_SCT),DE    ; store new MSW of sector
 536+ 150A ED 43 AA 81  SAVFL12:    ld      (LSW_SCT),BC    ; store new LSW of sector
 537+ 150E C3 B3 14                 jp      SAVFL10         ; repeat
 538+ 1511 CD A5 10     SAVFLEXT:   call    CF_STANDBY      ; set CF into stand-by mode
 539+ 1514 AF                       xor     A               ; clear Carry flag
 540+ 1515 C9                       ret                     ; return to caller
 541+ 1516
 542+ 1516
 543+ 1516              ; *****************************************************************************
 544+ 1516              ; C H A N G E    F I L E N A M E
 545+ 1516              ; change name to a file
 546+ 1516              ; *****************************************************************************
 547+ 1516 ED 5B A5 81  CHNGNAM:    ld      DE,(BYT_SIZ)    ; load lenght
 548+ 151A ED 53 0A 82              ld      (DKLNPT),DE     ; store it
 549+ 151E ED 5B AC 81              ld      DE,(RAM_PTR)    ; load address
 550+ 1522 ED 53 08 82              ld      (DKNMPT),DE     ; store it
 551+ 1526 CD 79 15                 call    CHKFLEXT        ; destination file already exists?
 552+ 1529 DA 6C 12                 jp      C,DUPLERR       ; file name already exists
 553+ 152C CD E9 18                 call    CLRIOBF         ; clear I/O buffer
 554+ 152F ED 5B 0C 82              ld      DE,(TMPBFR4)    ; load lenght
 555+ 1533 ED 53 0A 82              ld      (DKLNPT),DE     ; store it
 556+ 1537 ED 5B B6 81              ld      DE,(TPBF4+2)    ; load address
 557+ 153B ED 53 08 82              ld      (DKNMPT),DE     ; store it
 558+ 153F CD 96 15                 call    LK4FILE         ; look for file
 559+ 1542 D2 74 12                 jp      NC,FLNTFND      ; file not found error
 560+ 1545 ED 5B A5 81              ld      DE,(BYT_SIZ)    ; load lenght
 561+ 1549 ED 53 0A 82              ld      (DKLNPT),DE     ; store it
 562+ 154D ED 5B AC 81              ld      DE,(RAM_PTR)    ; load address
 563+ 1551 ED 53 08 82              ld      (DKNMPT),DE     ; store it
 564+ 1555 CD FE 18                 call    CLRDOSBF        ; clear DOS buffer
 565+ 1558 ED 5B 98 81              ld      DE,(DOSBFR)     ; DE set to beginning of DOS buffer
 566+ 155C CD 54 18                 call    CHKNMVAL        ; check and copy file name
 567+ 155F 2A 98 81                 ld      HL,(DOSBFR)     ; retrieve new name pointer
 568+ 1562 DD E5                    push    IX              ; copy dest. address...
 569+ 1564 D1                       pop     DE              ; ...into DE
 570+ 1565 01 10 00                 ld      BC,$0010        ; 16 chars to copy
 571+ 1568 ED B0                    ldir                    ; copy
 572+ 156A ED 5B B0 81              ld      DE,(TPBF2)      ; retrieve MSW of dir. sector
 573+ 156E ED 4B B2 81              ld      BC,(TPBF3)      ; retrieve LSW of dir. sector
 574+ 1572 CD D8 10                 call    CF_WR_SEC       ; write sector
 575+ 1575 CD A5 10                 call    CF_STANDBY      ; put CF in standby
 576+ 1578 C9                       ret                     ; return to caller
 577+ 1579
 578+ 1579
 579+ 1579              ; *****************************************************************************
 580+ 1579              ; C H E C K    F I L E    E X I S T A N C E
 581+ 1579              ; check if a file with the given name exists into dir
 582+ 1579              ; Carry set if duplicate
 583+ 1579              ; *****************************************************************************
 584+ 1579 CD E9 18     CHKFLEXT:   call    CLRIOBF         ; clear I/O
 585+ 157C CD 1C 18                 call    CHKDSKVAL       ; check DOS version & load disk details
 586+ 157F DA 7C 12                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 587+ 1582 CD C1 17                 call    LDENTRIES       ; load entries into RAM register NTR_NBR
 588+ 1585 CD 81 18                 call    HL2DE           ; get start of directory into DE
 589+ 1588 ED 53 9D 81              ld      (DIR_STRT),DE   ; store
 590+ 158C CD 81 18                 call    HL2DE           ; get start of data area into DE
 591+ 158F ED 53 9F 81              ld      (DAT_STRT),DE   ; store
 592+ 1593 C3 99 15                 jp      LK4FILE1        ; check for name already present in dir and return to caller
 593+ 1596
 594+ 1596
 595+ 1596              ; *****************************************************************************
 596+ 1596              ; L O O K    F O R    A    F I L E
 597+ 1596              ; look for the given file into the dir
 598+ 1596              ; Carry is reset if not found, set otherwise
 599+ 1596              ; *****************************************************************************
 600+ 1596 CD C1 17     LK4FILE:    call    LDENTRIES       ; load entries into RAM register NTR_NBR
 601+ 1599 CD E9 18     LK4FILE1:   call    CLRIOBF         ; clear IO buffer
 602+ 159C CD FE 18                 call    CLRDOSBF        ; clear DOS buffer
 603+ 159F ED 5B 98 81              ld      DE,(DOSBFR)     ; DE set to beginning of DOS buffer
 604+ 15A3 CD 54 18                 call    CHKNMVAL        ; check and copy file name
 605+ 15A6 DA 70 12                 jp      C,NAMERR        ; if Carry, file name error
 606+ 15A9 C3 CD 16                 jp      FILE_EXIST      ; check if file exists and return to caller
 607+ 15AC
 608+ 15AC
 609+ 15AC              ; *****************************************************************************
 610+ 15AC              ; F I L E    L O A D
 611+ 15AC              ; load a file from the disk into the memory
 612+ 15AC              ; *****************************************************************************
 613+ 15AC CD E9 18     LODFILE:    call    CLRIOBF         ; clear I/O
 614+ 15AF CD 1C 18                 call    CHKDSKVAL       ; check DOS version & load disk details
 615+ 15B2 DA 7C 12                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 616+ 15B5 CD 96 15                 call    LK4FILE         ; look for given file
 617+ 15B8 D2 74 12                 jp      NC,FLNTFND      ; file not found - error
 618+ 15BB DD E5                    push    IX              ; copy pointer to file...
 619+ 15BD E1                       pop     HL              ; ...into HL
 620+ 15BE 01 10 00                 ld      BC,$0010        ; skip file name (16 chars)...
 621+ 15C1 09                       add     HL,BC           ; ...by getting pointer to file details
 622+ 15C2 7E                       ld      A,(HL)          ; load file type
 623+ 15C3 FE 80                    cp      $80             ; 'BAS' type?
 624+ 15C5 28 0C                    jr      Z,LDFL4         ; yes, jump over
 625+ 15C7 FE 81                    cp      $81             ; 'BIN' type?
 626+ 15C9 C2 78 12                 jp      NZ,LODERR       ; no, raise error
 627+ 15CC 3A B4 81                 ld      A,(TPBF4)       ; if BIN file, file must be loaded into its original position
 628+ 15CF B7                       or      A               ; did the user set this?
 629+ 15D0 CA 78 12                 jp      Z,LODERR        ; no, raise an error
 630+ 15D3 0E 04        LDFL4:      ld      C,$04           ; 4 steps forward and also 4 bytes to copy
 631+ 15D5 09                       add     HL,BC           ; point to starting sector
 632+ 15D6 11 A8 81                 ld      DE,MSW_SCT      ; point to store sector address of file
 633+ 15D9 ED B0                    ldir                    ; copy MSW/LSW from entry into buffer
 634+ 15DB 11 A5 81                 ld      DE,BYT_SIZ      ; point to store size of file
 635+ 15DE 01 03 00                 ld      BC,$0003        ; 3 bytes to copy
 636+ 15E1 ED B0                    ldir                    ; copy size in bytes and sectors from entry into buffer
 637+ 15E3 11 4C 82                 ld      DE,PROGND       ; load start of BASIC RAM
 638+ 15E6 3A B4 81                 ld      A,(TPBF4)       ; check where to save the data from
 639+ 15E9 B7                       or      A               ; is it 0? (meaning from the current BASIC pointers)
 640+ 15EA 28 03                    jr      Z,LDFL1         ; yes, don't re-load the file from the address stored into the file
 641+ 15EC CD 81 18                 call    HL2DE           ; no, load RAM address from disk
 642+ 15EF ED 53 AC 81  LDFL1:      ld      (RAM_PTR),DE    ; store starting pointer
 643+ 15F3                          ; start loading from disk
 644+ 15F3 CD E9 18     LDFL2:      call    CLRIOBF         ; clear I/O buffer
 645+ 15F6 ED 5B A8 81              ld      DE,(MSW_SCT)    ; load MSW of sector
 646+ 15FA ED 4B AA 81              ld      BC,(LSW_SCT)    ; load LSW of sector
 647+ 15FE CD 6F 10                 call    CF_SETSTR       ; set sector
 648+ 1601 CD B1 10                 call    CF_RD_SEC       ; read sector
 649+ 1604 2A A5 81                 ld      HL,(BYT_SIZ)    ; load bytes left to be copied
 650+ 1607 11 00 02                 ld      DE,$0200        ; are they < 512?
 651+ 160A CD 4D 4D                 call    CMP16
 652+ 160D 30 04                    jr      NC,LDFL3        ; no, jump over
 653+ 160F ED 5B A5 81              ld      DE,(BYT_SIZ)    ; yes, so load only remaining bytes
 654+ 1613 4B           LDFL3:      ld      C,E             ; move bytes to copy...
 655+ 1614 42                       ld      B,D             ; ...into BC
 656+ 1615 2A 9A 81                 ld      HL,(IOBUFF)     ; point to I/O buffer
 657+ 1618 ED 5B AC 81              ld      DE,(RAM_PTR)    ; point to RAM where to save
 658+ 161C ED B0                    ldir                    ; copy data
 659+ 161E 21 A7 81                 ld      HL,SCT_SIZ      ; sector counter
 660+ 1621 35                       dec     (HL)            ; copied all the sectors?
 661+ 1622 CA 51 16                 jp      Z,LDFLEX        ; yes, exit
 662+ 1625 2A AC 81                 ld      HL,(RAM_PTR)    ; pointer to RAM
 663+ 1628 11 00 02                 ld      DE,$0200        ; block of 512 bytes copied
 664+ 162B 19                       add     HL,DE           ; calculate next starting address
 665+ 162C 22 AC 81                 ld      (RAM_PTR),HL    ; store next block
 666+ 162F AF                       xor     A               ; reset Carry
 667+ 1630 2A A5 81                 ld      HL,(BYT_SIZ)    ; load left bytes
 668+ 1633 ED 52                    sbc     HL,DE           ; subtract copied bytes
 669+ 1635 22 A5 81                 ld      (BYT_SIZ),HL    ; store left bytes
 670+ 1638 ED 4B AA 81              ld      BC,(LSW_SCT)    ; load LSW of sector
 671+ 163C 03                       inc     BC              ; next sector
 672+ 163D 78                       ld      A,B             ; BC=$0000?
 673+ 163E B1                       or      C
 674+ 163F 20 09                    jr      NZ,LDFL5        ; no, jump over
 675+ 1641 ED 5B A8 81              ld      DE,(MSW_SCT)    ; load MSW of sector
 676+ 1645 13                       inc     DE              ; increment DE
 677+ 1646 ED 53 A8 81              ld      (MSW_SCT),DE    ; store new MSW of sector
 678+ 164A ED 43 AA 81  LDFL5:      ld      (LSW_SCT),BC    ; store new LSW of sector
 679+ 164E C3 F3 15                 jp      LDFL2           ; repeat
 680+ 1651 CD A5 10     LDFLEX:     call    CF_STANDBY      ; set CF into stand-by mode
 681+ 1654 AF                       xor     A               ; clear Carry flag
 682+ 1655 C9                       ret                     ; return to caller
 683+ 1656
 684+ 1656
 685+ 1656              ; *****************************************************************************
 686+ 1656              ; F I L E    E R A S E
 687+ 1656              ; erase a file from disk, freeing its block
 688+ 1656              ; *****************************************************************************
 689+ 1656 CD E9 18     FIL_ERASE:  call    CLRIOBF         ; clear I/O
 690+ 1659 CD 1C 18                 call    CHKDSKVAL       ; check DOS version & load disk details
 691+ 165C DA 7C 12                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 692+ 165F CD 96 15                 call    LK4FILE         ; look for given file
 693+ 1662 D2 74 12                 jp      NC,FLNTFND      ; file not found - error
 694+ 1665 DD 5E 14                 ld      E,(IX+$14)      ; load MSW into DE
 695+ 1668 DD 56 15                 ld      D,(IX+$15)
 696+ 166B DD 4E 16                 ld      C,(IX+$16)      ; load LSW into BC
 697+ 166E DD 46 17                 ld      B,(IX+$17)
 698+ 1671 ED 53 A8 81              ld      (MSW_SCT),DE    ; store DE
 699+ 1675 ED 43 AA 81              ld      (LSW_SCT),BC    ; store BC
 700+ 1679 DD 7E 1A                 ld      A,(IX+$1A)      ; load size in sectors
 701+ 167C 32 A7 81                 ld      (SCT_SIZ),A     ; store it
 702+ 167F 3E 7F                    ld      A,$7F           ; marker for file deleted
 703+ 1681 DD 77 00                 ld      (IX),A          ; set file as deleted (quick erase)
 704+ 1684 3A B4 81                 ld      A,(TPBF4)       ; check for quick or full delete
 705+ 1687 B7                       or      A               ; A=0 quick erase
 706+ 1688 28 0A                    jr      Z,FIL_ERA5      ; jump if quick erase
 707+ 168A AF                       xor     A               ; clear A
 708+ 168B 06 20                    ld      B,$20           ; full erase - clean entry (32 cells)
 709+ 168D DD 77 00     FIL_ERA6:   ld      (IX),A          ; reset cell
 710+ 1690 DD 23                    inc     IX              ; next cell
 711+ 1692 10 F9                    djnz    FIL_ERA6        ; repeat
 712+ 1694 ED 5B B0 81  FIL_ERA5:   ld      DE,(TPBF2)      ; retrieve MSW of current directory sector
 713+ 1698 ED 4B B2 81              ld      BC,(TPBF3)      ; retrieve LSW of current directory sector
 714+ 169C CD D8 10                 call    CF_WR_SEC       ; write sector
 715+ 169F 38 27                    jr      C,WRT_ERR       ; error?
 716+ 16A1 3A B4 81                 ld      A,(TPBF4)       ; check for quick or full delete
 717+ 16A4 B7                       or      A               ; if A=0 then quick erase
 718+ 16A5 28 1C                    jr      Z,FIL_ERA3      ; yes, leave
 719+ 16A7 CD E9 18                 call    CLRIOBF         ; no, full delete - clear I/O buffer
 720+ 16AA ED 5B A8 81              ld      DE,(MSW_SCT)    ; load MSW of 1st sector of file block
 721+ 16AE ED 4B AA 81              ld      BC,(LSW_SCT)    ; load LSW of 1st sector of file block
 722+ 16B2 21 A7 81                 ld      HL,SCT_SIZ      ; pointer to size in sectors
 723+ 16B5 CD D8 10     FIL_ERA1:   call    CF_WR_SEC       ; erase sector
 724+ 16B8 38 0E                    jr      C,WRT_ERR       ; error?
 725+ 16BA 03                       inc     BC              ; next sector
 726+ 16BB 78                       ld      A,B             ; is LSW rolled back to 0?
 727+ 16BC B1                       or      C
 728+ 16BD 20 01                    jr      NZ,FIL_ERA2     ; no, jump over
 729+ 16BF 13                       inc     DE              ; yes, increment MSW
 730+ 16C0 35           FIL_ERA2:   dec     (HL)            ; decrement sector counter
 731+ 16C1 20 F2                    jr      NZ,FIL_ERA1     ; repeat if other sectors
 732+ 16C3 CD A5 10     FIL_ERA3:   call    CF_STANDBY      ; set CF into stand-by mode
 733+ 16C6 AF                       xor     A               ; clear Carry
 734+ 16C7 C9                       ret
 735+ 16C8 CD A5 10     WRT_ERR:    call    CF_STANDBY      ; put CF into stand-by
 736+ 16CB 37                       scf                     ; set error
 737+ 16CC C9                       ret                     ; return to caller
 738+ 16CD
 739+ 16CD
 740+ 16CD              ; *****************************************************************************
 741+ 16CD              ; F I L E    C H E C K
 742+ 16CD              ; check if file name already exists in directory
 743+ 16CD              ; file name must be stored from (DOSBFR) for 16 chars
 744+ 16CD              ; *****************************************************************************
 745+ 16CD FD 2A A3 81  FILE_EXIST: ld      IY,(NTR_NBR)    ; load max entries
 746+ 16D1 CD 88 17                 call    SETPTEN         ; point to 1st sector of dir
 747+ 16D4 CD 90 17     CHKSTNM1:   call    PT2FSEN         ; point to 1st entry of a dir's sect
 748+ 16D7 CD 9B 17     CHKSTNM2:   call    CKCREN          ; check current entry
 749+ 16DA 28 29                    jr      Z,CHKSTNM10     ; if empty or deleted, jump over
 750+ 16DC 22 AE 81                 ld      (TPBF1),HL      ; store HL
 751+ 16DF ED 53 B0 81              ld      (TPBF2),DE      ; store DE
 752+ 16E3 ED 43 B2 81              ld      (TPBF3),BC      ; store BC
 753+ 16E7 DD E5                    push    IX              ; copy IX...
 754+ 16E9 E1                       pop     HL              ; ...into HL
 755+ 16EA ED 5B 98 81              ld      DE,(DOSBFR)     ; beginning of name file
 756+ 16EE 06 10                    ld      B,$10           ; 16 chars to check
 757+ 16F0 1A           CHKSTNM3:   ld      A,(DE)          ; load a char from name on disk
 758+ 16F1 ED A1                    cpi                     ; compare with name from user
 759+ 16F3 20 05                    jr      NZ,CHKSTNM6     ; chars are different, leave
 760+ 16F5 13                       inc     DE              ; inc DE (HL is incremented by "cpi")
 761+ 16F6 10 F8                    djnz    CHKSTNM3        ; repeat for 16 chars
 762+ 16F8 18 17                    jr      FLEXST          ; file exists in dir
 763+ 16FA 2A AE 81     CHKSTNM6:   ld      HL,(TPBF1)      ; retrieve HL
 764+ 16FD ED 5B B0 81              ld      DE,(TPBF2)      ; retrieve DE
 765+ 1701 ED 4B B2 81              ld      BC,(TPBF3)      ; retrieve sector counter
 766+ 1705 CD A3 17     CHKSTNM10:  call    GTNXTEN         ; other entries in this sector?
 767+ 1708 20 CD                    jr      NZ,CHKSTNM2     ; yes, continue check
 768+ 170A CD AF 17     CHKSTNM5:   call    CKLSTEN         ; go to next sector
 769+ 170D 30 C5                    jr      NC,CHKSTNM1     ; more entries? repeat
 770+ 170F AF           FLNTEXS:    xor     A               ; file not found, reset Carry
 771+ 1710 C9                       ret                     ; return
 772+ 1711 37           FLEXST:     scf                     ; file is present - set Carry flag for error
 773+ 1712 C9                       ret
 774+ 1713
 775+ 1713
 776+ 1713              ; *****************************************************************************
 777+ 1713              ; UNDELETE DELETED FILES
 778+ 1713              ; look for deleted files and undelete them
 779+ 1713              ; *****************************************************************************
 780+ 1713 CD E9 18     DSKUNDFL:   call    CLRIOBF         ; clear I/O
 781+ 1716 CD 1C 18                 call    CHKDSKVAL       ; check DOS version & load disk details
 782+ 1719 DA 7C 12                 jp      C,DOSVERSERR    ; if Carry is set, raise DOS version error
 783+ 171C CD 60 17                 call    FNDFRENTR       ; find a free entry
 784+ 171F D8           DSKUNDFL1:  ret     C               ; return if entries are finished
 785+ 1720 DD 7E 00                 ld      A,(IX)          ; reload first char of entry
 786+ 1723 FE 7F                    cp      $7F             ; is it a deleted entry?
 787+ 1725 20 29                    jr      NZ,DSKUNDFL2    ; no, jump over
 788+ 1727 CD F3 17                 call    RND8            ; get a random char
 789+ 172A CD 11 18                 call    CHATOZ          ; transform it into a letter
 790+ 172D DD 77 00                 ld      (IX),A          ; store it as the first letter of filename
 791+ 1730 CD D8 10                 call    CF_WR_SEC       ; write sector (address is into DEBC)
 792+ 1733 E5                       push    HL              ; store HL
 793+ 1734 C5                       push    BC              ; store BC
 794+ 1735 D5                       push    DE              ; store DE
 795+ 1736 DD E5                    push    IX              ; copy IX...
 796+ 1738 E1                       pop     HL              ; ...into HL
 797+ 1739 06 10                    ld      B,$10           ; 16 chars
 798+ 173B 7E           DSKUNDPR:   ld      A,(HL)          ; retrieve char from filename
 799+ 173C CD CD 23                 call    OUTC            ; print char
 800+ 173F 23                       inc     HL              ; next char
 801+ 1740 10 F9                    djnz    DSKUNDPR        ; repeat
 802+ 1742 3E 20                    ld      A,SPC           ; print a space
 803+ 1744 CD CD 23                 call    OUTC
 804+ 1747 21 55 17                 ld      HL,DSKUNDTXT    ; print undeleted message
 805+ 174A CD A4 2F                 call    PRS
 806+ 174D D1                       pop     DE              ; retrieve DE
 807+ 174E C1                       pop     BC              ; retrieve BC
 808+ 174F E1                       pop     HL              ; retrieve HL
 809+ 1750 CD 74 17     DSKUNDFL2:  call    FNDFRENTR4      ; goto next entry
 810+ 1753 18 CA                    jr      DSKUNDFL1       ; repeat
 811+ 1755 75 6E 64 65  DSKUNDTXT:  defb    "undeleted",CR,0
 811+ 1759 6C 65 74 65
 811+ 175D 64 0D 00
 812+ 1760
 813+ 1760
 814+ 1760              ; *****************************************************************************
 815+ 1760              ; FIND A FREE ENTRY
 816+ 1760              ; find a free entry in the directory to store a new file
 817+ 1760              ; *****************************************************************************
 818+ 1760 CD D0 17     FNDFRENTR:  call    LDMSCT          ; read Master Sector
 819+ 1763 CD C1 17                 call    LDENTRIES       ; load entries into RAM register NTR_NBR and DE
 820+ 1766 D5                       push    DE              ; copy number of entries...
 821+ 1767 FD E1                    pop     IY              ; ...into IY
 822+ 1769 CD 88 17                 call    SETPTEN         ; point to first entry
 823+ 176C CD 90 17     FNDFRENTR1: call    PT2FSEN         ; point to 1st entry of sector
 824+ 176F CD 9B 17     FNDFRENTR2: call    CKCREN          ; check current entry
 825+ 1772 28 0B                    jr      Z,FNDFRENTR3    ; found a free entry
 826+ 1774 CD A3 17     FNDFRENTR4: call    GTNXTEN         ; other entries in this sector?
 827+ 1777 20 F6                    jr      NZ,FNDFRENTR2   ; yes, continue check
 828+ 1779 CD AF 17                 call    CKLSTEN         ; go to next sector
 829+ 177C 30 EE                    jr      NC,FNDFRENTR1   ; more entries? repeat
 830+ 177E C9                       ret                     ; entries finished - leave
 831+ 177F ED 43 A1 81  FNDFRENTR3: ld      (DIR_SCT),BC    ; store sector of dir
 832+ 1783 22 A3 81                 ld      (NTR_NBR),HL    ; store entry number
 833+ 1786 AF                       xor     A               ; reset Carry
 834+ 1787 C9                       ret
 835+ 1788
 836+ 1788
 837+ 1788              ; *****************************************************************************
 838+ 1788              ;   U T I L I T I E S
 839+ 1788              ; *****************************************************************************
 840+ 1788
 841+ 1788              ; set up registers to point to first sector of directory
 842+ 1788 01 01 00     SETPTEN:    ld      BC,$0001        ; BC=$0001 (starting sector of dir) (LSW)
 843+ 178B 50                       ld      D,B             ; DE=$0000 (starting sector of dir) (MSW)
 844+ 178C 58                       ld      E,B
 845+ 178D 60                       ld      H,B             ; HL=$0000 (entry counter)
 846+ 178E 68                       ld      L,B
 847+ 178F C9                       ret                     ; return to caller
 848+ 1790
 849+ 1790
 850+ 1790              ; load a sector and point to first entry
 851+ 1790 CD 6F 10     PT2FSEN:    call    CF_SETSTR       ; set sector to read (BC-DE)
 852+ 1793 CD B1 10                 call    CF_RD_SEC       ; read sector
 853+ 1796 DD 2A 9A 81              ld      IX,(IOBUFF)     ; beginning of I/O buffer
 854+ 179A C9                       ret
 855+ 179B
 856+ 179B
 857+ 179B              ; check current entry
 858+ 179B DD 7E 00     CKCREN:     ld      A,(IX)          ; load 1st char of entry name
 859+ 179E                          ;dec     IY              ; decrement number of entries
 860+ 179E B7                       or      A               ; is it $00 (empty entry)?
 861+ 179F C8                       ret     Z               ; yes, found an entry
 862+ 17A0 FE 7F                    cp      $7F             ; is it $7F (deleted entry)?
 863+ 17A2 C9                       ret
 864+ 17A3
 865+ 17A3              ; goto next entry
 866+ 17A3 C5           GTNXTEN:    push    BC              ; store BC
 867+ 17A4 01 20 00                 ld      BC,$0020        ; load BC with directory entry size (32 bytes)
 868+ 17A7 DD 09                    add     IX,BC           ; next entry in current sector
 869+ 17A9 C1                       pop     BC              ; retrieve sector pointer
 870+ 17AA 23                       inc     HL              ; increment entry counter
 871+ 17AB 7D                       ld      A,L
 872+ 17AC E6 0F                    and     %00001111       ; just done 16 entries?
 873+ 17AE C9                       ret
 874+ 17AF
 875+ 17AF
 876+ 17AF              ; check if reached last entry
 877+ 17AF              ; Carry is set if entries finished
 878+ 17AF 03           CKLSTEN:    inc     BC              ; entries in this sector finished .. goto next sector
 879+ 17B0 78                       ld      A,B             ; check if...
 880+ 17B1 B1                       or      C               ; ...BC=$000
 881+ 17B2 20 01                    jr      NZ,CKLSTEN1     ; no, jump over
 882+ 17B4 13                       inc     DE              ; yes, increment DE (MSW)
 883+ 17B5 E5           CKLSTEN1:   push    HL              ; preserve current entry
 884+ 17B6 D5                       push    DE
 885+ 17B7 FD E5                    push    IY              ; copy max allowed files...
 886+ 17B9 D1                       pop     DE              ; ...into HL
 887+ 17BA CD 4D 4D                 call    CMP16           ; check if reached max allowed entries
 888+ 17BD D1                       pop     DE
 889+ 17BE E1                       pop     HL              ; (retrieve current entry)
 890+ 17BF 3F                       ccf
 891+ 17C0 C9                       ret                     ; return
 892+ 17C1
 893+ 17C1
 894+ 17C1              ; load entries intro RAM register
 895+ 17C1 2A 9A 81     LDENTRIES:  ld      HL,(IOBUFF)     ; start of I/O buffer
 896+ 17C4 01 19 00                 ld      BC,$0019        ; point to max. allowed entries
 897+ 17C7 09                       add     HL,BC           ; get address
 898+ 17C8 CD 81 18                 call    HL2DE           ; get entries into DE
 899+ 17CB ED 53 A3 81              ld      (NTR_NBR),DE    ; store
 900+ 17CF C9                       ret                     ; return to caller
 901+ 17D0
 902+ 17D0
 903+ 17D0              ; load Master Sector (sector #0)
 904+ 17D0 01 00 00     LDMSCT:     ld      BC,$0000        ; LSW of sector
 905+ 17D3 50           LDMSCT1:    ld      D,B             ; MSW of sector
 906+ 17D4 58                       ld      E,B
 907+ 17D5 CD 6F 10                 call    CF_SETSTR       ; set sector
 908+ 17D8 CD B1 10                 call    CF_RD_SEC       ; read sector
 909+ 17DB C9                       ret
 910+ 17DC
 911+ 17DC
 912+ 17DC              ; generate random disk ID
 913+ 17DC C5           RND_ID:     push    BC
 914+ 17DD 06 02                    ld      B,$02           ; repeat 2 times
 915+ 17DF CD F3 17     RND_ID1:    call    RND8            ; get a random value
 916+ 17E2 CD 11 18                 call    CHATOZ          ; transform it into a letter
 917+ 17E5 12                       ld      (DE),A          ; store it
 918+ 17E6 13                       inc     DE              ; inc pointer
 919+ 17E7 CD F3 17                 call    RND8            ; get a random value
 920+ 17EA CD 06 18                 call    CH0TO9          ; transform it into a number from 0 to 9
 921+ 17ED 12                       ld      (DE),A          ; store it
 922+ 17EE 13                       inc     DE              ; inc pointer
 923+ 17EF 10 EE                    djnz    RND_ID1         ; repeat
 924+ 17F1 C1                       pop     BC
 925+ 17F2 C9                       ret                     ; return to caller
 926+ 17F3
 927+ 17F3
 928+ 17F3              ; generate a pseudo-random number using TMR and R registers
 929+ 17F3 C5           RND8:       push    BC
 930+ 17F4 3A E6 81                 ld      A,(TMRCNT)      ; load LSW of sys-timer
 931+ 17F7 47                       ld      B,A             ; copy into B
 932+ 17F8 ED 5F                    ld      A,R             ; load refresh register
 933+ 17FA A8                       xor     B               ; A xor B
 934+ 17FB 47                       ld      B,A             ; copy into B
 935+ 17FC 0F                       rrca                    ; multiply by 32
 936+ 17FD 0F                       rrca
 937+ 17FE 0F                       rrca
 938+ 17FF EE 1F                    xor     $1F
 939+ 1801 80                       add     A,B
 940+ 1802 DE FF                    sbc     A,255           ; carry
 941+ 1804 C1                       pop     BC
 942+ 1805 C9                       ret                     ; return to caller
 943+ 1806
 944+ 1806
 945+ 1806              ; char ported into 0-9 interval
 946+ 1806 E6 0F        CH0TO9:     and     %00001111       ; get only low nibble
 947+ 1808 FE 0A                    cp      $0A             ; is it < 10?
 948+ 180A 38 02                    jr      C,CH0TO9E       ; yes, jump over
 949+ 180C D6 0A                    sub     $0A             ; subract 10
 950+ 180E C6 30        CH0TO9E:    add     $30             ; get a number from 0 to 9
 951+ 1810 C9                       ret
 952+ 1811
 953+ 1811
 954+ 1811              ; char ported into A-Z interval
 955+ 1811 E6 1F        CHATOZ:     and     %00011111       ; get only first 5 bits
 956+ 1813 FE 1A                    cp      $1A             ; is it < 26?
 957+ 1815 38 02                    jr      C,CHATOZE       ; yes, jump over
 958+ 1817 D6 1A                    sub     $1A             ; no, subtract 26
 959+ 1819 C6 41        CHATOZE:    add     $41             ; get a letter from 'A' to 'Z'
 960+ 181B C9                       ret                     ; return to caller
 961+ 181C
 962+ 181C
 963+ 181C              ; first check DOS validity then load disk details
 964+ 181C CD 2D 10     CHKDSKVAL:  call    CF_INIT         ; open CF card comm.
 965+ 181F D8                       ret     C               ; if errors, leave
 966+ 1820 C5                       push    BC              ; store BC
 967+ 1821 D5                       push    DE              ; store DE
 968+ 1822 E5                       push    HL              ; store HL
 969+ 1823 01 00 00                 ld      BC,$0000        ; reset LSW of sector
 970+ 1826 50                       ld      D,B             ; reset MSW of sector
 971+ 1827 58                       ld      E,B
 972+ 1828 CD 6F 10                 call    CF_SETSTR       ; set sector #0
 973+ 182B CD B1 10                 call    CF_RD_SEC       ; read sector
 974+ 182E 2A 9A 81                 ld      HL,(IOBUFF)     ; address of default conf. buffer
 975+ 1831 11 0A 00                 ld      DE,$000A        ; point to disk DOS version
 976+ 1834 19                       add     HL,DE
 977+ 1835 11 06 11                 ld      DE,DFSCT0+10    ; get starting address of I/O buffer
 978+ 1838 06 04                    ld      B,$04           ; 4 chars
 979+ 183A 1A           CHKDSKVAL1: ld      A,(DE)          ; load char from DOS version into memory
 980+ 183B BE                       cp      (HL)            ; compare with disk DOS version
 981+ 183C 20 11                    jr      NZ,CHKDSKVALE   ; no match - so error
 982+ 183E 13                       inc     DE              ; next source
 983+ 183F 23                       inc     HL              ; next comparison
 984+ 1840 10 F8                    djnz    CHKDSKVAL1      ; repeat
 985+ 1842 2A 98 81                 ld      HL,(DOSBFR)     ; address of default conf. buffer
 986+ 1845 11 1D 00                 ld      DE,$001D        ; point to address of data area
 987+ 1848 19                       add     HL,DE           ; set pointer to beginning of identifies
 988+ 1849 CD 81 18                 call    HL2DE           ; first sector of data area into DE
 989+ 184C AF                       xor     A               ; no error - clear Carry flag
 990+ 184D 18 01                    jr      CHKDSKVAL2      ; jump over
 991+ 184F 37           CHKDSKVALE: scf                     ; error - set carry flag
 992+ 1850 E1           CHKDSKVAL2: pop     HL
 993+ 1851 D1                       pop     DE
 994+ 1852 C1                       pop     BC
 995+ 1853 C9                       ret                     ; return to caller
 996+ 1854
 997+ 1854
 998+ 1854              ; check name validity (only allowed chars) and copy it from string pool into a temp buff
 999+ 1854              ; Inputs: DE: pointer to dest. buffer
1000+ 1854              ; operation: copy (HL)->(DE) and pads to get a 16-chars name
1001+ 1854              ; destroys: A, BC, DE, HL
1002+ 1854 ED 4B 0A 82  CHKNMVAL:   ld      BC,(DKLNPT)     ; load lenght of name
1003+ 1858 79                       ld      A,C             ; lenght is max. 16 char, so we only check C
1004+ 1859 FE 11                    cp      $11             ; is it <=16?
1005+ 185B 38 02                    jr      C,CHKNMVAL1     ; yes, so jump over
1006+ 185D 0E 10                    ld      C,$10           ; no, get only 16 chars
1007+ 185F 41           CHKNMVAL1:  ld      B,C             ; copy lenght into B
1008+ 1860 0E 10                    ld      C,$10           ; char counter
1009+ 1862 2A 08 82                 ld      HL,(DKNMPT)     ; pointer to name
1010+ 1865 7E           CHKNMVAL2:  ld      A,(HL)          ; get a char from string name
1011+ 1866 CD D3 18                 call    CHK_NAM         ; check if valid
1012+ 1869 D8                       ret     C               ; no, name error
1013+ 186A 12                       ld      (DE),A          ; yes, store char
1014+ 186B 13                       inc     DE              ; next I/O location
1015+ 186C 23                       inc     HL              ; next name char
1016+ 186D 0D                       dec     C               ; decrement number of chars copied
1017+ 186E 10 F5                    djnz    CHKNMVAL2       ; repeat until name ends
1018+ 1870 79                       ld      A,C             ; check if there are no empty chars in file
1019+ 1871 B7                       or      A
1020+ 1872 C8                       ret     Z               ; yes, job finished - return
1021+ 1873 3E 20                    ld      A,SPC           ; no, padding required
1022+ 1875 12           CHKNMVAL3:  ld      (DE),A          ; store char
1023+ 1876 13                       inc     DE              ; next location
1024+ 1877 0D                       dec     C               ; check if padding is over
1025+ 1878 20 FB                    jr      NZ,CHKNMVAL3    ; no, continue
1026+ 187A AF                       xor     A               ; clear Carry flag
1027+ 187B C9                       ret                     ; return to caller
1028+ 187C
1029+ 187C
1030+ 187C              ; store DE into (HL) and (HL+1)
1031+ 187C 73           DE2HL:      ld      (HL),E          ; LSW of size
1032+ 187D 23                       inc     HL
1033+ 187E 72                       ld      (HL),D          ; MSW of size
1034+ 187F 23                       inc     HL
1035+ 1880 C9                       ret                     ; return to caller
1036+ 1881
1037+ 1881
1038+ 1881              ; get DE from (HL) and (HL+1)
1039+ 1881 5E           HL2DE:      ld      E,(HL)          ; get LSW into E
1040+ 1882 23                       inc     HL              ; next location
1041+ 1883 56                       ld      D,(HL)          ; get MSW into D
1042+ 1884 23                       inc     HL              ; next location
1043+ 1885 C9                       ret                     ; return to caller
1044+ 1886
1045+ 1886
1046+ 1886              ; convert a 16/32-bit number into an ASCII string and print it
1047+ 1886              ; inputs: HL pointer to 32-bit number
1048+ 1886 CD 81 18     PRN32ASCII: call    HL2DE           ; load MSW into DE  <-- entry for 32-bit
1049+ 1889 4E           PRN16ASCII: ld      C,(HL)          ; load LSW into BC   <-- entry for 16-bit (set DE to $0000 before to call)
1050+ 188A 23                       inc     HL
1051+ 188B 46                       ld      B,(HL)
1052+ 188C C5                       push    BC              ; copy BC...
1053+ 188D DD E1                    pop     IX              ; ...into IX
1054+ 188F FD 21 AE 81  PRN16ASCIX: ld      IY,TPBF1        ; number is into DEIX - now, load pointer to destination buffer
1055+ 1893 CD 16 4E                 call    CLCN32          ; convert number in DEIX into ASCII number
1056+ 1896 21 AE 81                 ld      HL,TPBF1        ; address of ASCII number
1057+ 1899 7E           PRNTSIZ:    ld      A,(HL)          ; get a char
1058+ 189A B7                       or      A               ; is it $00 (end of string)?
1059+ 189B C8                       ret     Z               ; yes, leave
1060+ 189C CD CD 23                 call    OUTC            ; no, print char
1061+ 189F 23                       inc     HL              ; next char
1062+ 18A0 18 F7                    jr      PRNTSIZ         ; repeat
1063+ 18A2
1064+ 18A2
1065+ 18A2              ; convert one or more bytes into memory in hex format
1066+ 18A2              ; HL: pointer to number in memory - B: number of bytes to convert
1067+ 18A2              ; destroys: A, D, HL
1068+ 18A2 50           PRN_HEX:    ld      D,B             ; move bytes into D
1069+ 18A3 7E           PRN_HEX1:   ld      A,(HL)          ; load value
1070+ 18A4 CD C3 18                 call    BYTEHEX         ; print hex number
1071+ 18A7 23                       inc     HL              ; next location
1072+ 18A8 15                       dec     D               ; decrement bytes to convert
1073+ 18A9 20 F8                    jr      NZ,PRN_HEX1     ; repeat
1074+ 18AB C9                       ret
1075+ 18AC
1076+ 18AC
1077+ 18AC              ; convert one or more words into memory in hex format
1078+ 18AC              ; IX: pointer to number in memory - B: number of words to convert
1079+ 18AC              ; destroys: AF, IX
1080+ 18AC D5           PRN_WHEX:   push    DE
1081+ 18AD 50                       ld      D,B
1082+ 18AE DD 7E 01     PRN_WHEX1:  ld      A,(IX+1)        ; load MSW into A
1083+ 18B1 CD C3 18                 call    BYTEHEX         ; print hex number
1084+ 18B4 DD 7E 00                 ld      A,(IX)          ; load LSW into A
1085+ 18B7 CD C3 18                 call    BYTEHEX         ; print hex number
1086+ 18BA DD 23                    inc     IX
1087+ 18BC DD 23                    inc     IX              ; next word
1088+ 18BE 15                       dec     D               ; decrement words to convert
1089+ 18BF 20 ED                    jr      NZ,PRN_WHEX1    ; repeat
1090+ 18C1 D1                       pop     DE
1091+ 18C2 C9                       ret
1092+ 18C3
1093+ 18C3
1094+ 18C3              ; print A in hex format
1095+ 18C3 C5           BYTEHEX:    push    BC
1096+ 18C4 D5                       push    DE
1097+ 18C5 CD 62 4C                 call    BYT2ASC         ; convert to HEX and get back into BC
1098+ 18C8 78                       ld      A,B
1099+ 18C9 CD CD 23                 call    OUTC            ; print left nibble
1100+ 18CC 79                       ld      A,C
1101+ 18CD CD CD 23                 call    OUTC            ; print right nibble
1102+ 18D0 D1                       pop     DE
1103+ 18D1 C1                       pop     BC
1104+ 18D2 C9                       ret                     ; return to caller
1105+ 18D3
1106+ 18D3
1107+ 18D3              ; check for non-allowed chars in disk/file names - allowed chars: '0'-'9', 'A'-'Z', '-', SPACE
1108+ 18D3              ; input: A -> char to check
1109+ 18D3              ; return: C is set if ERROR, reset otherwise
1110+ 18D3 FE 20        CHK_NAM:    cp      SPC             ; is it a space?
1111+ 18D5 C8                       ret     Z               ; return if equal (C is reset)
1112+ 18D6 FE 2D                    cp      '-'             ; is it a minus?
1113+ 18D8 C8                       ret     Z               ; return if equal
1114+ 18D9 FE 30                    cp      '0'             ; char < '0' ?
1115+ 18DB D8                       ret     C               ; yes, disk name error
1116+ 18DC FE 3A                    cp      ':'             ; is char <= '9' ?
1117+ 18DE 38 07                    jr      C,CHK_C_CF      ; yes, leave
1118+ 18E0 E6 5F                    and     %01011111       ; for letters, only UPPER CASE
1119+ 18E2 FE 41                    cp      'A'             ; is char >= 'A' ?
1120+ 18E4 D8                       ret     C               ; no, error
1121+ 18E5 FE 5B                    cp      '['             ; is char <= 'Z' ? (if yes, C=1, then C=0; otherwise, C=0 then C=1)
1122+ 18E7 3F           CHK_C_CF:   ccf                     ; Carry complement (invert Carry)
1123+ 18E8 C9           CHK_NAM_LV: ret                     ; return to caller
1124+ 18E9
1125+ 18E9
1126+ 18E9              ; clear I/O buffer
1127+ 18E9 F5           CLRIOBF:    push    AF              ; store AF
1128+ 18EA C5                       push    BC              ; store BC
1129+ 18EB E5                       push    HL              ; store HL
1130+ 18EC 2A 9A 81                 ld 	    HL,(IOBUFF)     ; load address of last BASIC location
1131+ 18EF 01 02 00                 ld      BC,$0002        ; B=256 iterations ($00); C=repeat 2 times
1132+ 18F2 AF           CLRBUFF:    xor     A               ; reset A   ----- common part -----
1133+ 18F3 77           RSTIOBF:    ld      (HL),A          ; reset cell
1134+ 18F4 23                       inc     HL              ; next cell
1135+ 18F5 10 FC                    djnz    RSTIOBF         ; repeat for 256 times
1136+ 18F7 0D                       dec     C               ; decrement C
1137+ 18F8 20 F9                    jr      NZ,RSTIOBF      ; repeat if not zero
1138+ 18FA E1                       pop     HL              ; retrieve HL
1139+ 18FB C1                       pop     BC              ; retrieve BC
1140+ 18FC F1                       pop     AF              ; retrieve AF
1141+ 18FD C9                       ret                     ; return to caller
1142+ 18FE
1143+ 18FE
1144+ 18FE              ; clear DOS buffer
1145+ 18FE F5           CLRDOSBF:   push    AF              ; store AF
1146+ 18FF C5                       push    BC              ; store BC
1147+ 1900 E5                       push    HL              ; store HL
1148+ 1901 2A 98 81                 ld 	    HL,(DOSBFR)     ; load address of last BASIC location
1149+ 1904 01 01 20                 ld      BC,$2001        ; B=32 iterations; C=repeat 1 time
1150+ 1907 C3 F2 18                 jp      CLRBUFF         ; continue to common part
# file closed: ../include/dos/dos-1.03.asm
  84  190A
  85  190A              ; include the latest version of the LM80C BASIC interpreter
  86  190A                  INCLUDE "../include/basic/basic-1.08.asm"
# file opened: ../include/basic/basic-1.08.asm
   1+ 190A              ; ------------------------------------------------------------------------------
   2+ 190A              ; LM80C BASIC (32K/64K) - R3.22
   3+ 190A              ; ------------------------------------------------------------------------------
   4+ 190A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 190A              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 190A              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 190A              ; kind of warranty: you can use them at your own risk.
   8+ 190A              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 190A              ; maintain the copyright notices, include this advice and the note to the
  10+ 190A              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 190A              ; redistribuite them.
  12+ 190A              ; https://www.leonardomiliani.com
  13+ 190A              ;
  14+ 190A              ; Please support me by visiting the following links:
  15+ 190A              ; Main project page: https://www.leonardomiliani.com
  16+ 190A              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 190A              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 190A              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 190A              ; ------------------------------------------------------------------------------
  20+ 190A              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 190A              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 190A              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 190A
  24+ 190A
  25+ 190A              ;------------------------------------------------------------------------------
  26+ 190A              ;  L M 8 0 C   B A S I C
  27+ 190A              ;------------------------------------------------------------------------------
  28+ 190A
  29+ 190A              ; GENERAL EQUATES
  30+ 190A
  31+ 190A              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 190A              CTRLC           equ     $03             ; Control "C"
  33+ 190A              CTRLG           equ     $07             ; Control "G"
  34+ 190A              BKSP            equ     $08             ; Back space
  35+ 190A              LF              equ     $0A             ; Line feed
  36+ 190A              CS              equ     $0C             ; Clear screen
  37+ 190A              CR              equ     $0D             ; Carriage return
  38+ 190A              CTRLO           equ     $0F             ; Control "O"
  39+ 190A              CTRLQ           equ     $11             ; Control "Q"
  40+ 190A              CTRLR           equ     $12             ; Control "R"
  41+ 190A              CTRLS           equ     $13             ; Control "S"
  42+ 190A              CTRLU           equ     $15             ; Control "U"
  43+ 190A              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 190A              ESC             equ     $1B             ; Escape
  45+ 190A              SPC             equ     $20             ; Space
  46+ 190A              DEL             equ     $7F             ; Delete
  47+ 190A              INSRT           equ     $1A             ; Insert Key
  48+ 190A              ; cursor ASCII codes
  49+ 190A              CRSLFT          equ     $1C             ; cursor left
  50+ 190A              CRSRGT          equ     $1D             ; cursor right
  51+ 190A              CRSUP           equ     $1E             ; cursor up
  52+ 190A              CRSDN           equ     $1F             ; cursor down
  53+ 190A
  54+ 190A
  55+ 190A              ;-------------------------------------------------------------------------
  56+ 190A              ; BASIC ERROR MESSAGES
  57+ 190A              ; the interpreter looks for a single-byte code in the following list,
  58+ 190A              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 190A              ; find where to retrieve the message text in "ERRORS"
  60+ 190A
  61+ 190A              ; BASIC ERROR CODE VALUES
  62+ 190A              ; These values act as an offset to point to the error message into the error table
  63+ 190A              ; must be incremented by 2 because they point to a word address jump
  64+ 190A              NF      equ     $00     ; NEXT without FOR
  65+ 190A              SN      equ     $02     ; Syntax error
  66+ 190A              RG      equ     $04     ; RETURN without GOSUB
  67+ 190A              OD      equ     $06     ; Out of DATA
  68+ 190A              FC      equ     $08     ; Function call error
  69+ 190A              OV      equ     $0A     ; Overflow
  70+ 190A              OM      equ     $0C     ; Out of memory
  71+ 190A              UL      equ     $0E     ; Undefined line number
  72+ 190A              BS      equ     $10     ; Bad subscript
  73+ 190A              DD      equ     $12     ; Re-Dimensioned array
  74+ 190A              DZ      equ     $14     ; Division by zero (/0)
  75+ 190A              ID      equ     $16     ; Illegal direct
  76+ 190A              TM      equ     $18     ; Type mis-match
  77+ 190A              OS      equ     $1A     ; Out of string space
  78+ 190A              LS      equ     $1C     ; String too long
  79+ 190A              ST      equ     $1E     ; String formula too complex
  80+ 190A              CN      equ     $20     ; Can't continue
  81+ 190A              UF      equ     $22     ; Undefined FN function
  82+ 190A              MO      equ     $24     ; Missing operand
  83+ 190A              HX      equ     $26     ; HEX error
  84+ 190A              BN      equ     $28     ; BIN error
  85+ 190A              GM      equ     $2A     ; No Graphics Mode
  86+ 190A              SC      equ     $2C     ; Serial configuration
  87+ 190A              SA      equ     $2E     ; Serial port already open
  88+ 190A              SO      equ     $30     ; Serial buffer overrun
  89+ 190A              HP      equ     $32     ; HELP call
  90+ 190A              IM      equ     $34     ; Illegal indirect
  91+ 190A              NR      equ     $36     ; Device not ready
  92+ 190A              D0      equ     $38     ; DOS not enabled
  93+ 190A              D1      equ     $3A     ; Disk/File name error
  94+ 190A              D2      equ     $3C     ; Disk geometry error
  95+ 190A              D3      equ     $3E     ; Save error
  96+ 190A              D4      equ     $40     ; Load error
  97+ 190A              D5      equ     $42     ; Disk full error
  98+ 190A              D6      equ     $44     ; Duplicate file name error
  99+ 190A              D7      equ     $46     ; DOS version error
 100+ 190A              D8      equ     $48     ; File not found error
 101+ 190A
 102+ 190A
 103+ 190A              ; BASIC ERROR POINTER TABLE
 104+ 190A              ERRTBL: equ $
 105+ 190A 54 19        NFPTR:  defw    NFMSG
 106+ 190C 65 19        SNPTR:  defw    SNMSG
 107+ 190E 6C 19        RGPTR:  defw    RGMSG
 108+ 1910 81 19        ODPTR:  defw    ODMSG
 109+ 1912 8D 19        FCPTR:  defw    FCMSG
 110+ 1914 A3 19        OVPTR:  defw    OVMSG
 111+ 1916 AC 19        OMPTR:  defw    OMMSG
 112+ 1918 BA 19        ULPTR:  defw    ULMSG
 113+ 191A C9 19        BSPTR:  defw    BSMSG
 114+ 191C D7 19        DDPTR:  defw    DDMSG
 115+ 191E EC 19        DZPTR:  defw    DZMSG
 116+ 1920 FD 19        IDPTR:  defw    IDMSG
 117+ 1922 11 1A        TMPTR:  defw    TMMSG
 118+ 1924 20 1A        OSPTR:  defw    OSMSG
 119+ 1926 34 1A        LSPTR:  defw    LSMSG
 120+ 1928 44 1A        STPTR:  defw    STMSG
 121+ 192A 5F 1A        CNPTR:  defw    CNMSG
 122+ 192C 6E 1A        UFPTR:  defw    UFMSG
 123+ 192E 84 1A        MOPTR:  defw    MOMSG
 124+ 1930 94 1A        HXPTR:  defw    HXMSG
 125+ 1932 9F 1A        BNPTR:  defw    BNMSG
 126+ 1934 AA 1A        GMPRT:  defw    GMMSG
 127+ 1936 BB 1A        SCPTR:  defw    SCMSG
 128+ 1938 D0 1A        SAPTR:  defw    SAMSG
 129+ 193A E9 1A        SOPTR:  defw    SOMSG
 130+ 193C FF 1A        HPPTR:  defw    HPMSG
 131+ 193E 09 1B        IMPRT:  defw    IMMSG
 132+ 1940 1F 1B        NRPRT:  defw    NRMSG
 133+ 1942 30 1B        D0PTR:  defw    D0MSG
 134+ 1944 40 1B        D1PRT:  defw    D1MSG
 135+ 1946 4C 1B        D2PRT:  defw    D2MSG
 136+ 1948 5A 1B        D3PRT:  defw    D3MSG
 137+ 194A 5F 1B        D4PTR:  defw    D4MSG
 138+ 194C 64 1B        D5PTR:  defw    D5MSG
 139+ 194E 6E 1B        D6PTR:  defw    D6MSG
 140+ 1950 82 1B        D7PRT:  defw    D7MSG
 141+ 1952 8E 1B        D8PTR:  defw    D8MSG
 142+ 1954
 143+ 1954
 144+ 1954              ; BASIC ERROR MESSAGE LIST
 145+ 1954              ERRORS  equ $
 146+ 1954 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 146+ 1958 20 57 69 74
 146+ 195C 68 6F 75 74
 146+ 1960 20 46 4F 52
 146+ 1964 00
 147+ 1965 53 79 6E 74  SNMSG:  defb    "Syntax",0
 147+ 1969 61 78 00
 148+ 196C 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 148+ 1970 52 4E 20 77
 148+ 1974 69 74 68 6F
 148+ 1978 75 74 20 47
 148+ 197C 4F 53 55 42
 148+ 1980 00
 149+ 1981 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 149+ 1985 6F 66 20 44
 149+ 1989 41 54 41 00
 150+ 198D 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 150+ 1991 67 61 6C 20
 150+ 1995 46 75 6E 63
 150+ 1999 74 69 6F 6E
 150+ 199D 20 43 61 6C
 150+ 19A1 6C 00
 151+ 19A3 4F 76 65 72  OVMSG:  defb    "Overflow",0
 151+ 19A7 66 6C 6F 77
 151+ 19AB 00
 152+ 19AC 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 152+ 19B0 6F 66 20 4D
 152+ 19B4 65 6D 6F 72
 152+ 19B8 79 00
 153+ 19BA 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 153+ 19BE 66 69 6E 65
 153+ 19C2 64 20 4C 69
 153+ 19C6 6E 65 00
 154+ 19C9 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 154+ 19CD 53 75 62 73
 154+ 19D1 63 72 69 70
 154+ 19D5 74 00
 155+ 19D7 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 155+ 19DB 69 6D 65 6E
 155+ 19DF 73 69 6F 6E
 155+ 19E3 65 64 20 41
 155+ 19E7 72 72 61 79
 155+ 19EB 00
 156+ 19EC 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 156+ 19F0 73 69 6F 6E
 156+ 19F4 20 62 79 20
 156+ 19F8 5A 65 72 6F
 156+ 19FC 00
 157+ 19FD 49 6C 6C 65  IDMSG:  defb    "Illegal Direct Mode",0
 157+ 1A01 67 61 6C 20
 157+ 1A05 44 69 72 65
 157+ 1A09 63 74 20 4D
 157+ 1A0D 6F 64 65 00
 158+ 1A11 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 158+ 1A15 20 4D 69 73
 158+ 1A19 2D 6D 61 74
 158+ 1A1D 63 68 00
 159+ 1A20 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 159+ 1A24 6F 66 20 53
 159+ 1A28 74 72 69 6E
 159+ 1A2C 67 20 53 70
 159+ 1A30 61 63 65 00
 160+ 1A34 53 74 72 69  LSMSG:  defb    "String Too Long",0
 160+ 1A38 6E 67 20 54
 160+ 1A3C 6F 6F 20 4C
 160+ 1A40 6F 6E 67 00
 161+ 1A44 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 161+ 1A48 6E 67 20 46
 161+ 1A4C 6F 72 6D 75
 161+ 1A50 6C 61 20 54
 161+ 1A54 6F 6F 20 43
 161+ 1A58 6F 6D 70 6C
 161+ 1A5C 65 78 00
 162+ 1A5F 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 162+ 1A63 74 20 43 6F
 162+ 1A67 6E 74 69 6E
 162+ 1A6B 75 65 00
 163+ 1A6E 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 163+ 1A72 66 69 6E 65
 163+ 1A76 64 20 46 4E
 163+ 1A7A 20 46 75 6E
 163+ 1A7E 63 74 69 6F
 163+ 1A82 6E 00
 164+ 1A84 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 164+ 1A88 69 6E 67 20
 164+ 1A8C 4F 70 65 72
 164+ 1A90 61 6E 64 00
 165+ 1A94 48 45 58 20  HXMSG:  defb    "HEX Format",0
 165+ 1A98 46 6F 72 6D
 165+ 1A9C 61 74 00
 166+ 1A9F 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 166+ 1AA3 46 6F 72 6D
 166+ 1AA7 61 74 00
 167+ 1AAA 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 167+ 1AAE 72 61 70 68
 167+ 1AB2 69 63 73 20
 167+ 1AB6 4D 6F 64 65
 167+ 1ABA 00
 168+ 1ABB 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 168+ 1ABF 61 6C 20 43
 168+ 1AC3 6F 6E 66 69
 168+ 1AC7 67 75 72 61
 168+ 1ACB 74 69 6F 6E
 168+ 1ACF 00
 169+ 1AD0 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 169+ 1AD4 61 6C 20 50
 169+ 1AD8 6F 72 74 20
 169+ 1ADC 41 6C 72 65
 169+ 1AE0 61 64 79 20
 169+ 1AE4 4F 70 65 6E
 169+ 1AE8 00
 170+ 1AE9 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 170+ 1AED 61 6C 20 42
 170+ 1AF1 75 66 66 65
 170+ 1AF5 72 20 4F 76
 170+ 1AF9 65 72 72 75
 170+ 1AFD 6E 00
 171+ 1AFF 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 171+ 1B03 20 43 61 6C
 171+ 1B07 6C 00
 172+ 1B09 49 6C 6C 65  IMMSG:  defb    "Illegal Indirect Mode",0
 172+ 1B0D 67 61 6C 20
 172+ 1B11 49 6E 64 69
 172+ 1B15 72 65 63 74
 172+ 1B19 20 4D 6F 64
 172+ 1B1D 65 00
 173+ 1B1F 44 65 76 69  NRMSG:  defb    "Device Not Ready",0
 173+ 1B23 63 65 20 4E
 173+ 1B27 6F 74 20 52
 173+ 1B2B 65 61 64 79
 173+ 1B2F 00
 174+ 1B30 44 4F 53 20  D0MSG:  defb    "DOS Not Enabled",0
 174+ 1B34 4E 6F 74 20
 174+ 1B38 45 6E 61 62
 174+ 1B3C 6C 65 64 00
 175+ 1B40 4E 61 6D 65  D1MSG:  defb    "Name String",0
 175+ 1B44 20 53 74 72
 175+ 1B48 69 6E 67 00
 176+ 1B4C 44 69 73 6B  D2MSG:  defb    "Disk Geometry",0
 176+ 1B50 20 47 65 6F
 176+ 1B54 6D 65 74 72
 176+ 1B58 79 00
 177+ 1B5A 53 61 76 65  D3MSG:  defb    "Save",0
 177+ 1B5E 00
 178+ 1B5F 4C 6F 61 64  D4MSG:  defb    "Load",0
 178+ 1B63 00
 179+ 1B64 44 69 73 6B  D5MSG:  defb    "Disk Full",0
 179+ 1B68 20 46 75 6C
 179+ 1B6C 6C 00
 180+ 1B6E 44 75 70 6C  D6MSG:  defb    "Duplicate File Name",0
 180+ 1B72 69 63 61 74
 180+ 1B76 65 20 46 69
 180+ 1B7A 6C 65 20 4E
 180+ 1B7E 61 6D 65 00
 181+ 1B82 44 4F 53 20  D7MSG:  defb    "DOS Version",0
 181+ 1B86 56 65 72 73
 181+ 1B8A 69 6F 6E 00
 182+ 1B8E 46 69 6C 65  D8MSG:  defb    "File Not Found",0
 182+ 1B92 20 4E 6F 74
 182+ 1B96 20 46 6F 75
 182+ 1B9A 6E 64 00
 183+ 1B9D
 184+ 1B9D
 185+ 1B9D              ;-----------------------------------------------------------------------------
 186+ 1B9D              ; STARTING POINTS FOR BASIC BOOT
 187+ 1B9D              ; COLD: reset every memory pointer, acting as a power-up boot
 188+ 1B9D              ; WARM: preserve program in memory, keeping every current pointer
 189+ 1B9D
 190+ 1B9D C3 A3 1B     COLD:   jp      STARTB          ; Jump for cold start
 191+ 1BA0 C3 6B 1C     WARM:   jp      WARMST          ; Jump for warm start
 192+ 1BA3
 193+ 1BA3 C3 AA 1B     STARTB: jp      CSTART          ; Jump to initialise
 194+ 1BA6 C1 26                defw    DEINT           ; Get integer -32768 to 32767
 195+ 1BA8 86 2E                defw    ABPASS          ; Return integer in AB
 196+ 1BAA 21 5E 80     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 197+ 1BAD F9                   ld      SP,HL           ; Set up a temporary stack
 198+ 1BAE C3 38 4D             jp      INITST          ; Go to initialise
 199+ 1BB1
 200+ 1BB1 21 5B 1F     SYSINIT:ld      HL,INITAB       ; Initialise workspace
 201+ 1BB4 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 202+ 1BB7 11 5E 80             ld      DE,WRKSPC       ; Into workspace RAM
 203+ 1BBA ED B0                ldir                    ; Copy data
 204+ 1BBC EB                   ex      DE,HL           ; Copy DE into HL
 205+ 1BBD F9                   ld      SP,HL           ; Temporary stack
 206+ 1BBE CD 24 22             call    CLREG           ; Clear registers and stack
 207+ 1BC1 CD D8 28             call    PRNTCRLF        ; Output CRLF
 208+ 1BC4 32 91 81             ld      (BUFFER+88+1),A ; Mark end of buffer
 209+ 1BC7 32 6F 82             ld      (PROGST),A      ; Initialise program area
 210+ 1BCA 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 211+ 1BCC 21 EF 1C     MSIZE:  ld      HL,MEMMSG       ; Point to message
 212+ 1BCF CD A4 2F             call    PRS             ; Output "Memory size"
 213+ 1BD2 CD 41 22             call    PROMPT          ; Get input with '?'
 214+ 1BD5 CD 44 09             call    CURSOR_ON       ; enable cursor
 215+ 1BD8 CD 0B 26             call    GETCHR          ; Get next character
 216+ 1BDB B7                   or      A               ; Set flags
 217+ 1BDC C2 F4 1B             jp      NZ,TSTMEM       ; If number - Test if RAM there
 218+ 1BDF 21 D3 82     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 219+ 1BE2 23           MLOOP:  inc     HL              ; Next byte
 220+ 1BE3 7C                   ld      A,H             ; Above address FFFF ?
 221+ 1BE4 B5                   or      L
 222+ 1BE5 CA 06 1C             jp      Z,SETTOP        ; Yes - 64K RAM
 223+ 1BE8 7E                   ld      A,(HL)          ; Get contents
 224+ 1BE9 47                   ld      B,A             ; Save it
 225+ 1BEA 2F                   cpl                     ; Flip all bits
 226+ 1BEB 77                   ld      (HL),A          ; Put it back
 227+ 1BEC BE                   cp      (HL)            ; RAM there if same
 228+ 1BED 70                   ld      (HL),B          ; Restore old contents
 229+ 1BEE CA E2 1B             jp      Z,MLOOP         ; If RAM - test next byte
 230+ 1BF1 C3 06 1C             jp      SETTOP          ; Top of RAM found
 231+ 1BF4
 232+ 1BF4 CD DB 26     TSTMEM: call    ATOH            ; Get high memory into DE
 233+ 1BF7 B7                   or      A               ; Set flags on last byte
 234+ 1BF8 C2 C2 20             jp      NZ,SNERR        ; ?SN Error if bad character
 235+ 1BFB EB                   ex      DE,HL           ; Address into HL
 236+ 1BFC 2B                   dec     HL              ; Back one byte
 237+ 1BFD 3E D9                ld      A,%11011001     ; Test byte
 238+ 1BFF 46                   ld      B,(HL)          ; Get old contents
 239+ 1C00 77                   ld      (HL),A          ; Load test byte
 240+ 1C01 BE                   cp      (HL)            ; RAM there if same
 241+ 1C02 70                   ld      (HL),B          ; Restore old contents
 242+ 1C03 C2 CC 1B             jp      NZ,MSIZE        ; Ask again if no RAM
 243+ 1C06
 244+ 1C06 CD 59 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 245+ 1C09 2B                   dec     HL              ; Back one byte
 246+ 1C0A 11 D2 82             ld      DE,STLOOK-1     ; See if enough RAM
 247+ 1C0D CD BC 23             call    CPDEHL          ; Compare DE with HL
 248+ 1C10 DA CC 1B             jp      C,MSIZE         ; Ask again if not enough RAM
 249+ 1C13 3A 4B 82             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 250+ 1C16 1F                   rra                     ; is DOS disabled?
 251+ 1C17 30 12                jr      NC,NODOS        ; yes, so jump over
 252+ 1C19 11 00 FE             ld      DE,0-512        ; no, so reserve 512 bytes on top of RAM...
 253+ 1C1C 19                   add     HL,DE           ; ...for I/O buffer...
 254+ 1C1D 22 9A 81             ld      (IOBUFF),HL     ; ...and store address
 255+ 1C20 11 E0 FF             ld      DE,0-32         ; then, reserve 32 bytes...
 256+ 1C23 19                   add     HL,DE           ; ...for DOS buffer...
 257+ 1C24 22 98 81             ld      (DOSBFR),HL     ; ...and store address
 258+ 1C27 11 FF FF             ld      DE,0-1          ; then, 1 more byte to go back to preserve...
 259+ 1C2A 19                   add     HL,DE           ; ... the 1st byte of buffer
 260+ 1C2B 11 9C FF     NODOS:  ld      DE,0-100        ; now, preserve 100 bytes for string space
 261+ 1C2E 22 96 81             ld      (LSTRAM),HL     ; Save last available RAM
 262+ 1C31 19                   add     HL,DE           ; Allocate string space
 263+ 1C32 22 AD 80             ld      (STRSPC),HL     ; Save string space
 264+ 1C35 CD FF 21             call    CLRPTR          ; Clear program area
 265+ 1C38 2A AD 80             ld      HL,(STRSPC)     ; Get end of memory
 266+ 1C3B 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 267+ 1C3E 19                   add     HL,DE           ; Adjust HL
 268+ 1C3F 11 6F 82             ld      DE,PROGST       ; Start of program text
 269+ 1C42 7D                   ld      A,L             ; Get LSB
 270+ 1C43 93                   sub     E               ; Adjust it
 271+ 1C44 6F                   ld      L,A             ; Re-save
 272+ 1C45 7C                   ld      A,H             ; Get MSB
 273+ 1C46 9A                   sbc     A,D             ; Adjust it
 274+ 1C47 67                   ld      H,A             ; Re-save
 275+ 1C48 E5                   push    HL              ; Save bytes free
 276+ 1C49 21 91 1C             ld      HL,SIGNON       ; Sign-on message
 277+ 1C4C CD A4 2F             call    PRS             ; Output string
 278+ 1C4F 3A 4B 82             ld      A,(DOS_EN)      ; check if DOS is enabled
 279+ 1C52 B7                   or      A
 280+ 1C53 28 06                jr      Z,SETTP1        ; no DOS, jump over
 281+ 1C55 21 D2 1C             ld      HL,DOSMSG       ; DOS message
 282+ 1C58 CD A4 2F             call    PRS
 283+ 1C5B 21 7A 1C     SETTP1: ld      HL,BLNSPC       ; Empty space
 284+ 1C5E CD A4 2F             call    PRS             ; Output string
 285+ 1C61 E1                   pop     HL              ; Get bytes free back
 286+ 1C62 CD 43 3A             call    PRNTHL          ; Output amount of free memory
 287+ 1C65 21 83 1C             ld      HL,BFREE        ; " Bytes free" message
 288+ 1C68 CD A4 2F             call    PRS             ; Output string
 289+ 1C6B
 290+ 1C6B 31 3D 81     WARMST: ld      SP,STACK        ; Temporary stack
 291+ 1C6E CD 24 22     BRKRET: call    CLREG           ; Clear registers and stack
 292+ 1C71 CD 6A 47             call    RESFN           ; reset FN keys and auto-repeat
 293+ 1C74 CD 44 09             call    CURSOR_ON       ; enable cursor
 294+ 1C77 C3 22 21             jp      PRNTOK          ; Go to get command line
 295+ 1C7A
 296+ 1C7A 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 296+ 1C7E 20 20 20 20
 296+ 1C82 00
 297+ 1C83 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 297+ 1C87 65 73 20 66
 297+ 1C8B 72 65 65 0D
 297+ 1C8F 0D 00
 298+ 1C91
 299+ 1C91 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.22 ",251,"2021 L.Miliani"
 299+ 1C95 43 20 42 41
 299+ 1C99 53 49 43 20
 299+ 1C9D 33 2E 32 32
 299+ 1CA1 20 FB 32 30
 299+ 1CA5 32 31 20 4C
 299+ 1CA9 2E 4D 69 6C
 299+ 1CAD 69 61 6E 69
 300+ 1CB1 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 300+ 1CB5 20 42 41 53
 300+ 1CB9 49 43 20 34
 300+ 1CBD 2E 37 20 20
 300+ 1CC1 FB 31 39 37
 300+ 1CC5 38 20 4D 69
 300+ 1CC9 63 72 6F 73
 300+ 1CCD 6F 66 74 0D
 300+ 1CD1 00
 301+ 1CD2 20 20 20 20  DOSMSG: defb    "     LM80C DOS ","1.03","  Loaded",CR,0
 301+ 1CD6 20 4C 4D 38
 301+ 1CDA 30 43 20 44
 301+ 1CDE 4F 53 20 31
 301+ 1CE2 2E 30 33 20
 301+ 1CE6 20 4C 6F 61
 301+ 1CEA 64 65 64 0D
 301+ 1CEE 00
 302+ 1CEF
 303+ 1CEF 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 303+ 1CF3 72 79 20 74
 303+ 1CF7 6F 70 00
 304+ 1CFA
 305+ 1CFA              ; The following list reports all the functions supported by the interpreter.
 306+ 1CFA              ; To add a custom function, the user must first insert the reserved word here,
 307+ 1CFA              ; then into the list of the reserved words below, and finally must increment the
 308+ 1CFA              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 309+ 1CFA              ; function.
 310+ 1CFA
 311+ 1CFA              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 312+ 1CFA              ; this list must be coherent with the tokens' functions list. This means that every
 313+ 1CFA              ; entry here must have the corresponding entry in the tokens list.
 314+ 1CFA B8 38        FNCTAB: defw    SGN
 315+ 1CFC 4E 2E                defw    TMR         ; added by Leonardo Miliani
 316+ 1CFE 7C 39                defw    INT
 317+ 1D00 CE 38                defw    ABS_        ; '_' necessary to avoid assembler warnings
 318+ 1D02 64 80                defw    USR
 319+ 1D04 64 2E                defw    FRE
 320+ 1D06 DF 32                defw    INP
 321+ 1D08 92 2E                defw    POS
 322+ 1D0A 42 3B                defw    SQR
 323+ 1D0C 21 3C                defw    RND
 324+ 1D0E 0C 37                defw    LOG
 325+ 1D10 90 3B                defw    EXP
 326+ 1D12 96 3C                defw    COS
 327+ 1D14 9C 3C                defw    SIN
 328+ 1D16 FD 3C                defw    TAN
 329+ 1D18 12 3D                defw    ATN
 330+ 1D1A BB 33                defw    PEEK
 331+ 1D1C 7D 3D                defw    DEEK
 332+ 1D1E C2 33                defw    VPEEK       ; added by Leonardo Miliani
 333+ 1D20 91 35                defw    VSTAT       ; added by Leonardo Miliani
 334+ 1D22 9C 35                defw    SSTAT       ; added by Leonardo Miliani
 335+ 1D24 B0 35                defw    INKEY       ; added by Leonardo Miliani
 336+ 1D26 D6 40                defw    POINT       ; added by Leonardo Miliani
 337+ 1D28 76 31                defw    INSTR       ; added by Leonardo Miliani
 338+ 1D2A 16 31                defw    LEN
 339+ 1D2C 2E 2F                defw    STR
 340+ 1D2E A6 32                defw    VAL
 341+ 1D30 25 31                defw    ASC
 342+ 1D32 36 31                defw    CHR
 343+ 1D34 2C 4C                defw    HEX         ; added by Grant Searle
 344+ 1D36 BD 4C                defw    BIN         ; added by Grant Searle
 345+ 1D38 46 31                defw    LEFT
 346+ 1D3A 6C 32                defw    RIGHT
 347+ 1D3C 76 32                defw    MID
 348+ 1D3E
 349+ 1D3E              ; RESERVED WORD LIST
 350+ 1D3E              ; Here are all the reserved words used by the interpreter
 351+ 1D3E              ; To add custom functions/commands, the user must insert the keyword
 352+ 1D3E              ; in this list, following the schematic
 353+ 1D3E C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 354+ 1D41 C6 4F 52             defb    'F'+$80,"OR"
 355+ 1D44 CE 45 58 54          defb    'N'+$80,"EXT"
 356+ 1D48 C4 41 54 41          defb    'D'+$80,"ATA"
 357+ 1D4C C9 4E 50 55          defb    'I'+$80,"NPUT"
 357+ 1D50 54
 358+ 1D51 C4 49 4D             defb    'D'+$80,"IM"
 359+ 1D54 D2 45 41 44          defb    'R'+$80,"EAD"
 360+ 1D58 CC 45 54             defb    'L'+$80,"ET"
 361+ 1D5B C7 4F 54 4F          defb    'G'+$80,"OTO"
 362+ 1D5F D2 55 4E             defb    'R'+$80,"UN"
 363+ 1D62 C9 46                defb    'I'+$80,"F"
 364+ 1D64 D2 45 53 54          defb    'R'+$80,"ESTORE"
 364+ 1D68 4F 52 45
 365+ 1D6B C7 4F 53 55          defb    'G'+$80,"OSUB"
 365+ 1D6F 42
 366+ 1D70 D2 45 54 55          defb    'R'+$80,"ETURN"
 366+ 1D74 52 4E
 367+ 1D76 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 368+ 1D79 D3 54 4F 50          defb    'S'+$80,"TOP"
 369+ 1D7D CF 55 54             defb    'O'+$80,"UT"
 370+ 1D80 CF 4E                defb    'O'+$80,"N"
 371+ 1D82 C6 49 4C 45          defb    'F'+$80,"ILES"          ; added by Leonardo Miliani
 371+ 1D86 53
 372+ 1D87 C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 372+ 1D8B 45
 373+ 1D8C C4 49 53 4B          defb    'D'+$80,"ISK"           ; added by Leonardo Miliani
 374+ 1D90 D7 41 49 54          defb    'W'+$80,"AIT"
 375+ 1D94 C4 45 46             defb    'D'+$80,"EF"
 376+ 1D97 D0 4F 4B 45          defb    'P'+$80,"OKE"
 377+ 1D9B C4 4F 4B 45          defb    'D'+$80,"OKE"
 378+ 1D9F D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 378+ 1DA3 45
 379+ 1DA4 D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 380+ 1DA8 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 381+ 1DAC D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 381+ 1DB0 45 4E
 382+ 1DB2 CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 382+ 1DB6 54 45
 383+ 1DB8 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 383+ 1DBC 44
 384+ 1DBD D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 384+ 1DC1 4D 45
 385+ 1DC3 D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 385+ 1DC7 45
 386+ 1DC8 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 386+ 1DCC 52
 387+ 1DCD D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 388+ 1DD1 C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 389+ 1DD5 C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 389+ 1DD9 4C 45
 390+ 1DDB D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 390+ 1DDF 54
 391+ 1DE0 D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 391+ 1DE4 41 4C
 392+ 1DE6 C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 393+ 1DEA C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 394+ 1DED CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 395+ 1DF0 CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 396+ 1DF3 C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 396+ 1DF7 4E 54
 397+ 1DF9 D7 49 44 54          defb    'W'+$80,"IDTH"
 397+ 1DFD 48
 398+ 1DFE D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 399+ 1E01 D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 399+ 1E05 54
 400+ 1E06 C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 401+ 1E0A D0 52 49 4E          defb    'P'+$80,"RINT"
 401+ 1E0E 54
 402+ 1E0F C3 4F 4E 54          defb    'C'+$80,"ONT"
 403+ 1E13 CC 49 53 54          defb    'L'+$80,"IST"
 404+ 1E17 C3 4C 45 41          defb    'C'+$80,"LEAR"
 404+ 1E1B 52
 405+ 1E1C CC 4F 41 44          defb    'L'+$80,"OAD"
 406+ 1E20 D3 41 56 45          defb    'S'+$80,"AVE"
 407+ 1E24 CE 45 57             defb    'N'+$80,"EW"
 408+ 1E27 D4 41 42 28          defb    'T'+$80,"AB("
 409+ 1E2B D4 4F                defb    'T'+$80,"O"
 410+ 1E2D C6 4E                defb    'F'+$80,"N"
 411+ 1E2F D3 50 43 28          defb    'S'+$80,"PC("
 412+ 1E33 D4 48 45 4E          defb    'T'+$80,"HEN"
 413+ 1E37 CE 4F 54             defb    'N'+$80,"OT"
 414+ 1E3A D3 54 45 50          defb    'S'+$80,"TEP"
 415+ 1E3E                      ; from here: operators
 416+ 1E3E AB                   defb    '+'+$80
 417+ 1E3F AD                   defb    '-'+$80
 418+ 1E40 AA                   defb    '*'+$80
 419+ 1E41 AF                   defb    '/'+$80
 420+ 1E42 A5                   defb    '%'+$80
 421+ 1E43 A3                   defb    '#'+$80
 422+ 1E44 DE                   defb    '^'+$80
 423+ 1E45 C1 4E 44             defb    'A'+$80,"ND"
 424+ 1E48 D8 4F 52             defb    'X'+$80,"OR"
 425+ 1E4B CF 52                defb    'O'+$80,"R"
 426+ 1E4D BE                   defb    '>'+$80
 427+ 1E4E BD                   defb    '='+$80
 428+ 1E4F BC                   defb    '<'+$80
 429+ 1E50
 430+ 1E50                      ; from here there are the tokens' FUNCTIONS list
 431+ 1E50                      ; this list must be coherent with the functions list above
 432+ 1E50 D3 47 4E             defb    'S'+$80,"GN"
 433+ 1E53 D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 434+ 1E56 C9 4E 54             defb    'I'+$80,"NT"
 435+ 1E59 C1 42 53             defb    'A'+$80,"BS"
 436+ 1E5C D5 53 52             defb    'U'+$80,"SR"
 437+ 1E5F C6 52 45             defb    'F'+$80,"RE"
 438+ 1E62 C9 4E 50             defb    'I'+$80,"NP"
 439+ 1E65 D0 4F 53             defb    'P'+$80,"OS"
 440+ 1E68 D3 51 52             defb    'S'+$80,"QR"
 441+ 1E6B D2 4E 44             defb    'R'+$80,"ND"
 442+ 1E6E CC 4F 47             defb    'L'+$80,"OG"
 443+ 1E71 C5 58 50             defb    'E'+$80,"XP"
 444+ 1E74 C3 4F 53             defb    'C'+$80,"OS"
 445+ 1E77 D3 49 4E             defb    'S'+$80,"IN"
 446+ 1E7A D4 41 4E             defb    'T'+$80,"AN"
 447+ 1E7D C1 54 4E             defb    'A'+$80,"TN"
 448+ 1E80 D0 45 45 4B          defb    'P'+$80,"EEK"
 449+ 1E84 C4 45 45 4B          defb    'D'+$80,"EEK"
 450+ 1E88 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 450+ 1E8C 4B
 451+ 1E8D D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 451+ 1E91 54
 452+ 1E92 D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 452+ 1E96 54
 453+ 1E97 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 453+ 1E9B 59
 454+ 1E9C D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 454+ 1EA0 54
 455+ 1EA1 C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 455+ 1EA5 52
 456+ 1EA6 CC 45 4E             defb    'L'+$80,"EN"
 457+ 1EA9 D3 54 52 24          defb    'S'+$80,"TR$"
 458+ 1EAD D6 41 4C             defb    'V'+$80,"AL"
 459+ 1EB0 C1 53 43             defb    'A'+$80,"SC"
 460+ 1EB3 C3 48 52 24          defb    'C'+$80,"HR$"
 461+ 1EB7 C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 462+ 1EBB C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 463+ 1EBF CC 45 46 54          defb    'L'+$80,"EFT$"
 463+ 1EC3 24
 464+ 1EC4 D2 49 47 48          defb    'R'+$80,"IGHT$"
 464+ 1EC8 54 24
 465+ 1ECA CD 49 44 24          defb    'M'+$80,"ID$"
 466+ 1ECE 80                   defb    $80                     ; End-of-list marker
 467+ 1ECF
 468+ 1ECF              ; KEYWORD ADDRESS TABLE
 469+ 1ECF              ; this list must be coherent with the commands'
 470+ 1ECF              ; tokens list above
 471+ 1ECF 55 26        WORDTB: defw    PEND
 472+ 1ED1 52 25                defw    FOR
 473+ 1ED3 51 2A                defw    NEXT
 474+ 1ED5 B4 27                defw    DATA
 475+ 1ED7 4E 29                defw    INPUT
 476+ 1ED9 A6 2C                defw    DIM
 477+ 1EDB 88 29                defw    READ
 478+ 1EDD CB 27                defw    LET
 479+ 1EDF 71 27                defw    GOTO
 480+ 1EE1 4C 27                defw    RUN
 481+ 1EE3 43 28                defw    IF
 482+ 1EE5 1B 26                defw    RESTOR
 483+ 1EE7 60 27                defw    GOSUB
 484+ 1EE9 8F 27                defw    RETURN
 485+ 1EEB B6 27                defw    REM         ; original REM
 486+ 1EED 53 26                defw    STOP
 487+ 1EEF EB 32                defw    POUT
 488+ 1EF1 25 28                defw    ON
 489+ 1EF3 3F 4A                defw    FILES       ; changed by Leonardo Miliani - was NULL
 490+ 1EF5 76 4A                defw    ERASE       ; added by Leonardo Miliani
 491+ 1EF7 D6 4A                defw    DISK        ; added by Leonardo Miliani
 492+ 1EF9 F1 32                defw    WAIT
 493+ 1EFB 9A 2E                defw    DEF
 494+ 1EFD E5 33                defw    POKE
 495+ 1EFF 88 3D                defw    DOKE
 496+ 1F01 EA 33                defw    VPOKE       ; added by Leonardo Miliani
 497+ 1F03 27 34                defw    SREG        ; added by Leonardo Miliani
 498+ 1F05 75 35                defw    VREG        ; added by Leonardo Miliani
 499+ 1F07 BE 3D                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 500+ 1F09 F5 33                defw    LOCATE      ; added by Leonardo Miliani
 501+ 1F0B 81 34                defw    SOUND       ; added by Leonardo Miliani
 502+ 1F0D 48 34                defw    VOLUME      ; added by Leonardo Miliani
 503+ 1F0F 9F 3D                defw    PAUSE       ; added by Leonardo Miliani
 504+ 1F11 39 3E                defw    COLOR       ; added by Leonardo Miliani
 505+ 1F13 29 41                defw    PLOT        ; added by Leonardo Miliani
 506+ 1F15 BC 41                defw    DRAW        ; added by Leonardo Miliani
 507+ 1F17 F5 42                defw    CIRCLE      ; added by Leonardo Miliani
 508+ 1F19 E6 3F                defw    PAINT       ; added by Leonardo Miliani
 509+ 1F1B 00 45                defw    SERIAL      ; added by Leonardo Miliani
 510+ 1F1D 3F 47                defw    HELP        ; changed by Leonardo Miliani - was LINES
 511+ 1F1F 61 3D                defw    CLS
 512+ 1F21 5D 47                defw    KEY         ; added by Leonardo Miliani
 513+ 1F23 33 33                defw    NMI         ; added by Leonardo Miliani
 514+ 1F25 F5 3E                defw    GPRINT      ; added by Leonardo Miliani
 515+ 1F27 75 3D                defw    WIDTH
 516+ 1F29 8D 33                defw    SYS         ; added by Leonardo Miliani
 517+ 1F2B 22 4D                defw    RESET       ; new behaviour: now it resets the system
 518+ 1F2D B8 27                defw    REM+2       ; ELSE: added by Leonardo Miliani
 519+ 1F2F 75 28                defw    PRINT
 520+ 1F31 87 26                defw    CONT
 521+ 1F33 29 24                defw    LIST
 522+ 1F35 00 27                defw    CLEAR
 523+ 1F37 D4 48                defw    LOAD        ; re-implemented by Leonardo Miliani (was CLOAD)
 524+ 1F39 71 49                defw    SAVE        ; re-implemented by Leonardo Miliani (was CSAVE)
 525+ 1F3B FE 21                defw    NEW
 526+ 1F3D
 527+ 1F3D              ; RESERVED WORD TOKEN VALUES
 528+ 1F3D              ; if you add a function or command you must increment by 1
 529+ 1F3D              ; the values below. Pay attention that you must increment only the
 530+ 1F3D              ; values AFTER the position where you entered the function/command word
 531+ 1F3D              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 532+ 1F3D              ; DOKE and SCREEN, and since REM is the reserved work listed below
 533+ 1F3D              ; that is before the point where VPOKE has been entered, every entry
 534+ 1F3D              ; after REM has been incremented.
 535+ 1F3D              ; Another example: when TMR has been added, since it's a function, every
 536+ 1F3D              ; entry after & included ZSGN must be checked (read below)
 537+ 1F3D
 538+ 1F3D              ZEND    equ     $80             ; END        <-- from here, there are the commands
 539+ 1F3D              ZFOR    equ     $81             ; FOR
 540+ 1F3D              ZDATA   equ     $83             ; DATA
 541+ 1F3D              ZGOTO   equ     $88             ; GOTO
 542+ 1F3D              ZGOSUB  equ     $8C             ; GOSUB
 543+ 1F3D              ZREM    equ     $8E             ; REM
 544+ 1F3D              ZELSE   equ     $AF             ; ELSE
 545+ 1F3D              ZPRINT  equ     $B0             ; PRINT
 546+ 1F3D              ZNEW    equ     $B6             ; NEW
 547+ 1F3D
 548+ 1F3D              ZTAB    equ     $B7             ; TAB
 549+ 1F3D              ZTO     equ     $B8             ; TO
 550+ 1F3D              ZFN     equ     $B9             ; FN
 551+ 1F3D              ZSPC    equ     $BA             ; SPC
 552+ 1F3D              ZTHEN   equ     $BB             ; THEN
 553+ 1F3D              ZNOT    equ     $BC             ; NOT
 554+ 1F3D              ZSTEP   equ     $BD             ; STEP
 555+ 1F3D
 556+ 1F3D              ZPLUS   equ     $BE             ; +         <-- from here, there are the math operators
 557+ 1F3D              ZMINUS  equ     $BF             ; -
 558+ 1F3D              ZTIMES  equ     $C0             ; *
 559+ 1F3D              ZDIV    equ     $C1             ; /
 560+ 1F3D              ZMOD    equ     $C2             ; %
 561+ 1F3D              ZDINT   equ     $C3             ; #
 562+ 1F3D              ZOR     equ     $C7             ; OR
 563+ 1F3D              ZGTR    equ     $C8             ; >
 564+ 1F3D              ZEQUAL  equ     $C9             ; M
 565+ 1F3D              ZLTH    equ     $CA             ; <
 566+ 1F3D
 567+ 1F3D              ZSGN    equ     $CB             ; SGN       <-- from here, there are the functions
 568+ 1F3D              ZPOINT  equ     $E1             ; ZPOINT    <-- if the user enters a custom function, between
 569+ 1F3D                                              ;               SGN and POINT, he/she must increment this pointer by 1
 570+ 1F3D              ZINSTR  equ     $E2             ; ZINSTR    <-- same here
 571+ 1F3D              ZLEFT   equ     $EA             ; LEFT$     <-- if the user enters a custom function anywhere,
 572+ 1F3D                                              ;               he/she must increment this pointer by 1
 573+ 1F3D
 574+ 1F3D              ; ARITHMETIC PRECEDENCE TABLE
 575+ 1F3D              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 576+ 1F3D              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 577+ 1F3D 79           PRITAB: defb    $79             ; Precedence value
 578+ 1F3E 2A 3A                defw    PADD            ; FPREG = <last> + FPREG
 579+ 1F40
 580+ 1F40 79                   defb    $79             ; Precedence value
 581+ 1F41 0D 36                defw    PSUB            ; FPREG = <last> - FPREG
 582+ 1F43
 583+ 1F43 7C                   defb    $7C             ; Precedence value
 584+ 1F44 4B 37                defw    MULT            ; PPREG = <last> * FPREG
 585+ 1F46
 586+ 1F46 7C                   defb    $7C             ; Precedence value
 587+ 1F47 FD 37                defw    DIV             ; FPREG = <last> / FPREG
 588+ 1F49
 589+ 1F49 7C                   defb    $7C             ; Precedence value
 590+ 1F4A A8 37                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 591+ 1F4C
 592+ 1F4C 7C                   defb    $7C             ; precedence value
 593+ 1F4D A0 37                defw    DINT            ; FPREG = INT(<last> / FPREG )
 594+ 1F4F
 595+ 1F4F 7F                   defb    $7F             ; Precedence value
 596+ 1F50 4B 3B                defw    POWER           ; FPREG = <last> ^ FPREG
 597+ 1F52
 598+ 1F52 50                   defb    $50             ; Precedence value
 599+ 1F53 EF 2B                defw    PAND            ; FPREG = <last> AND FPREG
 600+ 1F55
 601+ 1F55 4A                   defb    $4A             ; Precedence value
 602+ 1F56 F7 2B                defw    PXOR            ; FPREG = <last> XOR FPREG
 603+ 1F58
 604+ 1F58 46                   defb    $46             ; Precedence value
 605+ 1F59 F2 2B                defw    POR             ; FPREG = <last> OR FPREG
 606+ 1F5B
 607+ 1F5B
 608+ 1F5B              ; INITIALISATION TABLE -------------------------------------------------------
 609+ 1F5B              ; these values are copied into RAM at startup
 610+ 1F5B C3 6B 1C     INITAB: jp      WARMST          ; Warm start jump
 611+ 1F5E ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 612+ 1F61 C3 D6 26             jp      FCERR           ; "USR (X)" jump (Set to Error)
 613+ 1F64 D3 00                out     (0),A           ; "out p,n" skeleton
 614+ 1F66 C9                   ret
 615+ 1F67 D6 00                sub     $00             ; Division support routine
 616+ 1F69 6F                   ld      L,A
 617+ 1F6A 7C                   ld      A,H
 618+ 1F6B DE 00                sbc     A,$00
 619+ 1F6D 67                   ld      H,A
 620+ 1F6E 78                   ld      A,B
 621+ 1F6F DE 00                sbc     A,$00
 622+ 1F71 47                   ld      B,A
 623+ 1F72 3E 00                ld      A,$00
 624+ 1F74 C9                   ret
 625+ 1F75 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 626+ 1F78 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 627+ 1F7C 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 628+ 1F80 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 629+ 1F84 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 630+ 1F88 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 631+ 1F8C 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 632+ 1F90 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 633+ 1F94 D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 634+ 1F98 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 635+ 1F9C DB 00                in      A,($00)         ; INP (x) skeleton
 636+ 1F9E C9                   ret
 637+ 1F9F FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 638+ 1FA0 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 639+ 1FA1 00                   defb    $00             ; No nulls after input bytes
 640+ 1FA2 00                   defb    $00             ; Output enabled (^O off)
 641+ 1FA3 00 00                defw    $00             ; Array load/save check sum
 642+ 1FA5 00                   defb    $00             ; Break not by NMI
 643+ 1FA6 00                   defb    $00             ; Break flag
 644+ 1FA7 C3 42 23             jp      TTYLIN          ; Input reflection (set to TTY)
 645+ 1FAA D3 82                defw    STLOOK          ; Temp string space
 646+ 1FAC FE FF                defw    -2              ; Current line number (cold)
 647+ 1FAE FF FF                defw    -1              ; Current line with errors (no errors)
 648+ 1FB0 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 649+ 1FB1 08                   defb    $08             ; auto-repeat delay
 650+ 1FB2 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 650+ 1FB6 0D 00 00 00
 650+ 1FBA 00 00 00 00
 650+ 1FBE 00 00 00 00
 651+ 1FC2 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 651+ 1FC6 00 00 00 00
 651+ 1FCA 00 00 00 00
 651+ 1FCE 00 00 00 00
 652+ 1FD2 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 652+ 1FD6 45 4E 31 0D
 652+ 1FDA 00 00 00 00
 652+ 1FDE 00 00 00 00
 653+ 1FE2 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 653+ 1FE6 52 31 2C 31
 653+ 1FEA 35 2C 35 0D
 653+ 1FEE 00 00 00 00
 654+ 1FF2 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 654+ 1FF6 41 4C 31 2C
 654+ 1FFA 33 38 34 30
 654+ 1FFE 30 0D 00 00
 655+ 2002 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 655+ 2006 45 4E 32 0D
 655+ 200A 00 00 00 00
 655+ 200E 00 00 00 00
 656+ 2012 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 656+ 2016 0D 00 00 00
 656+ 201A 00 00 00 00
 656+ 201E 00 00 00 00
 657+ 2022 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 657+ 2026 0D 00 00 00
 657+ 202A 00 00 00 00
 657+ 202E 00 00 00 00
 658+ 2032 70 82                defw    PROGST+1        ; Start of program text
 659+ 2034              INITBE:
 660+ 2034
 661+ 2034              ; END OF INITIALISATION TABLE ---------------------------------------------------
 662+ 2034
 663+ 2034 20 45 72 72  ERRMSG: defb    " Error",0
 663+ 2038 6F 72 00
 664+ 203B 20 69 6E 20  INMSG:  defb    " in ",0
 664+ 203F 00
 665+ 2040              ZERBYT  equ     $-1             ; A zero byte
 666+ 2040 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 666+ 2044 00
 667+ 2045 42 72 65 61  BRKMSG: defb    "Break",0
 667+ 2049 6B 00
 668+ 204B
 669+ 204B 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 670+ 204E 39                   add     HL,SP           ; same index as specified
 671+ 204F 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 672+ 2050 23                   inc     HL              ; Point to index address
 673+ 2051 FE 81                cp      ZFOR            ; Is it a "FOR" token
 674+ 2053 C0                   ret     NZ              ; No - exit
 675+ 2054 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 676+ 2055 23                   inc     HL
 677+ 2056 46                   ld      B,(HL)
 678+ 2057 23                   inc     HL              ; Point to sign of STEP
 679+ 2058 E5                   push    HL              ; Save pointer to sign
 680+ 2059 69                   ld      L,C             ; HL = address of "FOR" index
 681+ 205A 60                   ld      H,B
 682+ 205B 7A                   ld      A,D             ; See if an index was specified
 683+ 205C B3                   or      E               ; DE = 0 if no index specified
 684+ 205D EB                   ex      DE,HL           ; Specified index into HL
 685+ 205E CA 65 20             jp      Z,INDFND        ; Skip if no index given
 686+ 2061 EB                   ex      DE,HL           ; Index back into DE
 687+ 2062 CD BC 23             call    CPDEHL          ; Compare index with one given
 688+ 2065 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 689+ 2068 E1                   pop     HL              ; Restore pointer to sign
 690+ 2069 C8                   ret     Z               ; Return if block found
 691+ 206A 09                   add     HL,BC           ; Point to next block
 692+ 206B C3 4F 20             jp      LOKFOR          ; Keep on looking
 693+ 206E
 694+ 206E CD 88 20     MOVUP:  call    ENFMEM          ; See if enough memory
 695+ 2071 C5           MOVSTR: push    BC              ; Save end of source
 696+ 2072 E3                   ex      (SP),HL         ; Swap source and dest" end
 697+ 2073 C1                   pop     BC              ; Get end of destination
 698+ 2074 CD BC 23     MOVLP:  call    CPDEHL          ; See if list moved
 699+ 2077 7E                   ld      A,(HL)          ; Get byte
 700+ 2078 02                   ld      (BC),A          ; Move it
 701+ 2079 C8                   ret     Z               ; Exit if all done
 702+ 207A 0B                   dec     BC              ; Next byte to move to
 703+ 207B 2B                   dec     HL              ; Next byte to move
 704+ 207C C3 74 20             jp      MOVLP           ; Loop until all bytes moved
 705+ 207F
 706+ 207F E5           CHKSTK: push    HL              ; Save code string address
 707+ 2080 2A 50 82             ld      HL,(ARREND)     ; Lowest free memory
 708+ 2083 06 00                ld      B,$00           ; BC = Number of levels to test
 709+ 2085 09                   add     HL,BC           ; 2 Bytes for each level
 710+ 2086 09                   add     HL,BC
 711+ 2087 3E                   defb    $3E             ; Skip "push HL"
 712+ 2088 E5           ENFMEM: push    HL              ; Save code string address
 713+ 2089 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 714+ 208B 95                   sub     L
 715+ 208C 6F                   ld      L,A
 716+ 208D 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 717+ 208F 9C                   sbc     A,H
 718+ 2090 DA 97 20             jp      C,OMERR         ; Not enough - ?OM Error
 719+ 2093 67                   ld      H,A
 720+ 2094 39                   add     HL,SP           ; Test if stack is overflowed
 721+ 2095 E1                   pop     HL              ; Restore code string address
 722+ 2096 D8                   ret     C               ; Return if enough memory
 723+ 2097 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 724+ 2099 C3 DC 20             jp      ERROR
 725+ 209C
 726+ 209C
 727+ 209C              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 728+ 209C F5           EXITGM: push    AF              ; store AF
 729+ 209D 3A F8 81             ld      A,(SCR_MODE)    ; check screen mode
 730+ 20A0 FE 02                cp      $02             ; G2?
 731+ 20A2 CA A9 20             jp      Z,LDG1          ; yes, back to G1
 732+ 20A5 FE 03                cp      $03             ; G3?
 733+ 20A7 20 11                jr      NZ,LDG1ND       ; no, so return
 734+ 20A9 E5           LDG1:   push    HL              ; store HL
 735+ 20AA D5                   push    DE              ; store DE
 736+ 20AB 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 737+ 20AE F3                   di                      ; disable INTs
 738+ 20AF CD ED 03             call    initVDP         ; initialize VDP with mode pointed by E
 739+ 20B2 FB                   ei                      ; re-enable INTs
 740+ 20B3 3E 01                ld      A,$01           ; activate the...
 741+ 20B5 32 02 82             ld      (PRNTVIDEO),A   ; ...video buffer...
 742+ 20B8 D1                   pop     DE              ; retrieve DE
 743+ 20B9 E1                   pop     HL              ; retrieve HL
 744+ 20BA F1           LDG1ND: pop     AF              ; retrieve AF
 745+ 20BB C9                   ret                     ; return to caller
 746+ 20BC
 747+ 20BC
 748+ 20BC 2A D9 81     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 749+ 20BF 22 AF 80             ld      (LINEAT),HL     ; Save as current line
 750+ 20C2 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 751+ 20C4 01                   defb    $01             ; Skip "ld E,DZ"
 752+ 20C5 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 753+ 20C7 01                   defb    $01             ; Skip "ld E,NF"
 754+ 20C8 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 755+ 20CA 01                   defb    $01             ; Skip "ld E,DD"
 756+ 20CB 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 757+ 20CD 01                   defb    $01             ; Skip "ld E,UF"
 758+ 20CE 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 759+ 20D0 01                   defb    $01             ; Skip "ld E,OV
 760+ 20D1 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 761+ 20D3 01                   defb    $01             ; Skip "ld E,TM"
 762+ 20D4 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 763+ 20D6 01                   defb    $01             ; Skip next statement
 764+ 20D7 1E 34        IMERR:  ld      E,IM            ; ?Illegal indirect mode error
 765+ 20D9 01                   defb    $01             ; Skip next statement
 766+ 20DA 1E 36        NRERR:  ld      E,NR            ; ?Device not ready error
 767+ 20DC
 768+ 20DC CD 24 22     ERROR:  call    CLREG           ; Clear registers and stack
 769+ 20DF CD 9C 20             call    EXITGM          ; exit from graphic modes
 770+ 20E2 32 A5 80             ld      (CTLOFG),A      ; Enable output (A is 0)
 771+ 20E5 CD 44 09             call    CURSOR_ON       ; enable cursor
 772+ 20E8 CD C6 28             call    STTLIN          ; Start new line
 773+ 20EB 21 0A 19             ld      HL,ERRTBL       ; Point to error codes
 774+ 20EE 57                   ld      D,A             ; D = 0 (A is 0)
 775+ 20EF 3E 3F                ld      A,'?'
 776+ 20F1 CD CD 23             call    OUTC            ; Output '?'
 777+ 20F4 19                   add     HL,DE           ; Offset to correct error code
 778+ 20F5 5E                   ld      E,(HL)          ; load pointer to error message
 779+ 20F6 23                   inc     HL              ; by loading LSB,
 780+ 20F7 56                   ld      D,(HL)          ; then MSB
 781+ 20F8 62 6B                ld      HL,DE           ; load pointer to HL
 782+ 20FA CD A4 2F             call    PRS             ; Output error message
 783+ 20FD 21 34 20             ld      HL,ERRMSG       ; "Error" message
 784+ 2100 CD A4 2F     ERRIN:  call    PRS             ; Output message
 785+ 2103 2A AF 80             ld      HL,(LINEAT)     ; Get line of error
 786+ 2106 11 FE FF             ld      DE,-2           ; Cold start error if -2
 787+ 2109 CD BC 23             call    CPDEHL          ; See if cold start error
 788+ 210C CA AA 1B             jp      Z,CSTART        ; Cold start error - Restart
 789+ 210F 7C                   ld      A,H             ; Was it a direct error?
 790+ 2110 A5                   and     L               ; Line = -1 if direct error
 791+ 2111 3C                   inc     A
 792+ 2112 CA 1D 21             jp      Z,PTLN          ; Yes, jump over
 793+ 2115 E5                   push    HL              ; indirect mode - store HL
 794+ 2116 2A AF 80             ld      HL,(LINEAT)     ; copy current line number
 795+ 2119 22 B1 80             ld      (HLPLN),HL      ; save in HELP line register
 796+ 211C E1                   pop     HL              ; retrieve HL
 797+ 211D C4 3B 3A     PTLN:   call    NZ,LINEIN       ; No - output line of error
 798+ 2120
 799+ 2120 3E                   defb    $3E             ; Skip "pop BC"
 800+ 2121 C1           POPNOK: pop     BC              ; Drop address in input buffer
 801+ 2122
 802+ 2122              ; run into direct mode: print OK and get command
 803+ 2122 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 804+ 2123 32 A5 80             ld      (CTLOFG),A      ; Enable output
 805+ 2126 CD C6 28             call    STTLIN          ; Start new line
 806+ 2129 21 40 20             ld      HL,OKMSG        ; "Ok" message
 807+ 212C CD A4 2F             call    PRS             ; Output "Ok"
 808+ 212F CD 44 09     GETCMD: call    CURSOR_ON       ; enable cursor
 809+ 2132 3A 48 82             ld      A,(SERIALS_EN)  ; load serial state
 810+ 2135 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 811+ 2137 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 812+ 213A 21 FF FF             ld      HL,-1           ; Flag direct mode
 813+ 213D 22 AF 80             ld      (LINEAT),HL     ; Save as current line
 814+ 2140 CD 42 23             call    GETLIN          ; Get an input line
 815+ 2143 DA 2F 21             jp      C,GETCMD        ; Get line again if break
 816+ 2146 CD 0B 26             call    GETCHR          ; Get first character
 817+ 2149 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 818+ 214A DA C2 20             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 819+ 214D 1F                   rra                     ; recover original char and Carry
 820+ 214E 3C                   inc     A               ; Test if end of line
 821+ 214F 3D                   dec     A               ; Without affecting Carry
 822+ 2150 CA 2F 21             jp      Z,GETCMD        ; Nothing entered - Get another
 823+ 2153 F5                   push    AF              ; Save Carry status
 824+ 2154 3A 48 82             ld      A,(SERIALS_EN)  ; load serial state
 825+ 2157 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 826+ 2159 CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
 827+ 215C CD 59 09             call    CURSOR_OFF      ; cursor disabled
 828+ 215F CD DB 26             call    ATOH            ; Get line number into DE
 829+ 2162 D5                   push    DE              ; Save line number
 830+ 2163 CD 59 22             call    CRUNCH          ; Tokenise rest of line
 831+ 2166 47                   ld      B,A             ; Length of tokenised line
 832+ 2167 D1                   pop     DE              ; Restore line number
 833+ 2168 F1                   pop     AF              ; Restore Carry
 834+ 2169 D2 EB 25             jp      NC,EXCUTE       ; No line number - Direct mode
 835+ 216C D5                   push    DE              ; Save line number
 836+ 216D C5                   push    BC              ; Save length of tokenised line
 837+ 216E AF                   xor     A
 838+ 216F 32 DC 81             ld      (LSTBIN),A      ; Clear last byte input
 839+ 2172 CD 0B 26             call    GETCHR          ; Get next character
 840+ 2175 B7                   or      A               ; Set flags
 841+ 2176 F5                   push    AF              ; And save them
 842+ 2177 CD DE 21             call    SRCHLN          ; Search for line number in DE
 843+ 217A DA 83 21             jp      C,LINFND        ; Jump if line found
 844+ 217D F1                   pop     AF              ; Get status
 845+ 217E F5                   push    AF              ; And re-save
 846+ 217F CA 8A 27             jp      Z,ULERR         ; Nothing after number - Error
 847+ 2182 B7                   or      A               ; Clear Carry
 848+ 2183 C5           LINFND: push    BC              ; Save address of line in prog
 849+ 2184 D2 9A 21             jp      NC,INEWLN       ; Line not found - Insert new
 850+ 2187 EB                   ex      DE,HL           ; Next line address in DE
 851+ 2188 2A 4C 82             ld      HL,(PROGND)     ; End of program
 852+ 218B 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 853+ 218C 02                   ld      (BC),A
 854+ 218D 03                   inc     BC              ; Next destination
 855+ 218E 13                   inc     DE              ; Next source
 856+ 218F CD BC 23             call    CPDEHL          ; All done?
 857+ 2192 C2 8B 21             jp      NZ,SFTPRG       ; More to do
 858+ 2195 60                   ld      H,B             ; HL - New end of program
 859+ 2196 69                   ld      L,C
 860+ 2197 22 4C 82             ld      (PROGND),HL     ; Update end of program
 861+ 219A
 862+ 219A D1           INEWLN: pop     DE              ; Get address of line,
 863+ 219B F1                   pop     AF              ; Get status
 864+ 219C CA C1 21             jp      Z,SETPTR        ; No text - Set up pointers
 865+ 219F 2A 4C 82             ld      HL,(PROGND)     ; Get end of program
 866+ 21A2 E3                   ex      (SP),HL         ; Get length of input line
 867+ 21A3 C1                   pop     BC              ; End of program to BC
 868+ 21A4 09                   add     HL,BC           ; Find new end
 869+ 21A5 E5                   push    HL              ; Save new end
 870+ 21A6 CD 6E 20             call    MOVUP           ; Make space for line
 871+ 21A9 E1                   pop     HL              ; Restore new end
 872+ 21AA 22 4C 82             ld      (PROGND),HL     ; Update end of program pointer
 873+ 21AD EB                   ex      DE,HL           ; Get line to move up in HL
 874+ 21AE 74                   ld      (HL),H          ; Save MSB
 875+ 21AF D1                   pop     DE              ; Get new line number
 876+ 21B0 23                   inc     HL              ; Skip pointer
 877+ 21B1 23                   inc     HL
 878+ 21B2 73                   ld      (HL),E          ; Save LSB of line number
 879+ 21B3 23                   inc     HL
 880+ 21B4 72                   ld      (HL),D          ; Save MSB of line number
 881+ 21B5 23                   inc     HL              ; To first byte in line
 882+ 21B6 11 38 81             ld      DE,BUFFER       ; Copy buffer to program
 883+ 21B9 1A           MOVBUF: ld      A,(DE)          ; Get source
 884+ 21BA 77                   ld      (HL),A          ; Save destinations
 885+ 21BB 23                   inc     HL              ; Next source
 886+ 21BC 13                   inc     DE              ; Next destination
 887+ 21BD B7                   or      A               ; Done?
 888+ 21BE C2 B9 21             jp      NZ,MOVBUF       ; No - Repeat
 889+ 21C1 CD 0A 22     SETPTR: call    RUNFST          ; Set line pointers
 890+ 21C4 23                   inc     HL              ; To LSB of pointer
 891+ 21C5 EB                   ex      DE,HL           ; Address to DE
 892+ 21C6 62           PTRLP:  ld      H,D             ; Address to HL
 893+ 21C7 6B                   ld      L,E
 894+ 21C8 7E                   ld      A,(HL)          ; Get LSB of pointer
 895+ 21C9 23                   inc     HL              ; To MSB of pointer
 896+ 21CA B6                   or      (HL)            ; Compare with MSB pointer
 897+ 21CB CA 2F 21             jp      Z,GETCMD        ; Get command line if end
 898+ 21CE 23                   inc     HL              ; To LSB of line number
 899+ 21CF 23                   inc     HL              ; Skip line number
 900+ 21D0 23                   inc     HL              ; Point to first byte in line
 901+ 21D1 AF                   xor     A               ; Looking for 00 byte
 902+ 21D2 BE           FNDEND: cp      (HL)            ; Found end of line?
 903+ 21D3 23                   inc     HL              ; Move to next byte
 904+ 21D4 C2 D2 21             jp      NZ,FNDEND       ; No - Keep looking
 905+ 21D7 EB                   ex      DE,HL           ; Next line address to HL
 906+ 21D8 73                   ld      (HL),E          ; Save LSB of pointer
 907+ 21D9 23                   inc     HL
 908+ 21DA 72                   ld      (HL),D          ; Save MSB of pointer
 909+ 21DB C3 C6 21             jp      PTRLP           ; Do next line
 910+ 21DE
 911+ 21DE 2A 35 81     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 912+ 21E1 44           SRCHLP: ld      B,H             ; BC = Address to look at
 913+ 21E2 4D                   ld      C,L
 914+ 21E3 7E                   ld      A,(HL)          ; Get address of next line
 915+ 21E4 23                   inc     HL
 916+ 21E5 B6                   or      (HL)            ; End of program found?
 917+ 21E6 2B                   dec     HL
 918+ 21E7 C8                   ret     Z               ; Yes - Line not found
 919+ 21E8 23                   inc     HL
 920+ 21E9 23                   inc     HL
 921+ 21EA 7E                   ld      A,(HL)          ; Get LSB of line number
 922+ 21EB 23                   inc     HL
 923+ 21EC 66                   ld      H,(HL)          ; Get MSB of line number
 924+ 21ED 6F                   ld      L,A
 925+ 21EE CD BC 23             call    CPDEHL          ; Compare with line in DE
 926+ 21F1 60                   ld      H,B             ; HL = Start of this line
 927+ 21F2 69                   ld      L,C
 928+ 21F3 7E                   ld      A,(HL)          ; Get LSB of next line address
 929+ 21F4 23                   inc     HL
 930+ 21F5 66                   ld      H,(HL)          ; Get MSB of next line address
 931+ 21F6 6F                   ld      L,A             ; Next line to HL
 932+ 21F7 3F                   ccf
 933+ 21F8 C8                   ret     Z               ; Lines found - Exit
 934+ 21F9 3F                   ccf
 935+ 21FA D0                   ret     NC              ; Line not found,at line after
 936+ 21FB C3 E1 21             jp      SRCHLP          ; Keep looking
 937+ 21FE
 938+ 21FE C0           NEW:    ret     NZ              ; Return if any more on line
 939+ 21FF 2A 35 81     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 940+ 2202 AF                   xor     A               ; Set program area to empty
 941+ 2203 77                   ld      (HL),A          ; Save LSB = 00
 942+ 2204 23                   inc     HL
 943+ 2205 77                   ld      (HL),A          ; Save MSB = 00
 944+ 2206 23                   inc     HL
 945+ 2207 22 4C 82             ld      (PROGND),HL     ; Set program end
 946+ 220A
 947+ 220A 2A 35 81     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 948+ 220D 2B                   dec     HL
 949+ 220E
 950+ 220E 22 DE 81     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 951+ 2211 2A 96 81             ld      HL,(LSTRAM)     ; Get end of RAM
 952+ 2214 22 D3 81             ld      (STRBOT),HL     ; Clear string space
 953+ 2217 AF                   xor     A
 954+ 2218 CD 1B 26             call    RESTOR          ; Reset DATA pointers
 955+ 221B 2A 4C 82             ld      HL,(PROGND)     ; Get end of program
 956+ 221E 22 4E 82             ld      (VAREND),HL     ; Clear variables
 957+ 2221 22 50 82             ld      (ARREND),HL     ; Clear arrays
 958+ 2224
 959+ 2224 C1           CLREG:  pop     BC              ; Save return address
 960+ 2225 2A AD 80             ld      HL,(STRSPC)     ; Get end of working RAM
 961+ 2228 F9                   ld      SP,HL           ; Set stack
 962+ 2229 21 C3 81             ld      HL,TMSTPL       ; Temporary string pool
 963+ 222C 22 C1 81             ld      (TMSTPT),HL     ; Reset temporary string ptr
 964+ 222F AF                   xor     A               ; A = 00
 965+ 2230 6F                   ld      L,A             ; HL = 0000
 966+ 2231 67                   ld      H,A
 967+ 2232 22 E4 81             ld      (CONTAD),HL     ; No CONTinue
 968+ 2235 32 DB 81             ld      (FORFLG),A      ; Clear FOR flag
 969+ 2238 22 54 82             ld      (FNRGNM),HL     ; Clear FN argument
 970+ 223B E5                   push    HL              ; HL = 0000
 971+ 223C C5                   push    BC              ; Put back return
 972+ 223D 2A DE 81     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 973+ 2240 C9                   ret                     ; Return to execution driver
 974+ 2241
 975+ 2241 3E 3F        PROMPT: ld      A,'?'           ; '?'
 976+ 2243 CD CD 23             call    OUTC            ; Output character
 977+ 2246 3E 00                ld      A,NLLCR         ; null char
 978+ 2248 CD CD 23             call    OUTC            ; Output character
 979+ 224B CD 44 09             call    CURSOR_ON       ; enable cursor
 980+ 224E 3A 48 82             ld      A,(SERIALS_EN)  ; load serial state
 981+ 2251 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
 982+ 2253 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
 983+ 2256 C3 AA 80             jp      RINPUT          ; Get input line
 984+ 2259
 985+ 2259 AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
 986+ 225A 32 95 81             ld      (DATFLG),A      ; Reset literal flag
 987+ 225D 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
 988+ 225F 11 38 81             ld      DE,BUFFER       ; Start of input buffer
 989+ 2262 7E           CRNCLP: ld      A,(HL)          ; Get byte
 990+ 2263 FE 20                cp      SPC             ; Is it a space?
 991+ 2265 CA E1 22             jp      Z,MOVDIR        ; Yes - Copy direct
 992+ 2268 47                   ld      B,A             ; Save character
 993+ 2269 FE 22                cp      $22             ; '"'             ; Is it a quote?
 994+ 226B CA 01 23             jp      Z,CPYLIT        ; Yes - Copy literal string
 995+ 226E B7                   or      A               ; Is it end of buffer?
 996+ 226F CA 08 23             jp      Z,ENDBUF        ; Yes - End buffer
 997+ 2272 3A 95 81             ld      A,(DATFLG)      ; Get data type
 998+ 2275 B7                   or      A               ; Literal?
 999+ 2276 7E                   ld      A,(HL)          ; Get byte to copy
1000+ 2277 C2 E1 22             jp      NZ,MOVDIR       ; Literal - Copy direct
1001+ 227A FE 3F                cp      '?'             ; Is it '?' short for PRINT
1002+ 227C 3E B0                ld      A,ZPRINT        ; "PRINT" token
1003+ 227E CA E1 22             jp      Z,MOVDIR        ; Yes - replace it
1004+ 2281 7E                   ld      A,(HL)          ; Get byte again
1005+ 2282 FE 30                cp      '0'             ; Is it less than '0'
1006+ 2284 DA 8C 22             jp      C,FNDWRD        ; Yes - Look for reserved words
1007+ 2287 FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
1008+ 2289 DA E1 22             jp      C,MOVDIR        ; Yes - copy it direct
1009+ 228C D5           FNDWRD: push    DE              ; Look for reserved words
1010+ 228D 11 3D 1D             ld      DE,WORDS-1      ; Point to table
1011+ 2290 C5                   push    BC              ; Save count
1012+ 2291 01 DD 22             ld      BC,RETNAD       ; Where to return to
1013+ 2294 C5                   push    BC              ; Save return address
1014+ 2295 06 7F                ld      B,ZEND-1        ; First token value -1
1015+ 2297 7E                   ld      A,(HL)          ; Get byte
1016+ 2298 FE 61                cp      'a'             ; Less than 'a' ?
1017+ 229A DA A5 22             jp      C,SEARCH        ; Yes - search for words
1018+ 229D FE 7B                cp      'z'+1           ; Greater than 'z' ?
1019+ 229F D2 A5 22             jp      NC,SEARCH       ; Yes - search for words
1020+ 22A2 E6 5F                and     %01011111       ; Force upper case
1021+ 22A4 77                   ld      (HL),A          ; Replace byte
1022+ 22A5 4E           SEARCH: ld      C,(HL)          ; Search for a word
1023+ 22A6 EB                   ex      DE,HL
1024+ 22A7 23           GETNXT: inc     HL              ; Get next reserved word
1025+ 22A8 B6                   or      (HL)            ; Start of word?
1026+ 22A9 F2 A7 22             jp      P,GETNXT        ; No - move on
1027+ 22AC 04                   inc     B               ; Increment token value
1028+ 22AD 7E                   ld      A,(HL)          ; Get byte from table
1029+ 22AE E6 7F                and     %01111111       ; Strip bit 7
1030+ 22B0 C8                   ret     Z               ; Return if end of list
1031+ 22B1 B9                   cp      C               ; Same character as in buffer?
1032+ 22B2 C2 A7 22             jp      NZ,GETNXT       ; No - get next word
1033+ 22B5 EB                   ex      DE,HL
1034+ 22B6 E5                   push    HL              ; Save start of word
1035+ 22B7
1036+ 22B7 13           NXTBYT: inc     DE              ; Look through rest of word
1037+ 22B8 1A                   ld      A,(DE)          ; Get byte from table
1038+ 22B9 B7                   or      A               ; End of word ?
1039+ 22BA FA D9 22             jp      M,MATCH         ; Yes - Match found
1040+ 22BD 4F                   ld      C,A             ; Save it
1041+ 22BE 78                   ld      A,B             ; Get token value
1042+ 22BF FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
1043+ 22C1 C2 C8 22             jp      NZ,NOSPC        ; No - Don't allow spaces
1044+ 22C4 CD 0B 26             call    GETCHR          ; Get next character
1045+ 22C7 2B                   dec     HL              ; Cancel increment from GETCHR
1046+ 22C8 23           NOSPC:  inc     HL              ; Next byte
1047+ 22C9 7E                   ld      A,(HL)          ; Get byte
1048+ 22CA FE 61                cp      'a'             ; Less than 'a' ?
1049+ 22CC DA D1 22             jp      C,NOCHNG        ; Yes - don't change
1050+ 22CF E6 5F                and     %01011111       ; Make upper case
1051+ 22D1 B9           NOCHNG: cp      C               ; Same as in buffer ?
1052+ 22D2 CA B7 22             jp      Z,NXTBYT        ; Yes - keep testing
1053+ 22D5 E1                   pop     HL              ; Get back start of word
1054+ 22D6 C3 A5 22             jp      SEARCH          ; Look at next word
1055+ 22D9
1056+ 22D9 48           MATCH:  ld      C,B             ; Word found - Save token value
1057+ 22DA F1                   pop     AF              ; Throw away return
1058+ 22DB EB                   ex      DE,HL
1059+ 22DC C9                   ret                     ; Return to "RETNAD"
1060+ 22DD EB           RETNAD: ex      DE,HL           ; Get address in string
1061+ 22DE 79                   ld      A,C             ; Get token value
1062+ 22DF C1                   pop     BC              ; Restore buffer length
1063+ 22E0 D1                   pop     DE              ; Get destination address
1064+ 22E1 23           MOVDIR: inc     HL              ; Next source in buffer
1065+ 22E2 12                   ld      (DE),A          ; Put byte in buffer
1066+ 22E3 13                   inc     DE              ; Move up buffer
1067+ 22E4 0C                   inc     C               ; Increment length of buffer
1068+ 22E5 D6 3A                sub     ':'             ; End of statement?
1069+ 22E7 CA EF 22             jp      Z,SETLIT        ; Jump if multi-statement line
1070+ 22EA FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1071+ 22EC C2 F2 22             jp      NZ,TSTREM       ; No - see if REM
1072+ 22EF 32 95 81     SETLIT: ld      (DATFLG),A      ; Set literal flag
1073+ 22F2 D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1074+ 22F4 C2 62 22             jp      NZ,CRNCLP       ; No - Leave flag
1075+ 22F7 47                   ld      B,A             ; Copy rest of buffer
1076+ 22F8 7E           NXTCHR: ld      A,(HL)          ; Get byte
1077+ 22F9 B7                   or      A               ; End of line ?
1078+ 22FA CA 08 23             jp      Z,ENDBUF        ; Yes - Terminate buffer
1079+ 22FD B8                   cp      B               ; End of statement ?
1080+ 22FE CA E1 22             jp      Z,MOVDIR        ; Yes - Get next one
1081+ 2301 23           CPYLIT: inc     HL              ; Move up source string
1082+ 2302 12                   ld      (DE),A          ; Save in destination
1083+ 2303 0C                   inc     C               ; Increment length
1084+ 2304 13                   inc     DE              ; Move up destination
1085+ 2305 C3 F8 22             jp      NXTCHR          ; Repeat
1086+ 2308
1087+ 2308 21 37 81     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1088+ 230B 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1089+ 230C 13                   inc     DE
1090+ 230D 12                   ld      (DE),A          ; A = 00
1091+ 230E 13                   inc     DE
1092+ 230F 12                   ld      (DE),A          ; A = 00
1093+ 2310 C9                   ret
1094+ 2311
1095+ 2311 3A A4 80     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1096+ 2314 B7                   or      A               ; Is it zero?
1097+ 2315 3E 00                ld      A,$00           ; Zero A - Leave flags
1098+ 2317 32 A4 80             ld      (NULFLG),A      ; Zero null flag
1099+ 231A C2 25 23             jp      NZ,ECHDEL       ; Set - Echo it
1100+ 231D 05                   dec     B               ; Decrement length
1101+ 231E CA 42 23             jp      Z,GETLIN        ; Get line again if empty
1102+ 2321 CD CD 23             call    OUTC            ; Output null character
1103+ 2324 3E                   defb    $3E             ; Skip "dec B"
1104+ 2325 05           ECHDEL: dec     B               ; Count bytes in buffer
1105+ 2326 2B                   dec     HL              ; Back space buffer
1106+ 2327 CA 39 23             jp      Z,OTKLN         ; No buffer - Try again
1107+ 232A 7E                   ld      A,(HL)          ; Get deleted byte
1108+ 232B CD CD 23             call    OUTC            ; Echo it
1109+ 232E C3 4B 23             jp      MORINP          ; Get more input
1110+ 2331
1111+ 2331 05           DELCHR: dec     B               ; Count bytes in buffer
1112+ 2332 2B                   dec     HL              ; Back space buffer
1113+ 2333 CD CD 23             call    OUTC            ; Output character in A
1114+ 2336 C2 4B 23             jp      NZ,MORINP       ; Not end - Get more
1115+ 2339 CD CD 23     OTKLN:  call    OUTC            ; Output character in A
1116+ 233C CD D8 28     KILIN:  call    PRNTCRLF        ; Output CRLF
1117+ 233F C3 42 23             jp      TTYLIN          ; Get line again
1118+ 2342
1119+ 2342              GETLIN:
1120+ 2342 21 38 81     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1121+ 2345 06 01                ld      B,$01           ; Set buffer as empty
1122+ 2347 AF                   xor     A
1123+ 2348 32 A4 80             ld      (NULFLG),A      ; Clear null flag
1124+ 234B CD 0E 24     MORINP: call    CLOTST          ; Get character and test ^O
1125+ 234E 4F                   ld      C,A             ; Save character in C
1126+ 234F FE 7F                cp      DEL             ; Delete character?
1127+ 2351 CA 11 23             jp      Z,DODEL         ; Yes - Process it
1128+ 2354 3A A4 80             ld      A,(NULFLG)      ; Get null flag
1129+ 2357 B7                   or      A               ; Test null flag status
1130+ 2358 CA 64 23             jp      Z,PROCES        ; Reset - Process character
1131+ 235B 3E 00                ld      A,$00           ; Set a null
1132+ 235D CD CD 23             call    OUTC            ; Output null
1133+ 2360 AF                   xor     A               ; Clear A
1134+ 2361 32 A4 80             ld      (NULFLG),A      ; Reset null flag
1135+ 2364 79           PROCES: ld      A,C             ; Get character
1136+ 2365 FE 07                cp      CTRLG           ; Bell?
1137+ 2367 CA A4 23             jp      Z,PUTCTL        ; Yes - Save it
1138+ 236A FE 03                cp      CTRLC           ; Is it control "C"?
1139+ 236C CC 99 23             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1140+ 236F 37                   scf                     ; Flag break
1141+ 2370 C8                   ret     Z               ; Return if control "C"
1142+ 2371 FE 0D                cp      CR              ; Is it enter?
1143+ 2373 CA CE 28             jp      Z,ENDINP        ; Yes - Terminate input
1144+ 2376 FE 15                cp      CTRLU           ; Is it control "U"?
1145+ 2378 CA 3C 23             jp      Z,KILIN         ; Yes - Get another line
1146+ 237B FE 08                cp      BKSP            ; Is it backspace?
1147+ 237D CA 31 23             jp      Z,DELCHR        ; Yes - Delete character
1148+ 2380 FE 12                cp      CTRLR           ; Is it control "R"?
1149+ 2382 C2 9F 23             jp      NZ,PUTBUF       ; No - Put in buffer
1150+ 2385 C5                   push    BC              ; Save buffer length
1151+ 2386 D5                   push    DE              ; Save DE
1152+ 2387 E5                   push    HL              ; Save buffer address
1153+ 2388 36 00                ld      (HL),$00        ; Mark end of buffer
1154+ 238A CD 47 4D             call    OUTNCR          ; Output and do CRLF
1155+ 238D 21 38 81             ld      HL,BUFFER       ; Point to buffer start
1156+ 2390 CD A4 2F             call    PRS             ; Output buffer
1157+ 2393 E1                   pop     HL              ; Restore buffer address
1158+ 2394 D1                   pop     DE              ; Restore DE
1159+ 2395 C1                   pop     BC              ; Restore buffer length
1160+ 2396 C3 4B 23             jp      MORINP          ; Get another character
1161+ 2399 CD 9C 20     GMNCR:  call    EXITGM          ; exit from graphic mode
1162+ 239C C3 D8 28             jp      PRNTCRLF        ; output CRLF
1163+ 239F
1164+ 239F FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1165+ 23A1 DA 4B 23             jp      C,MORINP        ; Yes - Ignore
1166+ 23A4 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1167+ 23A5 FE 59                cp      $58+$01         ; Test for line overflow
1168+ 23A7 3E 08                ld      A,BKSP          ; Set a bell
1169+ 23A9 D2 B6 23             jp      NC,OUTNBS       ; Ring bell if buffer full
1170+ 23AC 79                   ld      A,C             ; Get character
1171+ 23AD 71                   ld      (HL),C          ; Save in buffer
1172+ 23AE 32 DC 81             ld      (LSTBIN),A      ; Save last input byte
1173+ 23B1 23                   inc     HL              ; Move up buffer
1174+ 23B2 04                   inc     B               ; Increment length
1175+ 23B3 C3 4B 23     OUTIT:  jp      MORINP          ; Get another character
1176+ 23B6
1177+ 23B6 CD CD 23     OUTNBS: call    OUTC            ; Output bell and back over it
1178+ 23B9 C3 B3 23             jp      OUTIT           ; get more chars
1179+ 23BC
1180+ 23BC 7C           CPDEHL: ld      A,H             ; Get H
1181+ 23BD 92                   sub     D               ; Compare with D
1182+ 23BE C0                   ret     NZ              ; Different - Exit
1183+ 23BF 7D                   ld      A,L             ; Get L
1184+ 23C0 93                   sub     E               ; Compare with E
1185+ 23C1 C9                   ret                     ; Return status
1186+ 23C2
1187+ 23C2 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1188+ 23C3 E3                   ex      (SP),HL         ; Address of test byte
1189+ 23C4 BE                   cp      (HL)            ; Same as in code string?
1190+ 23C5 23                   inc     HL              ; Return address
1191+ 23C6 E3                   ex      (SP),HL         ; Put it back
1192+ 23C7 CA 0B 26             jp      Z,GETCHR        ; Yes - Get next character
1193+ 23CA C3 C2 20             jp      SNERR           ; Different - ?SN Error
1194+ 23CD
1195+ 23CD F5           OUTC:   push    AF              ; Save character
1196+ 23CE 3A A5 80             ld      A,(CTLOFG)      ; Get control "O" flag
1197+ 23D1 B7                   or      A               ; Is it set?
1198+ 23D2 C2 D9 2F             jp      NZ,POPAF        ; Yes - don't output
1199+ 23D5 F1                   pop     AF              ; Restore character
1200+ 23D6 C5                   push    BC              ; Save buffer length
1201+ 23D7 F5                   push    AF              ; Save character
1202+ 23D8 FE 20                cp      SPC             ; Is it a control code?
1203+ 23DA DA F1 23             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1204+ 23DD 3A A2 80             ld      A,(LWIDTH)      ; Get line width
1205+ 23E0 47                   ld      B,A             ; To B
1206+ 23E1 3A 92 81             ld      A,(CURPOS)      ; Get cursor position
1207+ 23E4 04                   inc     B               ; Width 255?
1208+ 23E5 CA ED 23             jp      Z,INCLEN        ; Yes - No width limit
1209+ 23E8 05                   dec     B               ; Restore width
1210+ 23E9 B8                   cp      B               ; At end of line?
1211+ 23EA CC D8 28             call    Z,PRNTCRLF      ; Yes - output CRLF
1212+ 23ED 3C           INCLEN: inc     A               ; Move on one character
1213+ 23EE 32 92 81             ld      (CURPOS),A      ; Save new position
1214+ 23F1 AF           DINPOS: xor     A
1215+ 23F2 32 40 82             ld      (KBDNPT),A      ; set flag for no char from keyboard
1216+ 23F5 F1                   pop     AF              ; Restore character
1217+ 23F6 C1                   pop     BC              ; Restore buffer length
1218+ 23F7 F5                   push    AF
1219+ 23F8 CD 00 24             call    SND2VID         ; send char to video
1220+ 23FB F1                   pop     AF
1221+ 23FC CD 1F 4D             call    MONOUT          ; send char to serial if enabled
1222+ 23FF C9                   ret
1223+ 2400
1224+ 2400              ; print char to video if cursor is on
1225+ 2400 32 03 82     SND2VID:ld      (CHR4VID),A     ; store A
1226+ 2403 3A 02 82             ld      A,(PRNTVIDEO)   ; check print-on-video
1227+ 2406 B7                   or      A               ; is it off?
1228+ 2407 C8                   ret     Z               ; yes, so return
1229+ 2408 F3                   di                      ; disable INTs
1230+ 2409 CD 78 07             call    CHAR2VID        ; cursor is on, so print char on screen
1231+ 240C FB                   ei                      ; re-enable INTs
1232+ 240D C9                   ret                     ; return to caller
1233+ 240E
1234+ 240E CD 5F 3D     CLOTST: call    GETINP          ; Get input character
1235+ 2411 FE 0F                cp      CTRLO           ; Is it control "O"?
1236+ 2413 C0                   ret     NZ              ; No don't flip flag
1237+ 2414 3A A5 80             ld      A,(CTLOFG)      ; Get flag
1238+ 2417 2F                   cpl                     ; Flip it
1239+ 2418 32 A5 80             ld      (CTLOFG),A      ; Put it back
1240+ 241B A7                   and     A               ; is output enabled?
1241+ 241C CC 44 09             call    Z,CURSOR_ON     ; yes, so cursor on
1242+ 241F 3A 48 82             ld      A,(SERIALS_EN)  ; load serial state
1243+ 2422 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1244+ 2424 CC AD 01             call    Z,A_RTS_ON      ; yes, set RTS on
1245+ 2427 AF                   xor     A               ; Null character
1246+ 2428 C9                   ret
1247+ 2429
1248+ 2429              ; LIST: list the program stored into memory
1249+ 2429 C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1250+ 242A 2B                   dec     HL              ; dec 'cos GETCHR INCs
1251+ 242B CD 0B 26             call    GETCHR          ; Get next character
1252+ 242E CA 84 24             jp      Z,LSTALL        ; list all if nothing follows
1253+ 2431 FE BF                cp      ZMINUS          ; is it '-'?
1254+ 2433 20 20                jr      NZ,LST01        ; no, look for a line number
1255+ 2435 11 00 00             ld      DE,$0000        ; yes, set search from 0
1256+ 2438 CD 25 25             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1257+ 243B ED 43 06 82          ld      (TMPBFR1),BC    ; store address of starting line
1258+ 243F CD C2 23             call    CHKSYN          ; skip '-'
1259+ 2442 BF                   defb    ZMINUS
1260+ 2443 CD DB 26             call    ATOH            ; now, look for another number (ASCII number to DE)
1261+ 2446 CD 2B 25             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1262+ 2449 ED 43 08 82          ld      (TMPBFR2),BC    ; store address of ending line
1263+ 244D ED 4B 06 82          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1264+ 2451 C5                   push    BC              ; store address of line for later use
1265+ 2452 C3 BC 24             jp      LISTLP          ; go listing
1266+ 2455 CD DB 26     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1267+ 2458 ED 53 0C 82  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1268+ 245C CD 25 25             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1269+ 245F ED 43 06 82          ld      (TMPBFR1),BC    ; store address of starting line
1270+ 2463 ED 43 08 82          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1271+ 2467 2B                   dec     HL              ; dec 'cos GETCHR INCs
1272+ 2468 CD 0B 26             call    GETCHR          ; Get next character
1273+ 246B CA 77 24             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1274+ 246E FE BF                cp      ZMINUS          ; is it '-'?
1275+ 2470 CA 9C 24             jp      Z,LST03         ; yes, read ending line
1276+ 2473 C5           LST06:  push    BC              ; store address for later use
1277+ 2474 C3 BC 24             jp      LISTLP          ; jump to list
1278+ 2477 ED 5B 0C 82  LSTNOT: ld      DE,(TMPBFR4)
1279+ 247B CD 25 25             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1280+ 247E DA 73 24             jp      C,LST06
1281+ 2481 C3 22 21             jp      PRNTOK
1282+ 2484 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1283+ 2487 CD 25 25             call    SRCHLIN         ; get address of last line
1284+ 248A ED 43 08 82          ld      (TMPBFR2),BC    ; store it
1285+ 248E 11 00 00             ld      DE,$0000        ; set start to first line in memory
1286+ 2491 CD 25 25             call    SRCHLIN         ; get address of first line
1287+ 2494 ED 43 06 82          ld      (TMPBFR1),BC    ; store it
1288+ 2498 C5                   push    BC              ; store address of starting line for later use
1289+ 2499 C3 BC 24             jp      LISTLP          ; start printing
1290+ 249C CD C2 23     LST03:  call    CHKSYN          ; skip '-'
1291+ 249F BF                   defb    ZMINUS
1292+ 24A0 CD DB 26             call    ATOH            ; look for another number (return into DE)
1293+ 24A3 7A                   ld      A,D
1294+ 24A4 B3                   or      E               ; is line=0?
1295+ 24A5 20 09                jr      NZ,LST05        ; no, jump over
1296+ 24A7 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1297+ 24AA CD 25 25             call    SRCHLIN         ; get address of last line
1298+ 24AD C3 B3 24             jp      LST02
1299+ 24B0 CD 2B 25     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1300+ 24B3 ED 43 08 82  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1301+ 24B7 ED 4B 06 82          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1302+ 24BB C5                   push    BC              ; store it for later use
1303+ 24BC E1           LISTLP: pop     HL              ; Restore address of line
1304+ 24BD 4E                   ld      C,(HL)          ; Get LSB of next line
1305+ 24BE 23                   inc     HL
1306+ 24BF 46                   ld      B,(HL)          ; Get MSB of next line
1307+ 24C0 23                   inc     HL
1308+ 24C1 78                   ld      A,B             ; BC = 0 (End of program)?
1309+ 24C2 B1                   or      C
1310+ 24C3 CA 22 21             jp      Z,PRNTOK        ; Yes - Go to command mode
1311+ 24C6 CD 36 26             call    TSTBRK          ; Test for break key
1312+ 24C9 CD 39 25             call    TSTSPC          ; test for space
1313+ 24CC C5                   push    BC              ; Save address of next line
1314+ 24CD 3A FB 81             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1315+ 24D0 A7                   and     A               ; is it at the beginning of a new line?
1316+ 24D1 20 0B                jr      NZ,LST08        ; No, jump over
1317+ 24D3 3E 0D                ld      A,CR            ; yes, so just send a CR
1318+ 24D5 CD 1F 4D             call    MONOUT          ; to serial if it's open
1319+ 24D8 AF                   xor     A               ; then, set cursor
1320+ 24D9 32 92 81             ld      (CURPOS),A      ; to position 0
1321+ 24DC 18 03                jr      LST07           ; and continue
1322+ 24DE CD D8 28     LST08:  call    PRNTCRLF        ; output CRLF
1323+ 24E1 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1324+ 24E2 23                   inc     HL
1325+ 24E3 56                   ld      D,(HL)          ; Get MSB of line number
1326+ 24E4 23                   inc     HL
1327+ 24E5 E5                   push    HL              ; Save address of line start
1328+ 24E6 EB                   ex      DE,HL           ; Line number to HL
1329+ 24E7 CD 43 3A             call    PRNTHL          ; Output line number in decimal
1330+ 24EA 3E 20                ld      A,SPC           ; Space after line number
1331+ 24EC E1                   pop     HL              ; Restore start of line address
1332+ 24ED CD CD 23     LSTLP2: call    OUTC            ; Output character in A
1333+ 24F0 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1334+ 24F1 B7                   or      A               ; End of line?
1335+ 24F2 23                   inc     HL              ; To next byte in line
1336+ 24F3 CA 17 25             jp      Z,NXTLN         ; Yes - check next line
1337+ 24F6 F2 ED 24             jp      P,LSTLP2        ; No token - output it
1338+ 24F9 D6 7F                sub     ZEND-1          ; Find and output word
1339+ 24FB 4F                   ld      C,A             ; Token offset+1 to C
1340+ 24FC 11 3E 1D             ld      DE,WORDS        ; Reserved word list
1341+ 24FF 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1342+ 2500 13                   inc     DE              ; Move on to next
1343+ 2501 B7                   or      A               ; Is it start of word?
1344+ 2502 F2 FF 24             jp      P,FNDTOK        ; No - Keep looking for word
1345+ 2505 0D                   dec     C               ; Count words
1346+ 2506 C2 FF 24             jp      NZ,FNDTOK       ; Not there - keep looking
1347+ 2509 E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1348+ 250B CD CD 23             call    OUTC            ; Output character
1349+ 250E 1A                   ld      A,(DE)          ; Get next character
1350+ 250F 13                   inc     DE              ; Move on to next
1351+ 2510 B7                   or      A               ; Is it end of word?
1352+ 2511 F2 09 25             jp      P,OUTWRD        ; No - output the rest
1353+ 2514 C3 F0 24             jp      LSTLP3          ; Next byte in line
1354+ 2517 D1           NXTLN:  pop     DE              ; recover address of current line
1355+ 2518 2A 08 82             ld      HL,(TMPBFR2)    ; address of last line to print
1356+ 251B CD 4D 4D             call    CMP16           ; check if current line is over last printable line
1357+ 251E DA 22 21             jp      C,PRNTOK        ; finish - leave & print OK
1358+ 2521 D5                   push    DE              ; store address of current line
1359+ 2522 C3 BC 24             jp      LISTLP          ; continue listing
1360+ 2525              ; look for the address of a program line
1361+ 2525 E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1362+ 2526 CD DE 21             call    SRCHLN          ; search for line number in DE
1363+ 2529 E1                   pop     HL              ; retrieve HL
1364+ 252A C9                   ret                     ; return to caller
1365+ 252B              ; look for the address of a program line - if the line isn't found,
1366+ 252B              ; it look backward for the previous line
1367+ 252B E5           SRCLN:  push    HL              ; store HL
1368+ 252C CD DE 21     SRCLN1: call    SRCHLN          ; search for line in DE
1369+ 252F DA 37 25             jp      C,LVSRLN        ; found it, leave loop
1370+ 2532 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1371+ 2533 7B                   ld      A,E
1372+ 2534 B2                   or      D               ; is line number zero?
1373+ 2535 20 F5                jr      NZ,SRCLN1       ; no, continue
1374+ 2537 E1           LVSRLN: pop     HL              ; retrieve HL
1375+ 2538 C9                   ret                     ; return to caller
1376+ 2539
1377+ 2539              ; during LISTing, check if PAUSE is pressed, then pause listing and
1378+ 2539              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1379+ 2539 3A 42 82     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1380+ 253C FE 20                cp      SPC             ; Is it SPACE?
1381+ 253E C0                   ret     NZ              ; No, return
1382+ 253F CD 5F 3D     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1383+ 2542 FE 20                cp      SPC             ; is it SPACE?
1384+ 2544 20 05                jr      NZ,CNTWTSP      ; no, continue
1385+ 2546 AF                   xor     A
1386+ 2547 32 42 82             ld      (TMPKEYBFR),A   ; reset key
1387+ 254A C9                   ret                     ; return to caller
1388+ 254B FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1389+ 254D 20 F0                jr      NZ,WTSPC        ; no, loop
1390+ 254F C3 6E 1C             jp      BRKRET          ; exit and output "Ok"
1391+ 2552
1392+ 2552
1393+ 2552 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1394+ 2554 32 DB 81             ld      (FORFLG),A      ; Save "FOR" flag
1395+ 2557 CD CB 27             call    LET             ; Set up initial index
1396+ 255A C1                   pop     BC              ; Drop RETurn address
1397+ 255B E5                   push    HL              ; Save code string address
1398+ 255C CD B4 27             call    DATA            ; Get next statement address
1399+ 255F 22 D7 81             ld      (LOOPST),HL     ; Save it for start of loop
1400+ 2562 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1401+ 2565 39                   add     HL,SP           ; Point to it
1402+ 2566 CD 4F 20     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1403+ 2569 D1                   pop     DE              ; Get code string address
1404+ 256A C2 82 25             jp      NZ,FORFND       ; No nesting found
1405+ 256D 09                   add     HL,BC           ; Move into "FOR" block
1406+ 256E D5                   push    DE              ; Save code string address
1407+ 256F 2B                   dec     HL
1408+ 2570 56                   ld      D,(HL)          ; Get MSB of loop statement
1409+ 2571 2B                   dec     HL
1410+ 2572 5E                   ld      E,(HL)          ; Get LSB of loop statement
1411+ 2573 23                   inc     HL
1412+ 2574 23                   inc     HL
1413+ 2575 E5                   push    HL              ; Save block address
1414+ 2576 2A D7 81             ld      HL,(LOOPST)     ; Get address of loop statement
1415+ 2579 CD BC 23             call    CPDEHL          ; Compare the FOR loops
1416+ 257C E1                   pop     HL              ; Restore block address
1417+ 257D C2 66 25             jp      NZ,FORSLP       ; Different FORs - Find another
1418+ 2580 D1                   pop     DE              ; Restore code string address
1419+ 2581 F9                   ld      SP,HL           ; Remove all nested loops
1420+ 2582
1421+ 2582 EB           FORFND: ex      DE,HL           ; Code string address to HL
1422+ 2583 0E 08                ld      C,$08
1423+ 2585 CD 7F 20             call    CHKSTK          ; Check for 8 levels of stack
1424+ 2588 E5                   push    HL              ; Save code string address
1425+ 2589 2A D7 81             ld      HL,(LOOPST)     ; Get first statement of loop
1426+ 258C E3                   ex      (SP),HL         ; Save and restore code string
1427+ 258D E5                   push    HL              ; Re-save code string address
1428+ 258E 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
1429+ 2591 E3                   ex      (SP),HL         ; Save and restore code string
1430+ 2592 CD 9F 2A             call    TSTNUM          ; Make sure it's a number
1431+ 2595 CD C2 23             call    CHKSYN          ; Make sure "TO" is next
1432+ 2598 B8                   defb    ZTO             ; "TO" token
1433+ 2599 CD 9C 2A             call    GETNUM          ; Get "TO" expression value
1434+ 259C E5                   push    HL              ; Save code string address
1435+ 259D CD F5 38             call    BCDEFP          ; Move "TO" value to BCDE
1436+ 25A0 E1                   pop     HL              ; Restore code string address
1437+ 25A1 C5                   push    BC              ; Save "TO" value in block
1438+ 25A2 D5                   push    DE
1439+ 25A3 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1440+ 25A6 51                   ld      D,C             ; C=0
1441+ 25A7 5A                   ld      E,D             ; D=0
1442+ 25A8 7E                   ld      A,(HL)          ; Get next byte in code string
1443+ 25A9 FE BD                cp      ZSTEP           ; See if "STEP" is stated
1444+ 25AB 3E 01                ld      A,$01           ; Sign of step = 1
1445+ 25AD C2 BE 25             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1446+ 25B0 CD 0B 26             call    GETCHR          ; Jump over "STEP" token
1447+ 25B3 CD 9C 2A             call    GETNUM          ; Get step value
1448+ 25B6 E5                   push    HL              ; Save code string address
1449+ 25B7 CD F5 38             call    BCDEFP          ; Move STEP to BCDE
1450+ 25BA CD A9 38             call    TSTSGN          ; Test sign of FPREG
1451+ 25BD E1                   pop     HL              ; Restore code string address
1452+ 25BE C5           SAVSTP: push    BC              ; Save the STEP value in block
1453+ 25BF D5                   push    DE
1454+ 25C0 F5                   push    AF              ; Save sign of STEP
1455+ 25C1 33                   inc     SP              ; Don't save flags
1456+ 25C2 E5                   push    HL              ; Save code string address
1457+ 25C3 2A DE 81             ld      HL,(BRKLIN)     ; Get address of index variable
1458+ 25C6 E3                   ex      (SP),HL         ; Save and restore code string
1459+ 25C7 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1460+ 25C9 C5                   push    BC              ; Save it
1461+ 25CA 33                   inc     SP              ; Don't save C
1462+ 25CB
1463+ 25CB CD 36 26     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1464+ 25CE 22 DE 81             ld      (BRKLIN),HL     ; Save code address for break
1465+ 25D1 7E                   ld      A,(HL)          ; Get next byte in code string
1466+ 25D2 FE 3A                cp      ':'             ; Multi statement line?
1467+ 25D4 CA EB 25             jp      Z,EXCUTE        ; Yes - Execute it
1468+ 25D7 B7                   or      A               ; End of line?
1469+ 25D8 C2 C2 20             jp      NZ,SNERR        ; No - Syntax error
1470+ 25DB 23                   inc     HL              ; Point to address of next line
1471+ 25DC 7E                   ld      A,(HL)          ; Get LSB of line pointer
1472+ 25DD 23                   inc     HL
1473+ 25DE B6                   or      (HL)            ; Is it zero (End of prog)?
1474+ 25DF CA 5D 26             jp      Z,ENDPRG        ; Yes - Terminate execution
1475+ 25E2 23                   inc     HL              ; Point to line number
1476+ 25E3 5E                   ld      E,(HL)          ; Get LSB of line number
1477+ 25E4 23                   inc     HL
1478+ 25E5 56                   ld      D,(HL)          ; Get MSB of line number
1479+ 25E6 EB                   ex      DE,HL           ; Line number to HL
1480+ 25E7 22 AF 80             ld      (LINEAT),HL     ; Save as current line number
1481+ 25EA EB                   ex      DE,HL           ; Line number back to DE
1482+ 25EB CD 0B 26     EXCUTE: call    GETCHR          ; Get key word
1483+ 25EE 11 CB 25             ld      DE,RUNCNT       ; Where to RETurn to
1484+ 25F1 D5                   push    DE              ; Save for RETurn
1485+ 25F2 C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1486+ 25F3
1487+ 25F3 D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1488+ 25F5 DA CB 27             jp      C,LET           ; No - try to assign it
1489+ 25F8 FE 37                cp      ZNEW+1-ZEND     ; END to NEW ?
1490+ 25FA D2 C2 20             jp      NC,SNERR        ; Not a key word - ?SN Error
1491+ 25FD 07                   rlca                    ; Double it
1492+ 25FE 4F                   ld      C,A             ; BC = Offset into table
1493+ 25FF 06 00                ld      B,0
1494+ 2601 EB                   ex      DE,HL           ; Save code string address
1495+ 2602 21 CF 1E             ld      HL,WORDTB       ; Keyword address table
1496+ 2605 09                   add     HL,BC           ; Point to routine address
1497+ 2606 4E                   ld      C,(HL)          ; Get LSB of routine address
1498+ 2607 23                   inc     HL
1499+ 2608 46                   ld      B,(HL)          ; Get MSB of routine address
1500+ 2609 C5                   push    BC              ; Save routine address
1501+ 260A EB                   ex      DE,HL           ; Restore code string address
1502+ 260B
1503+ 260B              ; get a char from input buffer: exit with NC if character found is
1504+ 260B              ; not a number; exit with Z if nothing found; char is into A
1505+ 260B 23           GETCHR: inc     HL              ; Point to next character
1506+ 260C 7E                   ld      A,(HL)          ; Get next code string byte
1507+ 260D FE 3A                cp      ':'             ; Z if ':'
1508+ 260F D0                   ret     NC              ; NC if > "9"
1509+ 2610 FE 20                cp      SPC
1510+ 2612 CA 0B 26             jp      Z,GETCHR        ; Skip over spaces
1511+ 2615 FE 30                cp      '0'
1512+ 2617 3F                   ccf                     ; NC if < '0'
1513+ 2618 3C                   inc     A               ; Test for zero - Leave carry
1514+ 2619 3D                   dec     A               ; Z if Null
1515+ 261A C9                   ret
1516+ 261B
1517+ 261B EB           RESTOR: ex      DE,HL           ; Save code string address
1518+ 261C 2A 35 81             ld      HL,(BASTXT)     ; Point to start of program
1519+ 261F CA 30 26             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1520+ 2622 EB                   ex      DE,HL           ; Restore code string address
1521+ 2623 CD DB 26             call    ATOH            ; Get line number to DE
1522+ 2626 E5                   push    HL              ; Save code string address
1523+ 2627 CD DE 21             call    SRCHLN          ; Search for line number in DE
1524+ 262A 60                   ld      H,B             ; HL = Address of line
1525+ 262B 69                   ld      L,C
1526+ 262C D1                   pop     DE              ; Restore code string address
1527+ 262D D2 8A 27             jp      NC,ULERR        ; ?UL Error if not found
1528+ 2630 2B           RESTNL: dec     HL              ; Byte before DATA statement
1529+ 2631 22 52 82     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1530+ 2634 EB                   ex      DE,HL           ; Restore code string address
1531+ 2635 C9                   ret
1532+ 2636
1533+ 2636
1534+ 2636              ; check if CTRL-C is into input buffer
1535+ 2636 DF           TSTBRK: rst     $18             ; Check input status
1536+ 2637 C8                   ret     Z               ; No key, go back
1537+ 2638 D7                   rst     $10             ; Get the key into A
1538+ 2639 FE 1B                cp      ESC             ; Escape key?
1539+ 263B 28 11                jr      Z,BRK           ; Yes, break
1540+ 263D FE 03                cp      CTRLC           ; <Ctrl-C>
1541+ 263F 28 0D                jr      Z,BRK           ; Yes, break
1542+ 2641 FE 13                cp      CTRLS           ; Stop scrolling?
1543+ 2643 C0                   ret     NZ              ; Other key, ignore
1544+ 2644
1545+ 2644
1546+ 2644              ; wait for a key while listing
1547+ 2644 D7           STALL:  rst     $10             ; Wait for key
1548+ 2645 FE 11                cp      CTRLQ           ; Resume scrolling?
1549+ 2647 C8                   ret     Z               ; Release the chokehold
1550+ 2648 FE 03                cp      CTRLC           ; Second break?
1551+ 264A 28 07                jr      Z,STOP          ; Break during hold exits prog
1552+ 264C 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1553+ 264E
1554+ 264E 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1555+ 2650 32 A9 80             ld      (BRKFLG),A      ; Store it
1556+ 2653
1557+ 2653 C0           STOP:   ret     NZ              ; Exit if anything else
1558+ 2654 F6                   defb    $F6             ; Flag "STOP"
1559+ 2655 C0           PEND:   ret     NZ              ; Exit if anything else
1560+ 2656 22 DE 81             ld      (BRKLIN),HL     ; Save point of break
1561+ 2659 21                   defb    $21             ; Skip "OR 11111111B"
1562+ 265A F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1563+ 265C C1                   pop     BC              ; Return not needed and more
1564+ 265D 2A AF 80     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1565+ 2660 F5                   push    AF              ; Save STOP / END status
1566+ 2661 7D                   ld      A,L             ; Is it direct break?
1567+ 2662 A4                   and     H
1568+ 2663 3C                   inc     A               ; Line is -1 if direct break
1569+ 2664 CA 70 26             jp      Z,NOLIN         ; Yes - No line number
1570+ 2667 22 E2 81             ld      (ERRLIN),HL     ; Save line of break
1571+ 266A 2A DE 81             ld      HL,(BRKLIN)     ; Get point of break
1572+ 266D 22 E4 81             ld      (CONTAD),HL     ; Save point to CONTinue
1573+ 2670 AF           NOLIN:  xor     A
1574+ 2671 32 A5 80             ld      (CTLOFG),A      ; Enable output
1575+ 2674 CD C6 28             call    STTLIN          ; Start a new line
1576+ 2677 F1                   pop     AF              ; Restore STOP / END status
1577+ 2678 21 45 20             ld      HL,BRKMSG       ; "Break" message
1578+ 267B C2 81 26             jp      NZ,ERRINT       ; "in line" wanted?
1579+ 267E C3 22 21             jp      PRNTOK          ; Go to command mode
1580+ 2681 CD 9C 20     ERRINT: call    EXITGM          ; exit from graphics mode
1581+ 2684 C3 00 21             jp      ERRIN           ; print message
1582+ 2687
1583+ 2687
1584+ 2687              ; CONTinue after a break/error
1585+ 2687 21 FF FF     CONT:   ld      HL,-1           ; reset...
1586+ 268A 22 B1 80             ld      (HLPLN),HL      ; ...HELP line register
1587+ 268D 2A E4 81             ld      HL,(CONTAD)     ; Get CONTinue address
1588+ 2690 7C                   ld      A,H             ; Is it zero?
1589+ 2691 B5                   or      L
1590+ 2692 1E 20                ld      E,CN            ; ?CN Error
1591+ 2694 CA DC 20             jp      Z,ERROR         ; Yes - output "?CN Error"
1592+ 2697 EB                   ex      DE,HL           ; Save code string address
1593+ 2698 2A E2 81             ld      HL,(ERRLIN)     ; Get line of last break
1594+ 269B 22 AF 80             ld      (LINEAT),HL     ; Set up current line number
1595+ 269E EB                   ex      DE,HL           ; Restore code string address
1596+ 269F C9                   ret                     ; CONTinue where left off
1597+ 26A0
1598+ 26A0 E5           ACCSUM: push    HL              ; Save address in array
1599+ 26A1 2A A6 80             ld      HL,(CHKSUM)     ; Get check sum
1600+ 26A4 06 00                ld      B,$00           ; BC - Value of byte
1601+ 26A6 4F                   ld      C,A
1602+ 26A7 09                   add     HL,BC           ; Add byte to check sum
1603+ 26A8 22 A6 80             ld      (CHKSUM),HL     ; Re-save check sum
1604+ 26AB E1                   pop     HL              ; Restore address in array
1605+ 26AC C9                   ret
1606+ 26AD
1607+ 26AD 7E           CHKLTR: ld      A,(HL)          ; Get byte
1608+ 26AE FE 41                cp      'A'             ; < 'a' ?
1609+ 26B0 D8                   ret     C               ; Carry set if not letter
1610+ 26B1 FE 5B                cp      'Z'+1           ; > 'z' ?
1611+ 26B3 3F                   ccf
1612+ 26B4 C9                   ret                     ; Carry set if not letter
1613+ 26B5
1614+ 26B5 CD 0B 26     FPSINT: call    GETCHR          ; Get next character
1615+ 26B8 CD 9C 2A     POSINT: call    GETNUM          ; Get integer 0 to 32767
1616+ 26BB CD A9 38     DEPINT: call    TSTSGN          ; Test sign of FPREG
1617+ 26BE FA D6 26             jp      M,FCERR         ; Negative - ?FC Error
1618+ 26C1 3A 5D 82     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1619+ 26C4 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1620+ 26C6 DA 51 39             jp      C,FPINT         ; Yes - convert it
1621+ 26C9 01 80 90             ld      BC,$9080        ; BCDE = -32768
1622+ 26CC 11 00 00             ld      DE,$0000
1623+ 26CF E5                   push    HL              ; Save code string address
1624+ 26D0 CD 24 39             call    CMPNUM          ; Compare FPREG with BCDE
1625+ 26D3 E1                   pop     HL              ; Restore code string address
1626+ 26D4 51                   ld      D,C             ; MSB to D
1627+ 26D5 C8                   ret     Z               ; Return if in range
1628+ 26D6 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1629+ 26D8 C3 DC 20             jp      ERROR           ; Output error-
1630+ 26DB
1631+ 26DB
1632+ 26DB              ; convert a number in ASCII chars into an integer and store it into DE
1633+ 26DB 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1634+ 26DC 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1635+ 26DF CD 0B 26     GTLNLP: call    GETCHR          ; Get next character
1636+ 26E2 D0                   ret     NC              ; Exit if not a digit
1637+ 26E3 E5                   push    HL              ; Save code string address
1638+ 26E4 F5                   push    AF              ; Save digit
1639+ 26E5 21 98 19             ld      HL,65529/10     ; Largest number 65529
1640+ 26E8 CD BC 23             call    CPDEHL          ; Number in range?
1641+ 26EB DA C2 20             jp      C,SNERR         ; No - ?SN Error
1642+ 26EE 62                   ld      H,D             ; HL = Number
1643+ 26EF 6B                   ld      L,E
1644+ 26F0 19                   add     HL,DE           ; Times 2
1645+ 26F1 29                   add     HL,HL           ; Times 4
1646+ 26F2 19                   add     HL,DE           ; Times 5
1647+ 26F3 29                   add     HL,HL           ; Times 10
1648+ 26F4 F1                   pop     AF              ; Restore digit
1649+ 26F5 D6 30                sub     '0'             ; Make it 0 to 9
1650+ 26F7 5F                   ld      E,A             ; DE = Value of digit
1651+ 26F8 16 00                ld      D,0
1652+ 26FA 19                   add     HL,DE           ; Add to number
1653+ 26FB EB                   ex      DE,HL           ; Number to DE
1654+ 26FC E1                   pop     HL              ; Restore code string address
1655+ 26FD C3 DF 26             jp      GTLNLP          ; Go to next character
1656+ 2700
1657+ 2700 CA 0E 22     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1658+ 2703 CD 9C 2A             call    GETNUM          ; Evaluate a number
1659+ 2706 CD C1 26             call    DEINT           ; Get integer -32768 to 32767 into DE
1660+ 2709 2B                   dec     HL              ; Cancel increment
1661+ 270A CD 0B 26             call    GETCHR          ; Get next character
1662+ 270D E5                   push    HL              ; Save code string address
1663+ 270E 2A 96 81             ld      HL,(LSTRAM)     ; Get end of RAM
1664+ 2711 CA 29 27             jp      Z,STORED        ; No value given - Use stored
1665+ 2714 E1                   pop     HL              ; Restore code string address
1666+ 2715 CD C2 23             call    CHKSYN          ; Check for comma
1667+ 2718 2C                   defb    ','
1668+ 2719 D5                   push    DE              ; Save number
1669+ 271A CD 9C 2A             call    GETNUM          ; Evaluate a number
1670+ 271D CD C1 26             call    DEINT           ; Get integer -32768 to 32767 into DE
1671+ 2720 2B                   dec     HL              ; Cancel increment
1672+ 2721 CD 0B 26             call    GETCHR          ; Get next character
1673+ 2724 C2 C2 20             jp      NZ,SNERR        ; ?SN Error if more on line
1674+ 2727 E3                   ex      (SP),HL         ; Save code string address
1675+ 2728 EB                   ex      DE,HL           ; Number to DE
1676+ 2729 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1677+ 272A 93                   sub     E               ; Subtract LSB of string space
1678+ 272B 5F                   ld      E,A             ; Save LSB
1679+ 272C 7C                   ld      A,H             ; Get MSB of new RAM top
1680+ 272D 9A                   sbc     A,D             ; Subtract MSB of string space
1681+ 272E 57                   ld      D,A             ; Save MSB
1682+ 272F DA 97 20             jp      C,OMERR         ; ?OM Error if not enough mem
1683+ 2732 E5                   push    HL              ; Save RAM top
1684+ 2733 2A 4C 82             ld      HL,(PROGND)     ; Get program end
1685+ 2736 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1686+ 2739 09                   add     HL,BC           ; Get lowest address
1687+ 273A CD BC 23             call    CPDEHL          ; Enough memory?
1688+ 273D D2 97 20             jp      NC,OMERR        ; No - ?OM Error
1689+ 2740 EB                   ex      DE,HL           ; RAM top to HL
1690+ 2741 22 AD 80             ld      (STRSPC),HL     ; Set new string space
1691+ 2744 E1                   pop     HL              ; End of memory to use
1692+ 2745 22 96 81             ld      (LSTRAM),HL     ; Set new top of RAM
1693+ 2748 E1                   pop     HL              ; Restore code string address
1694+ 2749 C3 0E 22             jp      INTVAR          ; Initialise variables
1695+ 274C
1696+ 274C E5           RUN:    push    HL              ; store HL
1697+ 274D 21 FF FF             ld      HL,-1           ; reset...
1698+ 2750 22 B1 80             ld      (HLPLN),HL      ; ...HELP line register
1699+ 2753 E1                   pop     HL              ; retrieve HL
1700+ 2754 CA 0A 22             jp      Z,RUNFST        ; RUN from start if just RUN
1701+ 2757 CD 0E 22             call    INTVAR          ; Initialise variables
1702+ 275A 01 CB 25             ld      BC,RUNCNT       ; Execution driver loop
1703+ 275D C3 70 27             jp      RUNLIN          ; RUN from line number
1704+ 2760
1705+ 2760 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1706+ 2762 CD 7F 20             call    CHKSTK          ; Check for 3 levels of stack
1707+ 2765 C1                   pop     BC              ; Get return address
1708+ 2766 E5                   push    HL              ; Save code string for RETURN
1709+ 2767 E5                   push    HL              ; And for GOSUB routine
1710+ 2768 2A AF 80             ld      HL,(LINEAT)     ; Get current line
1711+ 276B E3                   ex      (SP),HL         ; Into stack - Code string out
1712+ 276C 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1713+ 276E F5                   push    AF              ; Save token
1714+ 276F 33                   inc     SP              ; Don't save flags
1715+ 2770
1716+ 2770 C5           RUNLIN: push    BC              ; Save return address
1717+ 2771 CD DB 26     GOTO:   call    ATOH            ; ASCII number to DE binary
1718+ 2774 CD B6 27             call    REM             ; Get end of line
1719+ 2777 E5                   push    HL              ; Save end of line
1720+ 2778 2A AF 80             ld      HL,(LINEAT)     ; Get current line
1721+ 277B CD BC 23             call    CPDEHL          ; Line after current?
1722+ 277E E1                   pop     HL              ; Restore end of line
1723+ 277F 23                   inc     HL              ; Start of next line
1724+ 2780 DC E1 21             call    C,SRCHLP        ; Line is after current line
1725+ 2783 D4 DE 21             call    NC,SRCHLN       ; Line is before current line
1726+ 2786 60                   ld      H,B             ; Set up code string address
1727+ 2787 69                   ld      L,C
1728+ 2788 2B                   dec     HL              ; Incremented after
1729+ 2789 D8                   ret     C               ; Line found
1730+ 278A 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1731+ 278C C3 DC 20             jp      ERROR           ; Output error message
1732+ 278F
1733+ 278F C0           RETURN: ret     NZ              ; Return if not just RETURN
1734+ 2790 16 FF                ld      D,-1            ; Flag "GOSUB" search
1735+ 2792 CD 4B 20             call    BAKSTK          ; Look "GOSUB" block
1736+ 2795 F9                   ld      SP,HL           ; Kill all FORs in subroutine
1737+ 2796 FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1738+ 2798 1E 04                ld      E,RG            ; ?RG Error
1739+ 279A C2 DC 20             jp      NZ,ERROR        ; Error if no "GOSUB" found
1740+ 279D E1                   pop     HL              ; Get RETURN line number
1741+ 279E 22 AF 80             ld      (LINEAT),HL     ; Save as current
1742+ 27A1 23                   inc     HL              ; Was it from direct statement?
1743+ 27A2 7C                   ld      A,H
1744+ 27A3 B5                   or      L               ; Return to line
1745+ 27A4 C2 AE 27             jp      NZ,RETLIN       ; No - Return to line
1746+ 27A7 3A DC 81             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1747+ 27AA B7                   or      A               ; If so buffer is corrupted
1748+ 27AB C2 21 21             jp      NZ,POPNOK       ; Yes - Go to command mode
1749+ 27AE 21 CB 25     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1750+ 27B1 E3                   ex      (SP),HL         ; Into stack - Code string out
1751+ 27B2 3E                   defb    $3E             ; Skip "pop HL"
1752+ 27B3 E1           NXTDTA: pop     HL              ; Restore code string address
1753+ 27B4
1754+ 27B4 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1755+ 27B6 0E 00        REM:    ld      C,$00           ; 00  End of statement
1756+ 27B8 06 00                ld      B,$00
1757+ 27BA 79           NXTSTL: ld      A,C             ; Statement and byte
1758+ 27BB 48                   ld      C,B
1759+ 27BC 47                   ld      B,A             ; Statement end byte
1760+ 27BD 7E           NXTSTT: ld      A,(HL)          ; Get byte
1761+ 27BE B7                   or      A               ; End of line?
1762+ 27BF C8                   ret     Z               ; Yes - Exit
1763+ 27C0 B8                   cp      B               ; End of statement?
1764+ 27C1 C8                   ret     Z               ; Yes - Exit
1765+ 27C2 23                   inc     HL              ; Next byte
1766+ 27C3 FE 22                cp      $22             ; '"'             ; Literal string?
1767+ 27C5 CA BA 27             jp      Z,NXTSTL        ; Yes - Look for another '"'
1768+ 27C8 C3 BD 27             jp      NXTSTT          ; Keep looking
1769+ 27CB
1770+ 27CB CD AB 2C     LET:    call    GETVAR          ; Get variable name
1771+ 27CE CD C2 23             call    CHKSYN          ; Make sure "=" follows
1772+ 27D1 C9                   defb    ZEQUAL          ; "=" token
1773+ 27D2 D5                   push    DE              ; Save address of variable
1774+ 27D3 3A 94 81             ld      A,(TYPE)        ; Get data type
1775+ 27D6 F5                   push    AF              ; Save type
1776+ 27D7 CD AE 2A             call    EVAL            ; Evaluate expression
1777+ 27DA F1                   pop     AF              ; Restore type
1778+ 27DB E3                   ex      (SP),HL         ; Save code - Get var addr
1779+ 27DC 22 DE 81             ld      (BRKLIN),HL     ; Save address of variable
1780+ 27DF 1F                   rra                     ; Adjust type
1781+ 27E0 CD A1 2A             call    CHKTYP          ; Check types are the same
1782+ 27E3 CA 1E 28             jp      Z,LETNUM        ; Numeric - Move value
1783+ 27E6 E5           LETSTR: push    HL              ; Save address of string var
1784+ 27E7 2A 5A 82             ld      HL,(FPREG)      ; Pointer to string entry
1785+ 27EA E5                   push    HL              ; Save it on stack
1786+ 27EB 23                   inc     HL              ; Skip over length
1787+ 27EC 23                   inc     HL
1788+ 27ED 5E                   ld      E,(HL)          ; LSB of string address
1789+ 27EE 23                   inc     HL
1790+ 27EF 56                   ld      D,(HL)          ; MSB of string address
1791+ 27F0 2A 35 81             ld      HL,(BASTXT)     ; Point to start of program
1792+ 27F3 CD BC 23             call    CPDEHL          ; Is string before program?
1793+ 27F6 D2 0D 28             jp      NC,CRESTR       ; Yes - Create string entry
1794+ 27F9 2A AD 80             ld      HL,(STRSPC)     ; Point to string space
1795+ 27FC CD BC 23             call    CPDEHL          ; Is string literal in program?
1796+ 27FF D1                   pop     DE              ; Restore address of string
1797+ 2800 D2 15 28             jp      NC,MVSTPT       ; Yes - Set up pointer
1798+ 2803 21 CF 81             ld      HL,TMPSTR       ; Temporary string pool
1799+ 2806 CD BC 23             call    CPDEHL          ; Is string in temporary pool?
1800+ 2809 D2 15 28             jp      NC,MVSTPT       ; No - Set up pointer
1801+ 280C 3E                   defb    $3E             ; Skip "pop DE"
1802+ 280D D1           CRESTR: pop     DE              ; Restore address of string
1803+ 280E CD 05 31             call    BAKTMP          ; Back to last tmp-str entry
1804+ 2811 EB                   ex      DE,HL           ; Address of string entry
1805+ 2812 CD 3E 2F             call    SAVSTR          ; Save string in string area
1806+ 2815 CD 05 31     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1807+ 2818 E1                   pop     HL              ; Get string pointer
1808+ 2819 CD 04 39             call    DETHL4          ; Move string pointer to var
1809+ 281C E1                   pop     HL              ; Restore code string address
1810+ 281D C9                   ret
1811+ 281E
1812+ 281E E5           LETNUM: push    HL              ; Save address of variable
1813+ 281F CD 01 39             call    FPTHL           ; Move value to variable
1814+ 2822 D1                   pop     DE              ; Restore address of variable
1815+ 2823 E1                   pop     HL              ; Restore code string address
1816+ 2824 C9                   ret
1817+ 2825
1818+ 2825 CD 22 33     ON:     call    GETINT          ; Get integer 0-255
1819+ 2828 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1820+ 2829 47                   ld      B,A             ; Save in B
1821+ 282A FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1822+ 282C CA 34 28             jp      Z,ONGO          ; Yes - Find line number
1823+ 282F CD C2 23             call    CHKSYN          ; Make sure it's "GOTO"
1824+ 2832 88                   defb    ZGOTO           ; "GOTO" token
1825+ 2833 2B                   dec     HL              ; Cancel increment
1826+ 2834 4B           ONGO:   ld      C,E             ; Integer of branch value
1827+ 2835 0D           ONGOLP: dec     C               ; Count branches
1828+ 2836 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1829+ 2837 CA F3 25             jp      Z,ONJMP         ; Go to that line if right one
1830+ 283A CD DC 26             call    GETLN           ; Get line number to DE
1831+ 283D FE 2C                cp      ','             ; Another line number?
1832+ 283F C0                   ret     NZ              ; No - Drop through
1833+ 2840 C3 35 28             jp      ONGOLP          ; Yes - loop
1834+ 2843
1835+ 2843 CD AE 2A     IF:     call    EVAL            ; Evaluate expression
1836+ 2846 7E                   ld      A,(HL)          ; Get token
1837+ 2847 FE 88                cp      ZGOTO           ; "GOTO" token?
1838+ 2849 CA 51 28             jp      Z,IFGO          ; Yes - Get line
1839+ 284C CD C2 23             call    CHKSYN          ; Make sure it's "THEN"
1840+ 284F BB                   defb    ZTHEN           ; "THEN" token
1841+ 2850 2B                   dec     HL              ; Cancel increment
1842+ 2851 CD 9F 2A     IFGO:   call    TSTNUM          ; Make sure it's numeric
1843+ 2854 CD A9 38             call    TSTSGN          ; Test state of expression
1844+ 2857 CA 63 28             jp      Z,IF1           ; False - Jump over
1845+ 285A CD 0B 26     IF0:    call    GETCHR          ; Get next character
1846+ 285D DA 71 27             jp      C,GOTO          ; Number - GOTO that line
1847+ 2860 C3 F2 25             jp      IFJMP           ; Otherwise do statement
1848+ 2863 0E AF        IF1:    ld      C,ZELSE
1849+ 2865 CD B8 27             call    REM+2           ; check statement
1850+ 2868 B7                   or      A               ; end of line?
1851+ 2869 C8                   ret     Z               ; yes, leave
1852+ 286A FE AF                cp      ZELSE
1853+ 286C 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1854+ 286E C3 5A 28             jp      IF0             ; return to IF
1855+ 2871
1856+ 2871
1857+ 2871 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1858+ 2872 CD 0B 26             call    GETCHR          ; Get next character
1859+ 2875 CA D8 28     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1860+ 2878 C8           PRNTLP: ret     Z               ; End of list - Exit
1861+ 2879 FE B7                cp      ZTAB            ; "TAB(" token?
1862+ 287B CA 00 29             jp      Z,DOTAB         ; Yes - Do TAB routine
1863+ 287E FE BA                cp      ZSPC            ; "SPC(" token?
1864+ 2880 CA 00 29             jp      Z,DOTAB         ; Yes - Do SPC routine
1865+ 2883 E5                   push    HL              ; Save code string address
1866+ 2884 FE 2C                cp      ','             ; Comma?
1867+ 2886 CA E7 28             jp      Z,DOCOM         ; Yes - Move to next zone
1868+ 2889 FE 3B                cp      ';'             ; Semi-colon?
1869+ 288B CA 24 29             jp      Z,NEXITM        ; Do semi-colon routine
1870+ 288E C1                   pop     BC              ; Code string address to BC
1871+ 288F CD AE 2A             call    EVAL            ; Evaluate expression
1872+ 2892 E5                   push    HL              ; Save code string address
1873+ 2893 3A 94 81             ld      A,(TYPE)        ; Get variable type
1874+ 2896 B7                   or      A               ; Is it a string variable?
1875+ 2897 C2 BF 28             jp      NZ,PRNTST       ; Yes - Output string contents
1876+ 289A CD 4E 3A             call    NUMASC          ; Convert number to text
1877+ 289D CD 62 2F             call    CRTST           ; Create temporary string
1878+ 28A0 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1879+ 28A2 2A 5A 82             ld      HL,(FPREG)      ; Get length of output
1880+ 28A5 34                   inc     (HL)            ; Plus 1 for the space
1881+ 28A6 2A 5A 82             ld      HL,(FPREG)      ; < Not needed >
1882+ 28A9 3A A2 80             ld      A,(LWIDTH)      ; Get width of line
1883+ 28AC 47                   ld      B,A             ; To B
1884+ 28AD 04                   inc     B               ; Width 255 (No limit)?
1885+ 28AE CA BB 28             jp      Z,PRNTNB        ; Yes - Output number string
1886+ 28B1 04                   inc     B               ; Adjust it
1887+ 28B2 3A 92 81             ld      A,(CURPOS)      ; Get cursor position
1888+ 28B5 86                   add     A,(HL)          ; Add length of string
1889+ 28B6 3D                   dec     A               ; Adjust it
1890+ 28B7 B8                   cp      B               ; Will output fit on this line?
1891+ 28B8 D4 D8 28             call    NC,PRNTCRLF     ; No - CRLF first
1892+ 28BB CD A7 2F     PRNTNB: call    PRS1            ; Output string at (HL)
1893+ 28BE AF                   xor     A               ; Skip call by setting 'z' flag
1894+ 28BF C4 A7 2F     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1895+ 28C2 E1                   pop     HL              ; Restore code string address
1896+ 28C3 C3 71 28             jp      MRPRNT          ; See if more to PRINT
1897+ 28C6
1898+ 28C6 3A 92 81     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1899+ 28C9 B7                   or      A               ; Already at start?
1900+ 28CA C8                   ret     Z               ; Yes - Do nothing
1901+ 28CB C3 D8 28             jp      PRNTCRLF        ; Start a new line
1902+ 28CE
1903+ 28CE AF           ENDINP: xor     A
1904+ 28CF 32 40 82             ld      (KBDNPT),A      ; char is not from keyboard
1905+ 28D2 77                   ld      (HL),A          ; Mark end of buffer
1906+ 28D3 21 37 81             ld      HL,BUFFER-1     ; Point to buffer
1907+ 28D6 18 0A                jr      CNTEND
1908+ 28D8 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1909+ 28DA CD CD 23             call    OUTC            ; Output character
1910+ 28DD 3E 0A                ld      A,LF            ; Load a LF
1911+ 28DF CD CD 23             call    OUTC            ; Output character
1912+ 28E2 AF           CNTEND: xor     A               ; Set to position 0
1913+ 28E3 32 92 81             ld      (CURPOS),A      ; Store it
1914+ 28E6 C9                   ret                     ; return to caller
1915+ 28E7
1916+ 28E7 3A A3 80     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1917+ 28EA 47                   ld      B,A             ; Save in B
1918+ 28EB 3A FB 81             ld      A,(SCR_CURS_X)  ; Get current position
1919+ 28EE B8                   cp      B               ; Within the limit?
1920+ 28EF D4 D8 28             call    NC,PRNTCRLF     ; No - output CRLF
1921+ 28F2 D2 24 29             jp      NC,NEXITM       ; Get next item
1922+ 28F5 D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1923+ 28F7 D2 F5 28             jp      NC,ZONELP       ; Repeat if more zones
1924+ 28FA 2F                   cpl                     ; Number of null chars to output
1925+ 28FB 0E 00                ld      C,NLLCR         ; null char
1926+ 28FD C3 1A 29             jp      ASPCS           ; Output them
1927+ 2900
1928+ 2900 F5           DOTAB:  push    AF              ; Save token
1929+ 2901 CD 1F 33             call    FNDNUM          ; Evaluate expression
1930+ 2904 CD C2 23             call    CHKSYN          ; Make sure ")" follows
1931+ 2907 29                   defb    ')'
1932+ 2908 2B                   dec     HL              ; Back space on to ")"
1933+ 2909 F1                   pop     AF              ; Restore token
1934+ 290A 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1935+ 290C D6 BA                sub     ZSPC            ; Was it "SPC(" ?
1936+ 290E E5                   push    HL              ; Save code string address
1937+ 290F CA 15 29             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1938+ 2912 3A FB 81             ld      A,(SCR_CURS_X)  ; Get current X position
1939+ 2915 2F           DOSPC:  cpl                     ; Number of spaces to print to
1940+ 2916 83                   add     A,E             ; Total number to print
1941+ 2917 D2 24 29             jp      NC,NEXITM       ; TAB < Current POS(X)
1942+ 291A 3C           ASPCS:  inc     A               ; Output A spaces
1943+ 291B 47                   ld      B,A             ; Save number to print
1944+ 291C 79           SPCLP:  ld      A,C             ; char to print
1945+ 291D CD CD 23             call    OUTC            ; Output character in A
1946+ 2920 05                   dec     B               ; Count them
1947+ 2921 C2 1C 29             jp      NZ,SPCLP        ; Repeat if more
1948+ 2924 E1           NEXITM: pop     HL              ; Restore code string address
1949+ 2925 CD 0B 26             call    GETCHR          ; Get next character
1950+ 2928 C3 78 28             jp      PRNTLP          ; More to print
1951+ 292B
1952+ 292B 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1952+ 292F 6F 20 66 72
1952+ 2933 6F 6D 20 73
1952+ 2937 74 61 72 74
1952+ 293B 0D 00
1953+ 293D
1954+ 293D 3A DD 81     BADINP: ld      A,(READFG)      ; READ or INPUT?
1955+ 2940 B7                   or      A
1956+ 2941 C2 BC 20             jp      NZ,DATSNR       ; READ - ?SN Error
1957+ 2944 C1                   pop     BC              ; Throw away code string addr
1958+ 2945 21 2B 29             ld      HL,REDO         ; "Redo from start" message
1959+ 2948 CD A4 2F             call    PRS             ; Output string
1960+ 294B C3 3D 22             jp      DOAGN           ; Do last INPUT again
1961+ 294E
1962+ 294E CD 0F 2F     INPUT:  call    IDTEST          ; Test for illegal direct
1963+ 2951 7E                   ld      A,(HL)          ; Get character after "INPUT"
1964+ 2952 FE 22                cp      $22             ; '"' ; Is there a prompt string?
1965+ 2954 3E 00                ld      A,$00           ; Clear A and leave flags
1966+ 2956 32 A5 80             ld      (CTLOFG),A      ; Enable output
1967+ 2959 C2 68 29             jp      NZ,NOPMPT       ; No prompt - get input
1968+ 295C CD 63 2F             call    QTSTR           ; Get string terminated by '"'
1969+ 295F CD C2 23             call    CHKSYN          ; Check for ';' after prompt
1970+ 2962 3B                   defb    ";"
1971+ 2963 E5                   push    HL              ; Save code string address
1972+ 2964 CD A7 2F             call    PRS1            ; Output prompt string
1973+ 2967 3E                   defb    $3E             ; Skip "push HL"
1974+ 2968 E5           NOPMPT: push    HL              ; Save code string address
1975+ 2969 CD 41 22             call    PROMPT          ; Get input with "? " prompt
1976+ 296C C1                   pop     BC              ; Restore code string address
1977+ 296D DA 5A 26             jp      C,INPBRK        ; Break pressed - Exit
1978+ 2970 23                   inc     HL              ; Next byte
1979+ 2971 7E                   ld      A,(HL)          ; Get it
1980+ 2972 B7                   or      A               ; End of line?
1981+ 2973 2B                   dec     HL              ; Back again
1982+ 2974 C5                   push    BC              ; Re-save code string address
1983+ 2975 3A 48 82             ld      A,(SERIALS_EN)  ; load serial state
1984+ 2978 EE 05                xor     %00000101       ; check if serial 1 is open and RX enabled
1985+ 297A CC 8F 01             call    Z,A_RTS_OFF      ; yes, set RTS on
1986+ 297D CD 59 09             call    CURSOR_OFF      ; disable cursor
1987+ 2980 CA B3 27             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1988+ 2983 36 2C                ld      (HL),','        ; Store comma as separator
1989+ 2985 C3 8D 29             jp      NXTITM          ; Get next item
1990+ 2988
1991+ 2988 E5           READ:   push    HL              ; Save code string address
1992+ 2989 2A 52 82             ld      HL,(NXTDAT)     ; Next DATA statement
1993+ 298C F6                   defb    $F6             ; Flag "READ"
1994+ 298D AF           NXTITM: xor     A               ; Flag "INPUT"
1995+ 298E 32 DD 81             ld      (READFG),A      ; Save "READ"/"INPUT" flag
1996+ 2991 E3                   ex      (SP),HL         ; Get code str' , Save pointer
1997+ 2992 C3 99 29             jp      GTVLUS          ; Get values
1998+ 2995
1999+ 2995 CD C2 23     NEDMOR: call    CHKSYN          ; Check for comma between items
2000+ 2998 2C                   defb    ','
2001+ 2999 CD AB 2C     GTVLUS: call    GETVAR          ; Get variable name
2002+ 299C E3                   ex      (SP),HL         ; Save code str" , Get pointer
2003+ 299D D5                   push    DE              ; Save variable address
2004+ 299E 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
2005+ 299F FE 2C                cp      ','             ; Comma?
2006+ 29A1 CA C1 29             jp      Z,ANTVLU        ; Yes - Get another value
2007+ 29A4 3A DD 81             ld      A,(READFG)      ; Is it READ?
2008+ 29A7 B7                   or      A
2009+ 29A8 C2 2D 2A             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
2010+ 29AB 3E 3F                ld      A,'?'           ; More INPUT needed
2011+ 29AD CD CD 23             call    OUTC            ; Output character
2012+ 29B0 CD 41 22             call    PROMPT          ; Get INPUT with prompt
2013+ 29B3 D1                   pop     DE              ; Variable address
2014+ 29B4 C1                   pop     BC              ; Code string address
2015+ 29B5 DA 5A 26             jp      C,INPBRK        ; Break pressed
2016+ 29B8 23                   inc     HL              ; Point to next DATA byte
2017+ 29B9 7E                   ld      A,(HL)          ; Get byte
2018+ 29BA B7                   or      A               ; Is it zero (No input) ?
2019+ 29BB 2B                   dec     HL              ; Back space INPUT pointer
2020+ 29BC C5                   push    BC              ; Save code string address
2021+ 29BD CA B3 27             jp      Z,NXTDTA        ; Find end of buffer
2022+ 29C0 D5                   push    DE              ; Save variable address
2023+ 29C1 3A 94 81     ANTVLU: ld      A,(TYPE)        ; Check data type
2024+ 29C4 B7                   or      A               ; Is it numeric?
2025+ 29C5 CA EB 29             jp      Z,INPBIN        ; Yes - Convert to binary
2026+ 29C8 CD 0B 26             call    GETCHR          ; Get next character
2027+ 29CB 57                   ld      D,A             ; Save input character
2028+ 29CC 47                   ld      B,A             ; Again
2029+ 29CD FE 22                cp      $22             ; '"'     ; Start of literal sting?
2030+ 29CF CA DF 29             jp      Z,STRENT        ; Yes - Create string entry
2031+ 29D2 3A DD 81             ld      A,(READFG)      ; "READ" or "INPUT" ?
2032+ 29D5 B7                   or      A
2033+ 29D6 57                   ld      D,A             ; Save 00 if "INPUT"
2034+ 29D7 CA DC 29             jp      Z,ITMSEP        ; "INPUT" - End with 00
2035+ 29DA 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
2036+ 29DC 06 2C        ITMSEP: ld      B,','           ; Item separator
2037+ 29DE 2B                   dec     HL              ; Back space for DTSTR
2038+ 29DF CD 66 2F     STRENT: call    DTSTR           ; Get string terminated by D
2039+ 29E2 EB                   ex      DE,HL           ; String address to DE
2040+ 29E3 21 F6 29             ld      HL,LTSTND       ; Where to go after LETSTR
2041+ 29E6 E3                   ex      (SP),HL         ; Save HL , get input pointer
2042+ 29E7 D5                   push    DE              ; Save address of string
2043+ 29E8 C3 E6 27             jp      LETSTR          ; Assign string to variable
2044+ 29EB
2045+ 29EB CD 0B 26     INPBIN: call    GETCHR          ; Get next character
2046+ 29EE CD B0 39             call    ASCTFP          ; Convert ASCII to FP number
2047+ 29F1 E3                   ex      (SP),HL         ; Save input ptr, Get var addr
2048+ 29F2 CD 01 39             call    FPTHL           ; Move FPREG to variable
2049+ 29F5 E1                   pop     HL              ; Restore input pointer
2050+ 29F6 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
2051+ 29F7 CD 0B 26             call    GETCHR          ; Get next character
2052+ 29FA CA 02 2A             jp      Z,MORDT         ; End of line - More needed?
2053+ 29FD FE 2C                cp      ','             ; Another value?
2054+ 29FF C2 3D 29             jp      NZ,BADINP       ; No - Bad input
2055+ 2A02 E3           MORDT:  ex      (SP),HL         ; Get code string address
2056+ 2A03 2B                   dec     HL              ; dec 'cos GETCHR INCs
2057+ 2A04 CD 0B 26             call    GETCHR          ; Get next character
2058+ 2A07 C2 95 29             jp      NZ,NEDMOR       ; More needed - Get it
2059+ 2A0A D1                   pop     DE              ; Restore DATA pointer
2060+ 2A0B 3A DD 81             ld      A,(READFG)      ; "READ" or "INPUT" ?
2061+ 2A0E B7                   or      A
2062+ 2A0F EB                   ex      DE,HL           ; DATA pointer to HL
2063+ 2A10 C2 31 26             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
2064+ 2A13 D5                   push    DE              ; Save code string address
2065+ 2A14 B6                   or      (HL)            ; More input given?
2066+ 2A15 21 1D 2A             ld      HL,EXTIG        ; "?Extra ignored" message
2067+ 2A18 C4 A4 2F             call    NZ,PRS          ; Output string if extra given
2068+ 2A1B E1                   pop     HL              ; Restore code string address
2069+ 2A1C C9                   ret
2070+ 2A1D
2071+ 2A1D 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2071+ 2A21 72 61 20 69
2071+ 2A25 67 6E 6F 72
2071+ 2A29 65 64 0D 00
2072+ 2A2D
2073+ 2A2D CD B4 27     FDTLP:  call    DATA            ; Get next statement
2074+ 2A30 B7                   or      A               ; End of line?
2075+ 2A31 C2 46 2A             jp      NZ,FANDT        ; No - See if DATA statement
2076+ 2A34 23                   inc     HL
2077+ 2A35 7E                   ld      A,(HL)          ; End of program?
2078+ 2A36 23                   inc     HL
2079+ 2A37 B6                   or      (HL)            ; 00 00 Ends program
2080+ 2A38 1E 06                ld      E,OD            ; ?OD Error
2081+ 2A3A CA DC 20             jp      Z,ERROR         ; Yes - Out of DATA
2082+ 2A3D 23                   inc     HL
2083+ 2A3E 5E                   ld      E,(HL)          ; LSB of line number
2084+ 2A3F 23                   inc     HL
2085+ 2A40 56                   ld      D,(HL)          ; MSB of line number
2086+ 2A41 EB                   ex      DE,HL
2087+ 2A42 22 D9 81             ld      (DATLIN),HL     ; Set line of current DATA item
2088+ 2A45 EB                   ex      DE,HL
2089+ 2A46 CD 0B 26     FANDT:  call    GETCHR          ; Get next character
2090+ 2A49 FE 83                cp      ZDATA           ; "DATA" token
2091+ 2A4B C2 2D 2A             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2092+ 2A4E C3 C1 29             jp      ANTVLU          ; Found - Convert input
2093+ 2A51
2094+ 2A51 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2095+ 2A54 C4 AB 2C     NEXT1:  call    NZ,GETVAR       ; Get index address
2096+ 2A57 22 DE 81             ld      (BRKLIN),HL     ; Save code string address
2097+ 2A5A CD 4B 20             call    BAKSTK          ; Look for "FOR" block
2098+ 2A5D C2 C8 20             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2099+ 2A60 F9                   ld      SP,HL           ; Clear nested loops
2100+ 2A61 D5                   push    DE              ; Save index address
2101+ 2A62 7E                   ld      A,(HL)          ; Get sign of STEP
2102+ 2A63 23                   inc     HL
2103+ 2A64 F5                   push    AF              ; Save sign of STEP
2104+ 2A65 D5                   push    DE              ; Save index address
2105+ 2A66 CD E7 38             call    PHLTFP          ; Move index value to FPREG
2106+ 2A69 E3                   ex      (SP),HL         ; Save address of TO value
2107+ 2A6A E5                   push    HL              ; Save address of index
2108+ 2A6B CD 03 36             call    ADDPHL          ; Add STEP to index value
2109+ 2A6E E1                   pop     HL              ; Restore address of index
2110+ 2A6F CD 01 39             call    FPTHL           ; Move value to index variable
2111+ 2A72 E1                   pop     HL              ; Restore address of TO value
2112+ 2A73 CD F8 38             call    LOADFP          ; Move TO value to BCDE
2113+ 2A76 E5                   push    HL              ; Save address of line of FOR
2114+ 2A77 CD 24 39             call    CMPNUM          ; Compare index with TO value
2115+ 2A7A E1                   pop     HL              ; Restore address of line num
2116+ 2A7B C1                   pop     BC              ; Address of sign of STEP
2117+ 2A7C 90                   sub     B               ; Compare with expected sign
2118+ 2A7D CD F8 38             call    LOADFP          ; BC = Loop stmt,DE = Line num
2119+ 2A80 CA 8C 2A             jp      Z,KILFOR        ; Loop finished - Terminate it
2120+ 2A83 EB                   ex      DE,HL           ; Loop statement line number
2121+ 2A84 22 AF 80             ld      (LINEAT),HL     ; Set loop line number
2122+ 2A87 69                   ld      L,C             ; Set code string to loop
2123+ 2A88 60                   ld      H,B
2124+ 2A89 C3 C7 25             jp      PUTFID          ; Put back "FOR" and continue
2125+ 2A8C
2126+ 2A8C F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2127+ 2A8D 2A DE 81             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2128+ 2A90 7E                   ld      A,(HL)          ; Get next byte in code string
2129+ 2A91 FE 2C                cp      ','             ; More NEXTs ?
2130+ 2A93 C2 CB 25             jp      NZ,RUNCNT       ; No - Do next statement
2131+ 2A96 CD 0B 26             call    GETCHR          ; Position to index name
2132+ 2A99 CD 54 2A             call    NEXT1           ; Re-enter NEXT routine
2133+ 2A9C              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2134+ 2A9C
2135+ 2A9C CD AE 2A     GETNUM: call    EVAL            ; Get a numeric expression
2136+ 2A9F F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2137+ 2AA0 37           TSTSTR: scf                     ; Set carry (string)
2138+ 2AA1 3A 94 81     CHKTYP: ld      A,(TYPE)        ; Check types match
2139+ 2AA4 8F                   adc     A,A             ; Expected + actual
2140+ 2AA5 B7                   or      A               ; Clear carry , set parity
2141+ 2AA6 E8                   ret     PE              ; Even parity - Types match
2142+ 2AA7 C3 D4 20             jp      TMERR           ; Different types - Error
2143+ 2AAA
2144+ 2AAA CD C2 23     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2145+ 2AAD 28                   defb    '('
2146+ 2AAE 2B           EVAL:   dec     HL              ; Evaluate expression & save
2147+ 2AAF 16 00                ld      D,$00           ; Precedence value
2148+ 2AB1 D5           EVAL1:  push    DE              ; Save precedence
2149+ 2AB2 0E 01                ld      C,$01
2150+ 2AB4 CD 7F 20             call    CHKSTK          ; Check for 1 level of stack
2151+ 2AB7 CD 25 2B             call    OPRND           ; Get next expression value
2152+ 2ABA 22 E0 81     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2153+ 2ABD 2A E0 81     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2154+ 2AC0 C1                   pop     BC              ; Precedence value and operator
2155+ 2AC1 78                   ld      A,B             ; Get precedence value
2156+ 2AC2 FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2157+ 2AC4 D4 9F 2A             call    NC,TSTNUM       ; No - Make sure it's a number
2158+ 2AC7 7E                   ld      A,(HL)          ; Get next operator / function
2159+ 2AC8 16 00                ld      D,$00           ; Clear Last relation
2160+ 2ACA D6 C8        RLTLP:  sub     ZGTR            ; ">" Token
2161+ 2ACC DA E6 2A             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2162+ 2ACF FE 03                cp      ZLTH+1-ZGTR     ; < = >
2163+ 2AD1 D2 E6 2A             jp      NC,FOPRND       ; Function - Call it
2164+ 2AD4 FE 01                cp      ZEQUAL-ZGTR     ; "="
2165+ 2AD6 17                   rla                     ; <- Test for legal
2166+ 2AD7 AA                   xor     D               ; <- combinations of < = >
2167+ 2AD8 BA                   cp      D               ; <- by combining last token
2168+ 2AD9 57                   ld      D,A             ; <- with current one
2169+ 2ADA DA C2 20             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2170+ 2ADD 22 D5 81             ld      (CUROPR),HL     ; Save address of current token
2171+ 2AE0 CD 0B 26             call    GETCHR          ; Get next character
2172+ 2AE3 C3 CA 2A             jp      RLTLP           ; Treat the two as one
2173+ 2AE6
2174+ 2AE6 7A           FOPRND: ld      A,D             ; < = > found ?
2175+ 2AE7 B7                   or      A
2176+ 2AE8 C2 26 2C             jp      NZ,TSTRED       ; Yes - Test for reduction
2177+ 2AEB 7E                   ld      A,(HL)          ; Get operator token
2178+ 2AEC 22 D5 81             ld      (CUROPR),HL     ; Save operator address
2179+ 2AEF D6 BE                sub     ZPLUS           ; Operator or function?
2180+ 2AF1 D8                   ret     C               ; Neither - Exit
2181+ 2AF2 FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2182+ 2AF4 D0                   ret     NC              ; No - Exit
2183+ 2AF5 5F                   ld      E,A             ; Coded operator
2184+ 2AF6 3A 94 81             ld      A,(TYPE)        ; Get data type
2185+ 2AF9 3D                   dec     A               ; FF = numeric , 00 = string
2186+ 2AFA B3                   or      E               ; Combine with coded operator
2187+ 2AFB 7B                   ld      A,E             ; Get coded operator
2188+ 2AFC CA 9A 30             jp      Z,CONCAT        ; String concatenation
2189+ 2AFF 07                   rlca                    ; Times 2
2190+ 2B00 83                   add     A,E             ; Times 3
2191+ 2B01 5F                   ld      E,A             ; To DE (D is 0)
2192+ 2B02 21 3D 1F             ld      HL,PRITAB       ; Precedence table
2193+ 2B05 19                   add     HL,DE           ; To the operator concerned
2194+ 2B06 78                   ld      A,B             ; Last operator precedence
2195+ 2B07 56                   ld      D,(HL)          ; Get evaluation precedence
2196+ 2B08 BA                   cp      D               ; Compare with eval precedence
2197+ 2B09 D0                   ret     NC              ; Exit if higher precedence
2198+ 2B0A 23                   inc     HL              ; Point to routine address
2199+ 2B0B CD 9F 2A             call    TSTNUM          ; Make sure it's a number
2200+ 2B0E
2201+ 2B0E C5           STKTHS: push    BC              ; Save last precedence & token
2202+ 2B0F 01 BD 2A             ld      BC,EVAL3        ; Where to go on prec' break
2203+ 2B12 C5                   push    BC              ; Save on stack for return
2204+ 2B13 43                   ld      B,E             ; Save operator
2205+ 2B14 4A                   ld      C,D             ; Save precedence
2206+ 2B15 CD DA 38             call    STAKFP          ; Move value to stack
2207+ 2B18 58                   ld      E,B             ; Restore operator
2208+ 2B19 51                   ld      D,C             ; Restore precedence
2209+ 2B1A 4E                   ld      C,(HL)          ; Get LSB of routine address
2210+ 2B1B 23                   inc     HL
2211+ 2B1C 46                   ld      B,(HL)          ; Get MSB of routine address
2212+ 2B1D 23                   inc     HL
2213+ 2B1E C5                   push    BC              ; Save routine address
2214+ 2B1F 2A D5 81             ld      HL,(CUROPR)     ; Address of current operator
2215+ 2B22 C3 B1 2A             jp      EVAL1           ; Loop until prec' break
2216+ 2B25
2217+ 2B25 AF           OPRND:  xor     A               ; Get operand routine
2218+ 2B26 32 94 81             ld      (TYPE),A        ; Set numeric expected
2219+ 2B29 CD 0B 26             call    GETCHR          ; Get next character
2220+ 2B2C 1E 24                ld      E,MO            ; ?MO Error
2221+ 2B2E CA DC 20             jp      Z,ERROR         ; No operand - Error
2222+ 2B31 DA B0 39             jp      C,ASCTFP        ; Number - Get value
2223+ 2B34 CD AD 26             call    CHKLTR          ; See if a letter
2224+ 2B37 D2 8C 2B             jp      NC,CONVAR       ; Letter - Find variable
2225+ 2B3A FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2226+ 2B3C 20 12                jr      NZ,NOTAMP
2227+ 2B3E CD 0B 26             call    GETCHR          ; Get next character
2228+ 2B41 FE 48                cp      'H'             ; Hex number indicated? [function added]
2229+ 2B43 CA 7F 4C             jp      Z,HEXTFP        ; Convert Hex to FPREG
2230+ 2B46 FE 42                cp      'B'             ; Binary number indicated? [function added]
2231+ 2B48 CA EF 4C             jp      Z,BINTFP        ; Convert Bin to FPREG
2232+ 2B4B 1E 02                ld      E,SN            ; If neither then a ?SN Error
2233+ 2B4D CA DC 20             jp      Z,ERROR         ;
2234+ 2B50 FE BE        NOTAMP: cp      ZPLUS           ; '+' Token ?
2235+ 2B52 CA 25 2B             jp      Z,OPRND         ; Yes - Look for operand
2236+ 2B55 FE 2E                cp      '.'             ; '.' ?
2237+ 2B57 CA B0 39             jp      Z,ASCTFP        ; Yes - Create FP number
2238+ 2B5A FE BF                cp      ZMINUS          ; '-' Token ?
2239+ 2B5C CA 7B 2B             jp      Z,MINUS         ; Yes - Do minus
2240+ 2B5F FE 22                cp      $22             ; '"'             ; Literal string ?
2241+ 2B61 CA 63 2F             jp      Z,QTSTR         ; Get string terminated by '"'
2242+ 2B64 FE BC                cp      ZNOT            ; "NOT" Token ?
2243+ 2B66 CA 86 2C             jp      Z,EVNOT         ; Yes - Eval NOT expression
2244+ 2B69 FE B9                cp      ZFN             ; "FN" Token ?
2245+ 2B6B CA C7 2E             jp      Z,DOFN          ; Yes - Do FN routine
2246+ 2B6E D6 CB                sub     ZSGN            ; Is it a function?
2247+ 2B70 D2 9D 2B             jp      NC,FNOFST       ; Yes - Evaluate function
2248+ 2B73 CD AA 2A     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2249+ 2B76 CD C2 23             call    CHKSYN          ; Make sure ")" follows
2250+ 2B79 29                   defb    ')'
2251+ 2B7A C9                   ret
2252+ 2B7B
2253+ 2B7B 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2254+ 2B7D CD B1 2A             call    EVAL1           ; Evaluate until prec' break
2255+ 2B80 2A E0 81             ld      HL,(NXTOPR)     ; Get next operator address
2256+ 2B83 E5                   push    HL              ; Save next operator address
2257+ 2B84 CD D2 38             call    INVSGN          ; Negate value
2258+ 2B87 CD 9F 2A     RETNUM: call    TSTNUM          ; Make sure it's a number
2259+ 2B8A E1                   pop     HL              ; Restore next operator address
2260+ 2B8B C9                   ret
2261+ 2B8C
2262+ 2B8C CD AB 2C     CONVAR: call    GETVAR          ; Get variable address to DE
2263+ 2B8F E5           FRMEVL: push    HL              ; Save code string address
2264+ 2B90 EB                   ex      DE,HL           ; Variable address to HL
2265+ 2B91 22 5A 82             ld      (FPREG),HL      ; Save address of variable
2266+ 2B94 3A 94 81             ld      A,(TYPE)        ; Get type
2267+ 2B97 B7                   or      A               ; Numeric?
2268+ 2B98 CC E7 38             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2269+ 2B9B E1                   pop     HL              ; Restore code string address
2270+ 2B9C C9                   ret
2271+ 2B9D
2272+ 2B9D 06 00        FNOFST: ld      B,$00           ; Get address of function
2273+ 2B9F 07                   rlca                    ; Double function offset
2274+ 2BA0 4F                   ld      C,A             ; BC = Offset in function table
2275+ 2BA1 C5                   push    BC              ; Save adjusted token value
2276+ 2BA2 CD 0B 26             call    GETCHR          ; Get next character
2277+ 2BA5 79                   ld      A,C             ; Get adjusted token value
2278+ 2BA6 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2279+ 2BA8 CA D6 40             jp      Z,POINT         ; Yes, do "POINT"
2280+ 2BAB FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2281+ 2BAD CA 76 31             jp      Z,INSTR         ; Yes, do "INSTR"
2282+ 2BB0 FE 3D                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2283+ 2BB2 DA CE 2B             jp      C,FNVAL         ; No - Do function
2284+ 2BB5 CD AA 2A             call    OPNPAR          ; Evaluate expression  (X,...
2285+ 2BB8 CD C2 23             call    CHKSYN          ; Make sure ',' follows
2286+ 2BBB 2C                   defb    ','
2287+ 2BBC CD A0 2A             call    TSTSTR          ; Make sure it's a string
2288+ 2BBF EB                   ex      DE,HL           ; Save code string address
2289+ 2BC0 2A 5A 82             ld      HL,(FPREG)      ; Get address of string
2290+ 2BC3 E3                   ex      (SP),HL         ; Save address of string
2291+ 2BC4 E5                   push    HL              ; Save adjusted token value
2292+ 2BC5 EB                   ex      DE,HL           ; Restore code string address
2293+ 2BC6 CD 22 33             call    GETINT          ; Get integer 0-255
2294+ 2BC9 EB                   ex      DE,HL           ; Save code string address
2295+ 2BCA E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2296+ 2BCB C3 D6 2B             jp      GOFUNC          ; Jump to string function
2297+ 2BCE
2298+ 2BCE CD 73 2B     FNVAL:  call    EVLPAR          ; Evaluate expression
2299+ 2BD1 E3                   ex      (SP),HL         ; HL = Adjusted token value
2300+ 2BD2 11 87 2B             ld      DE,RETNUM       ; Return number from function
2301+ 2BD5 D5                   push    DE              ; Save on stack
2302+ 2BD6 01 FA 1C     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2303+ 2BD9 09                   add     HL,BC           ; Point to right address
2304+ 2BDA 4E                   ld      C,(HL)          ; Get LSB of address
2305+ 2BDB 23                   inc     HL              ;
2306+ 2BDC 66                   ld      H,(HL)          ; Get MSB of address
2307+ 2BDD 69                   ld      L,C             ; Address to HL
2308+ 2BDE E9                   jp      (HL)            ; Jump to function
2309+ 2BDF
2310+ 2BDF 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2311+ 2BE0 FE BF                cp      ZMINUS          ; '-' token ?
2312+ 2BE2 C8                   ret     Z               ; Yes - Return
2313+ 2BE3 FE 2D                cp      '-'             ; '-' ASCII ?
2314+ 2BE5 C8                   ret     Z               ; Yes - Return
2315+ 2BE6 14                   inc     D               ; Inc to flag positive exponent
2316+ 2BE7 FE 2B                cp      '+'             ; '+' ASCII ?
2317+ 2BE9 C8                   ret     Z               ; Yes - Return
2318+ 2BEA FE BE                cp      ZPLUS           ; '+' token ?
2319+ 2BEC C8                   ret     Z               ; Yes - Return
2320+ 2BED 2B                   dec     HL              ; dec 'cos GETCHR INCs
2321+ 2BEE C9                   ret                     ; Return "NZ"
2322+ 2BEF
2323+ 2BEF              ; execute OR, AND, and XOR operations
2324+ 2BEF AF           PAND:   xor     A               ; for AND, Z=1
2325+ 2BF0 18 07                jr      CNTLGC
2326+ 2BF2 AF           POR:    xor     A               ; for OR, Z=0, S=1
2327+ 2BF3 D6 01                sub     $01
2328+ 2BF5 18 02                jr      CNTLGC
2329+ 2BF7 AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2330+ 2BF8 3C                   inc     A
2331+ 2BF9 F5           CNTLGC: push    AF              ; store operand's flags
2332+ 2BFA CD 9F 2A             call    TSTNUM          ; Make sure it's a number
2333+ 2BFD CD C1 26             call    DEINT           ; Get integer -32768 to 32767
2334+ 2C00 F1                   pop     AF              ; retrieve operand's flags
2335+ 2C01 EB                   ex      DE,HL           ; <- Get last
2336+ 2C02 C1                   pop     BC              ; <-  value
2337+ 2C03 E3                   ex      (SP),HL         ; <-  from
2338+ 2C04 EB                   ex      DE,HL           ; <-  stack
2339+ 2C05 CD EA 38             call    FPBCDE          ; Move last value to FPREG
2340+ 2C08 F5                   push    AF              ; store operand's flags
2341+ 2C09 CD C1 26             call    DEINT           ; Get integer -32768 to 32767
2342+ 2C0C F1                   pop     AF              ; retrieve operand's flags
2343+ 2C0D C1                   pop     BC              ; Get value
2344+ 2C0E 79                   ld      A,C             ; Get LSB
2345+ 2C0F 21 85 2E             ld      HL,ACPASS       ; Address of save AC as current
2346+ 2C12 20 05                jr      NZ,POR1         ; if X/OR, jump over
2347+ 2C14 A3           PAND1:  and     E               ; "AND" LSBs
2348+ 2C15 4F                   ld      C,A             ; Save LSB
2349+ 2C16 78                   ld      A,B             ; Get MSB
2350+ 2C17 A2                   and     D               ; "AND" MSBs
2351+ 2C18 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2352+ 2C19 F2 21 2C     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2353+ 2C1C B3                   or      E               ; "OR" LSBs
2354+ 2C1D 4F                   ld      C,A             ; Save LSB
2355+ 2C1E 78                   ld      A,B             ; Get MSB
2356+ 2C1F B2                   or      D               ; "OR" MSBs
2357+ 2C20 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2358+ 2C21 AB           PXOR1:  xor     E               ; "XOR" LSBs
2359+ 2C22 4F                   ld      C,A             ; Save LSB
2360+ 2C23 78                   ld      A,B             ; Get MSB
2361+ 2C24 AA                   xor     D               ; "XOR" MSBs
2362+ 2C25 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2363+ 2C26
2364+ 2C26 21 38 2C     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2365+ 2C29 3A 94 81             ld      A,(TYPE)        ; Get data type
2366+ 2C2C 1F                   rra                     ; Carry set = string
2367+ 2C2D 7A                   ld      A,D             ; Get last precedence value
2368+ 2C2E 17                   rla                     ; Times 2 plus carry
2369+ 2C2F 5F                   ld      E,A             ; To E
2370+ 2C30 16 64                ld      D,$64           ; Relational precedence
2371+ 2C32 78                   ld      A,B             ; Get current precedence
2372+ 2C33 BA                   cp      D               ; Compare with last
2373+ 2C34 D0                   ret     NC              ; Eval if last was rel' or log'
2374+ 2C35 C3 0E 2B             jp      STKTHS          ; Stack this one and get next
2375+ 2C38
2376+ 2C38 3A 2C        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2377+ 2C3A 79           CMPLG1: ld      A,C             ; Get data type
2378+ 2C3B B7                   or      A
2379+ 2C3C 1F                   rra
2380+ 2C3D C1                   pop     BC              ; Get last expression to BCDE
2381+ 2C3E D1                   pop     DE
2382+ 2C3F F5                   push    AF              ; Save status
2383+ 2C40 CD A1 2A             call    CHKTYP          ; Check that types match
2384+ 2C43 21 7C 2C             ld      HL,CMPRES       ; Result to comparison
2385+ 2C46 E5                   push    HL              ; Save for RETurn
2386+ 2C47 CA 24 39             jp      Z,CMPNUM        ; Compare values if numeric
2387+ 2C4A AF                   xor     A               ; Compare two strings
2388+ 2C4B 32 94 81             ld      (TYPE),A        ; Set type to numeric
2389+ 2C4E D5                   push    DE              ; Save string name
2390+ 2C4F CD E7 30             call    GSTRCU          ; Get current string
2391+ 2C52 7E                   ld      A,(HL)          ; Get length of string
2392+ 2C53 23                   inc     HL
2393+ 2C54 23                   inc     HL
2394+ 2C55 4E                   ld      C,(HL)          ; Get LSB of address
2395+ 2C56 23                   inc     HL
2396+ 2C57 46                   ld      B,(HL)          ; Get MSB of address
2397+ 2C58 D1                   pop     DE              ; Restore string name
2398+ 2C59 C5                   push    BC              ; Save address of string
2399+ 2C5A F5                   push    AF              ; Save length of string
2400+ 2C5B CD EB 30             call    GSTRDE          ; Get second string
2401+ 2C5E CD F8 38             call    LOADFP          ; Get address of second string
2402+ 2C61 F1                   pop     AF              ; Restore length of string 1
2403+ 2C62 57                   ld      D,A             ; Length to D
2404+ 2C63 E1                   pop     HL              ; Restore address of string 1
2405+ 2C64 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2406+ 2C65 B2                   or      D               ; Bytes of string 1 to do
2407+ 2C66 C8                   ret     Z               ; Exit if all bytes compared
2408+ 2C67 7A                   ld      A,D             ; Get bytes of string 1 to do
2409+ 2C68 D6 01                sub     $01
2410+ 2C6A D8                   ret     C               ; Exit if end of string 1
2411+ 2C6B AF                   xor     A
2412+ 2C6C BB                   cp      E               ; Bytes of string 2 to do
2413+ 2C6D 3C                   inc     A
2414+ 2C6E D0                   ret     NC              ; Exit if end of string 2
2415+ 2C6F 15                   dec     D               ; Count bytes in string 1
2416+ 2C70 1D                   dec     E               ; Count bytes in string 2
2417+ 2C71 0A                   ld      A,(BC)          ; Byte in string 2
2418+ 2C72 BE                   cp      (HL)            ; Compare to byte in string 1
2419+ 2C73 23                   inc     HL              ; Move up string 1
2420+ 2C74 03                   inc     BC              ; Move up string 2
2421+ 2C75 CA 64 2C             jp      Z,CMPSTR        ; Same - Try next bytes
2422+ 2C78 3F                   ccf                     ; Flag difference (">" or "<")
2423+ 2C79 C3 B4 38             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2424+ 2C7C
2425+ 2C7C 3C           CMPRES: inc     A               ; Increment current value
2426+ 2C7D 8F                   adc     A,A             ; Double plus carry
2427+ 2C7E C1                   pop     BC              ; Get other value
2428+ 2C7F A0                   and     B               ; Combine them
2429+ 2C80 C6 FF                add     A,-1            ; Carry set if different
2430+ 2C82 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2431+ 2C83 C3 BB 38             jp      FLGREL          ; Set current value & continue
2432+ 2C86
2433+ 2C86 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2434+ 2C88 CD B1 2A             call    EVAL1           ; Eval until precedence break
2435+ 2C8B CD 9F 2A             call    TSTNUM          ; Make sure it's a number
2436+ 2C8E CD C1 26             call    DEINT           ; Get integer -32768 - 32767
2437+ 2C91 7B                   ld      A,E             ; Get LSB
2438+ 2C92 2F                   cpl                     ; Invert LSB
2439+ 2C93 4F                   ld      C,A             ; Save "NOT" of LSB
2440+ 2C94 7A                   ld      A,D             ; Get MSB
2441+ 2C95 2F                   cpl                     ; Invert MSB
2442+ 2C96 CD 85 2E             call    ACPASS          ; Save AC as current
2443+ 2C99 C1                   pop     BC              ; Clean up stack
2444+ 2C9A C3 BD 2A             jp      EVAL3           ; Continue evaluation
2445+ 2C9D
2446+ 2C9D 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2447+ 2C9E CD 0B 26             call    GETCHR          ; Get next character
2448+ 2CA1 C8                   ret     Z               ; End of DIM statement
2449+ 2CA2 CD C2 23             call    CHKSYN          ; Make sure ',' follows
2450+ 2CA5 2C                   defb    ','
2451+ 2CA6 01 9D 2C     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2452+ 2CA9 C5                   push    BC              ; Save on stack
2453+ 2CAA F6                   defb    $F6             ; Flag "Create" variable
2454+ 2CAB AF           GETVAR: xor     A               ; Find variable address,to DE
2455+ 2CAC 32 93 81             ld      (LCRFLG),A      ; Set locate / create flag
2456+ 2CAF 46                   ld      B,(HL)          ; Get First byte of name
2457+ 2CB0 CD AD 26     GTFNAM: call    CHKLTR          ; See if a letter
2458+ 2CB3 DA C2 20             jp      C,SNERR         ; ?SN Error if not a letter
2459+ 2CB6 AF                   xor     A
2460+ 2CB7 4F                   ld      C,A             ; Clear second byte of name
2461+ 2CB8 32 94 81             ld      (TYPE),A        ; Set type to numeric
2462+ 2CBB CD 0B 26             call    GETCHR          ; Get next character
2463+ 2CBE DA C7 2C             jp      C,SVNAM2        ; Numeric - Save in name
2464+ 2CC1 CD AD 26             call    CHKLTR          ; See if a letter
2465+ 2CC4 DA D4 2C             jp      C,CHARTY        ; Not a letter - Check type
2466+ 2CC7 4F           SVNAM2: ld      C,A             ; Save second byte of name
2467+ 2CC8 CD 0B 26     ENDNAM: call    GETCHR          ; Get next character
2468+ 2CCB DA C8 2C             jp      C,ENDNAM        ; Numeric - Get another
2469+ 2CCE CD AD 26             call    CHKLTR          ; See if a letter
2470+ 2CD1 D2 C8 2C             jp      NC,ENDNAM       ; Letter - Get another
2471+ 2CD4 D6 24        CHARTY: sub     '$'             ; String variable?
2472+ 2CD6 C2 E3 2C             jp      NZ,NOTSTR       ; No - Numeric variable
2473+ 2CD9 3C                   inc     A               ; A = 1 (string type)
2474+ 2CDA 32 94 81             ld      (TYPE),A        ; Set type to string
2475+ 2CDD 0F                   rrca                    ; A = 80H , Flag for string
2476+ 2CDE 81                   add     A,C             ; 2nd byte of name has bit 7 on
2477+ 2CDF 4F                   ld      C,A             ; Resave second byte on name
2478+ 2CE0 CD 0B 26             call    GETCHR          ; Get next character
2479+ 2CE3 3A DB 81     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2480+ 2CE6 3D                   dec     A
2481+ 2CE7 CA 90 2D             jp      Z,ARLDSV        ; Yes - Get array name
2482+ 2CEA F2 F3 2C             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2483+ 2CED 7E                   ld      A,(HL)          ; Get byte again
2484+ 2CEE D6 28                sub     '('             ; Subscripted variable?
2485+ 2CF0 CA 68 2D             jp      Z,SBSCPT        ; Yes - Sort out subscript
2486+ 2CF3
2487+ 2CF3 AF           NSCFOR: xor     A               ; Simple variable
2488+ 2CF4 32 DB 81             ld      (FORFLG),A      ; Clear "FOR" flag
2489+ 2CF7 E5                   push    HL              ; Save code string address
2490+ 2CF8 50                   ld      D,B             ; DE = Variable name to find
2491+ 2CF9 59                   ld      E,C
2492+ 2CFA 2A 54 82             ld      HL,(FNRGNM)     ; FN argument name
2493+ 2CFD CD BC 23             call    CPDEHL          ; Is it the FN argument?
2494+ 2D00 11 56 82             ld      DE,FNARG        ; Point to argument value
2495+ 2D03 CA 99 37             jp      Z,POPHRT        ; Yes - Return FN argument value
2496+ 2D06 2A 4E 82             ld      HL,(VAREND)     ; End of variables
2497+ 2D09 EB                   ex      DE,HL           ; Address of end of search
2498+ 2D0A 2A 4C 82             ld      HL,(PROGND)     ; Start of variables address
2499+ 2D0D CD BC 23     FNDVAR: call    CPDEHL          ; End of variable list table?
2500+ 2D10 CA 26 2D             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2501+ 2D13 79                   ld      A,C             ; Get second byte of name
2502+ 2D14 96                   sub     (HL)            ; Compare with name in list
2503+ 2D15 23                   inc     HL              ; Move on to first byte
2504+ 2D16 C2 1B 2D             jp      NZ,FNTHR        ; Different - Find another
2505+ 2D19 78                   ld      A,B             ; Get first byte of name
2506+ 2D1A 96                   sub     (HL)            ; Compare with name in list
2507+ 2D1B 23           FNTHR:  inc     HL              ; Move on to LSB of value
2508+ 2D1C CA 5A 2D             jp      Z,RETADR        ; Found - Return address
2509+ 2D1F 23                   inc     HL              ; <- Skip
2510+ 2D20 23                   inc     HL              ; <- over
2511+ 2D21 23                   inc     HL              ; <- F.P.
2512+ 2D22 23                   inc     HL              ; <- value
2513+ 2D23 C3 0D 2D             jp      FNDVAR          ; Keep looking
2514+ 2D26
2515+ 2D26 E1           CFEVAL: pop     HL              ; Restore code string address
2516+ 2D27 E3                   ex      (SP),HL         ; Get return address
2517+ 2D28 D5                   push    DE              ; Save address of variable
2518+ 2D29 11 8F 2B             ld      DE,FRMEVL       ; Return address in EVAL
2519+ 2D2C CD BC 23             call    CPDEHL          ; Called from EVAL ?
2520+ 2D2F D1                   pop     DE              ; Restore address of variable
2521+ 2D30 CA 5D 2D             jp      Z,RETNUL        ; Yes - Return null variable
2522+ 2D33 E3                   ex      (SP),HL         ; Put back return
2523+ 2D34 E5                   push    HL              ; Save code string address
2524+ 2D35 C5                   push    BC              ; Save variable name
2525+ 2D36 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2526+ 2D39 2A 50 82             ld      HL,(ARREND)     ; End of arrays
2527+ 2D3C E5                   push    HL              ; Save end of arrays
2528+ 2D3D 09                   add     HL,BC           ; Move up 6 bytes
2529+ 2D3E C1                   pop     BC              ; Source address in BC
2530+ 2D3F E5                   push    HL              ; Save new end address
2531+ 2D40 CD 6E 20             call    MOVUP           ; Move arrays up
2532+ 2D43 E1                   pop     HL              ; Restore new end address
2533+ 2D44 22 50 82             ld      (ARREND),HL     ; Set new end address
2534+ 2D47 60                   ld      H,B             ; End of variables to HL
2535+ 2D48 69                   ld      L,C
2536+ 2D49 22 4E 82             ld      (VAREND),HL     ; Set new end address
2537+ 2D4C
2538+ 2D4C 2B           ZEROLP: dec     HL              ; Back through to zero variable
2539+ 2D4D 36 00                ld      (HL),$00        ; Zero byte in variable
2540+ 2D4F CD BC 23             call    CPDEHL          ; Done them all?
2541+ 2D52 C2 4C 2D             jp      NZ,ZEROLP       ; No - Keep on going
2542+ 2D55 D1                   pop     DE              ; Get variable name
2543+ 2D56 73                   ld      (HL),E          ; Store second character
2544+ 2D57 23                   inc     HL
2545+ 2D58 72                   ld      (HL),D          ; Store first character
2546+ 2D59 23                   inc     HL
2547+ 2D5A EB           RETADR: ex      DE,HL           ; Address of variable in DE
2548+ 2D5B E1                   pop     HL              ; Restore code string address
2549+ 2D5C C9                   ret
2550+ 2D5D
2551+ 2D5D 32 5D 82     RETNUL: ld      (FPEXP),A       ; Set result to zero
2552+ 2D60 21 3F 20             ld      HL,ZERBYT       ; Also set a null string
2553+ 2D63 22 5A 82             ld      (FPREG),HL      ; Save for EVAL
2554+ 2D66 E1                   pop     HL              ; Restore code string address
2555+ 2D67 C9                   ret
2556+ 2D68
2557+ 2D68 E5           SBSCPT: push    HL              ; Save code string address
2558+ 2D69 2A 93 81             ld      HL,(LCRFLG)     ; Locate/Create and Type
2559+ 2D6C E3                   ex      (SP),HL         ; Save and get code string
2560+ 2D6D 57                   ld      D,A             ; Zero number of dimensions
2561+ 2D6E D5           SCPTLP: push    DE              ; Save number of dimensions
2562+ 2D6F C5                   push    BC              ; Save array name
2563+ 2D70 CD B5 26             call    FPSINT          ; Get subscript (0-32767)
2564+ 2D73 C1                   pop     BC              ; Restore array name
2565+ 2D74 F1                   pop     AF              ; Get number of dimensions
2566+ 2D75 EB                   ex      DE,HL
2567+ 2D76 E3                   ex      (SP),HL         ; Save subscript value
2568+ 2D77 E5                   push    HL              ; Save LCRFLG and TYPE
2569+ 2D78 EB                   ex      DE,HL
2570+ 2D79 3C                   inc     A               ; Count dimensions
2571+ 2D7A 57                   ld      D,A             ; Save in D
2572+ 2D7B 7E                   ld      A,(HL)          ; Get next byte in code string
2573+ 2D7C FE 2C                cp      ','             ; Comma (more to come)?
2574+ 2D7E CA 6E 2D             jp      Z,SCPTLP        ; Yes - More subscripts
2575+ 2D81 CD C2 23             call    CHKSYN          ; Make sure ")" follows
2576+ 2D84 29                   defb    ')'
2577+ 2D85 22 E0 81             ld      (NXTOPR),HL     ; Save code string address
2578+ 2D88 E1                   pop     HL              ; Get LCRFLG and TYPE
2579+ 2D89 22 93 81             ld      (LCRFLG),HL     ; Restore Locate/create & type
2580+ 2D8C 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2581+ 2D8E D5                   push    DE              ; Save number of dimensions (D)
2582+ 2D8F 11                   defb    $11             ; Skip "push HL" and "push AF'
2583+ 2D90
2584+ 2D90 E5           ARLDSV: push    HL              ; Save code string address
2585+ 2D91 F5                   push    AF              ; A = 00 , Flags set = Z,N
2586+ 2D92 2A 4E 82             ld      HL,(VAREND)     ; Start of arrays
2587+ 2D95 3E                   defb    $3E             ; Skip "add HL,DE"
2588+ 2D96 19           FNDARY: add     HL,DE           ; Move to next array start
2589+ 2D97 EB                   ex      DE,HL
2590+ 2D98 2A 50 82             ld      HL,(ARREND)     ; End of arrays
2591+ 2D9B EB                   ex      DE,HL           ; Current array pointer
2592+ 2D9C CD BC 23             call    CPDEHL          ; End of arrays found?
2593+ 2D9F CA C8 2D             jp      Z,CREARY        ; Yes - Create array
2594+ 2DA2 7E                   ld      A,(HL)          ; Get second byte of name
2595+ 2DA3 B9                   cp      C               ; Compare with name given
2596+ 2DA4 23                   inc     HL              ; Move on
2597+ 2DA5 C2 AA 2D             jp      NZ,NXTARY       ; Different - Find next array
2598+ 2DA8 7E                   ld      A,(HL)          ; Get first byte of name
2599+ 2DA9 B8                   cp      B               ; Compare with name given
2600+ 2DAA 23           NXTARY: inc     HL              ; Move on
2601+ 2DAB 5E                   ld      E,(HL)          ; Get LSB of next array address
2602+ 2DAC 23                   inc     HL
2603+ 2DAD 56                   ld      D,(HL)          ; Get MSB of next array address
2604+ 2DAE 23                   inc     HL
2605+ 2DAF C2 96 2D             jp      NZ,FNDARY       ; Not found - Keep looking
2606+ 2DB2 3A 93 81             ld      A,(LCRFLG)      ; Found Locate or Create it?
2607+ 2DB5 B7                   or      A
2608+ 2DB6 C2 CB 20             jp      NZ,DDERR        ; Create - ?DD Error
2609+ 2DB9 F1                   pop     AF              ; Locate - Get number of dim'ns
2610+ 2DBA 44                   ld      B,H             ; BC Points to array dim'ns
2611+ 2DBB 4D                   ld      C,L
2612+ 2DBC CA 99 37             jp      Z,POPHRT        ; Jump if array load/save
2613+ 2DBF 96                   sub     (HL)            ; Same number of dimensions?
2614+ 2DC0 CA 26 2E             jp      Z,FINDEL        ; Yes - Find element
2615+ 2DC3 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2616+ 2DC5 C3 DC 20             jp      ERROR           ; Output error
2617+ 2DC8
2618+ 2DC8 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2619+ 2DCB F1                   pop     AF              ; Array to save or 0 dim'ns?
2620+ 2DCC CA D6 26             jp      Z,FCERR         ; Yes - ?FC Error
2621+ 2DCF 71                   ld      (HL),C          ; Save second byte of name
2622+ 2DD0 23                   inc     HL
2623+ 2DD1 70                   ld      (HL),B          ; Save first byte of name
2624+ 2DD2 23                   inc     HL
2625+ 2DD3 4F                   ld      C,A             ; Number of dimensions to C
2626+ 2DD4 CD 7F 20             call    CHKSTK          ; Check if enough memory
2627+ 2DD7 23                   inc     HL              ; Point to number of dimensions
2628+ 2DD8 23                   inc     HL
2629+ 2DD9 22 D5 81             ld      (CUROPR),HL     ; Save address of pointer
2630+ 2DDC 71                   ld      (HL),C          ; Set number of dimensions
2631+ 2DDD 23                   inc     HL
2632+ 2DDE 3A 93 81             ld      A,(LCRFLG)      ; Locate of Create?
2633+ 2DE1 17                   rla                     ; Carry set = Create
2634+ 2DE2 79                   ld      A,C             ; Get number of dimensions
2635+ 2DE3 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2636+ 2DE6 D2 EB 2D             jp      NC,DEFSIZ       ; Locate - Set default size
2637+ 2DE9 C1                   pop     BC              ; Get specified dimension size
2638+ 2DEA 03                   inc     BC              ; Include zero element
2639+ 2DEB 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2640+ 2DEC 23                   inc     HL
2641+ 2DED 70                   ld      (HL),B          ; Save MSB of dimension size
2642+ 2DEE 23                   inc     HL
2643+ 2DEF F5                   push    AF              ; Save num' of dim'ns an status
2644+ 2DF0 E5                   push    HL              ; Save address of dim'n size
2645+ 2DF1 CD 95 39             call    MLDEBC          ; Multiply DE by BC to find
2646+ 2DF4 EB                   ex      DE,HL           ; amount of mem needed (to DE)
2647+ 2DF5 E1                   pop     HL              ; Restore address of dimension
2648+ 2DF6 F1                   pop     AF              ; Restore number of dimensions
2649+ 2DF7 3D                   dec     A               ; Count them
2650+ 2DF8 C2 E3 2D             jp      NZ,CRARLP       ; Do next dimension if more
2651+ 2DFB F5                   push    AF              ; Save locate/create flag
2652+ 2DFC 42                   ld      B,D             ; MSB of memory needed
2653+ 2DFD 4B                   ld      C,E             ; LSB of memory needed
2654+ 2DFE EB                   ex      DE,HL
2655+ 2DFF 19                   add     HL,DE           ; Add bytes to array start
2656+ 2E00 DA 97 20             jp      C,OMERR         ; Too big - Error
2657+ 2E03 CD 88 20             call    ENFMEM          ; See if enough memory
2658+ 2E06 22 50 82             ld      (ARREND),HL     ; Save new end of array
2659+ 2E09
2660+ 2E09 2B           ZERARY: dec     HL              ; Back through array data
2661+ 2E0A 36 00                ld      (HL),$00        ; Set array element to zero
2662+ 2E0C CD BC 23             call    CPDEHL          ; All elements zeroed?
2663+ 2E0F C2 09 2E             jp      NZ,ZERARY       ; No - Keep on going
2664+ 2E12 03                   inc     BC              ; Number of bytes + 1
2665+ 2E13 57                   ld      D,A             ; A=0
2666+ 2E14 2A D5 81             ld      HL,(CUROPR)     ; Get address of array
2667+ 2E17 5E                   ld      E,(HL)          ; Number of dimensions
2668+ 2E18 EB                   ex      DE,HL           ; To HL
2669+ 2E19 29                   add     HL,HL           ; Two bytes per dimension size
2670+ 2E1A 09                   add     HL,BC           ; Add number of bytes
2671+ 2E1B EB                   ex      DE,HL           ; Bytes needed to DE
2672+ 2E1C 2B                   dec     HL
2673+ 2E1D 2B                   dec     HL
2674+ 2E1E 73                   ld      (HL),E          ; Save LSB of bytes needed
2675+ 2E1F 23                   inc     HL
2676+ 2E20 72                   ld      (HL),D          ; Save MSB of bytes needed
2677+ 2E21 23                   inc     HL
2678+ 2E22 F1                   pop     AF              ; Locate / Create?
2679+ 2E23 DA 4A 2E             jp      C,ENDDIM        ; A is 0 , End if create
2680+ 2E26 47           FINDEL: ld      B,A             ; Find array element
2681+ 2E27 4F                   ld      C,A
2682+ 2E28 7E                   ld      A,(HL)          ; Number of dimensions
2683+ 2E29 23                   inc     HL
2684+ 2E2A 16                   defb    $16             ; Skip "pop HL"
2685+ 2E2B E1           FNDELP: pop     HL              ; Address of next dim' size
2686+ 2E2C 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2687+ 2E2D 23                   inc     HL
2688+ 2E2E 56                   ld      D,(HL)          ; Get MSB of dim'n size
2689+ 2E2F 23                   inc     HL
2690+ 2E30 E3                   ex      (SP),HL         ; Save address - Get index
2691+ 2E31 F5                   push    AF              ; Save number of dim'ns
2692+ 2E32 CD BC 23             call    CPDEHL          ; Dimension too large?
2693+ 2E35 D2 C3 2D             jp      NC,BSERR        ; Yes - ?BS Error
2694+ 2E38 E5                   push    HL              ; Save index
2695+ 2E39 CD 95 39             call    MLDEBC          ; Multiply previous by size
2696+ 2E3C D1                   pop     DE              ; Index supplied to DE
2697+ 2E3D 19                   add     HL,DE           ; Add index to pointer
2698+ 2E3E F1                   pop     AF              ; Number of dimensions
2699+ 2E3F 3D                   dec     A               ; Count them
2700+ 2E40 44                   ld      B,H             ; MSB of pointer
2701+ 2E41 4D                   ld      C,L             ; LSB of pointer
2702+ 2E42 C2 2B 2E             jp      NZ,FNDELP       ; More - Keep going
2703+ 2E45 29                   add     HL,HL           ; 4 Bytes per element
2704+ 2E46 29                   add     HL,HL
2705+ 2E47 C1                   pop     BC              ; Start of array
2706+ 2E48 09                   add     HL,BC           ; Point to element
2707+ 2E49 EB                   ex      DE,HL           ; Address of element to DE
2708+ 2E4A 2A E0 81     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2709+ 2E4D C9                   ret
2710+ 2E4E
2711+ 2E4E
2712+ 2E4E              ; returns the value of the 32-bit system tick counter as
2713+ 2E4E              ; two 16-bit words
2714+ 2E4E CD 9F 2A     TMR:    call    TSTNUM          ; Make sure it's a number
2715+ 2E51 CD C1 26             call    DEINT           ; Get integer (-32768 to 32767)
2716+ 2E54 2A E6 81             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2717+ 2E57 7B                   ld      A,E
2718+ 2E58 B2                   or      D               ; is it 0?
2719+ 2E59 CA 5F 2E             jp      Z,ENDTMR        ; yes, jump over
2720+ 2E5C 2A E8 81             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2721+ 2E5F 45           ENDTMR: ld      B,L             ; move bytes...
2722+ 2E60 7C                   ld      A,H             ; ...into AB
2723+ 2E61 C3 86 2E             jp      ABPASS          ; return word into AB
2724+ 2E64
2725+ 2E64
2726+ 2E64              ; returns the free space for BASIC or into the string pool
2727+ 2E64 2A 50 82     FRE:    ld      HL,(ARREND)     ; Start of free memory
2728+ 2E67 EB                   ex      DE,HL           ; To DE
2729+ 2E68 21 00 00             ld      HL,$0000        ; End of free memory
2730+ 2E6B 39                   add     HL,SP           ; Current stack value
2731+ 2E6C 3A 94 81             ld      A,(TYPE)        ; Dummy argument type
2732+ 2E6F B7                   or      A
2733+ 2E70 CA 80 2E             jp      Z,FRENUM        ; Numeric - Free variable space
2734+ 2E73 CD E7 30             call    GSTRCU          ; Current string to pool
2735+ 2E76 CD E7 2F             call    GARBGE          ; Garbage collection
2736+ 2E79 2A AD 80             ld      HL,(STRSPC)     ; Bottom of string space in use
2737+ 2E7C EB                   ex      DE,HL           ; To DE
2738+ 2E7D 2A D3 81             ld      HL,(STRBOT)     ; Bottom of string space
2739+ 2E80 7D           FRENUM: ld      A,L             ; Get LSB of end
2740+ 2E81 93                   sub     E               ; Subtract LSB of beginning
2741+ 2E82 4F                   ld      C,A             ; Save difference if C
2742+ 2E83 7C                   ld      A,H             ; Get MSB of end
2743+ 2E84 9A                   sbc     A,D             ; Subtract MSB of beginning
2744+ 2E85 41           ACPASS: ld      B,C             ; Return integer AC
2745+ 2E86 50           ABPASS: ld      D,B             ; Return integer AB
2746+ 2E87 1E 00                ld      E,$00
2747+ 2E89 21 94 81             ld      HL,TYPE         ; Point to type
2748+ 2E8C 73                   ld      (HL),E          ; Set type to numeric
2749+ 2E8D 06 90                ld      B,$80+$10       ; 16 bit integer
2750+ 2E8F C3 C0 38             jp      RETINT          ; Return the integer
2751+ 2E92
2752+ 2E92              ; returns the X position of the cursor during a print
2753+ 2E92 3A 92 81     POS:    ld      A,(CURPOS)      ; Get cursor position
2754+ 2E95              ; return the value in A as a number
2755+ 2E95 47           PASSA:  ld      B,A             ; Put A into AB
2756+ 2E96 AF                   xor     A               ; Zero A
2757+ 2E97 C3 86 2E             jp      ABPASS          ; Return integer AB
2758+ 2E9A
2759+ 2E9A CD 1D 2F     DEF:    call    CHEKFN          ; Get "FN" and name
2760+ 2E9D CD 0F 2F             call    IDTEST          ; Test for illegal direct
2761+ 2EA0 01 B4 27             ld      BC,DATA         ; To get next statement
2762+ 2EA3 C5                   push    BC              ; Save address for RETurn
2763+ 2EA4 D5                   push    DE              ; Save address of function ptr
2764+ 2EA5 CD C2 23             call    CHKSYN          ; Make sure "(" follows
2765+ 2EA8 28                   defb    '('
2766+ 2EA9 CD AB 2C             call    GETVAR          ; Get argument variable name
2767+ 2EAC E5                   push    HL              ; Save code string address
2768+ 2EAD EB                   ex      DE,HL           ; Argument address to HL
2769+ 2EAE 2B                   dec     HL
2770+ 2EAF 56                   ld      D,(HL)          ; Get first byte of arg name
2771+ 2EB0 2B                   dec     HL
2772+ 2EB1 5E                   ld      E,(HL)          ; Get second byte of arg name
2773+ 2EB2 E1                   pop     HL              ; Restore code string address
2774+ 2EB3 CD 9F 2A             call    TSTNUM          ; Make sure numeric argument
2775+ 2EB6 CD C2 23             call    CHKSYN          ; Make sure ")" follows
2776+ 2EB9 29                   defb    ')'
2777+ 2EBA CD C2 23             call    CHKSYN          ; Make sure "=" follows
2778+ 2EBD C9                   defb    ZEQUAL          ; "=" token
2779+ 2EBE 44                   ld      B,H             ; Code string address to BC
2780+ 2EBF 4D                   ld      C,L
2781+ 2EC0 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2782+ 2EC1 71                   ld      (HL),C          ; Save LSB of FN code string
2783+ 2EC2 23                   inc     HL
2784+ 2EC3 70                   ld      (HL),B          ; Save MSB of FN code string
2785+ 2EC4 C3 5C 2F             jp      SVSTAD          ; Save address and do function
2786+ 2EC7
2787+ 2EC7 CD 1D 2F     DOFN:   call    CHEKFN          ; Make sure FN follows
2788+ 2ECA D5                   push    DE              ; Save function pointer address
2789+ 2ECB CD 73 2B             call    EVLPAR          ; Evaluate expression in "()"
2790+ 2ECE CD 9F 2A             call    TSTNUM          ; Make sure numeric result
2791+ 2ED1 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2792+ 2ED2 5E                   ld      E,(HL)          ; Get LSB of FN code string
2793+ 2ED3 23                   inc     HL
2794+ 2ED4 56                   ld      D,(HL)          ; Get MSB of FN code string
2795+ 2ED5 23                   inc     HL
2796+ 2ED6 7A                   ld      A,D             ; And function DEFined?
2797+ 2ED7 B3                   or      E
2798+ 2ED8 CA CE 20             jp      Z,UFERR         ; No - ?UF Error
2799+ 2EDB 7E                   ld      A,(HL)          ; Get LSB of argument address
2800+ 2EDC 23                   inc     HL
2801+ 2EDD 66                   ld      H,(HL)          ; Get MSB of argument address
2802+ 2EDE 6F                   ld      L,A             ; HL = Arg variable address
2803+ 2EDF E5                   push    HL              ; Save it
2804+ 2EE0 2A 54 82             ld      HL,(FNRGNM)     ; Get old argument name
2805+ 2EE3 E3                   ex      (SP),HL         ; Save old , Get new
2806+ 2EE4 22 54 82             ld      (FNRGNM),HL     ; Set new argument name
2807+ 2EE7 2A 58 82             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2808+ 2EEA E5                   push    HL              ; Save it
2809+ 2EEB 2A 56 82             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2810+ 2EEE E5                   push    HL              ; Save it
2811+ 2EEF 21 56 82             ld      HL,FNARG        ; HL = Value of argument
2812+ 2EF2 D5                   push    DE              ; Save FN code string address
2813+ 2EF3 CD 01 39             call    FPTHL           ; Move FPREG to argument
2814+ 2EF6 E1                   pop     HL              ; Get FN code string address
2815+ 2EF7 CD 9C 2A             call    GETNUM          ; Get value from function
2816+ 2EFA 2B                   dec     HL              ; dec 'cos GETCHR INCs
2817+ 2EFB CD 0B 26             call    GETCHR          ; Get next character
2818+ 2EFE C2 C2 20             jp      NZ,SNERR        ; Bad character in FN - Error
2819+ 2F01 E1                   pop     HL              ; Get MSB,EXP of old arg
2820+ 2F02 22 56 82             ld      (FNARG),HL      ; Restore it
2821+ 2F05 E1                   pop     HL              ; Get LSB,NLSB of old arg
2822+ 2F06 22 58 82             ld      (FNARG+2),HL    ; Restore it
2823+ 2F09 E1                   pop     HL              ; Get name of old arg
2824+ 2F0A 22 54 82             ld      (FNRGNM),HL     ; Restore it
2825+ 2F0D E1                   pop     HL              ; Restore code string address
2826+ 2F0E C9                   ret
2827+ 2F0F
2828+ 2F0F E5           IDTEST: push    HL              ; Save code string address
2829+ 2F10 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
2830+ 2F13 23                   inc     HL              ; -1 means direct statement
2831+ 2F14 7C                   ld      A,H
2832+ 2F15 B5                   or      L
2833+ 2F16 E1                   pop     HL              ; Restore code string address
2834+ 2F17 C0                   ret     NZ              ; Return if in program
2835+ 2F18 1E 16                ld      E,ID            ; ?ID Error
2836+ 2F1A C3 DC 20             jp      ERROR
2837+ 2F1D
2838+ 2F1D CD C2 23     CHEKFN: call    CHKSYN          ; Make sure FN follows
2839+ 2F20 B9                   defb    ZFN             ; "FN" token
2840+ 2F21 3E 80                ld      A,$80
2841+ 2F23 32 DB 81             ld      (FORFLG),A      ; Flag FN name to find
2842+ 2F26 B6                   or      (HL)            ; FN name has bit 7 set
2843+ 2F27 47                   ld      B,A             ; in first byte of name
2844+ 2F28 CD B0 2C             call    GTFNAM          ; Get FN name
2845+ 2F2B C3 9F 2A             jp      TSTNUM          ; Make sure numeric function
2846+ 2F2E
2847+ 2F2E CD 9F 2A     STR:    call    TSTNUM          ; Make sure it's a number
2848+ 2F31 CD 4E 3A             call    NUMASC          ; Turn number into text
2849+ 2F34 CD 62 2F     STR1:   call    CRTST           ; Create string entry for it
2850+ 2F37 CD E7 30             call    GSTRCU          ; Current string to pool
2851+ 2F3A 01 42 31             ld      BC,TOPOOL       ; Save in string pool
2852+ 2F3D C5                   push    BC              ; Save address on stack
2853+ 2F3E
2854+ 2F3E 7E           SAVSTR: ld      A,(HL)          ; Get string length
2855+ 2F3F 23                   inc     HL
2856+ 2F40 23                   inc     HL
2857+ 2F41 E5                   push    HL              ; Save pointer to string
2858+ 2F42 CD BD 2F             call    TESTR           ; See if enough string space
2859+ 2F45 E1                   pop     HL              ; Restore pointer to string
2860+ 2F46 4E                   ld      C,(HL)          ; Get LSB of address
2861+ 2F47 23                   inc     HL
2862+ 2F48 46                   ld      B,(HL)          ; Get MSB of address
2863+ 2F49 CD 56 2F             call    CRTMST          ; Create string entry
2864+ 2F4C E5                   push    HL              ; Save pointer to MSB of addr
2865+ 2F4D 6F                   ld      L,A             ; Length of string
2866+ 2F4E CD DA 30             call    TOSTRA          ; Move to string area
2867+ 2F51 D1                   pop     DE              ; Restore pointer to MSB
2868+ 2F52 C9                   ret
2869+ 2F53
2870+ 2F53 CD BD 2F     MKTMST: call    TESTR           ; See if enough string space
2871+ 2F56 21 CF 81     CRTMST: ld      HL,TMPSTR       ; Temporary string
2872+ 2F59 E5                   push    HL              ; Save it
2873+ 2F5A 77                   ld      (HL),A          ; Save length of string
2874+ 2F5B 23                   inc     HL
2875+ 2F5C 23           SVSTAD: inc     HL
2876+ 2F5D 73                   ld      (HL),E          ; Save LSB of address
2877+ 2F5E 23                   inc     HL
2878+ 2F5F 72                   ld      (HL),D          ; Save MSB of address
2879+ 2F60 E1                   pop     HL              ; Restore pointer
2880+ 2F61 C9                   ret
2881+ 2F62
2882+ 2F62 2B           CRTST:  dec     HL              ; dec - INCed after
2883+ 2F63 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2884+ 2F65 50                   ld      D,B             ; Quote to D
2885+ 2F66 E5           DTSTR:  push    HL              ; Save start
2886+ 2F67 0E FF                ld      C,-1            ; Set counter to -1
2887+ 2F69 23           QTSTLP: inc     HL              ; Move on
2888+ 2F6A 7E                   ld      A,(HL)          ; Get byte
2889+ 2F6B 0C                   inc     C               ; Count bytes
2890+ 2F6C B7                   or      A               ; End of line?
2891+ 2F6D CA 78 2F             jp      Z,CRTSTE        ; Yes - Create string entry
2892+ 2F70 BA                   cp      D               ; Terminator D found?
2893+ 2F71 CA 78 2F             jp      Z,CRTSTE        ; Yes - Create string entry
2894+ 2F74 B8                   cp      B               ; Terminator B found?
2895+ 2F75 C2 69 2F             jp      NZ,QTSTLP       ; No - Keep looking
2896+ 2F78 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2897+ 2F7A CC 0B 26             call    Z,GETCHR        ; Yes - Get next character
2898+ 2F7D E3                   ex      (SP),HL         ; Starting quote
2899+ 2F7E 23                   inc     HL              ; First byte of string
2900+ 2F7F EB                   ex      DE,HL           ; To DE
2901+ 2F80 79                   ld      A,C             ; Get length
2902+ 2F81 CD 56 2F             call    CRTMST          ; Create string entry
2903+ 2F84 11 CF 81     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2904+ 2F87 2A C1 81             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2905+ 2F8A 22 5A 82             ld      (FPREG),HL      ; Save address of string ptr
2906+ 2F8D 3E 01                ld      A,$01
2907+ 2F8F 32 94 81             ld      (TYPE),A        ; Set type to string
2908+ 2F92 CD 04 39             call    DETHL4          ; Move string to pool
2909+ 2F95 CD BC 23             call    CPDEHL          ; Out of string pool?
2910+ 2F98 22 C1 81             ld      (TMSTPT),HL     ; Save new pointer
2911+ 2F9B E1                   pop     HL              ; Restore code string address
2912+ 2F9C 7E                   ld      A,(HL)          ; Get next code byte
2913+ 2F9D C0                   ret     NZ              ; Return if pool OK
2914+ 2F9E 1E 1E                ld      E,ST            ; ?ST Error
2915+ 2FA0 C3 DC 20             jp      ERROR           ; String pool overflow
2916+ 2FA3
2917+ 2FA3 23           PRNUMS: inc     HL              ; Skip leading space
2918+ 2FA4 CD 62 2F     PRS:    call    CRTST           ; Create string entry for it
2919+ 2FA7 CD E7 30     PRS1:   call    GSTRCU          ; Current string to pool
2920+ 2FAA CD F8 38             call    LOADFP          ; Move string block to BCDE
2921+ 2FAD 1C                   inc     E               ; Length + 1
2922+ 2FAE 1D           PRSLP:  dec     E               ; Count characters
2923+ 2FAF C8                   ret     Z               ; End of string
2924+ 2FB0 0A                   ld      A,(BC)          ; Get byte to output
2925+ 2FB1 CD CD 23             call    OUTC            ; Output character in A
2926+ 2FB4 FE 0D                cp      CR              ; Return?
2927+ 2FB6 CC E2 28             call    Z,CNTEND        ; Yes - Position cursor to 0
2928+ 2FB9 03                   inc     BC              ; Next byte in string
2929+ 2FBA C3 AE 2F             jp      PRSLP           ; More characters to output
2930+ 2FBD
2931+ 2FBD B7           TESTR:  or      A               ; Test if enough room
2932+ 2FBE 0E                   defb    $0E             ; No garbage collection done
2933+ 2FBF F1           GRBDON: pop     AF              ; Garbage collection done
2934+ 2FC0 F5                   push    AF              ; Save status
2935+ 2FC1 2A AD 80             ld      HL,(STRSPC)     ; Bottom of string space in use
2936+ 2FC4 EB                   ex      DE,HL           ; To DE
2937+ 2FC5 2A D3 81             ld      HL,(STRBOT)     ; Bottom of string area
2938+ 2FC8 2F                   cpl                     ; Negate length (Top down)
2939+ 2FC9 4F                   ld      C,A             ; -Length to BC
2940+ 2FCA 06 FF                ld      B,-1            ; BC = -ve length of string
2941+ 2FCC 09                   add     HL,BC           ; Add to bottom of space in use
2942+ 2FCD 23                   inc     HL              ; Plus one for 2's complement
2943+ 2FCE CD BC 23             call    CPDEHL          ; Below string RAM area?
2944+ 2FD1 DA DB 2F             jp      C,TESTOS        ; Tidy up if not done else err
2945+ 2FD4 22 D3 81             ld      (STRBOT),HL     ; Save new bottom of area
2946+ 2FD7 23                   inc     HL              ; Point to first byte of string
2947+ 2FD8 EB                   ex      DE,HL           ; Address to DE
2948+ 2FD9 F1           POPAF:  pop     AF              ; Throw away status push
2949+ 2FDA C9                   ret
2950+ 2FDB
2951+ 2FDB F1           TESTOS: pop     AF              ; Garbage collect been done?
2952+ 2FDC 1E 1A                ld      E,OS            ; ?OS Error
2953+ 2FDE CA DC 20             jp      Z,ERROR         ; Yes - Not enough string space
2954+ 2FE1 BF                   cp      A               ; Flag garbage collect done
2955+ 2FE2 F5                   push    AF              ; Save status
2956+ 2FE3 01 BF 2F             ld      BC,GRBDON       ; Garbage collection done
2957+ 2FE6 C5                   push    BC              ; Save for RETurn
2958+ 2FE7 2A 96 81     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2959+ 2FEA 22 D3 81     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2960+ 2FED 21 00 00             ld      HL,$0000
2961+ 2FF0 E5                   push    HL              ; Flag no string found
2962+ 2FF1 2A AD 80             ld      HL,(STRSPC)     ; Get bottom of string space
2963+ 2FF4 E5                   push    HL              ; Save bottom of string space
2964+ 2FF5 21 C3 81             ld      HL,TMSTPL       ; Temporary string pool
2965+ 2FF8 EB           GRBLP:  ex      DE,HL
2966+ 2FF9 2A C1 81             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2967+ 2FFC EB                   ex      DE,HL
2968+ 2FFD CD BC 23             call    CPDEHL          ; Temporary string pool done?
2969+ 3000 01 F8 2F             ld      BC,GRBLP        ; Loop until string pool done
2970+ 3003 C2 4C 30             jp      NZ,STPOOL       ; No - See if in string area
2971+ 3006 2A 4C 82             ld      HL,(PROGND)     ; Start of simple variables
2972+ 3009 EB           SMPVAR: ex      DE,HL
2973+ 300A 2A 4E 82             ld      HL,(VAREND)     ; End of simple variables
2974+ 300D EB                   ex      DE,HL
2975+ 300E CD BC 23             call    CPDEHL          ; All simple strings done?
2976+ 3011 CA 1F 30             jp      Z,ARRLP         ; Yes - Do string arrays
2977+ 3014 7E                   ld      A,(HL)          ; Get type of variable
2978+ 3015 23                   inc     HL
2979+ 3016 23                   inc     HL
2980+ 3017 B7                   or      A               ; "S" flag set if string
2981+ 3018 CD 4F 30             call    STRADD          ; See if string in string area
2982+ 301B C3 09 30             jp      SMPVAR          ; Loop until simple ones done
2983+ 301E
2984+ 301E C1           GNXARY: pop     BC              ; Scrap address of this array
2985+ 301F EB           ARRLP:  ex      DE,HL
2986+ 3020 2A 50 82             ld      HL,(ARREND)     ; End of string arrays
2987+ 3023 EB                   ex      DE,HL
2988+ 3024 CD BC 23             call    CPDEHL          ; All string arrays done?
2989+ 3027 CA 75 30             jp      Z,SCNEND        ; Yes - Move string if found
2990+ 302A CD F8 38             call    LOADFP          ; Get array name to BCDE
2991+ 302D 7B                   ld      A,E             ; Get type of array
2992+ 302E E5                   push    HL              ; Save address of num of dim'ns
2993+ 302F 09                   add     HL,BC           ; Start of next array
2994+ 3030 B7                   or      A               ; Test type of array
2995+ 3031 F2 1E 30             jp      P,GNXARY        ; Numeric array - Ignore it
2996+ 3034 22 D5 81             ld      (CUROPR),HL     ; Save address of next array
2997+ 3037 E1                   pop     HL              ; Get address of num of dim'ns
2998+ 3038 4E                   ld      C,(HL)          ; BC = Number of dimensions
2999+ 3039 06 00                ld      B,$00
3000+ 303B 09                   add     HL,BC           ; Two bytes per dimension size
3001+ 303C 09                   add     HL,BC
3002+ 303D 23                   inc     HL              ; Plus one for number of dim'ns
3003+ 303E EB           GRBARY: ex      DE,HL
3004+ 303F 2A D5 81             ld      HL,(CUROPR)     ; Get address of next array
3005+ 3042 EB                   ex      DE,HL
3006+ 3043 CD BC 23             call    CPDEHL          ; Is this array finished?
3007+ 3046 CA 1F 30             jp      Z,ARRLP         ; Yes - Get next one
3008+ 3049 01 3E 30             ld      BC,GRBARY       ; Loop until array all done
3009+ 304C C5           STPOOL: push    BC              ; Save return address
3010+ 304D F6 80                or      $80             ; Flag string type
3011+ 304F 7E           STRADD: ld      A,(HL)          ; Get string length
3012+ 3050 23                   inc     HL
3013+ 3051 23                   inc     HL
3014+ 3052 5E                   ld      E,(HL)          ; Get LSB of string address
3015+ 3053 23                   inc     HL
3016+ 3054 56                   ld      D,(HL)          ; Get MSB of string address
3017+ 3055 23                   inc     HL
3018+ 3056 F0                   ret     P               ; Not a string - Return
3019+ 3057 B7                   or      A               ; Set flags on string length
3020+ 3058 C8                   ret     Z               ; Null string - Return
3021+ 3059 44                   ld      B,H             ; Save variable pointer
3022+ 305A 4D                   ld      C,L
3023+ 305B 2A D3 81             ld      HL,(STRBOT)     ; Bottom of new area
3024+ 305E CD BC 23             call    CPDEHL          ; String been done?
3025+ 3061 60                   ld      H,B             ; Restore variable pointer
3026+ 3062 69                   ld      L,C
3027+ 3063 D8                   ret     C               ; String done - Ignore
3028+ 3064 E1                   pop     HL              ; Return address
3029+ 3065 E3                   ex      (SP),HL         ; Lowest available string area
3030+ 3066 CD BC 23             call    CPDEHL          ; String within string area?
3031+ 3069 E3                   ex      (SP),HL         ; Lowest available string area
3032+ 306A E5                   push    HL              ; Re-save return address
3033+ 306B 60                   ld      H,B             ; Restore variable pointer
3034+ 306C 69                   ld      L,C
3035+ 306D D0                   ret     NC              ; Outside string area - Ignore
3036+ 306E C1                   pop     BC              ; Get return , Throw 2 away
3037+ 306F F1                   pop     AF              ;
3038+ 3070 F1                   pop     AF              ;
3039+ 3071 E5                   push    HL              ; Save variable pointer
3040+ 3072 D5                   push    DE              ; Save address of current
3041+ 3073 C5                   push    BC              ; Put back return address
3042+ 3074 C9                   ret                     ; Go to it
3043+ 3075
3044+ 3075 D1           SCNEND: pop     DE              ; Addresses of strings
3045+ 3076 E1                   pop     HL              ;
3046+ 3077 7D                   ld      A,L             ; HL = 0 if no more to do
3047+ 3078 B4                   or      H
3048+ 3079 C8                   ret     Z               ; No more to do - Return
3049+ 307A 2B                   dec     HL
3050+ 307B 46                   ld      B,(HL)          ; MSB of address of string
3051+ 307C 2B                   dec     HL
3052+ 307D 4E                   ld      C,(HL)          ; LSB of address of string
3053+ 307E E5                   push    HL              ; Save variable address
3054+ 307F 2B                   dec     HL
3055+ 3080 2B                   dec     HL
3056+ 3081 6E                   ld      L,(HL)          ; HL = Length of string
3057+ 3082 26 00                ld      H,$00
3058+ 3084 09                   add     HL,BC           ; Address of end of string+1
3059+ 3085 50                   ld      D,B             ; String address to DE
3060+ 3086 59                   ld      E,C
3061+ 3087 2B                   dec     HL              ; Last byte in string
3062+ 3088 44                   ld      B,H             ; Address to BC
3063+ 3089 4D                   ld      C,L
3064+ 308A 2A D3 81             ld      HL,(STRBOT)     ; Current bottom of string area
3065+ 308D CD 71 20             call    MOVSTR          ; Move string to new address
3066+ 3090 E1                   pop     HL              ; Restore variable address
3067+ 3091 71                   ld      (HL),C          ; Save new LSB of address
3068+ 3092 23                   inc     HL
3069+ 3093 70                   ld      (HL),B          ; Save new MSB of address
3070+ 3094 69                   ld      L,C             ; Next string area+1 to HL
3071+ 3095 60                   ld      H,B
3072+ 3096 2B                   dec     HL              ; Next string area address
3073+ 3097 C3 EA 2F             jp      GARBLP          ; Look for more strings
3074+ 309A
3075+ 309A C5           CONCAT: push    BC              ; Save prec' opr & code string
3076+ 309B E5                   push    HL              ;
3077+ 309C 2A 5A 82             ld      HL,(FPREG)      ; Get first string
3078+ 309F E3                   ex      (SP),HL         ; Save first string
3079+ 30A0 CD 25 2B             call    OPRND           ; Get second string
3080+ 30A3 E3                   ex      (SP),HL         ; Restore first string
3081+ 30A4 CD A0 2A             call    TSTSTR          ; Make sure it's a string
3082+ 30A7 7E                   ld      A,(HL)          ; Get length of second string
3083+ 30A8 E5                   push    HL              ; Save first string
3084+ 30A9 2A 5A 82             ld      HL,(FPREG)      ; Get second string
3085+ 30AC E5                   push    HL              ; Save second string
3086+ 30AD 86                   add     A,(HL)          ; Add length of second string
3087+ 30AE 1E 1C                ld      E,LS            ; ?LS Error
3088+ 30B0 DA DC 20             jp      C,ERROR         ; String too long - Error
3089+ 30B3 CD 53 2F             call    MKTMST          ; Make temporary string
3090+ 30B6 D1                   pop     DE              ; Get second string to DE
3091+ 30B7 CD EB 30             call    GSTRDE          ; Move to string pool if needed
3092+ 30BA E3                   ex      (SP),HL         ; Get first string
3093+ 30BB CD EA 30             call    GSTRHL          ; Move to string pool if needed
3094+ 30BE E5                   push    HL              ; Save first string
3095+ 30BF 2A D1 81             ld      HL,(TMPSTR+2)   ; Temporary string address
3096+ 30C2 EB                   ex      DE,HL           ; To DE
3097+ 30C3 CD D1 30             call    SSTSA           ; First string to string area
3098+ 30C6 CD D1 30             call    SSTSA           ; Second string to string area
3099+ 30C9 21 BA 2A             ld      HL,EVAL2        ; Return to evaluation loop
3100+ 30CC E3                   ex      (SP),HL         ; Save return,get code string
3101+ 30CD E5                   push    HL              ; Save code string address
3102+ 30CE C3 84 2F             jp      TSTOPL          ; To temporary string to pool
3103+ 30D1
3104+ 30D1 E1           SSTSA:  pop     HL              ; Return address
3105+ 30D2 E3                   ex      (SP),HL         ; Get string block,save return
3106+ 30D3 7E                   ld      A,(HL)          ; Get length of string
3107+ 30D4 23                   inc     HL
3108+ 30D5 23                   inc     HL
3109+ 30D6 4E                   ld      C,(HL)          ; Get LSB of string address
3110+ 30D7 23                   inc     HL
3111+ 30D8 46                   ld      B,(HL)          ; Get MSB of string address
3112+ 30D9 6F                   ld      L,A             ; Length to L
3113+ 30DA 2C           TOSTRA: inc     L               ; inc - DECed after
3114+ 30DB 2D           TSALP:  dec     L               ; Count bytes moved
3115+ 30DC C8                   ret     Z               ; End of string - Return
3116+ 30DD 0A                   ld      A,(BC)          ; Get source
3117+ 30DE 12                   ld      (DE),A          ; Save destination
3118+ 30DF 03                   inc     BC              ; Next source
3119+ 30E0 13                   inc     DE              ; Next destination
3120+ 30E1 C3 DB 30             jp      TSALP           ; Loop until string moved
3121+ 30E4
3122+ 30E4 CD A0 2A     GETSTR: call    TSTSTR          ; Make sure it's a string
3123+ 30E7 2A 5A 82     GSTRCU: ld      HL,(FPREG)      ; Get current string
3124+ 30EA EB           GSTRHL: ex      DE,HL           ; Save DE
3125+ 30EB CD 05 31     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3126+ 30EE EB                   ex      DE,HL           ; Restore DE
3127+ 30EF C0                   ret     NZ              ; No - Return
3128+ 30F0 D5                   push    DE              ; Save string
3129+ 30F1 50                   ld      D,B             ; String block address to DE
3130+ 30F2 59                   ld      E,C
3131+ 30F3 1B                   dec     DE              ; Point to length
3132+ 30F4 4E                   ld      C,(HL)          ; Get string length
3133+ 30F5 2A D3 81             ld      HL,(STRBOT)     ; Current bottom of string area
3134+ 30F8 CD BC 23             call    CPDEHL          ; Last one in string area?
3135+ 30FB C2 03 31             jp      NZ,POPHL        ; No - Return
3136+ 30FE 47                   ld      B,A             ; Clear B (A=0)
3137+ 30FF 09                   add     HL,BC           ; Remove string from str' area
3138+ 3100 22 D3 81             ld      (STRBOT),HL     ; Save new bottom of str' area
3139+ 3103 E1           POPHL:  pop     HL              ; Restore string
3140+ 3104 C9                   ret
3141+ 3105
3142+ 3105 2A C1 81     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3143+ 3108 2B                   dec     HL              ; Back
3144+ 3109 46                   ld      B,(HL)          ; Get MSB of address
3145+ 310A 2B                   dec     HL              ; Back
3146+ 310B 4E                   ld      C,(HL)          ; Get LSB of address
3147+ 310C 2B                   dec     HL              ; Back
3148+ 310D 2B                   dec     HL              ; Back
3149+ 310E CD BC 23             call    CPDEHL          ; String last in string pool?
3150+ 3111 C0                   ret     NZ              ; Yes - Leave it
3151+ 3112 22 C1 81             ld      (TMSTPT),HL     ; Save new string pool top
3152+ 3115 C9                   ret
3153+ 3116
3154+ 3116 01 95 2E     LEN:    ld      BC,PASSA        ; To return integer A
3155+ 3119 C5                   push    BC              ; Save address
3156+ 311A CD E4 30     GETLEN: call    GETSTR          ; Get string and its length
3157+ 311D AF                   xor     A
3158+ 311E 57                   ld      D,A             ; Clear D
3159+ 311F 32 94 81             ld      (TYPE),A        ; Set type to numeric
3160+ 3122 7E                   ld      A,(HL)          ; Get length of string
3161+ 3123 B7                   or      A               ; Set status flags
3162+ 3124 C9                   ret
3163+ 3125
3164+ 3125 01 95 2E     ASC:    ld      BC,PASSA        ; To return integer A
3165+ 3128 C5                   push    BC              ; Save address
3166+ 3129 CD 1A 31     GTFLNM: call    GETLEN          ; Get length of string
3167+ 312C CA D6 26             jp      Z,FCERR         ; Null string - Error
3168+ 312F 23                   inc     HL
3169+ 3130 23                   inc     HL
3170+ 3131 5E                   ld      E,(HL)          ; Get LSB of address
3171+ 3132 23                   inc     HL
3172+ 3133 56                   ld      D,(HL)          ; Get MSB of address
3173+ 3134 1A                   ld      A,(DE)          ; Get first byte of string
3174+ 3135 C9                   ret
3175+ 3136
3176+ 3136 3E 01        CHR:    ld      A,$01           ; One character string
3177+ 3138 CD 53 2F             call    MKTMST          ; Make a temporary string
3178+ 313B CD 25 33             call    MAKINT          ; Make it integer A
3179+ 313E 2A D1 81             ld      HL,(TMPSTR+2)   ; Get address of string
3180+ 3141 73                   ld      (HL),E          ; Save character
3181+ 3142 C1           TOPOOL: pop     BC              ; Clean up stack
3182+ 3143 C3 84 2F             jp      TSTOPL          ; Temporary string to pool
3183+ 3146
3184+ 3146 CD D5 32     LEFT:   call    LFRGNM          ; Get number and ending ")"
3185+ 3149 AF                   xor     A               ; Start at first byte in string
3186+ 314A E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3187+ 314B 4F                   ld      C,A             ; Starting position in string
3188+ 314C E5           MID1:   push    HL              ; Save string block address
3189+ 314D 7E                   ld      A,(HL)          ; Get length of string
3190+ 314E B8                   cp      B               ; Compare with number given
3191+ 314F DA 54 31             jp      C,ALLFOL        ; All following bytes required
3192+ 3152 78                   ld      A,B             ; Get new length
3193+ 3153 11                   defb    $11             ; Skip "ld C,0"
3194+ 3154 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3195+ 3156 C5                   push    BC              ; Save position in string
3196+ 3157 CD BD 2F             call    TESTR           ; See if enough string space
3197+ 315A C1                   pop     BC              ; Get position in string
3198+ 315B E1                   pop     HL              ; Restore string block address
3199+ 315C E5                   push    HL              ; And re-save it
3200+ 315D 23                   inc     HL
3201+ 315E 23                   inc     HL
3202+ 315F 46                   ld      B,(HL)          ; Get LSB of address
3203+ 3160 23                   inc     HL
3204+ 3161 66                   ld      H,(HL)          ; Get MSB of address
3205+ 3162 68                   ld      L,B             ; HL = address of string
3206+ 3163 06 00                ld      B,$00           ; BC = starting address
3207+ 3165 09                   add     HL,BC           ; Point to that byte
3208+ 3166 44                   ld      B,H             ; BC = source string
3209+ 3167 4D                   ld      C,L
3210+ 3168 CD 56 2F             call    CRTMST          ; Create a string entry
3211+ 316B 6F                   ld      L,A             ; Length of new string
3212+ 316C CD DA 30             call    TOSTRA          ; Move string to string area
3213+ 316F D1                   pop     DE              ; Clear stack
3214+ 3170 CD EB 30             call    GSTRDE          ; Move to string pool if needed
3215+ 3173 C3 84 2F             jp      TSTOPL          ; Temporary string to pool
3216+ 3176
3217+ 3176
3218+ 3176              ; INSTR statement - look for a string inside another string
3219+ 3176              ; usage: INSTR(A$,B$) -> search for B$ into A$
3220+ 3176              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3221+ 3176              ; return 1~255 to indicate the starting position of B$ into A$
3222+ 3176              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3223+ 3176              LNS1    equ     TMPBFR1
3224+ 3176              ADRS1   equ     TMPBFR2
3225+ 3176              LNS2    equ     TMPBFR3
3226+ 3176              ADRS2   equ     TMPBFR4
3227+ 3176              PT      equ     VIDEOBUFF
3228+ 3176              PT1     equ     VIDEOBUFF+2
3229+ 3176              PT2     equ     VIDEOBUFF+4
3230+ 3176              TP      equ     VIDEOBUFF+6
3231+ 3176              TF      equ     VIDEOBUFF+8
3232+ 3176 CD C2 23     INSTR:  call    CHKSYN          ; make sure "(" follows
3233+ 3179 28                   defb    '('
3234+ 317A 2B                   dec     HL              ; dec 'cause GETCHR increments
3235+ 317B CD 0B 26             call    GETCHR          ; check if something follows
3236+ 317E CA C2 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
3237+ 3181 CD AE 2A             call    EVAL            ; Evaluate expression
3238+ 3184 CD A0 2A             call    TSTSTR          ; Make sure it's a string
3239+ 3187 22 0E 82             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3240+ 318A CD E7 30             call    GSTRCU          ; check that a string follows
3241+ 318D CD F8 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3242+ 3190 ED 53 06 82          ld      (LNS1),DE       ; store values into
3243+ 3194 ED 43 08 82          ld      (ADRS1),BC      ; temp buffers
3244+ 3198 2A 0E 82             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3245+ 319B CD C2 23             call    CHKSYN          ; Make sure ',' follows
3246+ 319E 2C                   defb    ','
3247+ 319F 2B                   dec     HL              ; dec 'cause GETCHR increments
3248+ 31A0 CD 0B 26             call    GETCHR          ; check if something follows
3249+ 31A3 CA C2 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
3250+ 31A6 CD AE 2A             call    EVAL            ; Evaluate expression
3251+ 31A9 CD A0 2A             call    TSTSTR          ; Make sure it's a string
3252+ 31AC 22 0E 82             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3253+ 31AF CD E7 30             call    GSTRCU          ; check that a string follows
3254+ 31B2 CD F8 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3255+ 31B5 ED 53 0A 82          ld      (LNS2),DE       ; store values into
3256+ 31B9 ED 43 0C 82          ld      (ADRS2),BC      ; temp buffers
3257+ 31BD 2A 0E 82             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3258+ 31C0 CD C2 23             call    CHKSYN          ; make sure ")" follows
3259+ 31C3 29                   defb    ')'
3260+ 31C4 E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3261+ 31C5 FD E1                pop     IY              ; ...into IY
3262+ 31C7 AF                   xor     A               ; reset 10 RAM cells
3263+ 31C8 06 0A                ld      B,$0A           ; (INSTR registers)
3264+ 31CA 21 0E 82             ld      HL,PT           ; first cell
3265+ 31CD 77           EMPTINS:ld      (HL),A          ; reset cell
3266+ 31CE 23                   inc     HL              ; next cell
3267+ 31CF 10 FC                djnz    EMPTINS         ; repeat
3268+ 31D1 ED 5B 0A 82          ld      DE,(LNS2)       ; load len(S2) into DE
3269+ 31D5 2A 06 82             ld      HL,(LNS1)       ; load len(S1) into HL
3270+ 31D8 CD 4D 4D             call    CMP16           ; check that len(S1)>=len(S2)
3271+ 31DB DA 50 32             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3272+ 31DE AF           RPTINST:xor     A               ; reset...
3273+ 31DF 32 14 82             ld      (TP),A          ; ...TP...
3274+ 31E2 32 16 82             ld      (TF),A          ; ...and TF
3275+ 31E5 ED 4B 0E 82          ld      BC,(PT)         ; pointer to S1
3276+ 31E9 2A 08 82             ld      HL,(ADRS1)      ; first cell of S1
3277+ 31EC 09                   add     HL,BC           ; get current position into RAM
3278+ 31ED 7E                   ld      A,(HL)          ; load S1(PT)
3279+ 31EE 2A 0C 82             ld      HL,(ADRS2)      ; pointer to first char of S2
3280+ 31F1 BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3281+ 31F2 20 3A                jr      NZ,CNT1INS      ; no, continue
3282+ 31F4 3A 0E 82             ld      A,(PT)          ; load current PT
3283+ 31F7 32 14 82             ld      (TP),A          ; TP=PT
3284+ 31FA 32 10 82             ld      (PT1),A         ; P1=PT
3285+ 31FD AF                   xor     A               ; set...
3286+ 31FE 32 12 82             ld      (PT2),A         ; ...PT2=0
3287+ 3201 3C                   inc     A               ;
3288+ 3202 32 16 82             ld      (TF),A          ; set TF=1
3289+ 3205 ED 4B 10 82  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3290+ 3209 2A 08 82             ld      HL,(ADRS1)      ; load address of S1
3291+ 320C 09                   add     HL,BC           ; find char of S1 pointed by PT1
3292+ 320D 7E                   ld      A,(HL)          ; load S1(PT1)
3293+ 320E ED 4B 12 82          ld      BC,(PT2)        ; load pointer PT2
3294+ 3212 2A 0C 82             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3295+ 3215 09                   add     HL,BC           ; find S2(PT2)
3296+ 3216 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3297+ 3217 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3298+ 3219 21 10 82             ld      HL,PT1
3299+ 321C 34                   inc     (HL)            ; increment PT1
3300+ 321D 3A 12 82             ld      A,(PT2)
3301+ 3220 3C                   inc     A               ; increment PT2
3302+ 3221 32 12 82             ld      (PT2),A
3303+ 3224 CA 2E 32             jp      Z,CNT1INS       ; if PT2>255 then exit
3304+ 3227 21 0A 82             ld      HL,LNS2         ; len(S2)
3305+ 322A BE                   cp      (HL)            ; PT2=len(S2)?
3306+ 322B DA 05 32             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3307+ 322E 3A 16 82     CNT1INS:ld      A,(TF)          ; check TF
3308+ 3231 A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3309+ 3232 20 1C                jr      NZ,RZINSTR      ; no, exit
3310+ 3234 2A 06 82             ld      HL,(LNS1)       ; load len(S1)
3311+ 3237 ED 4B 0A 82          ld      BC,(LNS2)       ; load len(S2)
3312+ 323B ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3313+ 323D ED 5B 0E 82          ld      DE,(PT)         ; load pointer
3314+ 3241 1C                   inc     E               ; PT=PT+1
3315+ 3242 ED 53 0E 82          ld      (PT),DE         ; store new value
3316+ 3246 EB                   ex      DE,HL           ; invert registers
3317+ 3247 CD 4D 4D             call    CMP16           ; check if PT>len(S1)-len(S2)
3318+ 324A DA DE 31             jp      C,RPTINST       ; repeat if <
3319+ 324D CA DE 31             jp      Z,RPTINST       ; repeat if =
3320+ 3250 3A 16 82     RZINSTR:ld      A,(TF)          ; current value of TF
3321+ 3253 A7                   and     A               ; is it 0?
3322+ 3254 CA 5B 32             jp      Z,LVINSTR       ; yes, return 0
3323+ 3257 3A 14 82             ld      A,(TP)          ; return TP...
3324+ 325A 3C                   inc     A               ; ...incremented by 1
3325+ 325B E1           LVINSTR:pop     HL              ; drop original return point
3326+ 325C FD E5                push    IY              ; load current string address from IY into stack
3327+ 325E 11 87 2B             ld      DE,RETNUM       ; Address of Return number from function...
3328+ 3261 D5                   push    DE              ; ...saved on stack
3329+ 3262 C3 95 2E             jp      PASSA           ; return TP
3330+ 3265 AF           CNTZIN: xor     A               ; set...
3331+ 3266 32 16 82             ld      (TF),A          ; TF=0
3332+ 3269 C3 2E 32             jp      CNT1INS         ; continue
3333+ 326C
3334+ 326C
3335+ 326C              ; returns the right portion of a string
3336+ 326C CD D5 32     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3337+ 326F D1                   pop     DE              ; Get string length
3338+ 3270 D5                   push    DE              ; And re-save
3339+ 3271 1A                   ld      A,(DE)          ; Get length
3340+ 3272 90                   sub     B               ; Move back N bytes
3341+ 3273 C3 4A 31             jp      RIGHT1          ; Go and get sub-string
3342+ 3276
3343+ 3276              ; returns a piece of a string
3344+ 3276 EB           MID:    ex      DE,HL           ; Get code string address
3345+ 3277 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3346+ 3278 CD DA 32             call    MIDNUM          ; Get number supplied
3347+ 327B 04                   inc     B               ; Is it character zero?
3348+ 327C 05                   dec     B
3349+ 327D CA D6 26             jp      Z,FCERR         ; Yes - Error
3350+ 3280 C5                   push    BC              ; Save starting position
3351+ 3281 1E FF                ld      E,$FF           ; All of string
3352+ 3283 FE 29                cp      ')'             ; Any length given?
3353+ 3285 CA 8F 32             jp      Z,RSTSTR        ; No - Rest of string
3354+ 3288 CD C2 23             call    CHKSYN          ; Make sure ',' follows
3355+ 328B 2C                   defb    ','
3356+ 328C CD 22 33             call    GETINT          ; Get integer 0-255
3357+ 328F CD C2 23     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3358+ 3292 29                   defb    ')'
3359+ 3293 F1                   pop     AF              ; Restore starting position
3360+ 3294 E3                   ex      (SP),HL         ; Get string,save code string
3361+ 3295 01 4C 31             ld      BC,MID1         ; Continuation of MID$ routine
3362+ 3298 C5                   push    BC              ; Save for return
3363+ 3299 3D                   dec     A               ; Starting position-1
3364+ 329A BE                   cp      (HL)            ; Compare with length
3365+ 329B 06 00                ld      B,$00           ; Zero bytes length
3366+ 329D D0                   ret     NC              ; Null string if start past end
3367+ 329E 4F                   ld      C,A             ; Save starting position-1
3368+ 329F 7E                   ld      A,(HL)          ; Get length of string
3369+ 32A0 91                   sub     C               ; Subtract start
3370+ 32A1 BB                   cp      E               ; Enough string for it?
3371+ 32A2 47                   ld      B,A             ; Save maximum length available
3372+ 32A3 D8                   ret     C               ; Truncate string if needed
3373+ 32A4 43                   ld      B,E             ; Set specified length
3374+ 32A5 C9                   ret                     ; Go and create string
3375+ 32A6
3376+ 32A6
3377+ 32A6              ; return the value of a numeric string
3378+ 32A6 CD 1A 31     VAL:    call    GETLEN          ; Get length of string
3379+ 32A9 CA 78 36             jp      Z,RESZER        ; Result zero
3380+ 32AC 5F                   ld      E,A             ; Save length
3381+ 32AD 23                   inc     HL
3382+ 32AE 23                   inc     HL
3383+ 32AF 7E                   ld      A,(HL)          ; Get LSB of address
3384+ 32B0 23                   inc     HL
3385+ 32B1 66                   ld      H,(HL)          ; Get MSB of address
3386+ 32B2 6F                   ld      L,A             ; HL = String address
3387+ 32B3 E5                   push    HL              ; Save string address
3388+ 32B4 19                   add     HL,DE
3389+ 32B5 46                   ld      B,(HL)          ; Get end of string+1 byte
3390+ 32B6 72                   ld      (HL),D          ; Zero it to terminate
3391+ 32B7 E3                   ex      (SP),HL         ; Save string end,get start
3392+ 32B8 C5                   push    BC              ; Save end+1 byte
3393+ 32B9 7E                   ld      A,(HL)          ; Get starting byte
3394+ 32BA FE 24                cp      '$'             ; Hex number indicated? [function added]
3395+ 32BC C2 C4 32             jp      NZ,VAL1
3396+ 32BF CD 7F 4C             call    HEXTFP          ; Convert Hex to FPREG
3397+ 32C2 18 0D                jr      VAL3
3398+ 32C4 FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3399+ 32C6 C2 CE 32             jp      NZ,VAL2
3400+ 32C9 CD EF 4C             call    BINTFP          ; Convert Bin to FPREG
3401+ 32CC 18 03                jr      VAL3
3402+ 32CE CD B0 39     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3403+ 32D1 C1           VAL3:   pop     BC              ; Restore end+1 byte
3404+ 32D2 E1                   pop     HL              ; Restore end+1 address
3405+ 32D3 70                   ld      (HL),B          ; Put back original byte
3406+ 32D4 C9                   ret
3407+ 32D5
3408+ 32D5 EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3409+ 32D6 CD C2 23             call    CHKSYN          ; Make sure ")" follows
3410+ 32D9 29                   defb    ')'
3411+ 32DA C1           MIDNUM: pop     BC              ; Get return address
3412+ 32DB D1                   pop     DE              ; Get number supplied
3413+ 32DC C5                   push    BC              ; Re-save return address
3414+ 32DD 43                   ld      B,E             ; Number to B
3415+ 32DE C9                   ret
3416+ 32DF
3417+ 32DF CD 25 33     INP:    call    MAKINT          ; Make it integer A
3418+ 32E2 32 A0 80             ld      (INPORT),A      ; Set input port
3419+ 32E5 CD 9F 80             call    INPSUB          ; Get input from port
3420+ 32E8 C3 95 2E             jp      PASSA           ; Return integer A
3421+ 32EB
3422+ 32EB CD 0F 33     POUT:   call    SETIO           ; Set up port number
3423+ 32EE C3 67 80             jp      OUTSUB          ; Output data and return
3424+ 32F1
3425+ 32F1 CD 0F 33     WAIT:   call    SETIO           ; Set up port number
3426+ 32F4 F5                   push    AF              ; Save AND mask
3427+ 32F5 1E 00                ld      E,$00           ; Assume zero if none given
3428+ 32F7 2B                   dec     HL              ; dec 'cos GETCHR INCs
3429+ 32F8 CD 0B 26             call    GETCHR          ; Get next character
3430+ 32FB CA 05 33             jp      Z,NOXOR         ; No XOR byte given
3431+ 32FE CD C2 23             call    CHKSYN          ; Make sure ',' follows
3432+ 3301 2C                   defb    ','
3433+ 3302 CD 22 33             call    GETINT          ; Get integer 0-255 to XOR with
3434+ 3305 C1           NOXOR:  pop     BC              ; Restore AND mask
3435+ 3306 CD 9F 80     WAITLP: call    INPSUB          ; Get input
3436+ 3309 AB                   xor     E               ; Flip selected bits
3437+ 330A A0                   and     B               ; Result non-zero?
3438+ 330B CA 06 33             jp      Z,WAITLP        ; No = keep waiting
3439+ 330E C9                   ret
3440+ 330F
3441+ 330F CD 22 33     SETIO:  call    GETINT          ; Get integer 0-255
3442+ 3312 32 A0 80             ld      (INPORT),A      ; Set input port
3443+ 3315 32 68 80             ld      (OTPORT),A      ; Set output port
3444+ 3318 CD C2 23             call    CHKSYN          ; Make sure ',' follows
3445+ 331B 2C                   defb    ','
3446+ 331C C3 22 33             jp      GETINT          ; Get integer 0-255 and return
3447+ 331F
3448+ 331F CD 0B 26     FNDNUM: call    GETCHR          ; Get next character
3449+ 3322 CD 9C 2A     GETINT: call    GETNUM          ; Get a number from 0 to 255
3450+ 3325 CD BB 26     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3451+ 3328 7A                   ld      A,D             ; Get MSB of number
3452+ 3329 B7                   or      A               ; Zero?
3453+ 332A C2 D6 26             jp      NZ,FCERR        ; No - Error
3454+ 332D 2B                   dec     HL              ; dec 'cos GETCHR INCs
3455+ 332E CD 0B 26             call    GETCHR          ; Get next character
3456+ 3331 7B                   ld      A,E             ; Get number to A
3457+ 3332 C9                   ret
3458+ 3333
3459+ 3333
3460+ 3333              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3461+ 3333              ; address must point to an ISR routine that terminates with EI/RETN instructions
3462+ 3333 CD 9C 2A     NMI:    call    GETNUM          ; Get memory address
3463+ 3336 CD C1 26             call    DEINT           ; get integer -32768 to 32767
3464+ 3339 7B                   ld      A,E             ; check if address is 0
3465+ 333A B2                   or      D
3466+ 333B 20 11                jr      NZ,NM1          ; no, so jump over
3467+ 333D F3           DISNMI: di                      ; disable INTs
3468+ 333E CD 6A 33             call    NMIDINT         ; disable VDP INT
3469+ 3341 E5                   push    HL              ; store HL
3470+ 3342 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3471+ 3345 22 61 80             ld      (NMIUSR),HL     ; store RETN
3472+ 3348 AF                   xor     A
3473+ 3349 32 63 80             ld      (NMIUSR+2),A    ; "NOP"
3474+ 334C 18 11                jr      NMI2            ; execute the last part of code
3475+ 334E E5           NM1:    push    HL              ; store current HL
3476+ 334F EB                   ex      DE,HL           ; move address argument into HL
3477+ 3350 F3                   di                      ; disable INTs
3478+ 3351 CD 6A 33             call    NMIDINT         ; disable VDP INT, if enabled
3479+ 3354 3E C3                ld      A,$C3           ; "jp" instruction
3480+ 3356 32 61 80             ld      (NMIUSR),A      ; store it
3481+ 3359 22 62 80             ld      (NMIUSR+1),HL   ; store address
3482+ 335C CD 63 33             call    NMIEINT         ; re-enable VDP INT
3483+ 335F FB           NMI2:   ei                      ; re-enable INTS
3484+ 3360 00                   nop                     ; wait for INTs
3485+ 3361 E1                   pop    HL               ; retrieve HL
3486+ 3362 C9                   ret                     ; return to caller
3487+ 3363              ; enable VDP INT
3488+ 3363 CD 79 33     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3489+ 3366 F6 20                or      %00100000       ; enable VDP INT
3490+ 3368 18 03                jr      NMIINT          ; rest of code is shared
3491+ 336A              ; disable VDP INT
3492+ 336A CD 79 33     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3493+ 336D D5           NMIINT: push    DE              ; store DE
3494+ 336E 5F                   ld      E,A             ; move value into E
3495+ 336F 3E 01                ld      A,$01           ; VREG #1
3496+ 3371 F3                   di                      ; disable INTs
3497+ 3372 CD D1 06             call    WRITE_VREG      ; disable VDP INT
3498+ 3375 FB                   ei                      ; re-enable INTs
3499+ 3376 00                   nop                     ; wait for INTs being enabled
3500+ 3377 D1                   pop     DE              ; retrieve DE
3501+ 3378 C9                   ret                     ; return to caller
3502+ 3379
3503+ 3379              ; load VREG #1 setting for current screen mode and return it into A
3504+ 3379 E5           NMIVR1: push    HL              ; store HL
3505+ 337A D5                   push    DE              ; store DE
3506+ 337B 3A F8 81             ld      A,(SCR_MODE)    ; check screen mode
3507+ 337E 87                   add     A,A             ; multiply A by 8...
3508+ 337F 87                   add     A,A             ; ...so that reg. A can points..
3509+ 3380 87                   add     A,A             ; to the correct settings
3510+ 3381 3C                   inc     A               ; need to change VREG 1
3511+ 3382 5F                   ld      E,A             ; copy A into E
3512+ 3383 16 00                ld      D,$00           ; reset D
3513+ 3385 21 43 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3514+ 3388 19                   add     HL,DE           ; ...for current screen mode
3515+ 3389 7E                   ld      A,(HL)          ; load current setting
3516+ 338A D1                   pop     DE              ; retrieve DE
3517+ 338B E1                   pop     HL              ; retrieve HL
3518+ 338C C9                   ret                     ; return to caller
3519+ 338D
3520+ 338D              ; execute a machine language routine, eventually passing a param into A
3521+ 338D CD 9C 2A     SYS:    call    GETNUM          ; Get memory address
3522+ 3390 CD C1 26             call    DEINT           ; Get integer -32768 to 32767
3523+ 3393 ED 53 08 82          ld      (TMPBFR2),DE    ; store user routine's address
3524+ 3397 AF                   xor     A               ; reset A
3525+ 3398 32 06 82             ld      (TMPBFR1),A     ; store into temp buffer
3526+ 339B 2B                   dec     HL              ; dec 'cos GETCHR INCs
3527+ 339C CD 0B 26             call    GETCHR          ; check next character
3528+ 339F 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3529+ 33A1 CD C2 23             call    CHKSYN          ; Make sure ',' follows
3530+ 33A4 2C                   defb    ','
3531+ 33A5 CD 22 33             call    GETINT          ; get byte value (0~255) if something follows
3532+ 33A8 32 06 82             ld      (TMPBFR1),A     ; store into temp buffer
3533+ 33AB 3A 06 82     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3534+ 33AE ED 5B 08 82          ld      DE,(TMPBFR2)    ; recover user routine's address
3535+ 33B2 E5                   push    HL              ; save code string address
3536+ 33B3 EB                   ex      DE,HL           ; move user routine's address into HL
3537+ 33B4 11 B9 33             ld      DE,SYSRET       ; set point of return after the user routine
3538+ 33B7 D5                   push    DE              ; store into stack
3539+ 33B8 E9                   jp      (HL)            ; call user routine
3540+ 33B9 E1           SYSRET: pop     HL              ; retrieve code string address
3541+ 33BA C9                   ret                     ; return to caller
3542+ 33BB
3543+ 33BB
3544+ 33BB              ; read the contents of a RAM location
3545+ 33BB CD C1 26     PEEK:   call    DEINT           ; Get memory address into DE
3546+ 33BE 1A                   ld      A,(DE)          ; Read value of memory cell
3547+ 33BF C3 95 2E             jp      PASSA           ; Return into A
3548+ 33C2
3549+ 33C2              ; read the contents of a VRAM location
3550+ 33C2 CD C1 26     VPEEK:  call    DEINT           ; Get VRAM address into DE
3551+ 33C5 EB                   ex      DE,HL           ; Copy param into HL
3552+ 33C6 F3                   di                      ; Disable interrupts
3553+ 33C7 CD A7 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3554+ 33CA FB                   ei                      ; Re-enable interrupts
3555+ 33CB EB                   ex      DE,HL           ; Restore HL
3556+ 33CC C3 95 2E             jp      PASSA           ; Return value into A
3557+ 33CF
3558+ 33CF              ; recover params for POKE/VPOKE commands
3559+ 33CF              ; returns address into DE and byte to be written into A
3560+ 33CF CD 9C 2A     PKEPRMS:call    GETNUM          ; Get memory address
3561+ 33D2 CD C1 26             call    DEINT           ; Get integer -32768 to 32767
3562+ 33D5 ED 53 06 82          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3563+ 33D9 CD C2 23             call    CHKSYN          ; Make sure ',' follows
3564+ 33DC 2C                   defb    ','
3565+ 33DD CD 22 33             call    GETINT          ; Get integer 0-255
3566+ 33E0 ED 5B 06 82          ld      DE,(TMPBFR1)    ; Restore memory address
3567+ 33E4 C9                   ret                     ; Return to caller
3568+ 33E5
3569+ 33E5              ; write a byte into a RAM location
3570+ 33E5 CD CF 33     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3571+ 33E8 12                   ld      (DE),A          ; Load it into memory
3572+ 33E9 C9                   ret
3573+ 33EA
3574+ 33EA              ; write a byte into a VRAM location
3575+ 33EA CD CF 33     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3576+ 33ED EB                   ex      DE,HL           ; Copy address into HL
3577+ 33EE F3                   di                      ; Disable interrupts
3578+ 33EF CD BC 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3579+ 33F2 FB                   ei                      ; Re-enable interrupts
3580+ 33F3 EB                   ex      DE,HL           ; Restore HL
3581+ 33F4 C9                   ret                     ; Return to caller
3582+ 33F5
3583+ 33F5              ; position the cursor at a specific X,Y location onto screen
3584+ 33F5 CD 22 33     LOCATE: call    GETINT          ; get the first param into A
3585+ 33F8 E5                   push    HL              ; store HL
3586+ 33F9 21 F6 81             ld      HL,SCR_SIZE_W   ; load address of screen width
3587+ 33FC 5E                   ld      E,(HL)          ; load screen width into E
3588+ 33FD E1                   pop     HL              ; restore HL
3589+ 33FE BB                   cp      E               ; compare witdh with param
3590+ 33FF D2 D6 26             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3591+ 3402 32 06 82             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3592+ 3405 CD C2 23             call    CHKSYN          ; Make sure ',' follows
3593+ 3408 2C                   defb    ','
3594+ 3409 CD 22 33             call    GETINT          ; Get the second param into A
3595+ 340C E5                   push    HL              ; store HL
3596+ 340D 21 F7 81             ld      HL,SCR_SIZE_H   ; load address of screen width
3597+ 3410 5E                   ld      E,(HL)          ; load screen width into A
3598+ 3411 E1                   pop     HL              ; restore HL
3599+ 3412 BB                   cp      E               ; compare witdh with param
3600+ 3413 D2 D6 26             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3601+ 3416 32 FE 81             ld      (SCR_CUR_NY),A  ; store new Y
3602+ 3419 3A 06 82             ld      A,(TMPBFR1)     ; recover the new X
3603+ 341C 32 FD 81             ld      (SCR_CUR_NX),A  ; store new X
3604+ 341F E5                   push    HL              ; store HL
3605+ 3420 F3                   di                      ; disable INTs
3606+ 3421 CD ED 06             call    MOVCRS          ; move cursor to new location
3607+ 3424 FB                   ei                      ; re-enable INTs
3608+ 3425 E1                   pop     HL              ; restore HL
3609+ 3426 C9                   ret                     ; return to caller
3610+ 3427
3611+ 3427              ; write a byte into one of the PSG registers
3612+ 3427 CD 22 33     SREG:   call    GETINT          ; Get register number back into A
3613+ 342A FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3614+ 342C D2 D6 26             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3615+ 342F 32 06 82             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3616+ 3432 CD C2 23             call    CHKSYN          ; Make sure ',' follows
3617+ 3435 2C                   defb    ','
3618+ 3436 CD 22 33             call    GETINT          ; get second value (0-255), returned into A
3619+ 3439 5F                   ld      E,A             ; store value into E
3620+ 343A 3A 06 82             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3621+ 343D F3                   di                      ; disable INTs
3622+ 343E 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3623+ 3440 ED 79                out     (C),A           ; send register # to PSG
3624+ 3442 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3625+ 3444 ED 59                out     (C),E           ; send byte to write into selected register
3626+ 3446 FB                   ei                      ; re-enable INTs
3627+ 3447 C9                   ret                     ; return to caller
3628+ 3448
3629+ 3448              ; VOLUME ch,vol
3630+ 3448              ; set the volume for the audio channels
3631+ 3448              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3632+ 3448 CD 22 33     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3633+ 344B FE 04                cp      $04             ; check if it's in the range 0~3
3634+ 344D D2 D6 26             jp      NC,FCERR        ; if not, exit with Illegal function call error
3635+ 3450 32 06 82             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3636+ 3453 CD C2 23             call    CHKSYN          ; Make sure ',' follows
3637+ 3456 2C                   defb    ','
3638+ 3457 CD 22 33             call    GETINT          ; get integer 0-255 (recover channel)
3639+ 345A FE 10                cp      $10             ; check if it's in the range 0~15
3640+ 345C D2 D6 26             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3641+ 345F 57                   ld      D,A             ; store volume into D
3642+ 3460 3A 06 82             ld      A,(TMPBFR1)     ; retrieve channel
3643+ 3463 A7                   and     A               ; is it 0? (0=every channel)
3644+ 3464 20 10                jr      NZ,VOLCH        ; no, jump over
3645+ 3466 06 03                ld      B,$03           ; yes, set every channel
3646+ 3468 1E 08                ld      E,$08           ; register volume of first channel
3647+ 346A 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3648+ 346C ED 59                out     (C),E           ; set register #
3649+ 346E 0E 41                ld      C,PSG_DAT       ; PSG data port
3650+ 3470 ED 51                out     (C),D           ; send volume
3651+ 3472 1C                   inc     E               ; next register
3652+ 3473 10 F5                djnz    RPVOLCG         ; repeat for each channel
3653+ 3475 C9                   ret                     ; return to caller
3654+ 3476 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3655+ 3478 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3656+ 347A ED 79                out     (C),A           ; set register
3657+ 347C 0E 41                ld      C,PSG_DAT       ; PSG data port
3658+ 347E ED 51                out     (C),D           ; send volume level
3659+ 3480 C9                   ret                     ; return to caller
3660+ 3481
3661+ 3481              ; SOUND ch,tone,dur
3662+ 3481              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3663+ 3481              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3664+ 3481              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3665+ 3481 CD 22 33     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3666+ 3484 A7                   and     A               ; is it zero?
3667+ 3485 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3668+ 3487 E5                   push    HL              ; store HL
3669+ 3488 F3                   di                      ; disable INTs
3670+ 3489 CD B5 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3671+ 348C FB                   ei                      ; re-enable INTs
3672+ 348D E1                   pop     HL              ; retrieve HL
3673+ 348E C9                   ret                     ; return to caller
3674+ 348F 32 06 82     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3675+ 3492 FE 04                cp      $04             ; is channel >3?
3676+ 3494 D2 13 35             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3677+ 3497 CD C2 23             call    CHKSYN          ; No, continue checking by making sure ',' follows
3678+ 349A 2C                   defb    ','
3679+ 349B CD 9C 2A             call    GETNUM          ; Get tone frequency
3680+ 349E CD C1 26             call    DEINT           ; Get integer -32768 to 32767
3681+ 34A1 ED 53 08 82          ld      (TMPBFR2),DE    ; Store frequency
3682+ 34A5 CD C2 23             call    CHKSYN          ; Make sure ',' follows
3683+ 34A8 2C                   defb    ','
3684+ 34A9 CD 9C 2A             call    GETNUM          ; Get duration
3685+ 34AC CD C1 26             call    DEINT           ; Get integer -32768 to 32767
3686+ 34AF ED 53 0A 82          ld      (TMPBFR3),DE    ; Store duration
3687+ 34B3                                              ; CHECK CHANNEL
3688+ 34B3 3A 06 82             ld      A,(TMPBFR1)     ; recover channel
3689+ 34B6 FE 01                cp      $01             ; is channel <1?
3690+ 34B8 DA D6 26             jp      C,FCERR         ; Yes - Illegal function call error
3691+ 34BB                                              ; CHECK FREQUENCY
3692+ 34BB ED 5B 08 82          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3693+ 34BF 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3694+ 34C0 FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3695+ 34C2 D2 D6 26             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3696+ 34C5                                              ; CHECK DURATION
3697+ 34C5 ED 5B 0A 82          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3698+ 34C9 7A                   ld      A,D             ; check if it is in the range 0~16383...
3699+ 34CA E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3700+ 34CC C2 D6 26             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3701+ 34CF                                              ;
3702+ 34CF                                              ; SET TONE:
3703+ 34CF                                              ; let's start by setting up the channel
3704+ 34CF 3A 06 82             ld      A,(TMPBFR1)     ; restore channel value
3705+ 34D2 FE 03                cp      $03             ; is it 3?
3706+ 34D4 20 02                jr      NZ,SND1         ; no, jump over
3707+ 34D6 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3708+ 34D8 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3709+ 34D9 CD 60 35             call    WRTSND          ; enable line into mixer of channel stored in A
3710+ 34DC                                              ; SET FREQUENCY
3711+ 34DC                                              ; we simply get frequency and subtract from 4096. The result
3712+ 34DC                                              ; is put into register pair of the corresponding freq tone channel
3713+ 34DC ED 5B 08 82          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3714+ 34E0 E5                   push    HL              ; store HL (it will be used by the subroutine)
3715+ 34E1 21 00 10             ld      HL,$1000        ; load 4096 into HL
3716+ 34E4 A7                   and     A               ; reset C flag
3717+ 34E5 ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3718+ 34E7 3A 06 82             ld      A,(TMPBFR1)     ; restore channel value
3719+ 34EA 3D                   dec     A               ; set A into the range 0~2
3720+ 34EB 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3721+ 34EC 0E 40                ld      C,PSG_REG       ; PSG register port
3722+ 34EE ED 79                out     (C),A           ; select first register of the pair
3723+ 34F0 0E 41                ld      C,PSG_DAT       ; PSG data port
3724+ 34F2 ED 69                out     (C),L           ; send high byte
3725+ 34F4 0E 40                ld      C,PSG_REG       ; PSG register support
3726+ 34F6 3C                   inc     A               ; second register of the pair
3727+ 34F7 ED 79                out     (C),A           ; select register
3728+ 34F9 0E 41                ld      C,PSG_DAT       ; PSG data port
3729+ 34FB ED 61                out     (C),H           ; send low byte
3730+ 34FD ED 5B 0A 82          ld      DE,(TMPBFR3)    ; recover duration
3731+ 3501 3A 06 82             ld      A,(TMPBFR1)     ; recover channel value
3732+ 3504 3D                   dec     A               ; set channel into the range 0~2
3733+ 3505 87                   add     A,A             ; double A to find the correct offset
3734+ 3506 21 3A 82             ld      HL,CHASNDDTN    ; set duration into...
3735+ 3509 85                   add     A,L             ; ...the proper...
3736+ 350A 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3737+ 350C 24                   inc     H               ; yes, increment H)
3738+ 350D 6F           SNDOVR: ld      L,A             ; ...register pair...
3739+ 350E 73                   ld      (HL),E          ; ...and store the value
3740+ 350F 23                   inc     HL
3741+ 3510 72                   ld      (HL),D
3742+ 3511 E1                   pop     HL              ; retrieve HL
3743+ 3512 C9                   ret                     ; Return to caller
3744+ 3513 FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3745+ 3515 D2 D6 26             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3746+ 3518 CD C2 23             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3747+ 351B 2C                   defb    ','
3748+ 351C CD 22 33             call    GETINT          ; get integer 0-255 (frequency)
3749+ 351F FE 20                cp      $20             ; make sure it's in range 0~31
3750+ 3521 D2 D6 26             jp      NC,FCERR        ; no, so Illegal function call
3751+ 3524 32 08 82             ld      (TMPBFR2),A     ; store freq.
3752+ 3527 2B                   dec     HL              ; dec 'cos GETCHR INCs
3753+ 3528 CD 0B 26             call    GETCHR          ; check that nothing follows
3754+ 352B C2 C2 20             jp      NZ,SNERR        ; error if no empty line
3755+ 352E 3A 08 82             ld      A,(TMPBFR2)     ; retrieve freq.
3756+ 3531 5F                   ld      E,A             ; store freq into E
3757+ 3532 3A 06 82             ld      A,(TMPBFR1)     ; retrieve channel
3758+ 3535 D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3759+ 3537 FE 03                cp      $03             ; is it 3?
3760+ 3539 20 02                jr      NZ,NOS1         ; no, jump over
3761+ 353B 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3762+ 353D 87           NOS1:   add     A,A
3763+ 353E 87                   add     A,A
3764+ 353F 87                   add     A,A             ; let's move A 3 bits to left
3765+ 3540 47                   ld      B,A             ; store channel into B
3766+ 3541 7B                   ld      A,E             ; check if
3767+ 3542 A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3768+ 3543 F3                   di                      ; disable INts
3769+ 3544 20 0A                jr      NZ,NOS2         ; no, so jump over
3770+ 3546 3E 07                ld      A,$07           ; mixer register
3771+ 3548 CD 03 0D             call    SETSNDREG       ; set mixer register
3772+ 354B ED 78                in      A,(C)           ; load current mixer value
3773+ 354D B0                   or      B               ; disable noise
3774+ 354E 18 19                jr      NOS3            ; continue over
3775+ 3550 78           NOS2:   ld      A,B             ; recover channel
3776+ 3551 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3777+ 3552 CD 60 35             call    WRTSND          ; enable line into mixer of channel stored in A
3778+ 3555 3E 06                ld      A,$06           ; write into noise register
3779+ 3557 CD 03 0D             call    SETSNDREG       ; set register into PSG
3780+ 355A 7B                   ld      A,E             ; load value for noise frequency
3781+ 355B CD 08 0D             call    WRTSNDREG       ; write data into register $06
3782+ 355E FB                   ei                      ; re-enable INTs
3783+ 355F C9                   ret
3784+ 3560                      ; enable line into mixer of channel stored in A
3785+ 3560 47           WRTSND: ld      B,A             ; move channel into B
3786+ 3561 3E 07                ld      A,$07           ; mixer register
3787+ 3563 CD 03 0D             call    SETSNDREG       ; set mixer register
3788+ 3566 ED 78                in      A,(C)           ; load current value
3789+ 3568 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3790+ 3569                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3791+ 3569                                              ; the register is still unchanged after reset) is 11111111 and
3792+ 3569                                              ; 11111111 AND 11111110 is equal to 11111110
3793+ 3569                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3794+ 3569 47           NOS3:   ld      B,A             ; store new mixer value into B
3795+ 356A 3E 07                ld      A,$07           ; mixer address
3796+ 356C CD 03 0D             call    SETSNDREG       ; set register
3797+ 356F 78                   ld      A,B             ; retrieve new mixer value from B
3798+ 3570 CD 08 0D             call    WRTSNDREG       ; send new value for the mixer
3799+ 3573 FB                   ei                      ; re-enable INTs
3800+ 3574 C9                   ret                     ; return to caller
3801+ 3575
3802+ 3575              ; write a byte into one of the VDP registers
3803+ 3575 CD 22 33     VREG:   call    GETINT          ; Get register number back into A
3804+ 3578 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3805+ 357A D2 D6 26             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3806+ 357D 32 06 82             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3807+ 3580 CD C2 23             call    CHKSYN          ; Make sure ',' follows
3808+ 3583 2C                   defb    ','
3809+ 3584 CD 22 33             call    GETINT          ; get value (0-255)
3810+ 3587 5F                   ld      E,A             ; store value into E
3811+ 3588 3A 06 82             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3812+ 358B F3                   di                      ; disable INTs
3813+ 358C CD D1 06             call    WRITE_VREG      ; write value into VDP register
3814+ 358F FB                   ei                      ; re-enable INTs
3815+ 3590 C9                   ret                     ; return to caller
3816+ 3591
3817+ 3591              ; read the VDP status register and return it into A
3818+ 3591 CD C1 26     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3819+ 3594 F3                   di                      ; disable INTs
3820+ 3595 CD DC 06             call    READ_VSTAT      ; read VDP register status
3821+ 3598 FB                   ei                      ; re-enable INTs
3822+ 3599 C3 95 2E             jp      PASSA           ; Return integer A
3823+ 359C
3824+ 359C              ; read from PSG register and return it into A
3825+ 359C CD C1 26     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3826+ 359F 7B                   ld      A,E             ; consider LSB
3827+ 35A0 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3828+ 35A2 D2 D6 26             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3829+ 35A5 F3                   di                      ; disable INts
3830+ 35A6 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3831+ 35A8 ED 79                out     (C),A           ; send register to read from
3832+ 35AA ED 78                in      A,(C)           ; read register's contents and store into A
3833+ 35AC FB                   ei                      ; re-enable INTs
3834+ 35AD C3 95 2E             jp      PASSA           ; return A
3835+ 35B0
3836+ 35B0              ; read the temp key buffer and return the value of the current key being pressed
3837+ 35B0              ; can wait for the number of 100thds of second before to return
3838+ 35B0 CD 0F 2F     INKEY:  call    IDTEST          ; Test for illegal direct
3839+ 35B3 CD C1 26             call    DEINT           ; get number param (100thds of second to wait) into DE
3840+ 35B6 C5                   push    BC              ; store BC
3841+ 35B7 3A E6 81             ld      A,(TMRCNT)      ; Load current value of system timer
3842+ 35BA 47                   ld      B,A             ; move it into B
3843+ 35BB 3A E6 81     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3844+ 35BE B8                   cp      B               ; ...to let the sniffer collect...
3845+ 35BF 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3846+ 35C1 7A                   ld      A,D             ; check the param
3847+ 35C2 B3                   or      E               ; if DE<>0 then...
3848+ 35C3 20 05                jr      NZ,INKEY2       ; ...jump over...
3849+ 35C5 3A 42 82             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3850+ 35C8 18 2A                jr      ENDINK          ; ...return it
3851+ 35CA 7A           INKEY2: ld      A,D             ; check if param>1023
3852+ 35CB FE 04                cp      $04             ; to do this we check if MSB>3
3853+ 35CD D2 D6 26             jp      NC,FCERR        ; if MSB >=4 then error
3854+ 35D0 E5                   push    HL              ; store HL
3855+ 35D1 21 09 00             ld      HL,$0009        ; check if value
3856+ 35D4 CD 4D 4D             call    CMP16           ; is < 10
3857+ 35D7 E1                   pop     HL              ; retrieve HL
3858+ 35D8 DA DE 35             jp      C,SRTINK        ; if value >= 10 then jump over
3859+ 35DB 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3860+ 35DE 3A E6 81     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3861+ 35E1 47                   ld      B,A             ; move it into B
3862+ 35E2 3A 42 82     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3863+ 35E5 A7                   and     A               ; is it 0?
3864+ 35E6 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3865+ 35E8 3A E6 81             ld      A,(TMRCNT)      ; load the first byte of the system timer
3866+ 35EB B8                   cp      B               ; is it the same value?
3867+ 35EC 28 F4                jr      Z,CHKINK        ; yes, so read again
3868+ 35EE 47                   ld      B,A             ; store new value
3869+ 35EF 1B                   dec     DE              ; no, decrement timer
3870+ 35F0 7A                   ld      A,D             ; check if zero reached
3871+ 35F1 B3                   or      E               ; by ORing D and E
3872+ 35F2 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3873+ 35F4 C1           ENDINK: pop     BC              ; restore BC
3874+ 35F5 F5                   push    AF              ; store A
3875+ 35F6 F3                   di                      ; disable INTs
3876+ 35F7 AF                   xor     A               ; clear the...
3877+ 35F8 32 42 82             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3878+ 35FB FB                   ei                      ; re-enable INTs
3879+ 35FC F1                   pop     AF              ; retrieve A
3880+ 35FD C3 95 2E     ENDINK2:jp      PASSA           ; return A as ASCII value
3881+ 3600
3882+ 3600
3883+ 3600 21 27 3B     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3884+ 3603 CD F8 38     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3885+ 3606 C3 12 36             jp      FPADD           ; Add BCDE to FPREG
3886+ 3609
3887+ 3609
3888+ 3609 CD F8 38     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3889+ 360C 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3890+ 360D C1           PSUB:   pop     BC              ; Get FP number from stack
3891+ 360E D1                   pop     DE
3892+ 360F CD D2 38     SUBCDE: call    INVSGN          ; Negate FPREG
3893+ 3612 78           FPADD:  ld      A,B             ; Get FP exponent
3894+ 3613 B7                   or      A               ; Is number zero?
3895+ 3614 C8                   ret     Z               ; Yes - Nothing to add
3896+ 3615 3A 5D 82             ld      A,(FPEXP)       ; Get FPREG exponent
3897+ 3618 B7                   or      A               ; Is this number zero?
3898+ 3619 CA EA 38             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3899+ 361C 90                   sub     B               ; BCDE number larger?
3900+ 361D D2 2C 36             jp      NC,NOSWAP       ; No - Don't swap them
3901+ 3620 2F                   cpl                     ; Two's complement
3902+ 3621 3C                   inc     A               ;  FP exponent
3903+ 3622 EB                   ex      DE,HL
3904+ 3623 CD DA 38             call    STAKFP          ; Put FPREG on stack
3905+ 3626 EB                   ex      DE,HL
3906+ 3627 CD EA 38             call    FPBCDE          ; Move BCDE to FPREG
3907+ 362A C1                   pop     BC              ; Restore number from stack
3908+ 362B D1                   pop     DE
3909+ 362C FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3910+ 362E D0                   ret     NC              ; Yes - First number is result
3911+ 362F F5                   push    AF              ; Save number of bits to scale
3912+ 3630 CD 0F 39             call    SIGNS           ; Set MSBs & sign of result
3913+ 3633 67                   ld      H,A             ; Save sign of result
3914+ 3634 F1                   pop     AF              ; Restore scaling factor
3915+ 3635 CD D7 36             call    SCALE           ; Scale BCDE to same exponent
3916+ 3638 B4                   or      H               ; Result to be positive?
3917+ 3639 21 5A 82             ld      HL,FPREG        ; Point to FPREG
3918+ 363C F2 52 36             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3919+ 363F CD B7 36             call    PLUCDE          ; Add FPREG to CDE
3920+ 3642 D2 98 36             jp      NC,RONDUP       ; No overflow - Round it up
3921+ 3645 23                   inc     HL              ; Point to exponent
3922+ 3646 34                   inc     (HL)            ; Increment it
3923+ 3647 CA D1 20             jp      Z,OVERR         ; Number overflowed - Error
3924+ 364A 2E 01                ld      L,$01           ; 1 bit to shift right
3925+ 364C CD ED 36             call    SHRT1           ; Shift result right
3926+ 364F C3 98 36             jp      RONDUP          ; Round it up
3927+ 3652
3928+ 3652 AF           MINCDE: xor     A               ; Clear A and carry
3929+ 3653 90                   sub     B               ; Negate exponent
3930+ 3654 47                   ld      B,A             ; Re-save exponent
3931+ 3655 7E                   ld      A,(HL)          ; Get LSB of FPREG
3932+ 3656 9B                   sbc     A, E            ; Subtract LSB of BCDE
3933+ 3657 5F                   ld      E,A             ; Save LSB of BCDE
3934+ 3658 23                   inc     HL
3935+ 3659 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3936+ 365A 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3937+ 365B 57                   ld      D,A             ; Save NMSB of BCDE
3938+ 365C 23                   inc     HL
3939+ 365D 7E                   ld      A,(HL)          ; Get MSB of FPREG
3940+ 365E 99                   sbc     A,C             ; Subtract MSB of BCDE
3941+ 365F 4F                   ld      C,A             ; Save MSB of BCDE
3942+ 3660 DC C3 36     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3943+ 3663
3944+ 3663 68           BNORM:  ld      L,B             ; L = Exponent
3945+ 3664 63                   ld      H,E             ; H = LSB
3946+ 3665 AF                   xor     A
3947+ 3666 47           BNRMLP: ld      B,A             ; Save bit count
3948+ 3667 79                   ld      A,C             ; Get MSB
3949+ 3668 B7                   or      A               ; Is it zero?
3950+ 3669 C2 85 36             jp      NZ,PNORM        ; No - Do it bit at a time
3951+ 366C 4A                   ld      C,D             ; MSB = NMSB
3952+ 366D 54                   ld      D,H             ; NMSB= LSB
3953+ 366E 65                   ld      H,L             ; LSB = VLSB
3954+ 366F 6F                   ld      L,A             ; VLSB= 0
3955+ 3670 78                   ld      A,B             ; Get exponent
3956+ 3671 D6 08                sub     $08             ; Count 8 bits
3957+ 3673 FE E0                cp      -24-8           ; Was number zero?
3958+ 3675 C2 66 36             jp      NZ,BNRMLP       ; No - Keep normalising
3959+ 3678 AF           RESZER: xor     A               ; Result is zero
3960+ 3679 32 5D 82     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3961+ 367C C9                   ret
3962+ 367D
3963+ 367D 05           NORMAL: dec     B               ; Count bits
3964+ 367E 29                   add     HL,HL           ; Shift HL left
3965+ 367F 7A                   ld      A,D             ; Get NMSB
3966+ 3680 17                   rla                     ; Shift left with last bit
3967+ 3681 57                   ld      D,A             ; Save NMSB
3968+ 3682 79                   ld      A,C             ; Get MSB
3969+ 3683 8F                   adc     A,A             ; Shift left with last bit
3970+ 3684 4F                   ld      C,A             ; Save MSB
3971+ 3685 F2 7D 36     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3972+ 3688 78                   ld      A,B             ; Number of bits shifted
3973+ 3689 5C                   ld      E,H             ; Save HL in EB
3974+ 368A 45                   ld      B,L
3975+ 368B B7                   or      A               ; Any shifting done?
3976+ 368C CA 98 36             jp      Z,RONDUP        ; No - Round it up
3977+ 368F 21 5D 82             ld      HL,FPEXP        ; Point to exponent
3978+ 3692 86                   add     A,(HL)          ; Add shifted bits
3979+ 3693 77                   ld      (HL),A          ; Re-save exponent
3980+ 3694 D2 78 36             jp      NC,RESZER       ; Underflow - Result is zero
3981+ 3697 C8                   ret     Z               ; Result is zero
3982+ 3698 78           RONDUP: ld      A,B             ; Get VLSB of number
3983+ 3699 21 5D 82     RONDB:  ld      HL,FPEXP        ; Point to exponent
3984+ 369C B7                   or      A               ; Any rounding?
3985+ 369D FC AA 36             call    M,FPROND        ; Yes - Round number up
3986+ 36A0 46                   ld      B,(HL)          ; B = Exponent
3987+ 36A1 23                   inc     HL
3988+ 36A2 7E                   ld      A,(HL)          ; Get sign of result
3989+ 36A3 E6 80                and     %10000000       ; Only bit 7 needed
3990+ 36A5 A9                   xor     C               ; Set correct sign
3991+ 36A6 4F                   ld      C,A             ; Save correct sign in number
3992+ 36A7 C3 EA 38             jp      FPBCDE          ; Move BCDE to FPREG
3993+ 36AA
3994+ 36AA 1C           FPROND: inc     E               ; Round LSB
3995+ 36AB C0                   ret     NZ              ; Return if ok
3996+ 36AC 14                   inc     D               ; Round NMSB
3997+ 36AD C0                   ret     NZ              ; Return if ok
3998+ 36AE 0C                   inc     C               ; Round MSB
3999+ 36AF C0                   ret     NZ              ; Return if ok
4000+ 36B0 0E 80                ld      C,$80           ; Set normal value
4001+ 36B2 34                   inc     (HL)            ; Increment exponent
4002+ 36B3 C0                   ret     NZ              ; Return if ok
4003+ 36B4 C3 D1 20             jp      OVERR           ; Overflow error
4004+ 36B7
4005+ 36B7 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
4006+ 36B8 83                   add     A,E             ; Add LSB of BCDE
4007+ 36B9 5F                   ld      E,A             ; Save LSB of BCDE
4008+ 36BA 23                   inc     HL
4009+ 36BB 7E                   ld      A,(HL)          ; Get NMSB of FPREG
4010+ 36BC 8A                   adc     A,D             ; Add NMSB of BCDE
4011+ 36BD 57                   ld      D,A             ; Save NMSB of BCDE
4012+ 36BE 23                   inc     HL
4013+ 36BF 7E                   ld      A,(HL)          ; Get MSB of FPREG
4014+ 36C0 89                   adc     A,C             ; Add MSB of BCDE
4015+ 36C1 4F                   ld      C,A             ; Save MSB of BCDE
4016+ 36C2 C9                   ret
4017+ 36C3
4018+ 36C3 21 5E 82     COMPL:  ld      HL,SGNRES       ; Sign of result
4019+ 36C6 7E                   ld      A,(HL)          ; Get sign of result
4020+ 36C7 2F                   cpl                     ; Negate it
4021+ 36C8 77                   ld      (HL),A          ; Put it back
4022+ 36C9 AF                   xor     A
4023+ 36CA 6F                   ld      L,A             ; Set L to zero
4024+ 36CB 90                   sub     B               ; Negate exponent,set carry
4025+ 36CC 47                   ld      B,A             ; Re-save exponent
4026+ 36CD 7D                   ld      A,L             ; Load zero
4027+ 36CE 9B                   sbc     A,E             ; Negate LSB
4028+ 36CF 5F                   ld      E,A             ; Re-save LSB
4029+ 36D0 7D                   ld      A,L             ; Load zero
4030+ 36D1 9A                   sbc     A,D             ; Negate NMSB
4031+ 36D2 57                   ld      D,A             ; Re-save NMSB
4032+ 36D3 7D                   ld      A,L             ; Load zero
4033+ 36D4 99                   sbc     A,C             ; Negate MSB
4034+ 36D5 4F                   ld      C,A             ; Re-save MSB
4035+ 36D6 C9                   ret
4036+ 36D7
4037+ 36D7 06 00        SCALE:  ld      B,$00           ; Clear underflow
4038+ 36D9 D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
4039+ 36DB DA E6 36             jp      C,SHRITE        ; No - Shift right A bits
4040+ 36DE 43                   ld      B,E             ; <- Shift
4041+ 36DF 5A                   ld      E,D             ; <- right
4042+ 36E0 51                   ld      D,C             ; <- eight
4043+ 36E1 0E 00                ld      C,$00           ; <- bits
4044+ 36E3 C3 D9 36             jp      SCALLP          ; More bits to shift
4045+ 36E6
4046+ 36E6 C6 09        SHRITE: add     A,8+1           ; Adjust count
4047+ 36E8 6F                   ld      L,A             ; Save bits to shift
4048+ 36E9 AF           SHRLP:  xor     A               ; Flag for all done
4049+ 36EA 2D                   dec     L               ; All shifting done?
4050+ 36EB C8                   ret     Z               ; Yes - Return
4051+ 36EC 79                   ld      A,C             ; Get MSB
4052+ 36ED 1F           SHRT1:  rra                     ; Shift it right
4053+ 36EE 4F                   ld      C,A             ; Re-save
4054+ 36EF 7A                   ld      A,D             ; Get NMSB
4055+ 36F0 1F                   rra                     ; Shift right with last bit
4056+ 36F1 57                   ld      D,A             ; Re-save it
4057+ 36F2 7B                   ld      A,E             ; Get LSB
4058+ 36F3 1F                   rra                     ; Shift right with last bit
4059+ 36F4 5F                   ld      E,A             ; Re-save it
4060+ 36F5 78                   ld      A,B             ; Get underflow
4061+ 36F6 1F                   rra                     ; Shift right with last bit
4062+ 36F7 47                   ld      B,A             ; Re-save underflow
4063+ 36F8 C3 E9 36             jp      SHRLP           ; More bits to do
4064+ 36FB
4065+ 36FB 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
4066+ 36FF
4067+ 36FF 03           LOGTAB: defb    $03             ; Table used by LOG
4068+ 3700 AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4069+ 3704 F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4070+ 3708 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4071+ 370C
4072+ 370C CD A9 38     LOG:    call    TSTSGN          ; Test sign of value
4073+ 370F B7                   or      A
4074+ 3710 EA D6 26             jp      PE,FCERR        ; ?FC Error if <= zero
4075+ 3713 21 5D 82             ld      HL,FPEXP        ; Point to exponent
4076+ 3716 7E                   ld      A,(HL)          ; Get exponent
4077+ 3717 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4078+ 371A 11 F3 04             ld      DE,$04F3
4079+ 371D 90                   sub     B               ; Scale value to be < 1
4080+ 371E F5                   push    AF              ; Save scale factor
4081+ 371F 70                   ld      (HL),B          ; Save new exponent
4082+ 3720 D5                   push    DE              ; Save SQR(1/2)
4083+ 3721 C5                   push    BC
4084+ 3722 CD 12 36             call    FPADD           ; Add SQR(1/2) to value
4085+ 3725 C1                   pop     BC              ; Restore SQR(1/2)
4086+ 3726 D1                   pop     DE
4087+ 3727 04                   inc     B               ; Make it SQR(2)
4088+ 3728 CD FF 37             call    DVBCDE          ; Divide by SQR(2)
4089+ 372B 21 FB 36             ld      HL,UNITY        ; Point to 1.
4090+ 372E CD 09 36             call    SUBPHL          ; Subtract FPREG from 1
4091+ 3731 21 FF 36             ld      HL,LOGTAB       ; Coefficient table
4092+ 3734 CD F1 3B             call    SUMSER          ; Evaluate sum of series
4093+ 3737 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4094+ 373A 11 00 00             ld      DE,$0000
4095+ 373D CD 12 36             call    FPADD           ; Subtract 0.5 from FPREG
4096+ 3740 F1                   pop     AF              ; Restore scale factor
4097+ 3741 CD 24 3A             call    RSCALE          ; Re-scale number
4098+ 3744 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4099+ 3747 11 18 72             ld      DE,$7218
4100+ 374A 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4101+ 374B
4102+ 374B C1           MULT:   pop     BC              ; Get number from stack
4103+ 374C D1                   pop     DE
4104+ 374D CD A9 38     FPMULT: call    TSTSGN          ; Test sign of FPREG
4105+ 3750 C8                   ret     Z               ; Return zero if zero
4106+ 3751 2E 00                ld      L,$00           ; Flag add exponents
4107+ 3753 CD 67 38             call    ADDEXP          ; Add exponents
4108+ 3756 79                   ld      A,C             ; Get MSB of multiplier
4109+ 3757 32 6C 82             ld      (MULVAL),A      ; Save MSB of multiplier
4110+ 375A EB                   ex      DE,HL
4111+ 375B 22 6D 82             ld      (MULVAL+1),HL   ; Save rest of multiplier
4112+ 375E 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4113+ 3761 50                   ld      D,B
4114+ 3762 58                   ld      E,B
4115+ 3763 21 63 36             ld      HL,BNORM        ; Address of normalise
4116+ 3766 E5                   push    HL              ; Save for return
4117+ 3767 21 6F 37             ld      HL,MULT8        ; Address of 8 bit multiply
4118+ 376A E5                   push    HL              ; Save for NMSB,MSB
4119+ 376B E5                   push    HL              ;
4120+ 376C 21 5A 82             ld      HL,FPREG        ; Point to number
4121+ 376F 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4122+ 3770 23                   inc     HL              ; Point to NMSB
4123+ 3771 B7                   or      A               ; Test LSB
4124+ 3772 CA 9B 37             jp      Z,BYTSFT        ; Zero - shift to next byte
4125+ 3775 E5                   push    HL              ; Save address of number
4126+ 3776 2E 08                ld      L,$08           ; 8 bits to multiply by
4127+ 3778 1F           MUL8LP: rra                     ; Shift LSB right
4128+ 3779 67                   ld      H,A             ; Save LSB
4129+ 377A 79                   ld      A,C             ; Get MSB
4130+ 377B D2 89 37             jp      NC,NOMADD       ; Bit was zero - Don't add
4131+ 377E E5                   push    HL              ; Save LSB and count
4132+ 377F 2A 6D 82             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4133+ 3782 19                   add     HL,DE           ; Add NMSB and LSB
4134+ 3783 EB                   ex      DE,HL           ; Leave sum in DE
4135+ 3784 E1                   pop     HL              ; Restore MSB and count
4136+ 3785 3A 6C 82             ld      A,(MULVAL)      ; Get MSB of multiplier
4137+ 3788 89                   adc     A,C             ; Add MSB
4138+ 3789 1F           NOMADD: rra                     ; Shift MSB right
4139+ 378A 4F                   ld      C,A             ; Re-save MSB
4140+ 378B 7A                   ld      A,D             ; Get NMSB
4141+ 378C 1F                   rra                     ; Shift NMSB right
4142+ 378D 57                   ld      D,A             ; Re-save NMSB
4143+ 378E 7B                   ld      A,E             ; Get LSB
4144+ 378F 1F                   rra                     ; Shift LSB right
4145+ 3790 5F                   ld      E,A             ; Re-save LSB
4146+ 3791 78                   ld      A,B             ; Get VLSB
4147+ 3792 1F                   rra                     ; Shift VLSB right
4148+ 3793 47                   ld      B,A             ; Re-save VLSB
4149+ 3794 2D                   dec     L               ; Count bits multiplied
4150+ 3795 7C                   ld      A,H             ; Get LSB of multiplier
4151+ 3796 C2 78 37             jp      NZ,MUL8LP       ; More - Do it
4152+ 3799 E1           POPHRT: pop     HL              ; Restore address of number
4153+ 379A C9                   ret
4154+ 379B
4155+ 379B 43           BYTSFT: ld      B,E             ; Shift partial product left
4156+ 379C 5A                   ld      E,D
4157+ 379D 51                   ld      D,C
4158+ 379E 4F                   ld      C,A
4159+ 379F C9                   ret
4160+ 37A0
4161+ 37A0
4162+ 37A0              ; WORKING ââ
4163+ 37A0 C1           DINT:   pop     BC              ; Get number from stack
4164+ 37A1 D1                   pop     DE
4165+ 37A2 CD FF 37             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4166+ 37A5 C3 7C 39             jp      INT             ; return INT(FPREG)
4167+ 37A8
4168+ 37A8
4169+ 37A8              ; A MODULO B - return remainder of the integer division A/B where:
4170+ 37A8              ; A is in stack; B is in FPREG
4171+ 37A8              ; math is:
4172+ 37A8              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4173+ 37A8 CD 7C 39     MOD:    call    INT             ; B=INT(B)
4174+ 37AB CD F5 38             call    BCDEFP          ; copy B (from FPREG) into BCDE
4175+ 37AE ED 53 0A 82          ld      (TMPBFR3),DE    ; store B into...
4176+ 37B2 ED 43 0C 82          ld      (TMPBFR4),BC    ; ...a temp buffer
4177+ 37B6 C1                   pop     BC              ; recover A...
4178+ 37B7 D1                   pop     DE              ; ...from stack
4179+ 37B8 CD EA 38             call    FPBCDE          ; store A into FPREG
4180+ 37BB CD 7C 39             call    INT             ; get integer part: A=INT(A)
4181+ 37BE CD F5 38             call    BCDEFP          ; copy A (from FPREG) into BCDE
4182+ 37C1 ED 53 06 82          ld      (TMPBFR1),DE    ; store A into...
4183+ 37C5 ED 43 08 82          ld      (TMPBFR2),BC    ; ...a temp buffer
4184+ 37C9                                              ; begin calculation
4185+ 37C9 2A 0A 82             ld      HL,(TMPBFR3)    ; move B...
4186+ 37CC 22 5A 82             ld      (FPREG),HL      ; ...from...
4187+ 37CF 2A 0C 82             ld      HL,(TMPBFR4)    ; ...temp buffer...
4188+ 37D2 22 5C 82             ld      (FPREG+2),HL    ; ...into FPREG
4189+ 37D5 CD FF 37             call    DVBCDE          ; compute A/B and store into FPREG
4190+ 37D8 CD 7C 39             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4191+ 37DB ED 5B 0A 82          ld      DE,(TMPBFR3)    ; load B...
4192+ 37DF ED 4B 0C 82          ld      BC,(TMPBFR4)    ; ...into BCDE
4193+ 37E3 CD 4D 37             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4194+ 37E6 ED 5B 06 82          ld      DE,(TMPBFR1)    ; retrieve A from...
4195+ 37EA ED 4B 08 82          ld      BC,(TMPBFR2)    ; ...temp buffer
4196+ 37EE C3 0F 36             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4197+ 37F1
4198+ 37F1
4199+ 37F1 CD DA 38     DIV10:  call    STAKFP          ; Save FPREG on stack
4200+ 37F4 01 20 84             ld      BC,$8420        ; BCDE = 10.
4201+ 37F7 11 00 00             ld      DE,$0000
4202+ 37FA CD EA 38             call    FPBCDE          ; Move 10 to FPREG
4203+ 37FD
4204+ 37FD C1           DIV:    pop     BC              ; Get number from stack
4205+ 37FE D1                   pop     DE
4206+ 37FF CD A9 38     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4207+ 3802 CA C5 20             jp      Z,DZERR         ; Error if division by zero
4208+ 3805 2E FF                ld      L,-1            ; Flag subtract exponents
4209+ 3807 CD 67 38             call    ADDEXP          ; Subtract exponents
4210+ 380A 34                   inc     (HL)            ; Add 2 to exponent to adjust
4211+ 380B 34                   inc     (HL)
4212+ 380C 2B                   dec     HL              ; Point to MSB
4213+ 380D 7E                   ld      A,(HL)          ; Get MSB of dividend
4214+ 380E 32 73 80             ld      (DIV3),A        ; Save for subtraction
4215+ 3811 2B                   dec     HL
4216+ 3812 7E                   ld      A,(HL)          ; Get NMSB of dividend
4217+ 3813 32 6F 80             ld      (DIV2),A        ; Save for subtraction
4218+ 3816 2B                   dec     HL
4219+ 3817 7E                   ld      A,(HL)          ; Get MSB of dividend
4220+ 3818 32 6B 80             ld      (DIV1),A        ; Save for subtraction
4221+ 381B 41                   ld      B,C             ; Get MSB
4222+ 381C EB                   ex      DE,HL           ; NMSB,LSB to HL
4223+ 381D AF                   xor     A
4224+ 381E 4F                   ld      C,A             ; Clear MSB of quotient
4225+ 381F 57                   ld      D,A             ; Clear NMSB of quotient
4226+ 3820 5F                   ld      E,A             ; Clear LSB of quotient
4227+ 3821 32 76 80             ld      (DIV4),A        ; Clear overflow count
4228+ 3824 E5           DIVLP:  push    HL              ; Save divisor
4229+ 3825 C5                   push    BC
4230+ 3826 7D                   ld      A,L             ; Get LSB of number
4231+ 3827 CD 6A 80             call    DIVSUP          ; Subt' divisor from dividend
4232+ 382A DE 00                sbc     A,$00           ; Count for overflows
4233+ 382C 3F                   ccf
4234+ 382D D2 37 38             jp      NC,RESDIV       ; Restore divisor if borrow
4235+ 3830 32 76 80             ld      (DIV4),A        ; Re-save overflow count
4236+ 3833 F1                   pop     AF              ; Scrap divisor
4237+ 3834 F1                   pop     AF
4238+ 3835 37                   scf                     ; Set carry to
4239+ 3836 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4240+ 3837
4241+ 3837 C1           RESDIV: pop     BC              ; Restore divisor
4242+ 3838 E1                   pop     HL
4243+ 3839 79                   ld      A,C             ; Get MSB of quotient
4244+ 383A 3C                   inc     A
4245+ 383B 3D                   dec     A
4246+ 383C 1F                   rra                     ; Bit 0 to bit 7
4247+ 383D FA 99 36             jp      M,RONDB         ; Done - Normalise result
4248+ 3840 17                   rla                     ; Restore carry
4249+ 3841 7B                   ld      A,E             ; Get LSB of quotient
4250+ 3842 17                   rla                     ; Double it
4251+ 3843 5F                   ld      E,A             ; Put it back
4252+ 3844 7A                   ld      A,D             ; Get NMSB of quotient
4253+ 3845 17                   rla                     ; Double it
4254+ 3846 57                   ld      D,A             ; Put it back
4255+ 3847 79                   ld      A,C             ; Get MSB of quotient
4256+ 3848 17                   rla                     ; Double it
4257+ 3849 4F                   ld      C,A             ; Put it back
4258+ 384A 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4259+ 384B 78                   ld      A,B             ; Get MSB of divisor
4260+ 384C 17                   rla                     ; Double it
4261+ 384D 47                   ld      B,A             ; Put it back
4262+ 384E 3A 76 80             ld      A,(DIV4)        ; Get VLSB of quotient
4263+ 3851 17                   rla                     ; Double it
4264+ 3852 32 76 80             ld      (DIV4),A        ; Put it back
4265+ 3855 79                   ld      A,C             ; Get MSB of quotient
4266+ 3856 B2                   or      D               ; Merge NMSB
4267+ 3857 B3                   or      E               ; Merge LSB
4268+ 3858 C2 24 38             jp      NZ,DIVLP        ; Not done - Keep dividing
4269+ 385B E5                   push    HL              ; Save divisor
4270+ 385C 21 5D 82             ld      HL,FPEXP        ; Point to exponent
4271+ 385F 35                   dec     (HL)            ; Divide by 2
4272+ 3860 E1                   pop     HL              ; Restore divisor
4273+ 3861 C2 24 38             jp      NZ,DIVLP        ; Ok - Keep going
4274+ 3864 C3 D1 20             jp      OVERR           ; Overflow error
4275+ 3867
4276+ 3867
4277+ 3867 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4278+ 3868 B7                   or      A               ; Test it
4279+ 3869 CA 8B 38             jp      Z,OVTST3        ; Zero - Result zero
4280+ 386C 7D                   ld      A,L             ; Get add/subtract flag
4281+ 386D 21 5D 82             ld      HL,FPEXP        ; Point to exponent
4282+ 3870 AE                   xor     (HL)            ; Add or subtract it
4283+ 3871 80                   add     A,B             ; Add the other exponent
4284+ 3872 47                   ld      B,A             ; Save new exponent
4285+ 3873 1F                   rra                     ; Test exponent for overflow
4286+ 3874 A8                   xor     B
4287+ 3875 78                   ld      A,B             ; Get exponent
4288+ 3876 F2 8A 38             jp      P,OVTST2        ; Positive - Test for overflow
4289+ 3879 C6 80                add     A,$80           ; Add excess 128
4290+ 387B 77                   ld      (HL),A          ; Save new exponent
4291+ 387C CA 99 37             jp      Z,POPHRT        ; Zero - Result zero
4292+ 387F CD 0F 39             call    SIGNS           ; Set MSBs and sign of result
4293+ 3882 77                   ld      (HL),A          ; Save new exponent
4294+ 3883 2B                   dec     HL              ; Point to MSB
4295+ 3884 C9                   ret
4296+ 3885
4297+ 3885 CD A9 38     OVTST1: call    TSTSGN          ; Test sign of FPREG
4298+ 3888 2F                   cpl                     ; Invert sign
4299+ 3889 E1                   pop     HL              ; Clean up stack
4300+ 388A B7           OVTST2: or      A               ; Test if new exponent zero
4301+ 388B E1           OVTST3: pop     HL              ; Clear off return address
4302+ 388C F2 78 36             jp      P,RESZER        ; Result zero
4303+ 388F C3 D1 20             jp      OVERR           ; Overflow error
4304+ 3892
4305+ 3892 CD F5 38     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4306+ 3895 78                   ld      A,B             ; Get exponent
4307+ 3896 B7                   or      A               ; Is it zero?
4308+ 3897 C8                   ret     Z               ; Yes - Result is zero
4309+ 3898 C6 02                add     A,$02           ; Multiply by 4
4310+ 389A DA D1 20             jp      C,OVERR         ; Overflow - ?OV Error
4311+ 389D 47                   ld      B,A             ; Re-save exponent
4312+ 389E CD 12 36             call    FPADD           ; Add BCDE to FPREG (Times 5)
4313+ 38A1 21 5D 82             ld      HL,FPEXP        ; Point to exponent
4314+ 38A4 34                   inc     (HL)            ; Double number (Times 10)
4315+ 38A5 C0                   ret     NZ              ; Ok - Return
4316+ 38A6 C3 D1 20             jp      OVERR           ; Overflow error
4317+ 38A9
4318+ 38A9 3A 5D 82     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4319+ 38AC B7                   or      A
4320+ 38AD C8                   ret     Z               ; RETurn if number is zero
4321+ 38AE 3A 5C 82             ld      A,(FPREG+2)     ; Get MSB of FPREG
4322+ 38B1 FE                   defb    0FEH            ; Test sign
4323+ 38B2 2F           RETREL: cpl                     ; Invert sign
4324+ 38B3 17                   rla                     ; Sign bit to carry
4325+ 38B4 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4326+ 38B5 C0                   ret     NZ              ; Return -1 if negative
4327+ 38B6 3C                   inc     A               ; Bump to +1
4328+ 38B7 C9                   ret                     ; Positive - Return +1
4329+ 38B8
4330+ 38B8 CD A9 38     SGN:    call    TSTSGN          ; Test sign of FPREG
4331+ 38BB 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4332+ 38BD 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4333+ 38C0 21 5D 82     RETINT: ld      HL,FPEXP        ; Point to exponent
4334+ 38C3 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4335+ 38C4 70                   ld      (HL),B          ; Save exponent
4336+ 38C5 06 00                ld      B,0             ; CDE = integer to normalise
4337+ 38C7 23                   inc     HL              ; Point to sign of result
4338+ 38C8 36 80                ld      (HL),$80        ; Set sign of result
4339+ 38CA 17                   rla                     ; Carry = sign of integer
4340+ 38CB C3 60 36             jp      CONPOS          ; Set sign of result
4341+ 38CE
4342+ 38CE CD A9 38     ABS_:   call    TSTSGN          ; Test sign of FPREG
4343+ 38D1 F0                   ret     P               ; Return if positive
4344+ 38D2 21 5C 82     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4345+ 38D5 7E                   ld      A,(HL)          ; Get sign of mantissa
4346+ 38D6 EE 80                xor     $80             ; Invert sign of mantissa
4347+ 38D8 77                   ld      (HL),A          ; Re-save sign of mantissa
4348+ 38D9 C9                   ret
4349+ 38DA
4350+ 38DA EB           STAKFP: ex      DE,HL           ; Save code string address
4351+ 38DB 2A 5A 82             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4352+ 38DE E3                   ex      (SP),HL         ; Stack them,get return
4353+ 38DF E5                   push    HL              ; Re-save return
4354+ 38E0 2A 5C 82             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4355+ 38E3 E3                   ex      (SP),HL         ; Stack them,get return
4356+ 38E4 E5                   push    HL              ; Re-save return
4357+ 38E5 EB                   ex      DE,HL           ; Restore code string address
4358+ 38E6 C9                   ret
4359+ 38E7
4360+ 38E7              ; store F.P. number from BCDE into (FPREG)
4361+ 38E7 CD F8 38     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4362+ 38EA EB           FPBCDE: ex      DE,HL           ; Save code string address
4363+ 38EB 22 5A 82             ld      (FPREG),HL      ; Save LSB,NLSB of number
4364+ 38EE 60                   ld      H,B             ; Exponent of number
4365+ 38EF 69                   ld      L,C             ; MSB of number
4366+ 38F0 22 5C 82             ld      (FPREG+2),HL    ; Save MSB and exponent
4367+ 38F3 EB                   ex      DE,HL           ; Restore code string address
4368+ 38F4 C9                   ret
4369+ 38F5
4370+ 38F5              ; load F.P. number from (FPREG) into BCDE
4371+ 38F5 21 5A 82     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4372+ 38F8 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4373+ 38F9 23                   inc     HL
4374+ 38FA 56                   ld      D,(HL)          ; Get NMSB of number
4375+ 38FB 23                   inc     HL
4376+ 38FC 4E                   ld      C,(HL)          ; Get MSB of number
4377+ 38FD 23                   inc     HL
4378+ 38FE 46                   ld      B,(HL)          ; Get exponent of number
4379+ 38FF 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4380+ 3900 C9                   ret
4381+ 3901
4382+ 3901              ; move floating point from (FPREG) into (HL)
4383+ 3901 11 5A 82     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4384+ 3904 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4385+ 3906 1A           DETHLB: ld      A,(DE)          ; Get source
4386+ 3907 77                   ld      (HL),A          ; Save destination
4387+ 3908 13                   inc     DE              ; Next source
4388+ 3909 23                   inc     HL              ; Next destination
4389+ 390A 05                   dec     B               ; Count bytes
4390+ 390B C2 06 39             jp      NZ,DETHLB       ; Loop if more
4391+ 390E C9                   ret
4392+ 390F
4393+ 390F 21 5C 82     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4394+ 3912 7E                   ld      A,(HL)          ; Get MSB
4395+ 3913 07                   rlca                    ; Old sign to carry
4396+ 3914 37                   scf                     ; Set MSBit
4397+ 3915 1F                   rra                     ; Set MSBit of MSB
4398+ 3916 77                   ld      (HL),A          ; Save new MSB
4399+ 3917 3F                   ccf                     ; Complement sign
4400+ 3918 1F                   rra                     ; Old sign to carry
4401+ 3919 23                   inc     HL
4402+ 391A 23                   inc     HL
4403+ 391B 77                   ld      (HL),A          ; Set sign of result
4404+ 391C 79                   ld      A,C             ; Get MSB
4405+ 391D 07                   rlca                    ; Old sign to carry
4406+ 391E 37                   scf                     ; Set MSBit
4407+ 391F 1F                   rra                     ; Set MSBit of MSB
4408+ 3920 4F                   ld      C,A             ; Save MSB
4409+ 3921 1F                   rra
4410+ 3922 AE                   xor     (HL)            ; New sign of result
4411+ 3923 C9                   ret
4412+ 3924
4413+ 3924 78           CMPNUM: ld      A,B             ; Get exponent of number
4414+ 3925 B7                   or      A
4415+ 3926 CA A9 38             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4416+ 3929 21 B2 38             ld      HL,RETREL       ; Return relation routine
4417+ 392C E5                   push    HL              ; Save for return
4418+ 392D CD A9 38             call    TSTSGN          ; Test sign of FPREG
4419+ 3930 79                   ld      A,C             ; Get MSB of number
4420+ 3931 C8                   ret     Z               ; FPREG zero - Number's MSB
4421+ 3932 21 5C 82             ld      HL,FPREG+2      ; MSB of FPREG
4422+ 3935 AE                   xor     (HL)            ; Combine signs
4423+ 3936 79                   ld      A,C             ; Get MSB of number
4424+ 3937 F8                   ret     M               ; Exit if signs different
4425+ 3938 CD 3E 39             call    CMPFP           ; Compare FP numbers
4426+ 393B 1F                   rra                     ; Get carry to sign
4427+ 393C A9                   xor     C               ; Combine with MSB of number
4428+ 393D C9                   ret
4429+ 393E
4430+ 393E 23           CMPFP:  inc     HL              ; Point to exponent
4431+ 393F 78                   ld      A,B             ; Get exponent
4432+ 3940 BE                   cp      (HL)            ; Compare exponents
4433+ 3941 C0                   ret     NZ              ; Different
4434+ 3942 2B                   dec     HL              ; Point to MBS
4435+ 3943 79                   ld      A,C             ; Get MSB
4436+ 3944 BE                   cp      (HL)            ; Compare MSBs
4437+ 3945 C0                   ret     NZ              ; Different
4438+ 3946 2B                   dec     HL              ; Point to NMSB
4439+ 3947 7A                   ld      A,D             ; Get NMSB
4440+ 3948 BE                   cp      (HL)            ; Compare NMSBs
4441+ 3949 C0                   ret     NZ              ; Different
4442+ 394A 2B                   dec     HL              ; Point to LSB
4443+ 394B 7B                   ld      A,E             ; Get LSB
4444+ 394C 96                   sub     (HL)            ; Compare LSBs
4445+ 394D C0                   ret     NZ              ; Different
4446+ 394E E1                   pop     HL              ; Drop RETurn
4447+ 394F E1                   pop     HL              ; Drop another RETurn
4448+ 3950 C9                   ret
4449+ 3951
4450+ 3951 47           FPINT:  ld      B,A             ; <- Move
4451+ 3952 4F                   ld      C,A             ; <- exponent
4452+ 3953 57                   ld      D,A             ; <- to all
4453+ 3954 5F                   ld      E,A             ; <- bits
4454+ 3955 B7                   or      A               ; Test exponent
4455+ 3956 C8                   ret     Z               ; Zero - Return zero
4456+ 3957 E5                   push    HL              ; Save pointer to number
4457+ 3958 CD F5 38             call    BCDEFP          ; Move FPREG to BCDE
4458+ 395B CD 0F 39             call    SIGNS           ; Set MSBs & sign of result
4459+ 395E AE                   xor     (HL)            ; Combine with sign of FPREG
4460+ 395F 67                   ld      H,A             ; Save combined signs
4461+ 3960 FC 75 39             call    M,DCBCDE        ; Negative - Decrement BCDE
4462+ 3963 3E 98                ld      A,$80+24        ; 24 bits
4463+ 3965 90                   sub     B               ; Bits to shift
4464+ 3966 CD D7 36             call    SCALE           ; Shift BCDE
4465+ 3969 7C                   ld      A,H             ; Get combined sign
4466+ 396A 17                   rla                     ; Sign to carry
4467+ 396B DC AA 36             call    C,FPROND        ; Negative - Round number up
4468+ 396E 06 00                ld      B,$00           ; Zero exponent
4469+ 3970 DC C3 36             call    C,COMPL         ; If negative make positive
4470+ 3973 E1                   pop     HL              ; Restore pointer to number
4471+ 3974 C9                   ret
4472+ 3975
4473+ 3975 1B           DCBCDE: dec     DE              ; Decrement BCDE
4474+ 3976 7A                   ld      A,D             ; Test LSBs
4475+ 3977 A3                   and     E
4476+ 3978 3C                   inc     A
4477+ 3979 C0                   ret     NZ              ; Exit if LSBs not FFFF
4478+ 397A 0B                   dec     BC              ; Decrement MSBs
4479+ 397B C9                   ret
4480+ 397C
4481+ 397C 21 5D 82     INT:    ld      HL,FPEXP        ; Point to exponent
4482+ 397F 7E                   ld      A,(HL)          ; Get exponent
4483+ 3980 FE 98                cp      $80+24          ; Integer accuracy only?
4484+ 3982 3A 5A 82             ld      A,(FPREG)       ; Get LSB
4485+ 3985 D0                   ret     NC              ; Yes - Already integer
4486+ 3986 7E                   ld      A,(HL)          ; Get exponent
4487+ 3987 CD 51 39             call    FPINT           ; F.P to integer
4488+ 398A 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4489+ 398C 7B                   ld      A,E             ; Get LSB of number
4490+ 398D F5                   push    AF              ; Save LSB
4491+ 398E 79                   ld      A,C             ; Get MSB of number
4492+ 398F 17                   rla                     ; Sign to carry
4493+ 3990 CD 60 36             call    CONPOS          ; Set sign of result
4494+ 3993 F1                   pop     AF              ; Restore LSB of number
4495+ 3994 C9                   ret
4496+ 3995
4497+ 3995 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4498+ 3998 78                   ld      A,B             ; Test multiplier
4499+ 3999 B1                   or      C
4500+ 399A C8                   ret     Z               ; Return zero if zero
4501+ 399B 3E 10                ld      A,$10           ; 16 bits
4502+ 399D 29           MLDBLP: add     HL,HL           ; Shift P.P left
4503+ 399E DA C3 2D             jp      C,BSERR         ; ?BS Error if overflow
4504+ 39A1 EB                   ex      DE,HL
4505+ 39A2 29                   add     HL,HL           ; Shift multiplier left
4506+ 39A3 EB                   ex      DE,HL
4507+ 39A4 D2 AB 39             jp      NC,NOMLAD       ; Bit was zero - No add
4508+ 39A7 09                   add     HL,BC           ; Add multiplicand
4509+ 39A8 DA C3 2D             jp      C,BSERR         ; ?BS Error if overflow
4510+ 39AB 3D           NOMLAD: dec     A               ; Count bits
4511+ 39AC C2 9D 39             jp      NZ,MLDBLP       ; More
4512+ 39AF C9                   ret
4513+ 39B0
4514+ 39B0 FE 2D        ASCTFP: cp      '-'             ; Negative?
4515+ 39B2 F5                   push    AF              ; Save it and flags
4516+ 39B3 CA BC 39             jp      Z,CNVNUM        ; Yes - Convert number
4517+ 39B6 FE 2B                cp      '+'             ; Positive?
4518+ 39B8 CA BC 39             jp      Z,CNVNUM        ; Yes - Convert number
4519+ 39BB 2B                   dec     HL              ; dec 'cos GETCHR INCs
4520+ 39BC CD 78 36     CNVNUM: call    RESZER          ; Set result to zero
4521+ 39BF 47                   ld      B,A             ; Digits after point counter
4522+ 39C0 57                   ld      D,A             ; Sign of exponent
4523+ 39C1 5F                   ld      E,A             ; Exponent of ten
4524+ 39C2 2F                   cpl
4525+ 39C3 4F                   ld      C,A             ; Before or after point flag
4526+ 39C4 CD 0B 26     MANLP:  call    GETCHR          ; Get next character
4527+ 39C7 DA 0D 3A             jp      C,ADDIG         ; Digit - Add to number
4528+ 39CA FE 2E                cp      '.'
4529+ 39CC CA E8 39             jp      Z,DPOINT        ; '.' - Flag point
4530+ 39CF FE 45                cp      'E'
4531+ 39D1 C2 EC 39             jp      NZ,CONEXP       ; Not 'E' - Scale number
4532+ 39D4 CD 0B 26             call    GETCHR          ; Get next character
4533+ 39D7 CD DF 2B             call    SGNEXP          ; Get sign of exponent
4534+ 39DA CD 0B 26     EXPLP:  call    GETCHR          ; Get next character
4535+ 39DD DA 2F 3A             jp      C,EDIGIT        ; Digit - Add to exponent
4536+ 39E0 14                   inc     D               ; Is sign negative?
4537+ 39E1 C2 EC 39             jp      NZ,CONEXP       ; No - Scale number
4538+ 39E4 AF                   xor     A
4539+ 39E5 93                   sub     E               ; Negate exponent
4540+ 39E6 5F                   ld      E,A             ; And re-save it
4541+ 39E7 0C                   inc     C               ; Flag end of number
4542+ 39E8 0C           DPOINT: inc     C               ; Flag point passed
4543+ 39E9 CA C4 39             jp      Z,MANLP         ; Zero - Get another digit
4544+ 39EC E5           CONEXP: push    HL              ; Save code string address
4545+ 39ED 7B                   ld      A,E             ; Get exponent
4546+ 39EE 90                   sub     B               ; Subtract digits after point
4547+ 39EF F4 05 3A     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4548+ 39F2 F2 FB 39             jp      P,ENDCON        ; Positive - All done
4549+ 39F5 F5                   push    AF              ; Save number of times to /10
4550+ 39F6 CD F1 37             call    DIV10           ; Divide by 10
4551+ 39F9 F1                   pop     AF              ; Restore count
4552+ 39FA 3C                   inc     A               ; Count divides
4553+ 39FB
4554+ 39FB C2 EF 39     ENDCON: jp      NZ,SCALMI       ; More to do
4555+ 39FE D1                   pop     DE              ; Restore code string address
4556+ 39FF F1                   pop     AF              ; Restore sign of number
4557+ 3A00 CC D2 38             call    Z,INVSGN        ; Negative - Negate number
4558+ 3A03 EB                   ex      DE,HL           ; Code string address to HL
4559+ 3A04 C9                   ret
4560+ 3A05
4561+ 3A05 C8           SCALPL: ret     Z               ; Exit if no scaling needed
4562+ 3A06 F5           MULTEN: push    AF              ; Save count
4563+ 3A07 CD 92 38             call    MLSP10          ; Multiply number by 10
4564+ 3A0A F1                   pop     AF              ; Restore count
4565+ 3A0B 3D                   dec     A               ; Count multiplies
4566+ 3A0C C9                   ret
4567+ 3A0D
4568+ 3A0D D5           ADDIG:  push    DE              ; Save sign of exponent
4569+ 3A0E 57                   ld      D,A             ; Save digit
4570+ 3A0F 78                   ld      A,B             ; Get digits after point
4571+ 3A10 89                   adc     A,C             ; Add one if after point
4572+ 3A11 47                   ld      B,A             ; Re-save counter
4573+ 3A12 C5                   push    BC              ; Save point flags
4574+ 3A13 E5                   push    HL              ; Save code string address
4575+ 3A14 D5                   push    DE              ; Save digit
4576+ 3A15 CD 92 38             call    MLSP10          ; Multiply number by 10
4577+ 3A18 F1                   pop     AF              ; Restore digit
4578+ 3A19 D6 30                sub     '0'             ; Make it absolute
4579+ 3A1B CD 24 3A             call    RSCALE          ; Re-scale number
4580+ 3A1E E1                   pop     HL              ; Restore code string address
4581+ 3A1F C1                   pop     BC              ; Restore point flags
4582+ 3A20 D1                   pop     DE              ; Restore sign of exponent
4583+ 3A21 C3 C4 39             jp      MANLP           ; Get another digit
4584+ 3A24
4585+ 3A24 CD DA 38     RSCALE: call    STAKFP          ; Put number on stack
4586+ 3A27 CD BB 38             call    FLGREL          ; Digit to add to FPREG
4587+ 3A2A C1           PADD:   pop     BC              ; Restore number
4588+ 3A2B D1                   pop     DE
4589+ 3A2C C3 12 36             jp      FPADD           ; Add BCDE to FPREG and return
4590+ 3A2F
4591+ 3A2F 7B           EDIGIT: ld      A,E             ; Get digit
4592+ 3A30 07                   rlca                    ; Times 2
4593+ 3A31 07                   rlca                    ; Times 4
4594+ 3A32 83                   add     A,E             ; Times 5
4595+ 3A33 07                   rlca                    ; Times 10
4596+ 3A34 86                   add     A,(HL)          ; Add next digit
4597+ 3A35 D6 30                sub     '0'             ; Make it absolute
4598+ 3A37 5F                   ld      E,A             ; Save new digit
4599+ 3A38 C3 DA 39             jp      EXPLP           ; Look for another digit
4600+ 3A3B
4601+ 3A3B E5           LINEIN: push    HL              ; Save code string address
4602+ 3A3C 21 3B 20             ld      HL,INMSG        ; Output " in "
4603+ 3A3F CD A4 2F             call    PRS             ; Output string at HL
4604+ 3A42 E1                   pop     HL              ; Restore code string address
4605+ 3A43 EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4606+ 3A44 AF                   xor     A
4607+ 3A45 06 98                ld      B,$80+24        ; 24 bits
4608+ 3A47 CD C0 38             call    RETINT          ; Return the integer
4609+ 3A4A 21 A3 2F             ld      HL,PRNUMS       ; Print number string
4610+ 3A4D E5                   push    HL              ; Save for return
4611+ 3A4E              ; conmvert FP number into ASCII chars
4612+ 3A4E 21 5F 82     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4613+ 3A51 E5                   push    HL              ; Save for return
4614+ 3A52 CD A9 38             call    TSTSGN          ; Test sign of FPREG
4615+ 3A55 36 20                ld      (HL),SPC        ; Space at start
4616+ 3A57 F2 5C 3A             jp      P,SPCFST        ; Positive - Space to start
4617+ 3A5A 36 2D                ld      (HL),'-'        ; '-' sign at start
4618+ 3A5C 23           SPCFST: inc     HL              ; First byte of number
4619+ 3A5D 36 30                ld      (HL),'0'        ; '0' if zero
4620+ 3A5F CA 12 3B             jp      Z,JSTZER        ; Return '0' if zero
4621+ 3A62 E5                   push    HL              ; Save buffer address
4622+ 3A63 FC D2 38             call    M,INVSGN        ; Negate FPREG if negative
4623+ 3A66 AF                   xor     A               ; Zero A
4624+ 3A67 F5                   push    AF              ; Save it
4625+ 3A68 CD 18 3B             call    RNGTST          ; Test number is in range
4626+ 3A6B 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4627+ 3A6E 11 F8 4F             ld      DE,$4FF8
4628+ 3A71 CD 24 39             call    CMPNUM          ; Compare numbers
4629+ 3A74 B7                   or      A
4630+ 3A75 E2 89 3A             jp      PO,INRNG        ; > 99999.9 - Sort it out
4631+ 3A78 F1                   pop     AF              ; Restore count
4632+ 3A79 CD 06 3A             call    MULTEN          ; Multiply by ten
4633+ 3A7C F5                   push    AF              ; Re-save count
4634+ 3A7D C3 6B 3A             jp      SIXDIG          ; Test it again
4635+ 3A80
4636+ 3A80 CD F1 37     GTSIXD: call    DIV10           ; Divide by 10
4637+ 3A83 F1                   pop     AF              ; Get count
4638+ 3A84 3C                   inc     A               ; Count divides
4639+ 3A85 F5                   push    AF              ; Re-save count
4640+ 3A86 CD 18 3B             call    RNGTST          ; Test number is in range
4641+ 3A89 CD 00 36     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4642+ 3A8C 3C                   inc     A
4643+ 3A8D CD 51 39             call    FPINT           ; F.P to integer
4644+ 3A90 CD EA 38             call    FPBCDE          ; Move BCDE to FPREG
4645+ 3A93 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4646+ 3A96 F1                   pop     AF              ; Restore count
4647+ 3A97 81                   add     A,C             ; 6 digits before point
4648+ 3A98 3C                   inc     A               ; Add one
4649+ 3A99 FA A5 3A             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4650+ 3A9C FE 08                cp      6+1+1           ; More than 999999 ?
4651+ 3A9E D2 A5 3A             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4652+ 3AA1 3C                   inc     A               ; Adjust for exponent
4653+ 3AA2 47                   ld      B,A             ; Exponent of number
4654+ 3AA3 3E 02                ld      A,2             ; Make it zero after
4655+ 3AA5
4656+ 3AA5 3D           MAKNUM: dec     A               ; Adjust for digits to do
4657+ 3AA6 3D                   dec     A
4658+ 3AA7 E1                   pop     HL              ; Restore buffer address
4659+ 3AA8 F5                   push    AF              ; Save count
4660+ 3AA9 11 2B 3B             ld      DE,POWERS       ; Powers of ten
4661+ 3AAC 05                   dec     B               ; Count digits before point
4662+ 3AAD C2 B6 3A             jp      NZ,DIGTXT       ; Not zero - Do number
4663+ 3AB0 36 2E                ld      (HL),'.'        ; Save point
4664+ 3AB2 23                   inc     HL              ; Move on
4665+ 3AB3 36 30                ld      (HL),'0'        ; Save zero
4666+ 3AB5 23                   inc     HL              ; Move on
4667+ 3AB6 05           DIGTXT: dec     B               ; Count digits before point
4668+ 3AB7 36 2E                ld      (HL),'.'        ; Save point in case
4669+ 3AB9 CC FF 38             call    Z,INCHL         ; Last digit - move on
4670+ 3ABC C5                   push    BC              ; Save digits before point
4671+ 3ABD E5                   push    HL              ; Save buffer address
4672+ 3ABE D5                   push    DE              ; Save powers of ten
4673+ 3ABF CD F5 38             call    BCDEFP          ; Move FPREG to BCDE
4674+ 3AC2 E1                   pop     HL              ; Powers of ten table
4675+ 3AC3 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4676+ 3AC5 04           TRYAGN: inc     B               ; Count subtractions
4677+ 3AC6 7B                   ld      A,E             ; Get LSB
4678+ 3AC7 96                   sub     (HL)            ; Subtract LSB
4679+ 3AC8 5F                   ld      E,A             ; Save LSB
4680+ 3AC9 23                   inc     HL
4681+ 3ACA 7A                   ld      A,D             ; Get NMSB
4682+ 3ACB 9E                   sbc     A,(HL)          ; Subtract NMSB
4683+ 3ACC 57                   ld      D,A             ; Save NMSB
4684+ 3ACD 23                   inc     HL
4685+ 3ACE 79                   ld      A,C             ; Get MSB
4686+ 3ACF 9E                   sbc     A,(HL)          ; Subtract MSB
4687+ 3AD0 4F                   ld      C,A             ; Save MSB
4688+ 3AD1 2B                   dec     HL              ; Point back to start
4689+ 3AD2 2B                   dec     HL
4690+ 3AD3 D2 C5 3A             jp      NC,TRYAGN       ; No overflow - Try again
4691+ 3AD6 CD B7 36             call    PLUCDE          ; Restore number
4692+ 3AD9 23                   inc     HL              ; Start of next number
4693+ 3ADA CD EA 38             call    FPBCDE          ; Move BCDE to FPREG
4694+ 3ADD EB                   ex      DE,HL           ; Save point in table
4695+ 3ADE E1                   pop     HL              ; Restore buffer address
4696+ 3ADF 70                   ld      (HL),B          ; Save digit in buffer
4697+ 3AE0 23                   inc     HL              ; And move on
4698+ 3AE1 C1                   pop     BC              ; Restore digit count
4699+ 3AE2 0D                   dec     C               ; Count digits
4700+ 3AE3 C2 B6 3A             jp      NZ,DIGTXT       ; More - Do them
4701+ 3AE6 05                   dec     B               ; Any decimal part?
4702+ 3AE7 CA F6 3A             jp      Z,DOEBIT        ; No - Do 'E' bit
4703+ 3AEA 2B           SUPTLZ: dec     HL              ; Move back through buffer
4704+ 3AEB 7E                   ld      A,(HL)          ; Get character
4705+ 3AEC FE 30                cp      '0'             ; '0' character?
4706+ 3AEE CA EA 3A             jp      Z,SUPTLZ        ; Yes - Look back for more
4707+ 3AF1 FE 2E                cp      '.'             ; A decimal point?
4708+ 3AF3 C4 FF 38             call    NZ,INCHL        ; Move back over digit
4709+ 3AF6
4710+ 3AF6 F1           DOEBIT: pop     AF              ; Get 'E' flag
4711+ 3AF7 CA 15 3B             jp      Z,NOENED        ; No 'E' needed - End buffer
4712+ 3AFA 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4713+ 3AFC 23                   inc     HL              ; And move on
4714+ 3AFD 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4715+ 3AFF F2 06 3B             jp      P,OUTEXP        ; Positive - Output exponent
4716+ 3B02 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4717+ 3B04 2F                   cpl                     ; Negate exponent
4718+ 3B05 3C                   inc     A
4719+ 3B06 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4720+ 3B08 04           EXPTEN: inc     B               ; Count subtractions
4721+ 3B09 D6 0A                sub     $0A             ; Tens digit
4722+ 3B0B D2 08 3B             jp      NC,EXPTEN       ; More to do
4723+ 3B0E C6 3A                add     A,'0'+10        ; Restore and make ASCII
4724+ 3B10 23                   inc     HL              ; Move on
4725+ 3B11 70                   ld      (HL),B          ; Save MSB of exponent
4726+ 3B12 23           JSTZER: inc     HL              ;
4727+ 3B13 77                   ld      (HL),A          ; Save LSB of exponent
4728+ 3B14 23                   inc     HL
4729+ 3B15 71           NOENED: ld      (HL),C          ; Mark end of buffer
4730+ 3B16 E1                   pop     HL              ; Restore code string address
4731+ 3B17 C9                   ret
4732+ 3B18
4733+ 3B18 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4734+ 3B1B 11 F7 23             ld      DE,$23F7
4735+ 3B1E CD 24 39             call    CMPNUM          ; Compare numbers
4736+ 3B21 B7                   or      A
4737+ 3B22 E1                   pop     HL              ; Return address to HL
4738+ 3B23 E2 80 3A             jp      PO,GTSIXD       ; Too big - Divide by ten
4739+ 3B26 E9                   jp      (HL)            ; Otherwise return to caller
4740+ 3B27
4741+ 3B27 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4742+ 3B2B
4743+ 3B2B A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4744+ 3B2E 10 27 00             defb    $10,$27,$00  ;  10000
4745+ 3B31 E8 03 00             defb    $E8,$03,$00  ;   1000
4746+ 3B34 64 00 00             defb    $64,$00,$00  ;    100
4747+ 3B37 0A 00 00             defb    $0A,$00,$00  ;     10
4748+ 3B3A 01 00 00             defb    $01,$00,$00  ;      1
4749+ 3B3D
4750+ 3B3D 21 D2 38     NEGAFT: ld      HL,INVSGN       ; Negate result
4751+ 3B40 E3                   ex      (SP),HL         ; To be done after caller
4752+ 3B41 E9                   jp      (HL)            ; Return to caller
4753+ 3B42
4754+ 3B42 CD DA 38     SQR:    call    STAKFP          ; Put value on stack
4755+ 3B45 21 27 3B             ld      HL,HALF         ; Set power to 1/2
4756+ 3B48 CD E7 38             call    PHLTFP          ; Move 1/2 to FPREG
4757+ 3B4B
4758+ 3B4B C1           POWER:  pop     BC              ; Get base
4759+ 3B4C D1                   pop     DE
4760+ 3B4D CD A9 38             call    TSTSGN          ; Test sign of power
4761+ 3B50 78                   ld      A,B             ; Get exponent of base
4762+ 3B51 CA 90 3B             jp      Z,EXP           ; Make result 1 if zero
4763+ 3B54 F2 5B 3B             jp      P,POWER1        ; Positive base - Ok
4764+ 3B57 B7                   or      A               ; Zero to negative power?
4765+ 3B58 CA C5 20             jp      Z,DZERR         ; Yes - ?/0 Error
4766+ 3B5B B7           POWER1: or      A               ; Base zero?
4767+ 3B5C CA 79 36             jp      Z,SAVEXP        ; Yes - Return zero
4768+ 3B5F D5                   push    DE              ; Save base
4769+ 3B60 C5                   push    BC
4770+ 3B61 79                   ld      A,C             ; Get MSB of base
4771+ 3B62 F6 7F                or      %01111111       ; Get sign status
4772+ 3B64 CD F5 38             call    BCDEFP          ; Move power to BCDE
4773+ 3B67 F2 78 3B             jp      P,POWER2        ; Positive base - Ok
4774+ 3B6A D5                   push    DE              ; Save power
4775+ 3B6B C5                   push    BC
4776+ 3B6C CD 7C 39             call    INT             ; Get integer of power
4777+ 3B6F C1                   pop     BC              ; Restore power
4778+ 3B70 D1                   pop     DE
4779+ 3B71 F5                   push    AF              ; MSB of base
4780+ 3B72 CD 24 39             call    CMPNUM          ; Power an integer?
4781+ 3B75 E1                   pop     HL              ; Restore MSB of base
4782+ 3B76 7C                   ld      A,H             ; but don't affect flags
4783+ 3B77 1F                   rra                     ; Exponent odd or even?
4784+ 3B78 E1           POWER2: pop     HL              ; Restore MSB and exponent
4785+ 3B79 22 5C 82             ld      (FPREG+2),HL    ; Save base in FPREG
4786+ 3B7C E1                   pop     HL              ; LSBs of base
4787+ 3B7D 22 5A 82             ld      (FPREG),HL      ; Save in FPREG
4788+ 3B80 DC 3D 3B             call    C,NEGAFT        ; Odd power - Negate result
4789+ 3B83 CC D2 38             call    Z,INVSGN        ; Negative base - Negate it
4790+ 3B86 D5                   push    DE              ; Save power
4791+ 3B87 C5                   push    BC
4792+ 3B88 CD 0C 37             call    LOG             ; Get LOG of base
4793+ 3B8B C1                   pop     BC              ; Restore power
4794+ 3B8C D1                   pop     DE
4795+ 3B8D CD 4D 37             call    FPMULT          ; Multiply LOG by power
4796+ 3B90
4797+ 3B90 CD DA 38     EXP:    call    STAKFP          ; Put value on stack
4798+ 3B93 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4799+ 3B96 11 3B AA             ld      DE,$AA3B
4800+ 3B99 CD 4D 37             call    FPMULT          ; Multiply value by 1/LN(2)
4801+ 3B9C 3A 5D 82             ld      A,(FPEXP)       ; Get exponent
4802+ 3B9F FE 88                cp      $80+8           ; Is it in range?
4803+ 3BA1 D2 85 38             jp      NC,OVTST1       ; No - Test for overflow
4804+ 3BA4 CD 7C 39             call    INT             ; Get INT of FPREG
4805+ 3BA7 C6 80                add     A,$80           ; For excess 128
4806+ 3BA9 C6 02                add     A,$02           ; Exponent > 126?
4807+ 3BAB DA 85 38             jp      C,OVTST1        ; Yes - Test for overflow
4808+ 3BAE F5                   push    AF              ; Save scaling factor
4809+ 3BAF 21 FB 36             ld      HL,UNITY        ; Point to 1.
4810+ 3BB2 CD 03 36             call    ADDPHL          ; Add 1 to FPREG
4811+ 3BB5 CD 44 37             call    MULLN2          ; Multiply by LN(2)
4812+ 3BB8 F1                   pop     AF              ; Restore scaling factor
4813+ 3BB9 C1                   pop     BC              ; Restore exponent
4814+ 3BBA D1                   pop     DE
4815+ 3BBB F5                   push    AF              ; Save scaling factor
4816+ 3BBC CD 0F 36             call    SUBCDE          ; Subtract exponent from FPREG
4817+ 3BBF CD D2 38             call    INVSGN          ; Negate result
4818+ 3BC2 21 D0 3B             ld      HL,EXPTAB       ; Coefficient table
4819+ 3BC5 CD 00 3C             call    SMSER1          ; Sum the series
4820+ 3BC8 11 00 00             ld      DE,$0000        ; Zero LSBs
4821+ 3BCB C1                   pop     BC              ; Scaling factor
4822+ 3BCC 4A                   ld      C,D             ; Zero MSB
4823+ 3BCD C3 4D 37             jp      FPMULT          ; Scale result to correct value
4824+ 3BD0
4825+ 3BD0 08           EXPTAB: defb    $08             ; Table used by EXP
4826+ 3BD1 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4827+ 3BD5 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4828+ 3BD9 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4829+ 3BDD E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4830+ 3BE1 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4831+ 3BE5 FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4832+ 3BE9 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4833+ 3BED 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4834+ 3BF1
4835+ 3BF1 CD DA 38     SUMSER: call    STAKFP          ; Put FPREG on stack
4836+ 3BF4 11 4B 37             ld      DE,MULT         ; Multiply by "X"
4837+ 3BF7 D5                   push    DE              ; To be done after
4838+ 3BF8 E5                   push    HL              ; Save address of table
4839+ 3BF9 CD F5 38             call    BCDEFP          ; Move FPREG to BCDE
4840+ 3BFC CD 4D 37             call    FPMULT          ; Square the value
4841+ 3BFF E1                   pop     HL              ; Restore address of table
4842+ 3C00 CD DA 38     SMSER1: call    STAKFP          ; Put value on stack
4843+ 3C03 7E                   ld      A,(HL)          ; Get number of coefficients
4844+ 3C04 23                   inc     HL              ; Point to start of table
4845+ 3C05 CD E7 38             call    PHLTFP          ; Move coefficient to FPREG
4846+ 3C08 06                   defb    06H             ; Skip "pop AF"
4847+ 3C09 F1           SUMLP:  pop     AF              ; Restore count
4848+ 3C0A C1                   pop     BC              ; Restore number
4849+ 3C0B D1                   pop     DE
4850+ 3C0C 3D                   dec     A               ; Cont coefficients
4851+ 3C0D C8                   ret     Z               ; All done
4852+ 3C0E D5                   push    DE              ; Save number
4853+ 3C0F C5                   push    BC
4854+ 3C10 F5                   push    AF              ; Save count
4855+ 3C11 E5                   push    HL              ; Save address in table
4856+ 3C12 CD 4D 37             call    FPMULT          ; Multiply FPREG by BCDE
4857+ 3C15 E1                   pop     HL              ; Restore address in table
4858+ 3C16 CD F8 38             call    LOADFP          ; Number at HL to BCDE
4859+ 3C19 E5                   push    HL              ; Save address in table
4860+ 3C1A CD 12 36             call    FPADD           ; Add coefficient to FPREG
4861+ 3C1D E1                   pop     HL              ; Restore address in table
4862+ 3C1E C3 09 3C             jp      SUMLP           ; More coefficients
4863+ 3C21
4864+ 3C21
4865+ 3C21              ; random number generator
4866+ 3C21              ; a negative argument is used as a seed for the RNG
4867+ 3C21              ; 0 is used to repeat the last random number
4868+ 3C21              ; a positive argument generates a new random number
4869+ 3C21 CD A9 38     RND:    call    TSTSGN          ; Test sign of FPREG
4870+ 3C24 21 7A 80             ld      HL,SEED+2       ; Random number seed
4871+ 3C27 FA 82 3C             jp      M,RESEED        ; Negative - Re-seed
4872+ 3C2A 21 9B 80             ld      HL,LSTRND       ; Last random number
4873+ 3C2D CD E7 38             call    PHLTFP          ; Move last RND to FPREG
4874+ 3C30 21 7A 80             ld      HL,SEED+2       ; Random number seed
4875+ 3C33 C8                   ret     Z               ; Return if RND(0)
4876+ 3C34 86                   add     A,(HL)          ; Add (SEED+2)
4877+ 3C35 E6 07                and     %00000111       ; 0 to 7
4878+ 3C37 06 00                ld      B,$00
4879+ 3C39 77                   ld      (HL),A          ; Re-save seed
4880+ 3C3A 23                   inc     HL              ; Move to coefficient table
4881+ 3C3B 87                   add     A,A             ; 4 bytes
4882+ 3C3C 87                   add     A,A             ; per entry
4883+ 3C3D 4F                   ld      C,A             ; BC = Offset into table
4884+ 3C3E 09                   add     HL,BC           ; Point to coefficient
4885+ 3C3F CD F8 38             call    LOADFP          ; Coefficient to BCDE
4886+ 3C42 CD 4D 37             call    FPMULT          ; Multiply FPREG by coefficient
4887+ 3C45 3A 79 80             ld      A,(SEED+1)      ; Get (SEED+1)
4888+ 3C48 3C                   inc     A               ; Add 1
4889+ 3C49 E6 03                and     %00000011       ; 0 to 3
4890+ 3C4B 06 00                ld      B,$00
4891+ 3C4D FE 01                cp      $01             ; Is it zero?
4892+ 3C4F 88                   adc     A,B             ; Yes - Make it 1
4893+ 3C50 32 79 80             ld      (SEED+1),A      ; Re-save seed
4894+ 3C53 21 86 3C             ld      HL,RNDTAB-4     ; Addition table
4895+ 3C56 87                   add     A,A             ; 4 bytes
4896+ 3C57 87                   add     A,A             ; per entry
4897+ 3C58 4F                   ld      C,A             ; BC = Offset into table
4898+ 3C59 09                   add     HL,BC           ; Point to value
4899+ 3C5A CD 03 36             call    ADDPHL          ; Add value to FPREG
4900+ 3C5D CD F5 38     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4901+ 3C60 7B                   ld      A,E             ; Get LSB
4902+ 3C61 59                   ld      E,C             ; LSB = MSB
4903+ 3C62 EE 4F                xor     %01001111       ; Fiddle around
4904+ 3C64 4F                   ld      C,A             ; New MSB
4905+ 3C65 36 80                ld      (HL),$80        ; Set exponent
4906+ 3C67 2B                   dec     HL              ; Point to MSB
4907+ 3C68 46                   ld      B,(HL)          ; Get MSB
4908+ 3C69 36 80                ld      (HL),$80        ; Make value -0.5
4909+ 3C6B 21 78 80             ld      HL,SEED         ; Random number seed
4910+ 3C6E 34                   inc     (HL)            ; Count seed
4911+ 3C6F 7E                   ld      A,(HL)          ; Get seed
4912+ 3C70 D6 AB                sub     $AB             ; Do it modulo 171
4913+ 3C72 C2 79 3C             jp      NZ,RND2         ; Non-zero - Ok
4914+ 3C75 77                   ld      (HL),A          ; Zero seed
4915+ 3C76 0C                   inc     C               ; Fillde about
4916+ 3C77 15                   dec     D               ; with the
4917+ 3C78 1C                   inc     E               ; number
4918+ 3C79 CD 63 36     RND2:   call    BNORM           ; Normalise number
4919+ 3C7C 21 9B 80             ld      HL,LSTRND       ; Save random number
4920+ 3C7F C3 01 39             jp      FPTHL           ; Move FPREG to last and return
4921+ 3C82
4922+ 3C82 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4923+ 3C83 2B                   dec     HL
4924+ 3C84 77                   ld      (HL),A
4925+ 3C85 2B                   dec     HL
4926+ 3C86 77                   ld      (HL),A
4927+ 3C87 C3 5D 3C             jp      RND1            ; Return RND seed
4928+ 3C8A
4929+ 3C8A 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4930+ 3C8E 99 E9 92 69          defb    $99,$E9,$92,$69
4931+ 3C92 10 D1 75 68          defb    $10,$D1,$75,$68
4932+ 3C96
4933+ 3C96              ; COS and SIN functions
4934+ 3C96 21 E0 3C     COS:    ld      HL,HALFPI       ; Point to PI/2
4935+ 3C99 CD 03 36             call    ADDPHL          ; Add it to PPREG
4936+ 3C9C CD DA 38     SIN:    call    STAKFP          ; Put angle on stack
4937+ 3C9F 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4938+ 3CA2 11 DB 0F             ld      DE,$0FDB
4939+ 3CA5 CD EA 38             call    FPBCDE          ; Move 2 PI to FPREG
4940+ 3CA8 C1                   pop     BC              ; Restore angle
4941+ 3CA9 D1                   pop     DE
4942+ 3CAA CD FF 37             call    DVBCDE          ; Divide angle by 2 PI
4943+ 3CAD CD DA 38             call    STAKFP          ; Put it on stack
4944+ 3CB0 CD 7C 39             call    INT             ; Get INT of result
4945+ 3CB3 C1                   pop     BC              ; Restore number
4946+ 3CB4 D1                   pop     DE
4947+ 3CB5 CD 0F 36             call    SUBCDE          ; Make it 0 <= value < 1
4948+ 3CB8 21 E4 3C             ld      HL,QUARTR       ; Point to 0.25
4949+ 3CBB CD 09 36             call    SUBPHL          ; Subtract value from 0.25
4950+ 3CBE CD A9 38             call    TSTSGN          ; Test sign of value
4951+ 3CC1 37                   scf                     ; Flag positive
4952+ 3CC2 F2 CC 3C             jp      P,SIN1          ; Positive - Ok
4953+ 3CC5 CD 00 36             call    ROUND           ; Add 0.5 to value
4954+ 3CC8 CD A9 38             call    TSTSGN          ; Test sign of value
4955+ 3CCB B7                   or      A               ; Flag negative
4956+ 3CCC F5           SIN1:   push    AF              ; Save sign
4957+ 3CCD F4 D2 38             call    P,INVSGN        ; Negate value if positive
4958+ 3CD0 21 E4 3C             ld      HL,QUARTR       ; Point to 0.25
4959+ 3CD3 CD 03 36             call    ADDPHL          ; Add 0.25 to value
4960+ 3CD6 F1                   pop     AF              ; Restore sign
4961+ 3CD7 D4 D2 38             call    NC,INVSGN       ; Negative - Make positive
4962+ 3CDA 21 E8 3C             ld      HL,SINTAB       ; Coefficient table
4963+ 3CDD C3 F1 3B             jp      SUMSER          ; Evaluate sum of series
4964+ 3CE0
4965+ 3CE0 DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4966+ 3CE4
4967+ 3CE4 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4968+ 3CE8
4969+ 3CE8 05           SINTAB: defb    $05             ; Table used by SIN
4970+ 3CE9 BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4971+ 3CED 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4972+ 3CF1 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4973+ 3CF5 E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4974+ 3CF9 DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4975+ 3CFD
4976+ 3CFD CD DA 38     TAN:    call    STAKFP          ; Put angle on stack
4977+ 3D00 CD 9C 3C             call    SIN             ; Get SIN of angle
4978+ 3D03 C1                   pop     BC              ; Restore angle
4979+ 3D04 E1                   pop     HL
4980+ 3D05 CD DA 38             call    STAKFP          ; Save SIN of angle
4981+ 3D08 EB                   ex      DE,HL           ; BCDE = Angle
4982+ 3D09 CD EA 38             call    FPBCDE          ; Angle to FPREG
4983+ 3D0C CD 96 3C             call    COS             ; Get COS of angle
4984+ 3D0F C3 FD 37             jp      DIV             ; TAN = SIN / COS
4985+ 3D12
4986+ 3D12 CD A9 38     ATN:    call    TSTSGN          ; Test sign of value
4987+ 3D15 FC 3D 3B             call    M,NEGAFT        ; Negate result after if -ve
4988+ 3D18 FC D2 38             call    M,INVSGN        ; Negate value if -ve
4989+ 3D1B 3A 5D 82             ld      A,(FPEXP)       ; Get exponent
4990+ 3D1E FE 81                cp      81H             ; Number less than 1?
4991+ 3D20 DA 2F 3D             jp      C,ATN1          ; Yes - Get arc tangnt
4992+ 3D23 01 00 81             ld      BC,$8100        ; BCDE = 1
4993+ 3D26 51                   ld      D,C
4994+ 3D27 59                   ld      E,C
4995+ 3D28 CD FF 37             call    DVBCDE          ; Get reciprocal of number
4996+ 3D2B 21 09 36             ld      HL,SUBPHL       ; Sub angle from PI/2
4997+ 3D2E E5                   push    HL              ; Save for angle > 1
4998+ 3D2F 21 39 3D     ATN1:   ld      HL,ATNTAB       ; Coefficient table
4999+ 3D32 CD F1 3B             call    SUMSER          ; Evaluate sum of series
5000+ 3D35 21 E0 3C             ld      HL,HALFPI       ; PI/2 - angle in case > 1
5001+ 3D38 C9                   ret                     ; Number > 1 - Sub from PI/2
5002+ 3D39
5003+ 3D39 09           ATNTAB: defb    $09             ; Table used by ATN
5004+ 3D3A 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
5005+ 3D3E 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
5006+ 3D42 FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
5007+ 3D46 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
5008+ 3D4A 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
5009+ 3D4E C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
5010+ 3D52 E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
5011+ 3D56 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
5012+ 3D5A 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
5013+ 3D5E
5014+ 3D5E
5015+ 3D5E C9           ARET:   ret                     ; A RETurn instruction
5016+ 3D5F
5017+ 3D5F D7           GETINP: rst     $10             ; input a character
5018+ 3D60 C9                   ret
5019+ 3D61
5020+ 3D61 E5           CLS:    push    HL
5021+ 3D62 D5                   push    DE
5022+ 3D63 3A F8 81             ld      A,(SCR_MODE)    ; check screen mode
5023+ 3D66 FE 02                cp      $02             ; G2 mode?
5024+ 3D68 CC F5 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
5025+ 3D6B D1                   pop     DE
5026+ 3D6C E1                   pop     HL
5027+ 3D6D 3E 0C                ld      A,CS            ; ASCII Clear screen
5028+ 3D6F CD 00 24             call    SND2VID         ; send to screen
5029+ 3D72 C3 1F 4D             jp      MONOUT          ; Output character
5030+ 3D75
5031+ 3D75 CD 22 33     WIDTH:  call    GETINT          ; Get integer 0-255
5032+ 3D78 7B                   ld      A,E             ; Width to A
5033+ 3D79 32 A2 80             ld      (LWIDTH),A      ; Set width
5034+ 3D7C C9                   ret
5035+ 3D7D
5036+ 3D7D
5037+ 3D7D              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
5038+ 3D7D              ; i.e., the first location is the LSB, while the second one is the MSB
5039+ 3D7D CD C1 26     DEEK:   call    DEINT           ; Get integer -32768 to 32767
5040+ 3D80 D5                   push    DE              ; Save number
5041+ 3D81 E1                   pop     HL              ; Number to HL
5042+ 3D82 46           RECWRD: ld      B,(HL)          ; Get LSB of contents
5043+ 3D83 23                   inc     HL
5044+ 3D84 7E                   ld      A,(HL)          ; Get MSB of contents
5045+ 3D85 C3 86 2E             jp      ABPASS          ; Return integer AB
5046+ 3D88
5047+ 3D88              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
5048+ 3D88              ; i.e., the LSB will go into the first location, while the MSB into the second one
5049+ 3D88 CD 9C 2A     DOKE:   call    GETNUM          ; Get a number
5050+ 3D8B CD C1 26             call    DEINT           ; Get integer -32768 to 32767
5051+ 3D8E D5                   push    DE              ; Save address
5052+ 3D8F CD C2 23             call    CHKSYN          ; Make sure ',' follows
5053+ 3D92 2C                   defb    ','
5054+ 3D93 CD 9C 2A             call    GETNUM          ; Get a number
5055+ 3D96 CD C1 26             call    DEINT           ; Get integer -32768 to 32767
5056+ 3D99 E3                   ex      (SP),HL         ; Save value,get address
5057+ 3D9A 73                   ld      (HL),E          ; Save LSB of value
5058+ 3D9B 23                   inc     HL
5059+ 3D9C 72                   ld      (HL),D          ; Save MSB of value
5060+ 3D9D E1                   pop     HL              ; Restore code string address
5061+ 3D9E C9                   ret
5062+ 3D9F
5063+ 3D9F              ; stop the execution of code for a certain bit of time. The pause
5064+ 3D9F              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
5065+ 3D9F CD 9C 2A     PAUSE:  call    GETNUM          ; Get a number
5066+ 3DA2 CD C1 26             call    DEINT           ; Get integer -32768 to 32767
5067+ 3DA5 7A                   ld      A,D             ; load D into A
5068+ 3DA6 B3                   or      E               ; are D & E equal to $00?
5069+ 3DA7 C8                   ret     Z               ; if yes, then return
5070+ 3DA8 C5           DIR_PAU:push    BC              ; store BC
5071+ 3DA9 3A E6 81             ld      A,(TMRCNT)      ; Load current value of system timer
5072+ 3DAC 47                   ld      B,A             ; move it into B
5073+ 3DAD CD 36 26     RPTPS:  call    TSTBRK          ; Test for break key
5074+ 3DB0 3A E6 81             ld      A,(TMRCNT)      ; Load current value of system timer
5075+ 3DB3 B8                   cp      B               ; is it the same value?
5076+ 3DB4 28 F7                jr      Z,RPTPS         ; yes, so read again
5077+ 3DB6 47                   ld      B,A             ; no, so store the new value
5078+ 3DB7 1B                   dec     DE              ; decrement interval
5079+ 3DB8 7A                   ld      A,D             ; load D into A
5080+ 3DB9 B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5081+ 3DBA 20 F1                jr      NZ,RPTPS        ; no, repeat
5082+ 3DBC C1                   pop     BC              ; yes, recover BC and continue
5083+ 3DBD C9                   ret
5084+ 3DBE
5085+ 3DBE              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5086+ 3DBE              ; where X is graphic mode:
5087+ 3DBE              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5088+ 3DBE              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5089+ 3DBE              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5090+ 3DBE              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5091+ 3DBE              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5092+ 3DBE AF           SCREEN: xor     A
5093+ 3DBF 32 08 82             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5094+ 3DC2 CD 22 33             call    GETINT          ; Get integer 0-255
5095+ 3DC5 FE 05                cp      $05             ; is it a valid mode (0~4)?
5096+ 3DC7 D2 D6 26             jp      NC,FCERR        ; No - Illegal function call Error
5097+ 3DCA 32 06 82             ld      (TMPBFR1),A     ; store graphic mode
5098+ 3DCD A7                   and     A               ; is it 0 (text mode)?
5099+ 3DCE CA EA 3D             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5100+ 3DD1 CD 29 3E     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
5101+ 3DD4 DA DC 3D             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5102+ 3DD7 3E 02                ld      A,$02           ; no, so set sprite size
5103+ 3DD9 32 08 82             ld      (TMPBFR2),A     ; ...to 16x16
5104+ 3DDC CD 29 3E     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5105+ 3DDF DA EA 3D             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5106+ 3DE2 3A 08 82             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5107+ 3DE5 F6 01                or      $01             ; ...set sprite magnification to 2x...
5108+ 3DE7 32 08 82             ld      (TMPBFR2),A     ; ...and save flags again
5109+ 3DEA F3           SCVDP:  di                      ; disable INTs
5110+ 3DEB D5                   push    DE              ; store DE
5111+ 3DEC E5                   push    HL              ; store HL
5112+ 3DED 3A 06 82             ld      A,(TMPBFR1)     ; recover graphic mode
5113+ 3DF0 5F                   ld      E,A             ; and store it into E
5114+ 3DF1 3A 08 82             ld      A,(TMPBFR2)     ; recover sprite flags
5115+ 3DF4 57                   ld      D,A             ; and store them into D
5116+ 3DF5 D5                   push    DE              ; store D & E
5117+ 3DF6 CD ED 03             call    initVDP         ; initialize VDP with mode pointed by E
5118+ 3DF9 D1                   pop     DE              ; retrieve D & E
5119+ 3DFA 7B                   ld      A,E             ; move graphic mode into A
5120+ 3DFB 87                   add     A,A
5121+ 3DFC 87                   add     A,A
5122+ 3DFD 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5123+ 3DFE 5F                   ld      E,A             ; and pass it into E
5124+ 3DFF D5                   push    DE              ; store sprite flags in E
5125+ 3E00 16 00                ld      D,$00           ; reset D
5126+ 3E02 21 44 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5127+ 3E05 19                   add     HL,DE           ; load correct reg#1 setting
5128+ 3E06 D1                   pop     DE              ; retrieve sprite flags from E
5129+ 3E07 7E                   ld      A,(HL)          ; load reg#1 setting
5130+ 3E08 E6 FC                and     %11111100       ; reset size & magn. bits
5131+ 3E0A B2                   or      D               ; set size & magn. bits
5132+ 3E0B 5F                   ld      E,A             ; value into E
5133+ 3E0C 3E 01                ld      A,$01           ; reg #1
5134+ 3E0E CD D1 06             call    WRITE_VREG      ; send setting to reg #1
5135+ 3E11 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
5136+ 3E14 23                   inc     HL              ; -1 means direct statement
5137+ 3E15 7C                   ld      A,H
5138+ 3E16 B5                   or      L
5139+ 3E17 CC 44 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5140+ 3E1A FB                   ei                      ; re-enable interrupts
5141+ 3E1B E1                   pop     HL              ; restore HL
5142+ 3E1C D1                   pop     DE              ; restore DE
5143+ 3E1D 3A F7 81             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5144+ 3E20 FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5145+ 3E22 D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5146+ 3E23 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5147+ 3E25 32 02 82             ld      (PRNTVIDEO),A   ; ...video buffer...
5148+ 3E28 C9                   ret                     ; ...and return to caller
5149+ 3E29
5150+ 3E29              ; check an additional argument for SCREEN - There are 2 ways of working:
5151+ 3E29              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5152+ 3E29              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5153+ 3E29 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5154+ 3E2A CD 0B 26             call    GETCHR          ; Get next character
5155+ 3E2D 37                   scf                     ; set carry flag
5156+ 3E2E C8                   ret     Z               ; return if nothing follows with Carry=1
5157+ 3E2F CD C2 23             call    CHKSYN          ; Make sure ',' follows
5158+ 3E32 2C                   defb    ','
5159+ 3E33 CD 22 33             call    GETINT          ; get value
5160+ 3E36 1F                   rra                     ; Carry=bit #0
5161+ 3E37 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5162+ 3E38 C9                   ret                     ; return
5163+ 3E39
5164+ 3E39
5165+ 3E39              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5166+ 3E39              ; a=foreground color / b=background color / c=border color
5167+ 3E39              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5168+ 3E39              ; the number of arguments is based on the current screen mode
5169+ 3E39 CD 22 33     COLOR:  call    GETINT          ; get first value
5170+ 3E3C CD E2 3E             call    CHKCLR1         ; check if it's in range 1~15
5171+ 3E3F 32 06 82             ld      (TMPBFR1),A     ; store it
5172+ 3E42 3A F8 81             ld      A,(SCR_MODE)    ; check screen mode
5173+ 3E45 FE 03                cp      $03             ; is it multicolor mode?
5174+ 3E47 20 0D                jr      NZ,CNTCKCL      ; no, continue
5175+ 3E49 3E 0F                ld      A,$0F           ; white for...
5176+ 3E4B 32 04 82             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5177+ 3E4E 3A 06 82             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5178+ 3E51 32 0A 82             ld      (TMPBFR3),A     ; move color into temp buffer 3
5179+ 3E54 18 31                jr      CLRMC           ; jump to set color
5180+ 3E56 CD C2 23     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5181+ 3E59 2C                   defb    ','
5182+ 3E5A CD 22 33             call    GETINT          ; get second value
5183+ 3E5D CD E2 3E             call    CHKCLR1         ; check if it's in range 1~15
5184+ 3E60 32 08 82             ld      (TMPBFR2),A     ; store it
5185+ 3E63 3A F8 81             ld      A,(SCR_MODE)    ; check screen mode
5186+ 3E66 A7                   and     A               ; is it text mode?
5187+ 3E67 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5188+ 3E69 CD C2 23             call    CHKSYN          ; Make sure ',' follows
5189+ 3E6C 2C                   defb    ','
5190+ 3E6D CD 22 33             call    GETINT          ; get third value
5191+ 3E70 CD E2 3E             call    CHKCLR1         ; check if it's in range 1~15
5192+ 3E73 32 0A 82             ld      (TMPBFR3),A     ; store it
5193+ 3E76 D5                   push    DE              ; store DE
5194+ 3E77 3A F8 81             ld      A,(SCR_MODE)    ; check screen mode
5195+ 3E7A FE 01                cp      $01             ; is it G1 mode?
5196+ 3E7C 28 10                jr      Z,CLRG1         ; yes, jump over
5197+ 3E7E FE 02                cp      $02             ; is it G2 mode?
5198+ 3E80 28 15                jr      Z,CLRG2         ; yes, jump over
5199+ 3E82 18 1C                jr      CLREX2          ; last case can only be ExG2
5200+ 3E84 CD D5 3E     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5201+ 3E87 32 0A 82     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5202+ 3E8A D5                   push    DE              ; store DE
5203+ 3E8B F3                   di                      ; disable INTs
5204+ 3E8C 18 2E                jr      SETBRCL         ; set colors and exit
5205+ 3E8E CD D5 3E     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5206+ 3E91 16 01                ld      D,$01           ; repeat 1 time
5207+ 3E93 06 20                ld      B,$20           ; 32 bytes of colors
5208+ 3E95 18 10                jr      LOADCLR         ; load colors
5209+ 3E97 CD D5 3E     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5210+ 3E9A 16 18                ld      D,$18           ; 18 pages of...
5211+ 3E9C 06 00                ld      B,$00           ; ...256 bytes each
5212+ 3E9E 18 07                jr      LOADCLR         ; load colors
5213+ 3EA0 CD D5 3E     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5214+ 3EA3 16 08                ld      D,$08           ; 8 pages of...
5215+ 3EA5 06 00                ld      B,$00           ; ...256 bytes each
5216+ 3EA7 E5           LOADCLR:push    HL              ; store HL
5217+ 3EA8 21 00 20             ld      HL,$2000        ; color table start: $2000
5218+ 3EAB F3                   di                      ; disable INTs
5219+ 3EAC CD 87 06             call    SETVDPADRS
5220+ 3EAF 0E 30                ld      C,VDP_DAT              ; VDP data mode
5221+ 3EB1 ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5222+ 3EB3 00                   nop
5223+ 3EB4 00                   nop
5224+ 3EB5 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5225+ 3EB7 15                   dec     D               ; did we fill up all the pages?
5226+ 3EB8 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5227+ 3EBA FB                   ei
5228+ 3EBB E1                   pop     HL              ; retrieve HL
5229+ 3EBC 3A 06 82     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5230+ 3EBF 32 04 82             ld      (FRGNDCLR),A    ; store it
5231+ 3EC2 3A 08 82             ld      A,(TMPBFR2)     ; retrieve background color
5232+ 3EC5 32 05 82             ld      (BKGNDCLR),A    ; store it
5233+ 3EC8 3A 0A 82             ld      A,(TMPBFR3)     ; recover border color
5234+ 3ECB 5F                   ld      E,A             ; move it into E
5235+ 3ECC 3E 07                ld      A,$07           ; set VDP register 7
5236+ 3ECE F3                   di
5237+ 3ECF CD D1 06             call    WRITE_VREG      ; send value to VDP: set border color
5238+ 3ED2 FB                   ei                      ; re-enable INTs
5239+ 3ED3 D1                   pop     DE              ; retrieve DE
5240+ 3ED4 C9                   ret                     ; return to caller
5241+ 3ED5
5242+ 3ED5
5243+ 3ED5              ; mix 2 color nibbles in 1 byte
5244+ 3ED5 3A 08 82     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5245+ 3ED8 47                   ld      B,A             ; move it into B
5246+ 3ED9 3A 06 82             ld      A,(TMPBFR1)     ; retrieve foreground color
5247+ 3EDC 87                   add     A,A             ; move foreground color into the high nibble of A
5248+ 3EDD 87                   add     A,A
5249+ 3EDE 87                   add     A,A
5250+ 3EDF 87                   add     A,A
5251+ 3EE0 B0                   or      B               ; put background color into the low nibble of A
5252+ 3EE1 C9                   ret                     ; return to caller
5253+ 3EE2
5254+ 3EE2
5255+ 3EE2              ; check if the color is not 0 and into the range 1~15
5256+ 3EE2 A7           CHKCLR1:and     A               ; is it 0?
5257+ 3EE3 CA C2 20             jp      Z,SNERR         ; yes, raise a SN error
5258+ 3EE6 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5259+ 3EE8 D2 C2 20             jp      NC,SNERR        ; no, raise a SN error
5260+ 3EEB C9                   ret                     ; param is OK, can return
5261+ 3EEC
5262+ 3EEC
5263+ 3EEC              ; check if in graphics 2 mode
5264+ 3EEC 3A F8 81     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5265+ 3EEF FE 02                cp      $02             ; actually, we can paint only in G2
5266+ 3EF1 C2 FB 44             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5267+ 3EF4 C9                   ret                     ; return to caller
5268+ 3EF5
5269+ 3EF5
5270+ 3EF5              ; print a text in screen 2
5271+ 3EF5              ; GPRINT text,x,y[,fc[,bc]]
5272+ 3EF5              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5273+ 3EF5              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5274+ 3EF5              ; colors (1~15), resp.
5275+ 3EF5              ; (portions of code are from nippur72)
5276+ 3EF5              GX      equ     TMPBFR3
5277+ 3EF5              GY      equ     TMPBFR4
5278+ 3EF5              TMPCLR  equ     TMPBFR2
5279+ 3EF5              MIXCOL  equ     TMPBFR1
5280+ 3EF5              TMPADR  equ     VIDEOBUFF
5281+ 3EF5              CHRPNT  equ     VIDEOBUFF+$02
5282+ 3EF5              NUMCHR  equ     VIDEOBUFF+$04
5283+ 3EF5              TMPHL   equ     VIDEOBUFF+$06
5284+ 3EF5 CD EC 3E     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5285+ 3EF8 2B                   dec     HL              ; dec 'cos GETCHR INCs
5286+ 3EF9 CD 0B 26             call    GETCHR          ; check if something follows
5287+ 3EFC CA C2 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
5288+ 3EFF 22 0E 82             ld      (TMPADR),HL     ; save current code string pointer
5289+ 3F02 CD AE 2A             call    EVAL            ; Evaluate expression
5290+ 3F05 CD A0 2A             call    TSTSTR          ; Make sure it's a string
5291+ 3F08 22 14 82             ld      (TMPHL),HL      ; store code string pointer
5292+ 3F0B CD E7 30             call    GSTRCU          ; Current string to pool
5293+ 3F0E CD F8 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5294+ 3F11 ED 43 10 82          ld      (CHRPNT),BC     ; store string pointer
5295+ 3F15 ED 53 12 82          ld      (NUMCHR),DE     ; store string lenght
5296+ 3F19 2A 14 82             ld      HL,(TMPHL)      ; restore code string pointer
5297+ 3F1C CD C2 23             call    CHKSYN          ; Make sure ',' follows
5298+ 3F1F 2C                   defb    ','
5299+ 3F20 CD 22 33             call    GETINT          ; get X coord.
5300+ 3F23 FE 20                cp      $20             ; is it in rage 0~31?
5301+ 3F25 D2 D6 26             jp      NC,FCERR        ; Illegal function call error
5302+ 3F28 32 0A 82             ld      (GX),A          ; store into temp. buffer
5303+ 3F2B CD C2 23             call    CHKSYN          ; Make sure ',' follows
5304+ 3F2E 2C                   defb    ','
5305+ 3F2F CD 22 33             call    GETINT          ; get Y coord.
5306+ 3F32 FE 18                cp      $18             ; is it in range 0~23?
5307+ 3F34 D2 D6 26             jp      NC,FCERR        ; Illegal function call error
5308+ 3F37 32 0C 82             ld      (GY),A          ; store into temp. buffer
5309+ 3F3A 11 08 82             ld      DE,TMPCLR
5310+ 3F3D 3A 05 82             ld      A,(BKGNDCLR)    ; load background color
5311+ 3F40 12                   ld      (DE),A          ; store into temp buff
5312+ 3F41 3A 04 82             ld      A,(FRGNDCLR)    ; load foreground color
5313+ 3F44 1B                   dec     DE
5314+ 3F45 1B                   dec     DE
5315+ 3F46 12                   ld      (DE),A          ; store into temp buff
5316+ 3F47 CD D3 3F             call    CKCOL           ; check color
5317+ 3F4A CA 52 3F             jp      Z,CNTGPT2       ; if anything follows, jump over
5318+ 3F4D 13                   inc     DE
5319+ 3F4E 13                   inc     DE
5320+ 3F4F CD D3 3F             call    CKCOL           ; check background color
5321+ 3F52 CD D5 3E     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5322+ 3F55 32 06 82             ld      (MIXCOL),A      ; store mixed colors
5323+ 3F58 E5                   push    HL              ; store code string address
5324+ 3F59 ED 4B 10 82          ld      BC,(CHRPNT)     ; retrieve string pointer
5325+ 3F5D ED 5B 12 82          ld      DE,(NUMCHR)     ; retrieve string lenght
5326+ 3F61 1C                   inc     E               ; Length + 1
5327+ 3F62 CD 67 3F             call    GPNT            ; print on G2
5328+ 3F65 E1                   pop     HL              ; recover HL
5329+ 3F66 C9                   ret                     ; return to caller
5330+ 3F67 D5           GPNT:   push    DE              ; store string lenght (E)
5331+ 3F68                      ; calculate VRAM address of first char
5332+ 3F68 3A 0A 82             LD      A,(GX)          ; load X
5333+ 3F6B 6F                   ld      L,A             ;
5334+ 3F6C 26 00                ld      H,0             ; HL = X
5335+ 3F6E 29                   add     HL,HL           ;
5336+ 3F6F 29                   add     HL,HL           ;
5337+ 3F70 29                   add     HL,HL           ; X=X*8
5338+ 3F71 3A 0C 82             ld      A,(GY)          ; load Y
5339+ 3F74 57                   ld      D,A             ; move it into D
5340+ 3F75 1E 00                ld      E,0             ; DE =Y*256
5341+ 3F77 19                   add     HL,DE           ; address = X*8 + Y*256
5342+ 3F78 22 0E 82             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5343+ 3F7B D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5344+ 3F7C 1D           RPGPNT: dec     E               ; Count characters
5345+ 3F7D C8                   ret     Z               ; End of string - return
5346+ 3F7E D5                   push    DE              ; store chars counter
5347+ 3F7F                      ; calculate dest address in color vram
5348+ 3F7F 2A 0E 82             ld      HL,(TMPADR)     ; recover VRAM address
5349+ 3F82 11 00 20             ld      DE,$2000        ; color map address
5350+ 3F85 19                   add     HL,DE           ; HL = $2000 + XY address
5351+ 3F86 F3                   di                      ; disable INTs
5352+ 3F87                      ; send color settings
5353+ 3F87 CD 87 06     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
5354+ 3F8A 3A 06 82             ld      A,(MIXCOL)      ; load color settings
5355+ 3F8D 06 08                ld      B,$08           ; repeat for 8 rows
5356+ 3F8F 0E 30                ld      C,VDP_DAT       ; VDP data mode
5357+ 3F91 ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5358+ 3F93 00                   nop                     ; wait...
5359+ 3F94 00                   nop                     ; ...a...
5360+ 3F95 00                   nop                     ; ...while
5361+ 3F96 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5362+ 3F98                      ; calculate source address
5363+ 3F98 2A 10 82             ld      HL,(CHRPNT)     ; load char pointer
5364+ 3F9B 7E                   ld      A,(HL)          ; get char
5365+ 3F9C 23                   inc     HL              ; increment char pointer
5366+ 3F9D 22 10 82             ld      (CHRPNT),HL     ; store char pointer
5367+ 3FA0 6F                   ld      L,A             ;
5368+ 3FA1 26 00                ld      H,$00           ; char into HL
5369+ 3FA3 29                   add     HL,HL           ;
5370+ 3FA4 29                   add     HL,HL           ;
5371+ 3FA5 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5372+ 3FA6 11 83 56             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5373+ 3FA9 19                   add     HL,DE           ; HL = start of characters in ROM
5374+ 3FAA EB                   ex      DE,HL           ; store address into DE
5375+ 3FAB 2A 0E 82     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
5376+ 3FAE CD 87 06             call    SETVDPADRS      ; send it to VDP
5377+ 3FB1 EB                   ex      DE,HL           ; restore address into HL
5378+ 3FB2 06 08                ld      B,$08           ; repeat for 8 rows
5379+ 3FB4 0E 30                ld      C,VDP_DAT              ; VDP data mode
5380+ 3FB6 ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5381+ 3FB8 00                   nop                     ; wait...
5382+ 3FB9 00                   nop                     ; ...a...
5383+ 3FBA 00                   nop                     ; ...while
5384+ 3FBB 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5385+ 3FBD FB                   ei                      ; re-enable INTs
5386+ 3FBE 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5387+ 3FC1 2A 0E 82             ld      HL,(TMPADR)     ; load VRAM address
5388+ 3FC4 19                   add     HL,DE           ; get address of next VRAM cell
5389+ 3FC5 22 0E 82             ld      (TMPADR),HL     ; store new VRAM address
5390+ 3FC8 11 00 18             ld      DE,$1800        ; forbidden address
5391+ 3FCB CD 4D 4D             call    CMP16           ; check if the printing has gone out of the screen
5392+ 3FCE D1                   pop     DE              ; retrieve number of chars to be printed
5393+ 3FCF D0                   ret     NC              ; if HL>=$1800 then leave
5394+ 3FD0 C3 7C 3F             jp      RPGPNT          ; otherwise, check if more chars to output
5395+ 3FD3
5396+ 3FD3              ; used by GPRINT to get a color argument (if present)
5397+ 3FD3 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5398+ 3FD4 CD 0B 26             call    GETCHR          ; Get next character
5399+ 3FD7 C8                   ret     Z               ; return if nothing follows
5400+ 3FD8 CD C2 23             call    CHKSYN          ; Make sure ',' follows
5401+ 3FDB 2C                   defb    ','
5402+ 3FDC D5                   push    DE              ; store DE
5403+ 3FDD CD 22 33             call    GETINT          ; get value
5404+ 3FE0 CD E2 3E             call    CHKCLR1         ; check if color is in range 1~15
5405+ 3FE3 D1                   pop     DE              ; retrieve DE
5406+ 3FE4 12                   ld      (DE),A          ; store color into temp buffer
5407+ 3FE5 C9                   ret                     ; return to caller
5408+ 3FE6
5409+ 3FE6
5410+ 3FE6              ; paint X,Y[,C]: in graphics mode, fills an area starting
5411+ 3FE6              ; at point X,Y, using default color or, if used, with
5412+ 3FE6              ; color set by C
5413+ 3FE6              ; TMPBFR1       X
5414+ 3FE6              ; TMPBFR2       Y
5415+ 3FE6              ; TMPBFR3       COLOR
5416+ 3FE6              PNT     equ     VIDEOBUFF
5417+ 3FE6              SPA     equ     VIDEOBUFF+$02
5418+ 3FE6              SPB     equ     VIDEOBUFF+$03
5419+ 3FE6              ORGSP   equ     VIDEOBUFF+$04
5420+ 3FE6 CD EC 3E     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5421+ 3FE9 CD 22 33             call    GETINT          ; get X
5422+ 3FEC 32 06 82             ld      (TMPBFR1),A     ; store X
5423+ 3FEF CD C2 23             call    CHKSYN          ; Make sure ',' follows
5424+ 3FF2 2C                   defb    ','
5425+ 3FF3 CD 22 33             call    GETINT          ; get Y coords,
5426+ 3FF6 FE C0                cp      $C0             ; check if Y is in range 0~191
5427+ 3FF8 D2 D6 26             jp      NC,FCERR        ; no, raise an FC error
5428+ 3FFB 32 08 82             ld      (TMPBFR2),A     ; store Y
5429+ 3FFE CD E2 44             call    CLRPRM          ; check if color has been passed
5430+ 4001 3A 0A 82             ld      A,(TMPBFR3)     ; load color
5431+ 4004 A7                   and     A               ; check if 0
5432+ 4005 CA D6 26             jp      Z,FCERR         ; yes, raise an error
5433+ 4008 E5                   push    HL              ; store HL
5434+ 4009 C5                   push    BC              ; store BC
5435+ 400A D5                   push    DE              ; store DE
5436+ 400B                      ; start algorithm
5437+ 400B CD 1E 41             call    PNTRTN          ; check if pixel is already set
5438+ 400E C2 C2 40             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5439+ 4011 ED 73 12 82          ld      (ORGSP),SP      ; no, store current Stack Pointer
5440+ 4015 21 01 00             ld      HL,$0001        ; HL=1
5441+ 4018 22 0E 82             ld      (PNT),HL        ; set PNT
5442+ 401B 3A 06 82             ld      A,(TMPBFR1)     ; load starting X...
5443+ 401E 47                   ld      B,A             ; ...into B
5444+ 401F 3A 08 82             ld      A,(TMPBFR2)     ; load starting Y...
5445+ 4022 4F                   ld      C,A             ; ...into C
5446+ 4023 C5                   push    BC              ; store starting X,Y into stack
5447+ 4024                      ; main loop
5448+ 4024 2A 0E 82     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5449+ 4027 7C                   ld      A,H             ; check if PNT=0
5450+ 4028 B5                   or      L
5451+ 4029 CA BE 40             jp      Z,EXITPAI       ; yes, no more points to process - exit
5452+ 402C 2B                   dec     HL              ; no, so decrement PNT...
5453+ 402D 22 0E 82             ld      (PNT),HL        ; ...and store it
5454+ 4030 C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5455+ 4031 CD C6 40     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5456+ 4034 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5457+ 4036 78                   ld      A,B             ; pixel is reset, check if X1=0
5458+ 4037 A7                   and     A               ; (reached the limit of the screen)
5459+ 4038 CA 40 40             jp      Z,PAINT1        ; yes, jump over
5460+ 403B 05                   dec     B               ; no, decrement X1...
5461+ 403C C3 31 40             jp      PAINT0          ; ...and repeat
5462+ 403F 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5463+ 4040 AF           PAINT1: xor     A               ; reset A
5464+ 4041 57                   ld      D,A             ; set SA=0
5465+ 4042 5F                   ld      E,A             ; set SB=0
5466+ 4043 CD C6 40     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5467+ 4046 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5468+ 4048 78                   ld      A,B             ; copy X1
5469+ 4049 32 06 82             ld      (TMPBFR1),A     ; into buffer
5470+ 404C 79                   ld      A,C             ; copy Y
5471+ 404D 32 08 82             ld      (TMPBFR2),A     ; into buffer
5472+ 4050 CD 44 41             call    CNTPLOT         ; plot pixel X1,Y
5473+ 4053 7A                   ld      A,D             ; load SA into A
5474+ 4054 A7                   and     A               ; SA=0?
5475+ 4055 20 1C                jr      NZ,PAINT2       ; no, jump over
5476+ 4057 79                   ld      A,C             ; load Y
5477+ 4058 FE 01                cp      $01             ; Y>0?
5478+ 405A DA 73 40             jp      C,PAINT2        ; no, jump over
5479+ 405D 3D                   dec     A               ; yes, Y=Y-1
5480+ 405E CD C7 40             call    CHECKPY         ; check pixel X1,Y-1
5481+ 4061 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5482+ 4063 0D                   dec     C               ; Y=Y-1
5483+ 4064 C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5484+ 4065 0C                   inc     C               ; retrieve original Y
5485+ 4066 2A 0E 82             ld      HL,(PNT)        ; load PNT
5486+ 4069 23                   inc     HL              ; increment PNT
5487+ 406A 22 0E 82             ld      (PNT),HL        ; store new PNT
5488+ 406D 3E 01                ld      A,$01           ; set SA=1 and...
5489+ 406F 57                   ld      D,A             ; ...store SA into memory
5490+ 4070 C3 86 40             jp      PAINT3          ; jump over
5491+ 4073 7A           PAINT2: ld      A,D             ; load SA into A
5492+ 4074 1F                   rra                     ; check if SA=1
5493+ 4075 30 0F                jr      NC,PAINT3       ; no, jump over
5494+ 4077 79                   ld      A,C             ; load Y
5495+ 4078 FE 01                cp      $01             ; Y>0?
5496+ 407A DA 86 40             jp      C,PAINT3        ; no, jump over
5497+ 407D 3D                   dec     A               ; Y=Y-1
5498+ 407E CD C7 40             call    CHECKPY         ; check pixel X1,Y-1
5499+ 4081 CA 86 40             jp      Z,PAINT3        ; if pixel is off, jump over
5500+ 4084 AF                   xor     A               ; pixel is on, so...
5501+ 4085 57                   ld      D,A             ; ...set SA=0
5502+ 4086 7B           PAINT3: ld      A,E             ; check if...
5503+ 4087 A7                   and     A               ; SB=0
5504+ 4088 20 1B                jr      NZ,PAINT4       ; no, jump over
5505+ 408A 79                   ld      A,C             ; load Y
5506+ 408B FE BF                cp      $BF             ; Y<191?
5507+ 408D 30 16                jr      NC,PAINT4       ; no, jump over
5508+ 408F 3C                   inc     A               ; Y=Y+1
5509+ 4090 CD C7 40             call    CHECKPY         ; check pixel X1,Y+1
5510+ 4093 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5511+ 4095 0C                   inc     C               ; Y=Y+1
5512+ 4096 C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5513+ 4097 0D                   dec     C               ; retrieve original Y
5514+ 4098 2A 0E 82             ld      HL,(PNT)        ; PNT
5515+ 409B 23                   inc     HL              ; PNT=PNT+1
5516+ 409C 22 0E 82             ld      (PNT),HL        ; store PNT
5517+ 409F 3E 01                ld      A,$01           ; SB=1
5518+ 40A1 5F                   ld      E,A             ; set SB
5519+ 40A2 C3 B7 40             jp      PAINT5          ; jump over
5520+ 40A5 7B           PAINT4: ld      A,E             ; load SB
5521+ 40A6 1F                   rra                     ; check if SB=1
5522+ 40A7 30 0E                jr      NC,PAINT5       ; no, jump over
5523+ 40A9 79                   ld      A,C             ; load Y
5524+ 40AA FE BF                cp      $BF             ; Y<191?
5525+ 40AC 30 09                jr      NC,PAINT5       ; no, jump over
5526+ 40AE 3C                   inc     A               ; Y=Y+1
5527+ 40AF CD C7 40             call    CHECKPY         ; check pixel X1,Y+1
5528+ 40B2 CA B7 40             jp      Z,PAINT5        ; if pixel is off, jump over
5529+ 40B5 AF                   xor     A               ; pixel is on, so...
5530+ 40B6 5F                   ld      E,A             ; ...set SB=0
5531+ 40B7 04           PAINT5: inc     B               ; X1=X1+1
5532+ 40B8 CA 24 40             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5533+ 40BB C3 43 40             jp      MNPAINT         ; otherwise, repeat for next X
5534+ 40BE ED 7B 12 82  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5535+ 40C2 D1           EXITPA2:pop     DE              ; retrieve DE
5536+ 40C3 C1                   pop     BC              ; retrieve BC
5537+ 40C4 E1                   pop     HL              ; retrieve HL
5538+ 40C5 C9                   ret                     ; return to caller
5539+ 40C6 79           CHECKPA:ld      A,C             ; copy Y into A
5540+ 40C7 32 08 82     CHECKPY:ld      (TMPBFR2),A     ; store Y
5541+ 40CA 78                   ld      A,B             ; copy X1 into A
5542+ 40CB 32 06 82             ld      (TMPBFR1),A     ; store X1
5543+ 40CE C5                   push    BC              ; save X1,Y
5544+ 40CF D5                   push    DE
5545+ 40D0 CD 1E 41             call    PNTRTN          ; check if pixel is set/reset
5546+ 40D3 D1                   pop     DE
5547+ 40D4 C1                   pop     BC              ; retrieve X1,Y
5548+ 40D5 C9                   ret                     ; return to caller
5549+ 40D6
5550+ 40D6
5551+ 40D6              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5552+ 40D6 CD EC 3E     POINT:  call    CHKG2M          ; check if in graphic mode 2
5553+ 40D9 CD C2 23             call    CHKSYN          ; make sure "(" follows
5554+ 40DC 28                   defb    '('
5555+ 40DD CD 22 33             call    GETINT          ; get X coords.
5556+ 40E0 32 06 82             ld      (TMPBFR1),A     ; store it into a temp buffer
5557+ 40E3 CD C2 23             call    CHKSYN          ; Make sure ',' follows
5558+ 40E6 2C                   defb    ','
5559+ 40E7 CD 22 33             call    GETINT          ; get Y coords,
5560+ 40EA FE C0                cp      $C0             ; check if Y is in range 0~191
5561+ 40EC D2 D6 26             jp      NC,FCERR        ; no, raise an FC error
5562+ 40EF 32 08 82             ld      (TMPBFR2),A     ; store into a temp buffer
5563+ 40F2 CD C2 23             call    CHKSYN          ; make sure ")" follows
5564+ 40F5 29                   defb    ')'
5565+ 40F6 E5                   push    HL              ; store current string address - the point after the ")" - ...
5566+ 40F7 FD E1                pop     IY              ; ...into IY
5567+ 40F9 CD 1E 41             call    PNTRTN          ; check if pixel is set or reset
5568+ 40FC 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5569+ 40FE AF                   xor     A               ; no, it's OFF. make sure to reset A...
5570+ 40FF 47                   ld      B,A             ; ...and B
5571+ 4100 E1           PNTEND: pop     HL              ; drop original return point
5572+ 4101 FD E5                push    IY              ; load current string address from IY into stack
5573+ 4103 11 87 2B             ld      DE,RETNUM       ; Address of Return number from function...
5574+ 4106 D5                   push    DE              ; ...saved on stack
5575+ 4107 C3 86 2E             jp      ABPASS          ; return AB
5576+ 410A CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5577+ 410C F3                   di
5578+ 410D CD A7 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5579+ 4110 FB                   ei
5580+ 4111 CB 3F                srl     A               ; shift A...
5581+ 4113 CB 3F                srl     A               ; ...4 times...
5582+ 4115 CB 3F                srl     A               ; ...to move foreground color...
5583+ 4117 CB 3F                srl     A               ; ...into lowest nibble
5584+ 4119 47                   ld      B,A             ; color into B
5585+ 411A AF                   xor     A               ; reset MSB
5586+ 411B C3 00 41             jp      PNTEND          ; return AB
5587+ 411E CD 91 41     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5588+ 4121 57                   ld      D,A             ; store pixel index
5589+ 4122 F3                   di                      ; disable INTs
5590+ 4123 CD A7 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5591+ 4126 FB                   ei                      ; re-enable INTs
5592+ 4127 A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5593+ 4128 C9                   ret                     ; return to caller
5594+ 4129
5595+ 4129
5596+ 4129              ; PLOT X,Y[,color]
5597+ 4129              ; plot a pixel in graphic mode 2
5598+ 4129 CD EC 3E     PLOT:   call    CHKG2M          ; check if in G2 mode
5599+ 412C CD 22 33             call    GETINT          ; get X coords.
5600+ 412F 32 06 82             ld      (TMPBFR1),A     ; store it into a temp buffer
5601+ 4132 CD C2 23             call    CHKSYN          ; Make sure ',' follows
5602+ 4135 2C                   defb    ','
5603+ 4136 CD 22 33             call    GETINT          ; get Y coords,
5604+ 4139 FE C0                cp      $C0             ; check if Y is in range 0~191
5605+ 413B D2 D6 26             jp      NC,FCERR        ; no, raise an FC error
5606+ 413E 32 08 82             ld      (TMPBFR2),A     ; store into a temp buffer
5607+ 4141 CD E2 44             call    CLRPRM          ; check if param "color" has been passed
5608+ 4144 E5           CNTPLOT:push    HL              ; store HL
5609+ 4145 C5                   push    BC              ; store BC
5610+ 4146 D5                   push    DE              ; store DE
5611+ 4147 CD 91 41             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5612+ 414A D2 85 41             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5613+ 414D 57                   ld      D,A             ; move pixel value into D
5614+ 414E 3A 0A 82             ld      A,(TMPBFR3)     ; retrieve color
5615+ 4151 A7                   and     A               ; is it 0? (background, or reset pixel)
5616+ 4152 20 11                jr      NZ,CNTPLT1      ; no, continue
5617+ 4154 F3                   di                      ; yes - so, disable INTs
5618+ 4155 CD A7 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5619+ 4158 FB                   ei                      ; re-enable INTs
5620+ 4159 5F                   ld      E,A             ; store value of cell
5621+ 415A 7A                   ld      A,D             ; retrieve pixel
5622+ 415B 2F                   cpl                     ; revert bits
5623+ 415C A3                   and     E               ; set video pixel to off
5624+ 415D F3                   di                      ; disable INTs
5625+ 415E CD BC 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5626+ 4161 FB                   ei                      ; re-enable INTs
5627+ 4162 C3 85 41             jp      NOGD            ; leave
5628+ 4165 87           CNTPLT1:add     A,A             ; now we move low nibble
5629+ 4166 87                   add     A,A             ; in the high nibble
5630+ 4167 87                   add     A,A             ; by adding A to itself
5631+ 4168 87                   add     A,A             ; 4 times (this is a shift left 4)
5632+ 4169 5F                   ld      E,A             ; move it into E
5633+ 416A F3                   di                      ; disable INTs
5634+ 416B CD A7 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5635+ 416E FB                   ei
5636+ 416F B2                   or      D               ; merge new pixel preserving original pattern
5637+ 4170 F3                   di
5638+ 4171 CD BC 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5639+ 4174 FB                   ei
5640+ 4175 CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5641+ 4177 F3                   di
5642+ 4178 CD A7 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5643+ 417B FB                   ei
5644+ 417C E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5645+ 417E B3                   or      E               ; set new foreground color
5646+ 417F F3                   di
5647+ 4180 CD BC 06             call    WRITE_VIDEO_LOC ; write new color settings
5648+ 4183 FB                   ei                      ; re-enable INTs
5649+ 4184 00                   nop                     ; wait for INTs to be enabled again
5650+ 4185 D1           NOGD:   pop     DE              ; retrieve DE
5651+ 4186 C1                   pop     BC              ; retrieve BC
5652+ 4187 E1                   pop     HL              ; retrieve HL
5653+ 4188 C9                   ret                     ; return to caller
5654+ 4189 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5654+ 418D 08 04 02 01
5655+ 4191                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5656+ 4191
5657+ 4191
5658+ 4191              ; compute the VRAM address of the byte containing the pixel
5659+ 4191              ; being pointed by X,Y (TMPBFR1,TMPBFR2)
5660+ 4191              ; byte address is returned into HL
5661+ 4191              ; pixel is returned into A
5662+ 4191              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5663+ 4191                      ; where R(Y/8) is the remainder of (Y/8)
5664+ 4191                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5665+ 4191 3A 08 82             ld      A,(TMPBFR2)     ; retrieve Y
5666+ 4194 FE C0                cp      $C0             ; Y>=192?
5667+ 4196 D0                   ret     NC              ; yes, so leave
5668+ 4197 1E 08                ld      E,$08           ; load E with divisor
5669+ 4199 57                   ld      D,A             ; and store into D (dividend)
5670+ 419A CD 98 4D             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5671+ 419D 4F                   ld      C,A             ; store remainder into C
5672+ 419E 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5673+ 419F 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5674+ 41A1 3A 06 82             ld      A,(TMPBFR1)     ; retrieve X
5675+ 41A4 57                   ld      D,A             ; and move it into D (dividend)
5676+ 41A5 CD 98 4D             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5677+ 41A8 4F                   ld      C,A             ; store remainder into C
5678+ 41A9 7A                   ld      A,D             ; move quotient into A
5679+ 41AA 87                   add     A,A             ; multiply quotient by 8
5680+ 41AB 87                   add     A,A
5681+ 41AC 87                   add     A,A
5682+ 41AD 5F                   ld      E,A             ; store result into E
5683+ 41AE 16 00                ld      D,$00           ; reset D
5684+ 41B0 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5685+ 41B1 EB                   ex      DE,HL           ; move VRAM address into DE
5686+ 41B2 21 89 41             ld      HL,PXLSET       ; starting address of table for pixel to draw
5687+ 41B5 06 00                ld      B,$00           ; reset B
5688+ 41B7 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5689+ 41B8 7E                   ld      A,(HL)          ; load pixel data
5690+ 41B9 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5691+ 41BA 37                   scf                     ; set Carry for normal exit
5692+ 41BB C9                   ret                     ; return to caller
5693+ 41BC
5694+ 41BC
5695+ 41BC              ; DRAW X1,Y1,X2,Y2[,color]
5696+ 41BC              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5697+ 41BC              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5698+ 41BC              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5699+ 41BC              ; the values. If color is not specified, the foreground color set
5700+ 41BC              ; with COLOR will be used
5701+ 41BC              X1      equ     TMPBFR1
5702+ 41BC              Y1      equ     TMPBFR2
5703+ 41BC              X2      equ     VIDEOBUFF
5704+ 41BC              Y2      equ     VIDEOBUFF+$02
5705+ 41BC              ER      equ     VIDEOBUFF+$04
5706+ 41BC              E2      equ     VIDEOBUFF+$06
5707+ 41BC              SX      equ     VIDEOBUFF+$08
5708+ 41BC              SY      equ     VIDEOBUFF+$0A
5709+ 41BC              DX      equ     VIDEOBUFF+$0C
5710+ 41BC              DY      equ     VIDEOBUFF+$0E
5711+ 41BC CD EC 3E     DRAW:   call    CHKG2M          ; check if in G2 mode
5712+ 41BF CD C4 44             call    CLRTMBF         ; clear TMPBFRx
5713+ 41C2 CD D3 44             call    CLRVDBF         ; clear VIDEOBUFF
5714+ 41C5 CD 22 33             call    GETINT          ; get X1 coords.
5715+ 41C8 32 06 82             ld      (X1),A          ; store it into a temp buffer
5716+ 41CB CD C2 23             call    CHKSYN          ; Make sure ',' follows
5717+ 41CE 2C                   defb    ','
5718+ 41CF CD 22 33             call    GETINT          ; get Y1 coords.
5719+ 41D2 FE C0                cp      $C0             ; check if Y1 is in range 0~191
5720+ 41D4 D2 D6 26             jp      NC,FCERR        ; no, raise an FC error
5721+ 41D7 32 08 82             ld      (Y1),A          ; store into a temp buffer
5722+ 41DA CD C2 23             call    CHKSYN          ; Make sure ',' follows
5723+ 41DD 2C                   defb    ','
5724+ 41DE CD 22 33             call    GETINT          ; get X2 coords.
5725+ 41E1 32 0E 82             ld      (X2),A          ; store it into a temp buffer
5726+ 41E4 CD C2 23             call    CHKSYN          ; Make sure ',' follows
5727+ 41E7 2C                   defb    ','
5728+ 41E8 CD 22 33             call    GETINT          ; get Y2 coords
5729+ 41EB FE C0                cp      $C0             ; check if Y2 is in range 0~191
5730+ 41ED D2 D6 26             jp      NC,FCERR        ; no, raise an FC error
5731+ 41F0 32 10 82             ld      (Y2),A          ; store it into a temp buffer
5732+ 41F3 CD E2 44             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5733+ 41F6 E5                   push    HL              ; store register we'll use
5734+ 41F7 D5                   push    DE
5735+ 41F8 C5                   push    BC
5736+ 41F9 ED 5B 06 82          ld      DE,(X1)         ; load X1 and
5737+ 41FD 2A 0E 82             ld      HL,(X2)         ; X2
5738+ 4200 B7                   or      A               ; clear CARRY
5739+ 4201 ED 52                sbc     HL,DE           ; DX=X2-X1
5740+ 4203 CD 8E 4D             call    absHL           ; DX=ABS(DX)
5741+ 4206 22 1A 82             ld      (DX),HL         ; store DX
5742+ 4209 01 FF FF             ld      BC,$FFFF        ; SX=-1
5743+ 420C 2A 06 82             ld      HL,(X1)
5744+ 420F ED 5B 0E 82          ld      DE,(X2)
5745+ 4213 CD 4D 4D             call    CMP16           ; X1<X2?
5746+ 4216 CA 1F 42             jp      Z,X1GR          ; no, X1=X2
5747+ 4219 F2 1F 42             jp      P,X1GR          ; no, X1>X2
5748+ 421C 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5749+ 421F ED 43 16 82  X1GR:   ld      (SX),BC         ; store SX
5750+ 4223 ED 5B 08 82          ld      DE,(Y1)
5751+ 4227 2A 10 82             ld      HL,(Y2)
5752+ 422A B7                   or      A               ; clear Carry
5753+ 422B ED 52                sbc     HL,DE           ; DY=Y2-Y1
5754+ 422D CD 8E 4D             call    absHL           ; DY=ABS(DY)
5755+ 4230 22 1C 82             ld      (DY),HL         ; store DY
5756+ 4233 01 FF FF             ld      BC,$FFFF        ; SY=-1
5757+ 4236 2A 08 82             ld      HL,(Y1)
5758+ 4239 ED 5B 10 82          ld      DE,(Y2)
5759+ 423D CD 4D 4D             call    CMP16           ; is Y1<Y2?
5760+ 4240 CA 49 42             jp      Z,Y1GR          ; no, Y1=Y2
5761+ 4243 F2 49 42             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5762+ 4246 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5763+ 4249 ED 43 18 82  Y1GR:   ld      (SY),BC         ; store SY
5764+ 424D 2A 1C 82             ld      HL,(DY)         ; ER=DY
5765+ 4250 CD 91 4D             call    negHL           ; ER=-DY
5766+ 4253 22 12 82             ld      (ER),HL         ; store ER
5767+ 4256 2A 1A 82             ld      HL,(DX)
5768+ 4259 ED 5B 1C 82          ld      DE,(DY)
5769+ 425D CD 4D 4D             call    CMP16           ; DX>DY?
5770+ 4260 CA 6C 42             jp      Z,ER2           ; no, DX=DY
5771+ 4263 FA 6C 42             jp      M,ER2           ; no, DX<DY
5772+ 4266 2A 1A 82             ld      HL,(DX)         ; reload DX
5773+ 4269 22 12 82             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5774+ 426C 2A 12 82     ER2:    ld      HL,(ER)         ; load ER
5775+ 426F CB 2C                sra     H               ; right shift (and preserve sign)...
5776+ 4271 CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5777+ 4273 CB 7C                bit     7,H             ; is the number negative?
5778+ 4275 CA 79 42             jp      Z,STRE2         ; no, jump over
5779+ 4278 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5780+ 4279 22 12 82     STRE2:  ld      (ER),HL         ; store ER
5781+ 427C CD 44 41     RPTDRW: call    CNTPLOT         ; plot first pixel
5782+ 427F 2A 06 82             ld      HL,(X1)
5783+ 4282 ED 5B 0E 82          ld      DE,(X2)
5784+ 4286 CD 4D 4D             call    CMP16           ; X1=X2?
5785+ 4289 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5786+ 428B 2A 08 82             ld      HL,(Y1)         ; yes, so check
5787+ 428E ED 5B 10 82          ld      DE,(Y2)         ; also Y
5788+ 4292 CD 4D 4D             call    CMP16           ; Y1=Y2?
5789+ 4295 CA F1 42             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5790+ 4298 ED 5B 12 82  CNTDRW: ld      DE,(ER)
5791+ 429C ED 53 14 82          ld      (E2),DE         ; E2=ER
5792+ 42A0 2A 1A 82             ld      HL,(DX)
5793+ 42A3 CD 91 4D             call    negHL           ; DX=-DX
5794+ 42A6 EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5795+ 42A7 CD 4D 4D             call    CMP16           ; E2>-DX?
5796+ 42AA CA C8 42             jp      Z,DXGR          ; no, E2=-DX: jump
5797+ 42AD FA C8 42             jp      M,DXGR          ; no, E2<-DX: jump
5798+ 42B0 2A 12 82             ld      HL,(ER)         ; yes
5799+ 42B3 ED 5B 1C 82          ld      DE,(DY)
5800+ 42B7 B7                   or      A               ; clear CARRY
5801+ 42B8 ED 52                sbc     HL,DE           ; ER=ER-DY
5802+ 42BA 22 12 82             ld      (ER),HL
5803+ 42BD 2A 06 82             ld      HL,(X1)
5804+ 42C0 ED 5B 16 82          ld      DE,(SX)
5805+ 42C4 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5806+ 42C5 22 06 82             ld      (X1),HL
5807+ 42C8 2A 14 82     DXGR:   ld      HL,(E2)
5808+ 42CB ED 5B 1C 82          ld      DE,(DY)
5809+ 42CF CD 4D 4D             call    CMP16           ; E2<DY?
5810+ 42D2 CA 7C 42             jp      Z,RPTDRW        ; no, E2=DY: jump
5811+ 42D5 F2 7C 42             jp      P,RPTDRW        ; no, E2>DY: jump
5812+ 42D8 2A 12 82             ld      HL,(ER)         ; yes
5813+ 42DB ED 5B 1A 82          ld      DE,(DX)
5814+ 42DF 19                   add     HL,DE           ; ER=ER+DX
5815+ 42E0 22 12 82             ld      (ER),HL
5816+ 42E3 2A 08 82             ld      HL,(Y1)
5817+ 42E6 ED 5B 18 82          ld      DE,(SY)
5818+ 42EA 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5819+ 42EB 22 08 82             ld      (Y1),HL
5820+ 42EE C3 7C 42             jp      RPTDRW          ; repeat
5821+ 42F1 C1           ENDDRAW:pop     BC              ; retrieve BC
5822+ 42F2 D1                   pop     DE              ; retrieve DE
5823+ 42F3 E1                   pop     HL              ; retrieve HL
5824+ 42F4 C9                   ret                     ; return to caller
5825+ 42F5
5826+ 42F5
5827+ 42F5              ; CIRCLE X,Y,R[,C]
5828+ 42F5              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5829+ 42F5              ; and radius R, with optional color C. If color is not specified, the
5830+ 42F5              ; foreground color set with COLOR will be used
5831+ 42F5              XC      equ     VIDEOBUFF
5832+ 42F5              YC      equ     VIDEOBUFF+$02
5833+ 42F5              RADIUS  equ     VIDEOBUFF+$04
5834+ 42F5              XI      equ     VIDEOBUFF+$06
5835+ 42F5              YI      equ     VIDEOBUFF+$08
5836+ 42F5              DC      equ     VIDEOBUFF+$0A
5837+ 42F5 CD EC 3E     CIRCLE: call    CHKG2M          ; check if in G2 mode
5838+ 42F8 CD D3 44             call    CLRVDBF         ; clear VIDEOBUFF
5839+ 42FB CD 22 33             call    GETINT          ; get X coords.
5840+ 42FE 32 0E 82             ld      (XC),A          ; store it into a temp buffer
5841+ 4301 CD C2 23             call    CHKSYN          ; Make sure ',' follows
5842+ 4304 2C                   defb    ','
5843+ 4305 CD 22 33             call    GETINT          ; get Y coords,
5844+ 4308 32 10 82             ld      (YC),A          ; store it into a temp buffer
5845+ 430B CD C2 23             call    CHKSYN          ; Make sure ',' follows
5846+ 430E 2C                   defb    ','
5847+ 430F CD 22 33             call    GETINT          ; get radius
5848+ 4312 32 12 82             ld      (RADIUS),A      ; store it into a temp buffer
5849+ 4315 CD E2 44             call    CLRPRM          ; check if param "color" has been passed
5850+ 4318 C5                   push    BC              ; store BC
5851+ 4319 D5                   push    DE              ; store DE
5852+ 431A E5                   push    HL              ; store HL
5853+ 431B AF                   xor     A               ; clear A,
5854+ 431C 47                   ld      B,A             ; B,
5855+ 431D 4F                   ld      C,A             ; C,
5856+ 431E 57                   ld      D,A             ; D,
5857+ 431F 67                   ld      H,A             ; and H
5858+ 4320 ED 43 14 82          ld      (XI),BC         ; clear XI
5859+ 4324 3A 12 82             ld      A,(RADIUS)      ; load RADIUS into A
5860+ 4327 6F                   ld      L,A             ; HL now contains R
5861+ 4328 22 16 82             ld      (YI),HL         ; YI=RADIUS
5862+ 432B 29                   add     HL,HL           ; R*2
5863+ 432C EB                   ex      DE,HL           ; put HL into DE
5864+ 432D 21 03 00             ld      HL,$0003        ; HL = 3
5865+ 4330 AF                   xor     A               ; clear Carry
5866+ 4331 ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5867+ 4333 22 18 82             ld      (DC),HL         ; store D
5868+ 4336 CD 95 43             call    DRWCRL          ; draw initial point
5869+ 4339 ED 5B 14 82  RPTCRL: ld      DE,(XI)         ; load XI
5870+ 433D 2A 16 82             ld      HL,(YI)         ; load YI
5871+ 4340 CD 4D 4D             call    CMP16           ; is YI<DI?
5872+ 4343 CA 4C 43             jp      Z,RPTCL1        ; no, YI=XI
5873+ 4346 F2 4C 43             jp      P,RPTCL1        ; no, YI>XI
5874+ 4349 C3 91 43             jp      ENDCRL          ; yes, so we've finished
5875+ 434C 21 14 82     RPTCL1: ld      HL,XI
5876+ 434F 34                   inc     (HL)            ; XI=XI+1
5877+ 4350 2A 18 82             ld      HL,(DC)         ; load D
5878+ 4353 7C                   ld      A,H
5879+ 4354 B5                   or      L               ; is D=0? Yes, jump over
5880+ 4355 CA 79 43             jp      Z,DLSZ
5881+ 4358 CB 7C                bit     7,H             ; is D<0?
5882+ 435A 20 1D                jr      NZ,DLSZ         ; yes, jump over
5883+ 435C ED 5B 16 82          ld      DE,(YI)         ; D>0
5884+ 4360 1B                   dec     DE              ; so, YI=YI-1
5885+ 4361 ED 53 16 82          ld      (YI),DE         ; store YI
5886+ 4365 AF                   xor     A               ; clear Carry
5887+ 4366 2A 14 82             ld      HL,(XI)
5888+ 4369 ED 52                sbc     HL,DE           ; HL=XI-YI
5889+ 436B 29                   add     HL,HL
5890+ 436C 29                   add     HL,HL           ; HL=HL*4
5891+ 436D 11 0A 00             ld      DE,10
5892+ 4370 19                   add     HL,DE           ; HL=HL+10
5893+ 4371 ED 5B 18 82          ld      DE,(DC)         ; load D
5894+ 4375 EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5895+ 4376 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5896+ 4377 18 0F                jr      PLTCRL          ; plot next pixel
5897+ 4379 2A 14 82     DLSZ:   ld      HL,(XI)         ; load XI
5898+ 437C 29                   add     HL,HL
5899+ 437D 29                   add     HL,HL           ; XI=XI*4
5900+ 437E 11 06 00             ld      DE,$0006
5901+ 4381 19                   add     HL,DE
5902+ 4382 ED 5B 18 82          ld      DE,(DC)
5903+ 4386 EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5904+ 4387 19                   add     HL,DE           ; D=D+4*XI+6
5905+ 4388 22 18 82     PLTCRL: ld      (DC),HL         ; store new D
5906+ 438B CD 95 43             call    DRWCRL          ; plot pixel
5907+ 438E C3 39 43             jp      RPTCRL          ; repeat
5908+ 4391 E1           ENDCRL: pop     HL
5909+ 4392 D1                   pop     DE
5910+ 4393 C1                   pop     BC
5911+ 4394 C9                   ret                     ; return to caller
5912+ 4395 2A 0E 82     DRWCRL: ld      HL,(XC)
5913+ 4398 ED 5B 14 82          ld      DE,(XI)
5914+ 439C 19                   add     HL,DE           ; X=XC+XI
5915+ 439D 22 06 82             ld      (X1),HL         ; store X
5916+ 43A0 CD B4 44             call    VALIDX          ; check if X is valid (0~255)
5917+ 43A3 DA B7 43             jp      C,CNTCL1        ; if Carry is set, X is not valid
5918+ 43A6 2A 10 82             ld      HL,(YC)
5919+ 43A9 ED 5B 16 82          ld      DE,(YI)
5920+ 43AD 19                   add     HL,DE           ; Y=YC+YI
5921+ 43AE 22 08 82             ld      (Y1),HL         ; store Y
5922+ 43B1 CD B9 44             call    VALIDY          ; check if Y is valid (0~191)
5923+ 43B4 D4 44 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5924+ 43B7 AF           CNTCL1: xor     A               ; clear Carry
5925+ 43B8 2A 0E 82             ld      HL,(XC)
5926+ 43BB ED 5B 14 82          ld      DE,(XI)
5927+ 43BF ED 52                sbc     HL,DE           ; X=XC-XI
5928+ 43C1 22 06 82             ld      (X1),HL         ; store X
5929+ 43C4 CD B4 44             call    VALIDX          ; check if X is valid (0~255)
5930+ 43C7 DA DB 43             jp      C,CNTCL2        ; if Carry is set, X is not valid
5931+ 43CA 2A 10 82             ld      HL,(YC)
5932+ 43CD ED 5B 16 82          ld      DE,(YI)
5933+ 43D1 19                   add     HL,DE           ; Y=YC+YI
5934+ 43D2 22 08 82             ld      (Y1),HL         ; store Y
5935+ 43D5 CD B9 44             call    VALIDY          ; check if Y is valid (0~191)
5936+ 43D8 D4 44 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5937+ 43DB 2A 0E 82     CNTCL2: ld      HL,(XC)
5938+ 43DE ED 5B 14 82          ld      DE,(XI)
5939+ 43E2 19                   add     HL,DE           ; X=XC+XI
5940+ 43E3 22 06 82             ld      (X1),HL         ; store X
5941+ 43E6 CD B4 44             call    VALIDX          ; check if X is valid (0~255)
5942+ 43E9 DA FF 43             jp      C,CNTCL3        ; if Carry is set, X is not valid
5943+ 43EC AF                   xor     A               ; clear Carry
5944+ 43ED 2A 10 82             ld      HL,(YC)
5945+ 43F0 ED 5B 16 82          ld      DE,(YI)
5946+ 43F4 ED 52                sbc     HL,DE           ; Y=YC-YI
5947+ 43F6 22 08 82             ld      (Y1),HL         ; store Y
5948+ 43F9 CD B9 44             call    VALIDY          ; check if Y is valid (0~191)
5949+ 43FC D4 44 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5950+ 43FF AF           CNTCL3: xor     A               ; clear Carry
5951+ 4400 2A 0E 82             ld      HL,(XC)
5952+ 4403 ED 5B 14 82          ld      DE,(XI)
5953+ 4407 ED 52                sbc     HL,DE           ; X=XC-XI
5954+ 4409 22 06 82             ld      (X1),HL         ; store X
5955+ 440C CD B4 44             call    VALIDX          ; check if X is valid (0~255)
5956+ 440F DA 25 44             jp      C,CNTCL4        ; if Carry is set, X is not valid
5957+ 4412 AF                   xor     A               ; clear Carry
5958+ 4413 2A 10 82             ld      HL,(YC)
5959+ 4416 ED 5B 16 82          ld      DE,(YI)
5960+ 441A ED 52                sbc     HL,DE           ; Y=YC-YI
5961+ 441C 22 08 82             ld      (Y1),HL         ; store Y
5962+ 441F CD B9 44             call    VALIDY          ; check if Y is valid (0~191)
5963+ 4422 D4 44 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5964+ 4425 2A 0E 82     CNTCL4: ld      HL,(XC)
5965+ 4428 ED 5B 16 82          ld      DE,(YI)
5966+ 442C 19                   add     HL,DE           ; X=XC+YI
5967+ 442D 22 06 82             ld      (X1),HL         ; store X
5968+ 4430 CD B4 44             call    VALIDX          ; check if X is valid (0~255)
5969+ 4433 DA 47 44             jp      C,CNTCL5        ; if Carry is set, X is not valid
5970+ 4436 2A 10 82             ld      HL,(YC)
5971+ 4439 ED 5B 14 82          ld      DE,(XI)
5972+ 443D 19                   add     HL,DE           ; Y=YC+XI
5973+ 443E 22 08 82             ld      (Y1),HL         ; store Y
5974+ 4441 CD B9 44             call    VALIDY          ; check if Y is valid (0~191)
5975+ 4444 D4 44 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5976+ 4447 AF           CNTCL5: xor     A               ; clear Carry
5977+ 4448 2A 0E 82             ld      HL,(XC)
5978+ 444B ED 5B 16 82          ld      DE,(YI)
5979+ 444F ED 52                sbc     HL,DE           ; X=XC-YI
5980+ 4451 22 06 82             ld      (X1),HL         ; store X
5981+ 4454 CD B4 44             call    VALIDX          ; check if X is valid (0~255)
5982+ 4457 DA 6B 44             jp      C,CNTCL6        ; if Carry is set, X is not valid
5983+ 445A 2A 10 82             ld      HL,(YC)
5984+ 445D ED 5B 14 82          ld      DE,(XI)
5985+ 4461 19                   add     HL,DE           ; Y=YC+XI
5986+ 4462 22 08 82             ld      (Y1),HL         ; store Y
5987+ 4465 CD B9 44             call    VALIDY          ; check if Y is valid (0~191)
5988+ 4468 D4 44 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5989+ 446B 2A 0E 82     CNTCL6: ld      HL,(XC)
5990+ 446E ED 5B 16 82          ld      DE,(YI)
5991+ 4472 19                   add     HL,DE           ; X=XC+YI
5992+ 4473 22 06 82             ld      (X1),HL         ; store X
5993+ 4476 CD B4 44             call    VALIDX          ; check if X is valid (0~255)
5994+ 4479 DA 8F 44             jp      C,CNTCL7        ; if Carry is set, X is not valid
5995+ 447C AF                   xor     A               ; clear Carry
5996+ 447D 2A 10 82             ld      HL,(YC)
5997+ 4480 ED 5B 14 82          ld      DE,(XI)
5998+ 4484 ED 52                sbc     HL,DE           ; Y=YC-XI
5999+ 4486 22 08 82             ld      (Y1),HL         ; store Y
6000+ 4489 CD B9 44             call    VALIDY          ; check if Y is valid (0~191)
6001+ 448C D4 44 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6002+ 448F AF           CNTCL7: xor     A               ; clear Carry
6003+ 4490 2A 0E 82             ld      HL,(XC)
6004+ 4493 ED 5B 16 82          ld      DE,(YI)
6005+ 4497 ED 52                sbc     HL,DE           ; X=XC-YI
6006+ 4499 22 06 82             ld      (X1),HL         ; store X
6007+ 449C CD B4 44             call    VALIDX          ; check if X is valid (0~255)
6008+ 449F D8                   ret     C               ; if Carry is set, X is not valid
6009+ 44A0 AF                   xor     A               ; clear Carry
6010+ 44A1 2A 10 82             ld      HL,(YC)
6011+ 44A4 ED 5B 14 82          ld      DE,(XI)
6012+ 44A8 ED 52                sbc     HL,DE           ; Y=YC-XI
6013+ 44AA 22 08 82             ld      (Y1),HL         ; store Y
6014+ 44AD CD B9 44             call    VALIDY          ; check if Y is valid (0~191)
6015+ 44B0 D4 44 41             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
6016+ 44B3 C9                   ret                     ; return to caller
6017+ 44B4
6018+ 44B4              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
6019+ 44B4              ; input: HL (value to check), can be negative
6020+ 44B4              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
6021+ 44B4              ; destroys: A
6022+ 44B4 AF           VALIDX: xor     A               ; reset A
6023+ 44B5 B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
6024+ 44B6 C8                   ret     Z               ; yes, we can return (C is clear)
6025+ 44B7 37                   scf                     ; set Carry flag to raise error
6026+ 44B8 C9                   ret                     ; return to caller
6027+ 44B9
6028+ 44B9 AF           VALIDY: xor     A               ; reset A
6029+ 44BA B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
6030+ 44BB 28 02                jr      Z,CNTVALY       ; yes, continue checking
6031+ 44BD 37                   scf                     ; no, raise error by setting Carry flag
6032+ 44BE C9                   ret                     ; return to caller
6033+ 44BF 7D           CNTVALY:ld      A,L
6034+ 44C0 FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
6035+ 44C2 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
6036+ 44C3 C9                   ret                     ; return to caller
6037+ 44C4
6038+ 44C4
6039+ 44C4
6040+ 44C4              ; cleat TMPBFR1-4 buffers before using them
6041+ 44C4 AF           CLRTMBF:xor     A               ; reset A
6042+ 44C5 E5                   push    HL              ; store HL
6043+ 44C6 C5                   push    BC              ; store BC
6044+ 44C7 21 06 82             ld      HL,TMPBFR1      ; address of 1st location
6045+ 44CA 06 08                ld      B,$08           ; 8 locations
6046+ 44CC 77           RPCLTMB:ld      (HL),A          ; clear byte
6047+ 44CD 23                   inc     HL              ; next location
6048+ 44CE 10 FC                djnz    RPCLTMB         ; repeat
6049+ 44D0 C1                   pop     BC              ; retrieve BC
6050+ 44D1 E1                   pop     HL              ; retrieve HL
6051+ 44D2 C9                   ret                     ; return to caller
6052+ 44D3
6053+ 44D3
6054+ 44D3              ; clear VIDEOBUFF before using it as temp buffer
6055+ 44D3 AF           CLRVDBF:xor     A               ; clear A
6056+ 44D4 C5                   push    BC              ; store BC
6057+ 44D5 E5                   push    HL              ; store HL
6058+ 44D6 06 28                ld      B,$28           ; 40 cells
6059+ 44D8 21 0E 82             ld      HL,VIDEOBUFF    ; address of 1st cell
6060+ 44DB 77           RPTCVBF:ld      (HL),A          ; clear cell
6061+ 44DC 23                   inc     HL              ; next cell
6062+ 44DD 10 FC                djnz    RPTCVBF         ; repeat
6063+ 44DF E1                   pop     HL              ; retrieve HL
6064+ 44E0 C1                   pop     BC              ; retrieve BC
6065+ 44E1 C9                   ret                     ; return to caller
6066+ 44E2
6067+ 44E2
6068+ 44E2              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
6069+ 44E2              ; commands. If not present, the default foreground color will be used
6070+ 44E2 3A 04 82     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
6071+ 44E5 32 0A 82             ld      (TMPBFR3),A     ; store into temp buffer
6072+ 44E8 2B                   dec     HL              ; dec 'cos GETCHR INCs
6073+ 44E9 CD 0B 26             call    GETCHR          ; Get next character
6074+ 44EC C8                   ret     Z               ; return foreground color if nothing follows
6075+ 44ED CD C2 23             call    CHKSYN          ; Make sure ',' follows
6076+ 44F0 2C                   defb    ','
6077+ 44F1 CD 22 33             call    GETINT          ; get value
6078+ 44F4 CD E6 3E             call    CHKCLR0         ; check if color is in range 0~15
6079+ 44F7 32 0A 82             ld      (TMPBFR3),A     ; store color into temp buffer
6080+ 44FA C9                   ret                     ; return to caller
6081+ 44FB
6082+ 44FB
6083+ 44FB              ; no graphics mode error: raised when a graphics command is invoked
6084+ 44FB              ; out of graphic 2 mode.
6085+ 44FB 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6086+ 44FD C3 DC 20             jp      ERROR           ; print error
6087+ 4500
6088+ 4500
6089+ 4500              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6090+ 4500              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6091+ 4500              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6092+ 4500              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6093+ 4500              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6094+ 4500              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6095+ 4500              ; they are assumed to be 8,0,1 resp.
6096+ 4500              PRTNUM  equ     VIDEOBUFF
6097+ 4500              BPS     equ     PRTNUM+$01
6098+ 4500              DATABT  equ     BPS+$02
6099+ 4500              PARBT   equ     DATABT+$01
6100+ 4500              STPBT   equ     PARBT+$01
6101+ 4500              SIOBFR  equ     STPBT+$01
6102+ 4500 CD 22 33     SERIAL: call    GETINT          ; get port #
6103+ 4503 A7                   and     A               ; is it zero?
6104+ 4504 CA D6 26             jp      Z,FCERR         ; yes, error
6105+ 4507 FE 03                cp      $03             ; is it 1 or 2?
6106+ 4509 D2 29 47             jp      NC,SCERR        ; no, error
6107+ 450C 32 0E 82             ld      (PRTNUM),A      ; store port number into a temp buffer
6108+ 450F CD C2 23             call    CHKSYN          ; Make sure ',' follows
6109+ 4512 2C                   defb    ','
6110+ 4513 2B                   dec     HL
6111+ 4514 CD 0B 26             call    GETCHR          ; check what's following
6112+ 4517 CA C2 20             jp      Z,SNERR         ; error if nothing follows
6113+ 451A 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6114+ 451C CD DB 26             call    ATOH            ; get bps (returned into DE)
6115+ 451F 18 0F                jr      CHKZSER         ; jump over
6116+ 4521 CD 9C 2A     SERVAR: call    GETNUM          ; get number
6117+ 4524 CD A9 38             call    TSTSGN          ; check value
6118+ 4527 FA D6 26             jp      M,FCERR         ; negative - illegal function call
6119+ 452A 3A 5D 82             ld      A,(FPEXP)       ; Get integer value to DE
6120+ 452D CD 51 39             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6121+ 4530 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6122+ 4531 B3                   or      E               ; check if bps=0
6123+ 4532 20 3A                jr      NZ,CNTSER       ; no, continue checking
6124+ 4534                      ; if baud rate is 0, then close the serial comm.
6125+ 4534 3A 0E 82     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6126+ 4537 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6127+ 4538 C6 22                add     SIO_CA          ; find correct channel
6128+ 453A 4F                   ld      C,A             ; store serial channel
6129+ 453B F3                   di                      ; disable INTs
6130+ 453C AF                   xor     A               ; reset A
6131+ 453D 16 01                ld      D,$01           ; start from WR1
6132+ 453F 06 05                ld      B,$05           ; 5 registers
6133+ 4541 ED 51        RPTRSSR:out     (C),D           ; select register
6134+ 4543 ED 79                out     (C),A           ; reset register
6135+ 4545 14                   inc     D               ; next register
6136+ 4546 10 F9                djnz    RPTRSSR         ; repeat
6137+ 4548 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6138+ 454A ED 79                out     (C),A           ; send command to serial channel
6139+ 454C 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6140+ 454E ED 79                out     (C),A           ; send command to serial channel
6141+ 4550 FB                   ei                      ; re-enable INTs
6142+ 4551 E5                   push    HL              ; store HL
6143+ 4552 21 48 82             ld      HL,SERIALS_EN   ; serials enabled status byte
6144+ 4555 DB 01                in      A,(PIO_DB)      ; read status LEDs
6145+ 4557 CB 41                bit     0,C             ; check serial port
6146+ 4559 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6147+ 455B CB B7                res     6,A             ; it's port 1
6148+ 455D CB A7                res     4,A             ; remove possible error LED
6149+ 455F CB 86                res     0,(HL)          ; disable port 1
6150+ 4561 C3 6A 45             jp      SERLED          ; jump over
6151+ 4564 CB BF        SRPT2:  res     7,A             ; it's port 2
6152+ 4566 CB AF                res     5,A             ; remove possible error LED
6153+ 4568 CB 8E                res     1,(HL)          ; disable port 2
6154+ 456A D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6155+ 456C E1                   pop     HL              ; retrieve HL
6156+ 456D C9                   ret                     ; return to caller
6157+ 456E                      ; check if bps=1, meaning reactivate RX on serial
6158+ 456E 7A           CNTSER: ld      A,D
6159+ 456F B2                   or      D               ; check if bps<>1 by first checking D=0
6160+ 4570 20 36                jr      NZ,CNTSER2      ; if not, jump over
6161+ 4572 7B                   ld      A,E             ; then by checking that
6162+ 4573 FE 01                cp      $01             ; E=1
6163+ 4575 20 31                jr      NZ,CNTSER2      ; if not, jump over
6164+ 4577 3A 0E 82             ld      A,(PRTNUM)      ; load port number
6165+ 457A 57                   ld      D,A             ; store port on D
6166+ 457B 3A 48 82             ld      A,(SERIALS_EN)  ; load address of serial status cell
6167+ 457E A2                   and     D               ; check status
6168+ 457F CA 29 47             jp      Z,SCERR         ; port not open, raise error
6169+ 4582 F3                   di                      ; disable INTs
6170+ 4583 7A                   ld      A,D             ; move port # into A
6171+ 4584 5F                   ld      E,A             ; and also into E
6172+ 4585 87                   add     A
6173+ 4586 87                   add     A               ; move A to left times 2
6174+ 4587 57                   ld      D,A             ; move value into D
6175+ 4588 3A 48 82             ld      A,(SERIALS_EN)  ; load serial status byte
6176+ 458B B2                   or      D               ; re-enable RX
6177+ 458C 32 48 82             ld      (SERIALS_EN),A  ; store new serial status
6178+ 458F 7B                   ld      A,E             ; recover port #
6179+ 4590 3D                   dec     A               ; check port
6180+ 4591 20 0A                jr      NZ,CNTRX2       ; port is #2
6181+ 4593 CD E3 01             call    SIO_A_EI        ; re-enable RX on port 1
6182+ 4596 DB 01                in      A,(PIO_DB)      ; load status LEDs
6183+ 4598 CB A7                res     4,A             ; remove error LED
6184+ 459A C3 A4 45             jp      RXEND           ; terminate setting
6185+ 459D CD EB 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6186+ 45A0 DB 01                in      A,(PIO_DB)      ; load status LEDs
6187+ 45A2 CB AF                res     5,A             ; remove error LED
6188+ 45A4 D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6189+ 45A6 FB                   ei                      ; re-enable INTs
6190+ 45A7 C9                   ret                     ; return to caller
6191+ 45A8                      ; set serial port comm.
6192+ 45A8 D5           CNTSER2:push    DE              ; store BPS
6193+ 45A9 3A 0E 82             ld      A,(PRTNUM)      ; load port number
6194+ 45AC 57                   ld      D,A             ; move port # into D
6195+ 45AD 3A 48 82             ld      A,(SERIALS_EN)  ; check if serial port is already open
6196+ 45B0 A2                   and     D               ; by ANDing A with D
6197+ 45B1 D1                   pop     DE              ; retrieve BPS
6198+ 45B2 CA BA 45             jp      Z,CNTSER3       ; not open, continue
6199+ 45B5 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6200+ 45B7 C3 DC 20             jp      ERROR           ; and leave
6201+ 45BA E5           CNTSER3:push    HL              ; store HL
6202+ 45BB 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6203+ 45BE CD 4D 4D             call    CMP16           ; is bps<=57,600?
6204+ 45C1 E1                   pop     HL              ; but first, recover HL
6205+ 45C2 DA 29 47             jp      C,SCERR         ; no (bps>57,600) then error
6206+ 45C5 ED 53 0F 82          ld      (BPS),DE        ; store bps
6207+ 45C9 2B                   dec     HL              ; dec 'cos GETCHR INCs
6208+ 45CA CD 0B 26             call    GETCHR          ; Get next character
6209+ 45CD CA 05 46             jp      Z,DEFSER        ; defaults if nothing follows
6210+ 45D0 CD C2 23             call    CHKSYN          ; Make sure ',' follows
6211+ 45D3 2C                   defb    ','
6212+ 45D4 CD 22 33             call    GETINT          ; get data bits
6213+ 45D7 FE 05                cp      $05             ; is it <5?
6214+ 45D9 DA 29 47             jp      C,SCERR         ; yes, error
6215+ 45DC FE 09                cp      $09             ; is it >=9?
6216+ 45DE D2 D6 26             jp      NC,FCERR        ; yes, error
6217+ 45E1 32 11 82             ld      (DATABT),A      ; store data bits
6218+ 45E4 CD C2 23             call    CHKSYN          ; Make sure ',' follows
6219+ 45E7 2C                   defb    ','
6220+ 45E8 CD 22 33             call    GETINT          ; get parity bits
6221+ 45EB BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6222+ 45EE D2 29 47             jp      NC,SCERR        ; no, error
6223+ 45F1 32 12 82             ld      (PARBT),A       ; store parity
6224+ 45F4 CD C2 23             call    CHKSYN          ; Make sure ',' follows
6225+ 45F7 2C                   defb    ','
6226+ 45F8 CD 22 33             call    GETINT          ; get stop bits
6227+ 45FB FE 03                cp      $03             ; is it >=3?
6228+ 45FD D2 29 47             jp      NC,SCERR        ; yes, error
6229+ 4600 32 13 82             ld      (STPBT),A       ; store stop bits
6230+ 4603 18 0D                jr      SETSER          ; jump to set serial
6231+ 4605 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6232+ 4607 32 11 82             ld      (DATABT),A
6233+ 460A AF                   xor     A               ; no parity bit
6234+ 460B 32 12 82             ld      (PARBT),A
6235+ 460E 3C                   inc     A               ; 1 bit for stop
6236+ 460F 32 13 82             ld      (STPBT),A
6237+ 4612                      ; check if bps are legal
6238+ 4612 E5           SETSER: push    HL              ; store HL
6239+ 4613 D5                   push    DE              ; store DE
6240+ 4614 DD E5                push    IX              ; store IX
6241+ 4616 DD 21 04 47          ld      IX,SUP_BPS      ; allowed BPSs
6242+ 461A 06 0B                ld      B,$0B           ; 11 items
6243+ 461C 0E 00                ld      C,$00           ; reset pointer
6244+ 461E 2A 0F 82     CKBPS:  ld      HL,(BPS)        ; load BPS
6245+ 4621 DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6246+ 4624 DD 56 01             ld      D,(IX+1)        ; load MSB of item
6247+ 4627 CD 4D 4D             call    CMP16           ; is it equal?
6248+ 462A CA 37 46             jp      Z,SET_PT        ; yes, found a correspondance
6249+ 462D DD 23                inc     IX
6250+ 462F DD 23                inc     IX              ; no, go to next entry
6251+ 4631 0C                   inc     C               ; increment pointer
6252+ 4632 10 EA                djnz    CKBPS           ; repeat for 10 entries
6253+ 4634 C3 25 47             jp      SCERR1          ; if nothing found, raise an error
6254+ 4637              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6255+ 4637                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6256+ 4637                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6257+ 4637                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6258+ 4637 F3                   di                      ; disable INTs
6259+ 4638 06 00                ld      B,$00           ; reset B
6260+ 463A 21 1A 47             ld      HL,CTC_CFG      ; address of first CTC divider
6261+ 463D 09                   add     HL,BC           ; adjust for correct CTC divider
6262+ 463E 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6263+ 4640 3A 0E 82             ld      A,(PRTNUM)      ; load port number
6264+ 4643 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6265+ 4644 DA 48 46             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6266+ 4647 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6267+ 4648 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6268+ 464A                                              ; start upon loading time constant, time constant follows, sw reset, command word
6269+ 464A ED 79                out     (C),A           ; configure CTC channel
6270+ 464C 7E                   ld      A,(HL)          ; load CTC divider
6271+ 464D ED 79                out     (C),A           ; send divider
6272+ 464F                      ; configure SIO
6273+ 464F 21 54 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6274+ 4652 11 14 82             ld      DE,SIOBFR       ; into a temp buffer
6275+ 4655 01 0A 00             ld      BC,$000A        ; 10 items to copy
6276+ 4658 ED B0                ldir                    ; copy SIO settings into TEMP buffer
6277+ 465A 3A 19 82             ld      A,(SIOBFR+5)    ; load WR5 setting
6278+ 465D 47                   ld      B,A             ; move it into B
6279+ 465E 3A 11 82             ld      A,(DATABT)      ; load DATA bits
6280+ 4661 FE 05                cp      $05             ; is it 5 bits?
6281+ 4663 20 06                jr      NZ,BITS6        ; no, jump over
6282+ 4665 CB B0                res     6,B
6283+ 4667 CB A8                res     5,B             ; set D6 & D5 to 0
6284+ 4669 18 19                jr      SETPAR          ; jump to set parity
6285+ 466B FE 06        BITS6:  cp      $06             ; is it 6 bits?
6286+ 466D 20 06                jr      NZ,BITS7        ; no, jump over
6287+ 466F CB F0                set     6,B
6288+ 4671 CB A8                res     5,B             ; set D6 & D5 to 1,0
6289+ 4673 18 0F                jr      SETPAR          ; jump to set parity
6290+ 4675 FE 07        BITS7:  cp      $07             ; is it 7 bits?
6291+ 4677 20 07                jr      NZ,BITS8        ; no, jump over
6292+ 4679 CB B0                res     6,B
6293+ 467B CB E8                set     5,B             ; set D6 & D5 to 0,1
6294+ 467D C3 84 46             jp      SETPAR          ; jump to set parity
6295+ 4680 CB F0        BITS8:  set     6,B
6296+ 4682 CB E8                set     5,B             ; set D6 & D5 to 1,1
6297+ 4684 21 49 82     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6298+ 4687 3A 0E 82             ld      A,(PRTNUM)      ; check serial port number
6299+ 468A 3D                   dec     A               ; is it port #1?
6300+ 468B CA 8F 46             jp      Z,SETPAR2       ; yes, jump over
6301+ 468E 23                   inc     HL              ; port #2, use SERBBITS instead
6302+ 468F 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6303+ 4690 32 19 82             ld      (SIOBFR+5),A    ; save DATA bits
6304+ 4693 E6 60                and     %01100000       ; filter only D5&D6 bits
6305+ 4695 87                   add     A,A             ; shift left times 1
6306+ 4696 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6307+ 4697 3A 13 82             ld      A,(STPBT)       ; load STOP bits
6308+ 469A 87                   add     A,A
6309+ 469B 87                   add     A,A             ; 2 left shifts
6310+ 469C 47                   ld      B,A             ; move forming byte into B
6311+ 469D 3A 12 82             ld      A,(PARBT)       ; load PARITY setting
6312+ 46A0 A7                   and     A               ; is it 0?
6313+ 46A1 CA AC 46             jp      Z,STRPAR        ; yes, jump over
6314+ 46A4 CB C0                set     0,B             ; set PARITY on
6315+ 46A6 3D                   dec     A               ; is parity ODD?
6316+ 46A7 CA AC 46             jp      Z,STRPAR        ; yes, so jump over
6317+ 46AA CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6318+ 46AC 3A 17 82     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6319+ 46AF E6 F0                and     %11110000       ; reset STOP & PARITY bits
6320+ 46B1 B0                   or      B               ; set new STOP & PARITY bits
6321+ 46B2 32 17 82             ld      (SIOBFR+3),A    ; store new value
6322+ 46B5                      ;set up TX and RX:
6323+ 46B5                      ; the followings are settings for channel A
6324+ 46B5 21 14 82             ld      HL,SIOBFR       ; settings for SIO ch. A
6325+ 46B8 06 06                ld      B,$06           ; 6 bytes to send
6326+ 46BA 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6327+ 46BC 3A 0E 82             ld      A,(PRTNUM)      ; load port number
6328+ 46BF 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6329+ 46C0 DA C4 46             jp      C,SRLCNT        ; port 1, continue
6330+ 46C3 0C                   inc     C               ; port 2, increment address port into C
6331+ 46C4 ED B3        SRLCNT: otir                    ; send bytes to SIO
6332+ 46C6                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6333+ 46C6 06 04                ld      B,$04           ; other 4 bytes to send
6334+ 46C8 51                   ld      D,C             ; store port address into D
6335+ 46C9 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6336+ 46CB ED B3                otir                    ; send bytes to SIO
6337+ 46CD                      ; the following are settings for selected channel
6338+ 46CD 3E 01                ld      A,$01           ; write into WR0: select WR1
6339+ 46CF 4A                   ld      C,D             ; retrieve port address
6340+ 46D0 ED 79                out     (C),A
6341+ 46D2 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6342+ 46D4                                              ; buffer overrun is special condition
6343+ 46D4 ED 79                out     (C),A
6344+ 46D6 21 48 82             ld      HL,SERIALS_EN
6345+ 46D9 3A 0E 82             ld      A,(PRTNUM)      ; retrieve serial channel
6346+ 46DC 3D                   dec     A               ; channel A?
6347+ 46DD 20 10                jr      NZ,ENCHB        ; no, jump over
6348+ 46DF CD E3 01             call    SIO_A_EI        ; enable RX on SIO channel A
6349+ 46E2 CB C6                set     0,(HL)          ; set serial port 1 status ON
6350+ 46E4 CB D6                set     2,(HL)          ; set serial port 1 RX ON
6351+ 46E6                      ; back to normal running
6352+ 46E6 FB                   ei                      ; re-enable INTs
6353+ 46E7 DB 01                in      A,(PIO_DB)      ; load status LEDs
6354+ 46E9 CB F7                set     6,A             ; set status LED on
6355+ 46EB CB A7                res     4,A             ; set error LED off
6356+ 46ED 18 0E                jr      EXNRM           ; leave
6357+ 46EF CD EB 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6358+ 46F2 CB CE                set     1,(HL)          ; set serial port 2 status ON
6359+ 46F4 CB DE                set     3,(HL)          ; set serial port 2 RX ON
6360+ 46F6                      ; back to normal running
6361+ 46F6 FB                   ei                      ; re-enable INTs
6362+ 46F7 DB 01                in      A,(PIO_DB)      ; load status LEDs
6363+ 46F9 CB FF                set     7,A             ; set status LED on
6364+ 46FB CB AF                res     5,A             ; set error LED off
6365+ 46FD D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6366+ 46FF DD E1                pop     IX              ; retrieve IX
6367+ 4701 D1                   pop     DE              ; retrieve DE
6368+ 4702 E1                   pop     HL              ; retrieve HL
6369+ 4703 C9                   ret                     ; return to caller
6370+ 4704
6371+ 4704              ; allowed bps (Bauds per second)
6372+ 4704 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6372+ 4708 80 70 00 4B
6372+ 470C 40 38 80 25
6372+ 4710 C0 12 10 0E
6372+ 4714 60 09 B0 04
6372+ 4718 58 02
6373+ 471A              ; corresponding CTC divider
6374+ 471A 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6374+ 471E 08 0C 18 20
6374+ 4722 30 60 C0
6375+ 4725
6376+ 4725
6377+ 4725              ; serial configuration error
6378+ 4725 DD E1        SCERR1: pop     IX              ; retrieve IX
6379+ 4727 D1                   pop     DE              ; retrieve DE
6380+ 4728 E1                   pop     HL              ; retrieve HL
6381+ 4729 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6382+ 472B C3 DC 20             jp      ERROR           ; print error
6383+ 472E
6384+ 472E
6385+ 472E              ; serial buffer overrun
6386+ 472E CD D8 28     SOERR:  call    PRNTCRLF
6387+ 4731 1E 30                ld      E,SO            ; Serial Buffer Overrun
6388+ 4733 C3 DC 20             jp      ERROR
6389+ 4736
6390+ 4736
6391+ 4736              ; check for direct mode:
6392+ 4736              ; Z is set if in direct mode, reset otherwise
6393+ 4736 E5           DIRMOD: push    HL              ; Save code string address
6394+ 4737 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
6395+ 473A 23                   inc     HL              ; -1 means direct statement
6396+ 473B 7C                   ld      A,H
6397+ 473C B5                   or      L
6398+ 473D E1                   pop     HL              ; Restore code string address
6399+ 473E C9                   ret
6400+ 473F
6401+ 473F
6402+ 473F              ; HELP lists the line program where an error occured
6403+ 473F CD 36 47     HELP:   call    DIRMOD          ; check if in direct mode
6404+ 4742 C2 58 47             jp      NZ,HLPERR       ; raise error if in indirect mode
6405+ 4745 E5                   push    HL              ; store HL
6406+ 4746 2A B1 80             ld      HL,(HLPLN)      ; load HELP line
6407+ 4749 23                   inc     HL              ; increment HL
6408+ 474A 7C                   ld      A,H
6409+ 474B B5                   or      L               ; check if there is a line into the HELP reg.
6410+ 474C E1                   pop     HL
6411+ 474D CA 58 47             jp      Z,HLPERR        ; no line found, raise error
6412+ 4750 ED 5B B1 80          ld      DE,(HLPLN)      ; recover line
6413+ 4754 C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6414+ 4755 C3 58 24             jp      LST01H          ; jump to list line
6415+ 4758 1E 32        HLPERR: ld      E,HP            ; HELP call error
6416+ 475A C3 DC 20             jp      ERROR           ; raise error
6417+ 475D
6418+ 475D
6419+ 475D              ; KEY command to list/modify function keys and auto-repeat
6420+ 475D 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6421+ 475E CD 0B 26             call    GETCHR          ; Get next character
6422+ 4761 CA E1 47             jp      Z,LSTKEYS       ; jump if nothing follows
6423+ 4764                      ; change FN keys
6424+ 4764 CD 22 33             call    GETINT          ; get a number
6425+ 4767 A7                   and     A               ; is it 0?
6426+ 4768 20 10                jr      NZ,KEYCH        ; no, jump over
6427+ 476A E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6428+ 476B D5                   push    DE              ; store HL & DE
6429+ 476C 21 B0 1F             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6430+ 476F 11 B3 80             ld      DE,KEYDEL       ; pointer to destination
6431+ 4772 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6432+ 4775 ED B0                ldir                    ; restore default texts
6433+ 4777 D1                   pop     DE              ; retrieve DE
6434+ 4778 E1                   pop     HL              ; retrieve HL
6435+ 4779 C9                   ret                     ; return to caller
6436+ 477A FE 09        KEYCH:  cp      $09             ; is it >= 9?
6437+ 477C D2 94 48             jp      NC,SETREP       ; yes - jump over
6438+ 477F 3D                   dec     A               ; FN key in range 0~7
6439+ 4780 87                   add     A,A             ; multiply A...
6440+ 4781 87                   add     A,A             ; ... times 4...
6441+ 4782 87                   add     A,A             ; ... to get the correct...
6442+ 4783 87                   add     A,A             ; ... offset fo FN key text
6443+ 4784 32 06 82             ld      (TMPBFR1),A     ; store FN key offset...
6444+ 4787 AF                   xor     A               ; ...in a...
6445+ 4788 32 07 82             ld      (TMPBFR1+1),A   ; ...16-bit register
6446+ 478B CD C2 23             call    CHKSYN          ; Make sure ',' follows
6447+ 478E 2C                   defb    ','
6448+ 478F 44 4D                ld      BC,HL           ; copy address into BC
6449+ 4791 CD AE 2A             call    EVAL            ; Evaluate expression (in E there is the length)
6450+ 4794 E5                   push    HL              ; store string pointer
6451+ 4795 3A 94 81             ld      A,(TYPE)        ; Get variable type
6452+ 4798 B7                   or      A               ; Is it a string variable?
6453+ 4799 CA C2 20             jp      Z,SNERR         ; no - syntax error
6454+ 479C CD E7 30             call    GSTRCU          ; Current string to pool
6455+ 479F CD F8 38             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6456+ 47A2 7B                   ld      A,E             ; copy length into A
6457+ 47A3 FE 11                cp      $11             ; is length > 16?
6458+ 47A5 DA AA 47             jp      C,DECLN1        ; no, jump over
6459+ 47A8 1E 10                ld      E,$10           ; yes, so set length to 16
6460+ 47AA 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6461+ 47AC 93                   sub     E               ; ...null chars needed to fill up...
6462+ 47AD 57                   ld      D,A             ; ...the FN key text
6463+ 47AE C5                   push    BC              ; store address of string
6464+ 47AF ED 4B 06 82          ld      BC,(TMPBFR1)    ; load FN key offset
6465+ 47B3 21 B5 80             ld      HL,FNKEYS       ; load address of FN keys texts
6466+ 47B6 09                   add     HL,BC           ; get corrected address
6467+ 47B7 C1                   pop     BC              ; retrieve address of string chars
6468+ 47B8 0A           CPKEY:  ld      A,(BC)          ; load char from string
6469+ 47B9 FE 0D                cp      CR              ; return?
6470+ 47BB CA C8 47             jp      Z,CPKEY2        ; yes, store char
6471+ 47BE FE 7B                cp      $7B             ; if char > "z" ?
6472+ 47C0 D2 C2 20             jp      NC,SNERR        ; yes - syntax error
6473+ 47C3 FE 20                cp      $20             ; is char < space?
6474+ 47C5 DA C2 20             jp      C,SNERR         ; yes - syntax error
6475+ 47C8 FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6476+ 47CA DA CF 47             jp      C,CPKEY3        ; no, continue
6477+ 47CD E6 5F                and     %01011111       ; set letters to uppercase
6478+ 47CF 77           CPKEY3: ld      (HL),A          ; store char
6479+ 47D0 23                   inc     HL              ; next string char
6480+ 47D1 03                   inc     BC              ; next free cell
6481+ 47D2 1D                   dec     E               ; decrement E
6482+ 47D3 20 E3                jr      NZ,CPKEY        ; repeat until 0
6483+ 47D5 AF                   xor     A               ; null char
6484+ 47D6 14                   inc     D               ; +1 to decrement below
6485+ 47D7 15           CPKEY1: dec     D               ; how many null chars to insert?
6486+ 47D8 CA DF 47             jp      Z,CPKYEND       ; no more nulls, so exit
6487+ 47DB 77                   ld      (HL),A          ; store it
6488+ 47DC 23                   inc     HL              ; next cell
6489+ 47DD 18 F8                jr      CPKEY1          ; repeat
6490+ 47DF E1           CPKYEND:pop     HL              ; retrieve pointer to string
6491+ 47E0 C9                   ret                     ; return to caller
6492+ 47E1                                              ; list FN keys
6493+ 47E1 E5           LSTKEYS:push    HL              ; Save code string address
6494+ 47E2 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
6495+ 47E5 23                   inc     HL              ; -1 means direct statement
6496+ 47E6 7C                   ld      A,H
6497+ 47E7 B5                   or      L
6498+ 47E8 E1                   pop     HL              ; Restore code string address
6499+ 47E9 C2 C2 20             jp      NZ,SNERR        ; raise error if in indirect mode
6500+ 47EC E5                   push    HL              ; store HL
6501+ 47ED D5                   push    DE              ; store DE
6502+ 47EE 21 B5 80             ld      HL,FNKEYS       ; load starting address of FN keys text
6503+ 47F1 0E 01                ld      C,$01           ; 8 function keys
6504+ 47F3 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6505+ 47F5 11 B6 48     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
6506+ 47F8 CD 85 48             call    PRTCKEY         ; print it
6507+ 47FB 79                   ld      A,C             ; load FN key
6508+ 47FC C6 30                add     $30             ; get number in ASCI code
6509+ 47FE CD CD 23             call    OUTC            ; print it
6510+ 4801 11 BB 48             ld      DE,CHKEY2       ; message ": ""
6511+ 4804 CD 85 48             call    PRTCKEY         ; print it
6512+ 4807 3E 01                ld      A,$01           ; " opened
6513+ 4809 32 06 82             ld      (TMPBFR1),A
6514+ 480C 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6515+ 480D A7                   and     A               ; is it zero?
6516+ 480E CA 21 48             jp      Z,CNTLTK        ; yes, go next char
6517+ 4811 CD 6D 48             call    OPNQT           ; check if quotes are opened
6518+ 4814 FE 22                cp      $22             ; check if char is "?
6519+ 4816 CA 36 48             jp      Z,PRTCHR        ; yes, print "chr$("
6520+ 4819 FE 0D                cp      CR              ; is it a CR?
6521+ 481B CA 36 48             jp      Z,PRTCHR        ; yes, print "chr$("
6522+ 481E CD CD 23     PRTK3:  call    OUTC            ; no, just print it
6523+ 4821 23           CNTLTK: inc     HL              ; next char
6524+ 4822 10 E8                djnz    LDKEY           ; continue until finished
6525+ 4824 CD 5B 48             call    CLSQT           ; check if quotes are still open
6526+ 4827 3E 0D                ld      A,CR            ; go next line
6527+ 4829 CD CD 23             call    OUTC            ; print it
6528+ 482C 0C                   inc     C               ; next FN key
6529+ 482D 79                   ld      A,C             ; check if...
6530+ 482E FE 09                cp      $09             ; finished keys?
6531+ 4830 DA F3 47             jp      C,PRTK4         ; no, repeat 1 more time
6532+ 4833 D1                   pop     DE              ; retrieve DE
6533+ 4834 E1                   pop     HL              ; retrieve HL
6534+ 4835 C9                   ret                     ; return to caller
6535+ 4836 E5           PRTCHR: push    HL              ; store HL
6536+ 4837 CD 5B 48             call    CLSQT           ; check if quotes are closed
6537+ 483A 3E 2B                ld      A,'+'           ; '+' char
6538+ 483C CD CD 23             call    OUTC            ; print it
6539+ 483F 11 BE 48             ld      DE,CHKEY3       ; address of "CHR$("
6540+ 4842 CD 85 48             call    PRTCKEY         ; print it
6541+ 4845 E1                   pop     HL              ; recover HL
6542+ 4846 23                   inc     HL              ; next char
6543+ 4847 05                   dec     B               ; increment char counter
6544+ 4848 11 C4 48             ld      DE,CHKEY4       ; load address of RETURN
6545+ 484B 7E                   ld      A,(HL)          ; load char
6546+ 484C FE 0D                cp      CR              ; is it a RETURN?
6547+ 484E 20 03                jr      NZ,PTCHR1       ; no, jump over
6548+ 4850 11 C7 48             ld      DE,CHKEY5       ; yes, load address of "
6549+ 4853 CD 85 48     PTCHR1: call    PRTCKEY         ; print it
6550+ 4856 3E 29                ld      A,')'           ; char )
6551+ 4858 C3 1E 48             jp      PRTK3           ; continue
6552+ 485B F5           CLSQT:  push    AF              ; store A
6553+ 485C 3A 06 82             ld      A,(TMPBFR1)     ; quote status
6554+ 485F A7                   and     A               ; are they closed?
6555+ 4860 28 09                jr      Z,CLSQT1        ; if yes, return
6556+ 4862 3E 22                ld      A,$22           ; no, so close them
6557+ 4864 CD CD 23             call    OUTC            ; print "
6558+ 4867 AF                   xor     A               ; set quotes
6559+ 4868 32 06 82             ld      (TMPBFR1),A     ; as closed
6560+ 486B F1           CLSQT1: pop     AF              ; retrieve A
6561+ 486C C9                   ret                     ; return to caller
6562+ 486D F5           OPNQT:  push    AF              ; store A
6563+ 486E 3A 06 82             ld      A,(TMPBFR1)     ; quote status
6564+ 4871 A7                   and     A               ; are they open?
6565+ 4872 20 0F                jr      NZ,OPNQT1       ; if yes, return
6566+ 4874 3E 2B                ld      A,'+'           ; no, so add '+
6567+ 4876 CD CD 23             call    OUTC            ; print it
6568+ 4879 3E 22                ld      A,$22           ; and then open quotes
6569+ 487B CD CD 23             call    OUTC            ; print them
6570+ 487E 3E 01                ld      A,$01           ; set quotes
6571+ 4880 32 06 82             ld      (TMPBFR1),A     ; as opened
6572+ 4883 F1           OPNQT1: pop     AF              ; retrieve A
6573+ 4884 C9                   ret                     ; return to caller
6574+ 4885 F5           PRTCKEY:push    AF              ; store original char
6575+ 4886 1A           PRTK1:  ld      A,(DE)          ; load char
6576+ 4887 A7                   and     A               ; is it 0?
6577+ 4888 CA 92 48             jp      Z,PRTEND        ; yes, finished printing
6578+ 488B CD CD 23             call    OUTC            ; no, print char
6579+ 488E 13                   inc     DE              ; next char
6580+ 488F C3 86 48             jp      PRTK1           ; repeat
6581+ 4892 F1           PRTEND: pop     AF              ; retrieve AF
6582+ 4893 C9                   ret                     ; return to caller
6583+ 4894 FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6584+ 4896 C2 C2 20             jp      NZ,SNERR        ; no, raise an error
6585+ 4899 CD C2 23             call    CHKSYN          ; Check for comma
6586+ 489C 2C                   defb    ','
6587+ 489D CD 22 33             call    GETINT          ; get a number
6588+ 48A0 32 06 82             ld      (TMPBFR1),A     ; store it
6589+ 48A3 CD C2 23             call    CHKSYN          ; Check for comma
6590+ 48A6 2C                   defb    ','
6591+ 48A7 CD 22 33             call    GETINT          ; get another number
6592+ 48AA E5                   push    HL              ; store HL
6593+ 48AB 21 B4 80             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6594+ 48AE 77                   ld      (HL),A          ; store auto-repeat delay
6595+ 48AF 2B                   dec     HL              ; previous cell
6596+ 48B0 3A 06 82             ld      A,(TMPBFR1)     ; retrieve value
6597+ 48B3 77                   ld      (HL),A          ; store delay for auto-repeat
6598+ 48B4 E1                   pop     HL              ; retrieve HL
6599+ 48B5 C9                   ret
6600+ 48B6 4B 45 59 20  CHKEY1: defb    "KEY ",0
6600+ 48BA 00
6601+ 48BB 3A 22 00     CHKEY2: defb    ":",34,0
6602+ 48BE 63 68 72 24  CHKEY3: defb    "chr$(",0
6602+ 48C2 28 00
6603+ 48C4 31 33 00     CHKEY4: defb    "13",0
6604+ 48C7 33 34 00     CHKEY5: defb    "34",0
6605+ 48CA
6606+ 48CA
6607+ 48CA              ; check if DOS is enabled
6608+ 48CA 3A 4B 82     CHKDOS: ld      A,(DOS_EN)      ; load DOS state
6609+ 48CD A7                   and     A               ; check if 0 (NOT enabled)
6610+ 48CE C0                   ret     NZ              ; return if enabled
6611+ 48CF 1E 38                ld      E,D0            ; DOS not enabled error
6612+ 48D1 C3 DC 20             jp      ERROR           ; raise error
6613+ 48D4
6614+ 48D4
6615+ 48D4              ; LOAD "filename"[,1]  <- load a BASIC program from disk
6616+ 48D4              ; LOAD x,y,z           <- load a sector from disc, LBA address equals to (((z*256)+y)*256)+x
6617+ 48D4 CD CA 48     LOAD:   call    CHKDOS          ; check if DOS is enabled
6618+ 48D7 CD 2A 49             call    LDSVPT          ; check if in direct mode and what's following
6619+ 48DA CA F8 48             jp      Z,LOADST        ; number - load a single sector
6620+ 48DD CD 36 47             call    DIRMOD          ; a file can be loaded ONLY in direct mode
6621+ 48E0 C2 D7 20             jp      NZ,IMERR        ; raise error if in indirect mode
6622+ 48E3 CD 0F 4C             call    CHKFN1          ; string - evaluate file name
6623+ 48E6 CD 5D 4A             call    CHK1AR          ; check for ",1" argument
6624+ 48E9 22 06 82             ld      (TMPBFR1),HL    ; store HL
6625+ 48EC 21 19 49             ld      HL,TXTLDG       ; loading message
6626+ 48EF CD A4 2F             call    PRS             ; print
6627+ 48F2 CD AC 15             call    LODFILE         ; load file into memory
6628+ 48F5 C3 0D 49             jp      LDEND           ; retrieve registers and leave
6629+ 48F8 2A 06 82     LOADST: ld      HL,(TMPBFR1)    ; retrieve HL
6630+ 48FB CD 3F 49             call    GET3AR          ; get 3 arguments
6631+ 48FE 22 06 82             ld      (TMPBFR1),HL    ; store HL
6632+ 4901 CD 6F 10             call    CF_SETSTR       ; set sector
6633+ 4904 CD B1 10             call    CF_RD_SEC       ; read sector
6634+ 4907 38 0B                jr      C,LDERR
6635+ 4909 CD A5 10             call    CF_STANDBY      ; put CF in standby mode
6636+ 490C AF                   xor     A               ; clear Carry
6637+ 490D 2A 06 82     LDEND:  ld      HL,(TMPBFR1)    ; retrieve HL
6638+ 4910 DA 56 4A             jp      C,DOS_ERR       ; jump if DOS error
6639+ 4913 C9                   ret                     ; return to caller
6640+ 4914 1E 40        LDERR:  ld      E,D4            ; load error
6641+ 4916 C3 DC 20             jp      ERROR
6642+ 4919 4C 6F 61 64  TXTLDG: defb    "Loading file... ",0
6642+ 491D 69 6E 67 20
6642+ 4921 66 69 6C 65
6642+ 4925 2E 2E 2E 20
6642+ 4929 00
6643+ 492A
6644+ 492A
6645+ 492A              ; common code for LOAD/SAVE to check the type of operation required
6646+ 492A              ; (load/save a file or a single sector)
6647+ 492A              ; returns Z if argument is a number, NZ if it's a string
6648+ 492A CD CA 48     LDSVPT: call    CHKDOS          ; check if DOS is enabled
6649+ 492D 2B                   dec     HL              ; dec 'cos GETCHR INCs
6650+ 492E CD 0B 26             call    GETCHR          ; check if something follows
6651+ 4931 CA C2 20             jp      Z,SNERR         ; if anything else, raise a syntax error
6652+ 4934 22 06 82             ld      (TMPBFR1),HL    ; save current code string pointer
6653+ 4937 CD AE 2A             call    EVAL            ; Evaluate expression
6654+ 493A 3A 94 81             ld      A,(TYPE)        ; Get variable type
6655+ 493D B7                   or      A               ; Is it a string variable?
6656+ 493E C9                   ret                     ; return to caller
6657+ 493F
6658+ 493F
6659+ 493F              ; shared code between LOAD and SAVE
6660+ 493F              ; get 3 arguments after the command LOAD or SAVE
6661+ 493F              ; and load them into appropriate registers
6662+ 493F 2A 06 82     GET3AR: ld      HL,(TMPBFR1)     ; retrieve string code pointer
6663+ 4942 CD 22 33             call    GETINT          ; get 1st pointer
6664+ 4945 32 9D 81             ld      (TMPDBF),A      ; store it into a temp buffer
6665+ 4948 CD C2 23             call    CHKSYN          ; Make sure ',' follows
6666+ 494B 2C                   defb    ','
6667+ 494C CD 22 33             call    GETINT          ; get 2nd pointer
6668+ 494F 32 9E 81             ld      (TMPDBF+1),A    ; store it into a temp buffer
6669+ 4952 CD C2 23             call    CHKSYN          ; Make sure ',' follows
6670+ 4955 2C                   defb    ','
6671+ 4956 CD 22 33             call    GETINT          ; get 3rd pointer
6672+ 4959 32 9F 81             ld      (TMPDBF+2),A    ; store it into a temp buffer
6673+ 495C CD 2D 10             call    CF_INIT         ; init CF card
6674+ 495F DA DA 20             jp      C,NRERR         ; error if device not available/ready
6675+ 4962 3A 9D 81             ld      A,(TMPDBF)      ; retrieve 1st pointer
6676+ 4965 4F                   ld      C,A
6677+ 4966 3A 9E 81             ld      A,(TMPDBF+1)    ; retrieve 2nd pointer
6678+ 4969 47                   ld      B,A
6679+ 496A 3A 9F 81             ld      A,(TMPDBF+2)    ; retrieve 3rd pointer
6680+ 496D 5F                   ld      E,A
6681+ 496E 16 00                ld      D,$00           ; set disk
6682+ 4970 C9                   ret                     ; return to caller
6683+ 4971
6684+ 4971
6685+ 4971              ; save a file onto the disk
6686+ 4971              ; syntax: save "filename" to save a BASIC program
6687+ 4971              ; save x,y,z to save IO buffer into x-y-z sector
6688+ 4971              ; save "filename",start,end to save a portion of memory
6689+ 4971 CD CA 48     SAVE:   call    CHKDOS          ; check if DOS is enabled
6690+ 4974 2B                   dec     HL              ; dec 'cos GETCHR INCs
6691+ 4975 CD 0B 26             call    GETCHR          ; check if something follows
6692+ 4978 CA C2 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
6693+ 497B 22 06 82             ld      (TMPBFR1),HL    ; save current code string pointer
6694+ 497E CD AE 2A             call    EVAL            ; Evaluate expression
6695+ 4981 3A 94 81             ld      A,(TYPE)        ; Get variable type
6696+ 4984 B7                   or      A               ; Is it a string variable?
6697+ 4985 CA E3 49             jp      Z,SAVESCT       ; no - save a single sector
6698+ 4988 CD 0F 4C             call    CHKFN1          ; yes, load string name
6699+ 498B ED 53 0C 82          ld      (TMPBFR4),DE    ; store lenght into another buffer
6700+ 498F ED 43 B6 81          ld      (TPBF4+2),BC    ; store address into another buffer
6701+ 4993 3E 80                ld      A,$80           ; set BAS as file type
6702+ 4995 32 B4 81             ld      (TPBF4),A
6703+ 4998 2B                   dec     HL              ; dec 'cos GETCHR INCs
6704+ 4999 CD 0B 26             call    GETCHR          ; check if something follows
6705+ 499C 28 30                jr      Z,SAVE1         ; no, jump over
6706+ 499E CD C2 23             call    CHKSYN          ; yes - Make sure ',' follows
6707+ 49A1 2C                   defb    ','
6708+ 49A2 22 9D 81             ld      (TMPDBF),HL     ; store code string pointer
6709+ 49A5 CD AE 2A             call    EVAL            ; check expression
6710+ 49A8 2A 9D 81             ld      HL,(TMPDBF)     ; point back to the beginning of epression
6711+ 49AB 3A 94 81             ld      A,(TYPE)        ; check result type
6712+ 49AE B7                   or      A               ; is it another string?
6713+ 49AF 20 4B                jr      NZ,RENFIL       ; yes, jump to rename file
6714+ 49B1 CD 9C 2A             call    GETNUM          ; no, this is the memory address for a BIN file
6715+ 49B4 CD C1 26             call    DEINT           ; Get integer -32768 to 32767
6716+ 49B7 ED 53 B6 81          ld      (SRTMEM),DE     ; Store DE into a temp. buffer
6717+ 49BB CD C2 23             call    CHKSYN          ; Make sure ',' follows
6718+ 49BE 2C                   defb    ','
6719+ 49BF CD 9C 2A             call    GETNUM          ; Get memory address
6720+ 49C2 CD C1 26             call    DEINT           ; Get integer -32768 to 32767
6721+ 49C5 ED 53 B8 81          ld      (ENDMEM),DE     ; Store DE into a temp. buffer
6722+ 49C9 3E 81                ld      A,$81           ; set BIN for file type
6723+ 49CB 32 B4 81             ld      (TPBF4),A
6724+ 49CE CD 36 47     SAVE1:  call    DIRMOD          ; can be executed ONLY in direct mode
6725+ 49D1 C2 D7 20             jp      NZ,IMERR        ; raise error if in indirect mode
6726+ 49D4 22 06 82             ld      (TMPBFR1),HL    ; store code string pointer
6727+ 49D7 21 2F 4A             ld      HL,TXTSVG       ; loading message
6728+ 49DA CD A4 2F             call    PRS             ; print
6729+ 49DD CD E8 13             call    SAVFILE         ; load file into memory
6730+ 49E0 C3 F5 49             jp      SVEND           ; retrieve registers and leave
6731+ 49E3                      ;save a single sector
6732+ 49E3 2A 9D 81     SAVESCT:ld      HL,(TMPDBF)     ; retrieve string code pointer
6733+ 49E6 CD 3F 49             call    GET3AR          ; get 3 arguments
6734+ 49E9 22 06 82             ld      (TMPBFR1),HL    ; store code string pointer
6735+ 49EC CD D8 10             call    CF_WR_SEC       ; read sector
6736+ 49EF 38 39                jr      C,SVERR
6737+ 49F1 CD A5 10             call    CF_STANDBY      ; put CF in standby mode
6738+ 49F4 AF                   xor     A               ; clear Carry
6739+ 49F5 2A 06 82     SVEND:  ld      HL,(TMPBFR1)    ; retrieve code string pointer
6740+ 49F8 DA 56 4A             jp      C,DOS_ERR       ; jump if DOS error
6741+ 49FB C9                   ret                     ; return to caller
6742+ 49FC CD E7 30     RENFIL: call    GSTRCU          ; check that a string follows
6743+ 49FF CD F8 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
6744+ 4A02 ED 53 A5 81          ld      (BYT_SIZ),DE    ; store values into
6745+ 4A06 ED 43 AC 81          ld      (RAM_PTR),BC    ; temp buffers
6746+ 4A0A E5                   push    HL              ; store code string pointer
6747+ 4A0B 21 19 4A             ld      HL,TXTRNM       ; point to "renaming file"
6748+ 4A0E CD A4 2F             call    PRS             ; print string
6749+ 4A11 CD 16 15             call    CHNGNAM         ; rename file
6750+ 4A14 E1                   pop     HL              ; retrieve code string pointer
6751+ 4A15 DA 56 4A             jp      C,DOS_ERR       ; any error?
6752+ 4A18 C9                   ret                     ; return to caller
6753+ 4A19 52 65 6E 61  TXTRNM: defb    "Renaming file...",0
6753+ 4A1D 6D 69 6E 67
6753+ 4A21 20 66 69 6C
6753+ 4A25 65 2E 2E 2E
6753+ 4A29 00
6754+ 4A2A 1E 3E        SVERR:  ld      E,D3            ; save error
6755+ 4A2C C3 DC 20             jp      ERROR
6756+ 4A2F 53 61 76 69  TXTSVG: defb    "Saving file... ",0
6756+ 4A33 6E 67 20 66
6756+ 4A37 69 6C 65 2E
6756+ 4A3B 2E 2E 20 00
6757+ 4A3F
6758+ 4A3F
6759+ 4A3F              ; FILES
6760+ 4A3F              ; list files on disk
6761+ 4A3F CD CA 48     FILES:  call    CHKDOS          ; check if DOS is enabled
6762+ 4A42 CD E9 18             call    CLRIOBF         ; clear I/O buffer
6763+ 4A45 CD 2D 10             call    CF_INIT         ; init CF card
6764+ 4A48 DA 56 4A             jp      C,DOS_ERR       ; error if device not available/ready
6765+ 4A4B E5                   push    HL              ; store code string pointer
6766+ 4A4C 16 01                ld      D,$01           ; print disk details and file list
6767+ 4A4E CD BD 12             call    LST_FILES       ; list files
6768+ 4A51 E1                   pop     HL              ; retrieve code string pointer
6769+ 4A52 DA 56 4A             jp      C,DOS_ERR       ; any error?
6770+ 4A55 C9                   ret                     ; return to caller
6771+ 4A56
6772+ 4A56
6773+ 4A56              ; raise a DOS error
6774+ 4A56 3A 9C 81     DOS_ERR:ld      A,(DOSER)       ; load error code
6775+ 4A59 5F                   ld      E,A             ; copy into E
6776+ 4A5A C3 DC 20             jp      ERROR           ; goto error routine
6777+ 4A5D
6778+ 4A5D
6779+ 4A5D              ; check for ",1" argument
6780+ 4A5D              ; check if 1 is passed as argument after LOAD and ERASE
6781+ 4A5D AF           CHK1AR: xor     A               ; reset A
6782+ 4A5E 32 B4 81             ld      (TPBF4),A       ; default setting
6783+ 4A61                                              ; (load=store file in RAM using current BASIC pointers
6784+ 4A61                                              ; (erase=quick delete)
6785+ 4A61 2B                   dec     HL              ; dec 'cause GETCHR increments
6786+ 4A62 CD 0B 26             call    GETCHR          ; check if something follows
6787+ 4A65 C8                   ret     Z               ; if nothing follows, return
6788+ 4A66 CD C2 23             call    CHKSYN          ; Make sure ',' follows
6789+ 4A69 2C                   defb    ','
6790+ 4A6A CD 22 33             call    GETINT          ; get a value
6791+ 4A6D 3D                   dec     A               ; decrement it
6792+ 4A6E C2 C2 20             jp      NZ,SNERR        ; not '1' - raise an error
6793+ 4A71 3C                   inc     A               ; A=1
6794+ 4A72 32 B4 81             ld      (TPBF4),A       ; load=store file in RAM using address in file
6795+ 4A75                                              ; erase=full delete
6796+ 4A75 C9                   ret                     ; return to caller
6797+ 4A76
6798+ 4A76
6799+ 4A76              ; ERASE "filename"
6800+ 4A76              ; erase a file from disk
6801+ 4A76 CD CA 48     ERASE:  call    CHKDOS          ; check if DOS is enabled
6802+ 4A79 CD 05 4C             call    CHKFLNM         ; check for a disk name
6803+ 4A7C CD 5D 4A             call    CHK1AR          ; check for ",1" argument
6804+ 4A7F E5                   push    HL              ; store code string pointer
6805+ 4A80 21 A3 4A             ld      HL,ERSTX        ; Point to message
6806+ 4A83 CD A4 2F             call    PRS             ; print message for init confirmation
6807+ 4A86 E1                   pop     HL              ; retrieve HL
6808+ 4A87 CD E0 4B             call    CNFREQ          ; ask for confirmation
6809+ 4A8A 38 33                jr      C,ABRTDS        ; if Carry set then abort
6810+ 4A8C CD 2D 10             call    CF_INIT         ; init CF card
6811+ 4A8F DA 56 4A             jp      C,DOS_ERR       ; error if device not available/ready
6812+ 4A92 E5                   push    HL              ; store code string pointer
6813+ 4A93 CD 56 16             call    FIL_ERASE       ; deleted file
6814+ 4A96 E1                   pop     HL              ; retrieve code string pointer
6815+ 4A97 DA 56 4A             jp      C,DOS_ERR       ; leave if error
6816+ 4A9A E5                   push    HL              ; store HL
6817+ 4A9B 21 B1 4A             ld      HL,ERASED       ; point to message of file deleted
6818+ 4A9E CD A4 2F             call    PRS             ; print it
6819+ 4AA1 E1                   pop     HL              ; retrieve HL
6820+ 4AA2 C9                   ret                     ; return to caller
6821+ 4AA3 44 65 6C 65  ERSTX:  defb    "Delete file? ",0
6821+ 4AA7 74 65 20 66
6821+ 4AAB 69 6C 65 3F
6821+ 4AAF 20 00
6822+ 4AB1 46 69 6C 65  ERASED: defb    "File deleted",CR,0
6822+ 4AB5 20 64 65 6C
6822+ 4AB9 65 74 65 64
6822+ 4ABD 0D 00
6823+ 4ABF
6824+ 4ABF
6825+ 4ABF              ; disk operation aborted
6826+ 4ABF 3E 01        ABRTDS: ld      A,$01           ; re-enable...
6827+ 4AC1 32 02 82             ld      (PRNTVIDEO),A   ; ...print-on-video
6828+ 4AC4 E5                   push    HL              ; store code string pointer
6829+ 4AC5 21 CD 4A             ld      HL,ABRTXT       ; Point to message
6830+ 4AC8 CD A4 2F             call    PRS             ; print message for leaving init procedure
6831+ 4ACB E1                   pop     HL              ; retrieve code string pointer
6832+ 4ACC C9                   ret                     ; return to caller
6833+ 4ACD 0D 41 62 6F  ABRTXT: defb    CR,"Aborted",0
6833+ 4AD1 72 74 65 64
6833+ 4AD5 00
6834+ 4AD6
6835+ 4AD6
6836+ 4AD6               ; DISK command -------
6837+ 4AD6              ; execute several operations on a disk:
6838+ 4AD6              ; "F": format/rewrite Master Sector
6839+ 4AD6              ; "R": rename disk
6840+ 4AD6              ; syntax: DISK "arg1"[,arg2][,1]
6841+ 4AD6              TPHL:   equ     TMPDBF          ; temp. buffer for code string pointer
6842+ 4AD6 CD 36 47     DISK:   call    DIRMOD          ; can be executed ONLY in direct mode
6843+ 4AD9 C2 D7 20             jp      NZ,IMERR        ; raise error if in indirect mode
6844+ 4ADC CD CA 48             call    CHKDOS          ; check if DOS is enabled
6845+ 4ADF                      ; check first argument
6846+ 4ADF 2B                   dec     HL              ; dec 'cause GETCHR increments
6847+ 4AE0 CD 0B 26             call    GETCHR          ; check if something follows
6848+ 4AE3 CA C2 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
6849+ 4AE6 CD AE 2A             call    EVAL            ; Evaluate expression
6850+ 4AE9 CD A0 2A             call    TSTSTR          ; Make sure it's a string
6851+ 4AEC 22 9D 81             ld      (TPHL),HL       ; store code string pointer into a temp buffer
6852+ 4AEF CD E7 30             call    GSTRCU          ; check that a string follows
6853+ 4AF2 CD F8 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
6854+ 4AF5 7B                   ld      A,E
6855+ 4AF6 3D                   dec     A               ; lenght must be = 1
6856+ 4AF7 2A 9D 81             ld      HL,(TPHL)       ; retrieve code string pointer
6857+ 4AFA C2 C2 20             jp      NZ,SNERR
6858+ 4AFD 0A                   ld      A,(BC)          ; load command
6859+ 4AFE E6 5F                and     %01011111       ; Force upper case
6860+ 4B00 FE 46                cp      'F'             ; format command?
6861+ 4B02 CA 12 4B             jp      Z,DSKFRM        ; yes, format disk
6862+ 4B05 FE 52                cp      'R'             ; rename command?
6863+ 4B07 CA AE 4B             jp      Z,DSKRNM        ; yes, rename disk
6864+ 4B0A FE 55                cp      'U'             ; undelete command?
6865+ 4B0C CA A1 4B             jp      Z,DSKUND        ; yes undelete files
6866+ 4B0F C3 C2 20             jp      SNERR           ; nothing more - raise a syntax error
6867+ 4B12
6868+ 4B12
6869+ 4B12              ; Format disk or rewrite Master sector
6870+ 4B12              ; syntax: DISK "F","disk name"[,1]
6871+ 4B12              ; "disk name" is the name -> max 16 chars, allowed chars: "A" to "Z", "0" to "9","-", SPACE
6872+ 4B12              ; ",1": just rewrite Master sector without overwriting current directory
6873+ 4B12              ; Format: set up a fresh new file system, re-writing the Master sector and
6874+ 4B12              ; initializing the directory
6875+ 4B12              ; Master Sector rewriting: re-initialize the Master Sector, writing a new disk name and
6876+ 4B12              ; re-calculating disk geometry
6877+ 4B12              DKNMPT: equ     TMPBFR2         ; store the pointer to the disk name string
6878+ 4B12              DKLNPT: equ     TMPBFR3         ; store the pointer to the lenght of disk name string
6879+ 4B12 CD C2 23     DSKFRM: call    CHKSYN          ; Make sure ',' follows
6880+ 4B15 2C                   defb    ','
6881+ 4B16 CD 05 4C             call    CHKFLNM         ; check for file name
6882+ 4B19 CD 5D 4A             call    CHK1AR          ; check if ",1" follows - saved into A
6883+ 4B1C 11 5C 4B             ld      DE,MSTTXT       ; format message
6884+ 4B1F B7                   or      A               ; A=0?
6885+ 4B20 20 03                jr      NZ,CFINIT       ; no, jump over
6886+ 4B22 11 74 4B             ld      DE,FRMTXT       ; only Master Sector
6887+ 4B25 E5           CFINIT: push    HL              ; store code string pointer
6888+ 4B26 62                   ld      H,D             ; Point to message
6889+ 4B27 6B                   ld      L,E
6890+ 4B28 CD A4 2F             call    PRS             ; print message for confirmation
6891+ 4B2B E1                   pop     HL              ; retrieve HL
6892+ 4B2C CD E0 4B             call    CNFREQ          ; ask for confirmation
6893+ 4B2F DA BF 4A             jp      C,ABRTDS        ; if Carry set then abort
6894+ 4B32 CD 2D 10     INITDSK:call    CF_INIT         ; init CF card
6895+ 4B35 DA 56 4A             jp      C,DOS_ERR       ; error if device not available/ready
6896+ 4B38 E5                   push    HL              ; store code string pointer
6897+ 4B39 CD 0D 11             call    DSK_INIT        ; init disk
6898+ 4B3C E1                   pop     HL              ; retrieve code string pointer
6899+ 4B3D DA 56 4A             jp      C,DOS_ERR       ; if Carry set, raise error
6900+ 4B40 E5           INITFN: push    HL              ; store code string pointer
6901+ 4B41 3A 06 82             ld      A,(TMPBFR1)
6902+ 4B44 B7                   or      A               ; full formatting?
6903+ 4B45 20 0D                jr      NZ,MSPTOK       ; no
6904+ 4B47 21 8C 4B             ld      HL,OPRCMP       ; yes, Point to message
6905+ 4B4A CD A4 2F             call    PRS             ; print message for init confirmation
6906+ 4B4D 16 00                ld      D,$00           ; print only disk details, no file list
6907+ 4B4F CD BD 12             call    LST_FILES       ; print details of disk and list files
6908+ 4B52 E1                   pop     HL              ; retrieve code string pointer
6909+ 4B53 C9                   ret                     ; return to caller
6910+ 4B54 21 8C 4B     MSPTOK: ld      HL,OPRCMP       ; format OK message
6911+ 4B57 CD A4 2F             call    PRS             ; print message for init confirmation
6912+ 4B5A E1                   pop     HL              ; retrieve code string pointer
6913+ 4B5B C9                   ret                     ; return to caller
6914+ 4B5C 52 65 77 72  MSTTXT: defb    "Rewrite Master Sector? ",0
6914+ 4B60 69 74 65 20
6914+ 4B64 4D 61 73 74
6914+ 4B68 65 72 20 53
6914+ 4B6C 65 63 74 6F
6914+ 4B70 72 3F 20 00
6915+ 4B74 57 41 52 4E  FRMTXT: defb    "WARNING!! Format disk? ",0
6915+ 4B78 49 4E 47 21
6915+ 4B7C 21 20 46 6F
6915+ 4B80 72 6D 61 74
6915+ 4B84 20 64 69 73
6915+ 4B88 6B 3F 20 00
6916+ 4B8C 4F 70 65 72  OPRCMP: defb    "Operation completed",CR,0
6916+ 4B90 61 74 69 6F
6916+ 4B94 6E 20 63 6F
6916+ 4B98 6D 70 6C 65
6916+ 4B9C 74 65 64 0D
6916+ 4BA0 00
6917+ 4BA1
6918+ 4BA1
6919+ 4BA1              ; undelete files
6920+ 4BA1              ; look for files marked as "deleted" and undelete them
6921+ 4BA1 2B           DSKUND: dec     HL              ; dec 'cause GETCHR increments
6922+ 4BA2 CD 0B 26             call    GETCHR          ; check if something follows
6923+ 4BA5 C2 C2 20             jp      NZ,SNERR        ; if something else, raise a syntax error
6924+ 4BA8 E5                   push    HL              ; store code string pointer
6925+ 4BA9 CD 13 17             call    DSKUNDFL        ; undelete files
6926+ 4BAC E1                   pop     HL              ; retrieve code string pointer
6927+ 4BAD C9                   ret                     ; return to caller
6928+ 4BAE
6929+ 4BAE
6930+ 4BAE              ; disk rename
6931+ 4BAE              ; change the name of the disk w/o altering anything else
6932+ 4BAE CD C2 23     DSKRNM: call    CHKSYN          ; Make sure ',' follows
6933+ 4BB1 2C                   defb    ','
6934+ 4BB2 CD 05 4C             call    CHKFLNM         ; check for file name
6935+ 4BB5 E5                   push    HL              ; store code string pointer
6936+ 4BB6 21 D2 4B             ld      HL,RNDKTX       ; Point to message
6937+ 4BB9 CD A4 2F             call    PRS             ; print message for confirmation
6938+ 4BBC E1                   pop     HL              ; retrieve HL
6939+ 4BBD CD E0 4B             call    CNFREQ          ; ask for confirmation
6940+ 4BC0 DA BF 4A             jp      C,ABRTDS        ; if Carry set then abort
6941+ 4BC3 CD 2D 10             call    CF_INIT         ; init CF card
6942+ 4BC6 DA 56 4A             jp      C,DOS_ERR       ; error if device not available/ready
6943+ 4BC9 E5                   push    HL              ; store code string pointer
6944+ 4BCA CD 41 12             call    DSK_RNM         ; init disk
6945+ 4BCD E1                   pop     HL              ; retrieve code string pointer
6946+ 4BCE DA 56 4A             jp      C,DOS_ERR       ; DOS error
6947+ 4BD1 C9                   ret
6948+ 4BD2 52 65 6E 61  RNDKTX: defb    "Rename disk? ",0
6948+ 4BD6 6D 65 20 64
6948+ 4BDA 69 73 6B 3F
6948+ 4BDE 20 00
6949+ 4BE0
6950+ 4BE0
6951+ 4BE0              ; confirmation required by the user ('y' or 'Y' DO confirm, otherwise DON'T)
6952+ 4BE0 CD 44 09     CNFREQ: call    CURSOR_ON       ; enable cursor
6953+ 4BE3 AF                   xor     A
6954+ 4BE4 32 02 82             ld      (PRNTVIDEO),A   ; disable print-on-video
6955+ 4BE7 CD 2A 02             call    RXA             ; look for a pressed key
6956+ 4BEA FE 03                cp      CTRLC           ; is it RUN STOP?
6957+ 4BEC 28 15                jr      Z,CNFRQN        ; yes, abort operation
6958+ 4BEE E6 DF                and     %11011111       ; only UPPERCASE char
6959+ 4BF0 FE 59                cp      'Y'             ; 'Y'?
6960+ 4BF2 20 0F                jr      NZ,CNFRQN       ; no, abort operation
6961+ 4BF4 08                   ex      AF,AF'
6962+ 4BF5 3E 01                ld      A,$01           ; re-enable...
6963+ 4BF7 32 02 82             ld      (PRNTVIDEO),A   ; ...print-on-video
6964+ 4BFA 08                   ex      AF,AF'
6965+ 4BFB CD 1F 03             call    ECHO_CHAR       ; yes, echoes the char
6966+ 4BFE CD 59 09             call    CURSOR_OFF      ; disable cursor
6967+ 4C01 AF                   xor     A               ; reset Carry flag
6968+ 4C02 C9                   ret                     ; return to caller
6969+ 4C03 37           CNFRQN: scf                     ; set Carry flag
6970+ 4C04 C9                   ret                     ; return to caller
6971+ 4C05
6972+ 4C05
6973+ 4C05              ; check that a disk/file name follows
6974+ 4C05 2B           CHKFLNM:dec     HL              ; dec 'cause GETCHR increments
6975+ 4C06 CD 0B 26             call    GETCHR          ; check if something follows
6976+ 4C09 CA C2 20             jp      Z,SNERR         ; if nothing else, raise a syntax error
6977+ 4C0C CD AE 2A             call    EVAL            ; Evaluate expression
6978+ 4C0F CD A0 2A     CHKFN1: call    TSTSTR          ; Make sure it's a string
6979+ 4C12 22 9F 81             ld      (TMPDBF+2),HL   ; store code string pointer into a temp buffer
6980+ 4C15 CD E7 30             call    GSTRCU          ; get current string into pool
6981+ 4C18 CD F8 38             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
6982+ 4C1B 7B                   ld      A,E             ; check if lenght = 0
6983+ 4C1C A7                   and     A               ; null string?
6984+ 4C1D CA C2 20             jp      Z,SNERR         ; yes, syntax error
6985+ 4C20 ED 53 0A 82          ld      (DKLNPT),DE     ; no, store lenght
6986+ 4C24 ED 43 08 82          ld      (DKNMPT),BC     ; store address of temp string
6987+ 4C28 2A 9F 81             ld      HL,(TMPDBF+2)   ; retrieve code string pointer
6988+ 4C2B C9                   ret                     ; return to caller
6989+ 4C2C
6990+ 4C2C
6991+ 4C2C              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6992+ 4C2C CD 9F 2A     HEX: 	call	TSTNUM          ; Verify it's a number
6993+ 4C2F CD C1 26             call	DEINT           ; Get integer -32768 to 32767
6994+ 4C32 C5                   push	BC              ; Save contents of BC
6995+ 4C33 21 5F 82             ld      HL,PBUFF        ; load address of PBUFF into HL
6996+ 4C36 7A                   ld      A,D             ; Get MSB into A
6997+ 4C37 B7                   or      A               ; OR with LSB to see if param=0
6998+ 4C38 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6999+ 4C3A CD 62 4C             call    BYT2ASC         ; Convert D to ASCII
7000+ 4C3D 78                   ld      A,B             ; cechk if B
7001+ 4C3E FE 30                cp      '0'             ; is 0
7002+ 4C40 28 02                jr      Z,HEX1          ; Don't store high digit if zero
7003+ 4C42 70                   ld      (HL),B          ; Store it to PBUFF
7004+ 4C43 23                   inc     HL              ; Next location
7005+ 4C44 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
7006+ 4C45 23                   inc     HL              ; Next location
7007+ 4C46 7B           HEX2:   ld      A,E             ; Get lower byte
7008+ 4C47 CD 62 4C             call    BYT2ASC         ; Convert E to ASCII
7009+ 4C4A 7A                   ld      A,D
7010+ 4C4B B7                   or      A
7011+ 4C4C 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
7012+ 4C4E 78                   ld      A,B
7013+ 4C4F FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
7014+ 4C51 28 02                jr      Z,HEX4
7015+ 4C53 70           HEX3:   ld      (HL),B          ; to PBUFF+2
7016+ 4C54 23                   inc     HL              ; Next location
7017+ 4C55 71           HEX4:   ld      (HL),C          ; to PBUFF+3
7018+ 4C56 23                   inc     HL              ; PBUFF+4 to zero
7019+ 4C57 AF                   xor     A               ; Terminating character
7020+ 4C58 77                   ld      (HL),A          ; Store zero to terminate
7021+ 4C59 23                   inc     HL              ; Make sure PBUFF is terminated
7022+ 4C5A 77                   ld      (HL),A          ; Store the double zero there
7023+ 4C5B C1                   pop     BC              ; Get BC back
7024+ 4C5C 21 5F 82             ld      HL,PBUFF        ; Reset to start of PBUFF
7025+ 4C5F C3 34 2F             jp      STR1            ; Convert the PBUFF to a string and return it
7026+ 4C62 47           BYT2ASC:ld      B,A             ; Save original value
7027+ 4C63 E6 0F                and     $0F             ; Strip off upper nybble
7028+ 4C65 FE 0A                cp      $0A             ; 0-9?
7029+ 4C67 38 02                jr      C,ADD30         ; If A-F, add 7 more
7030+ 4C69 C6 07                add     A,$07           ; Bring value up to ASCII A-F
7031+ 4C6B C6 30        ADD30:  add     A,$30           ; And make ASCII
7032+ 4C6D 4F                   ld      C,A             ; Save converted char to C
7033+ 4C6E 78                   ld      A,B             ; Retrieve original value
7034+ 4C6F 0F                   rrca                    ; and Rotate it right
7035+ 4C70 0F                   rrca
7036+ 4C71 0F                   rrca
7037+ 4C72 0F                   rrca
7038+ 4C73 E6 0F                and     $0F             ; Mask off upper nybble
7039+ 4C75 FE 0A                cp      $0A             ; 0-9? < A hex?
7040+ 4C77 38 02                jr      C,ADD301        ; Skip Add 7
7041+ 4C79 C6 07                add     A,$07           ; Bring it up to ASCII A-F
7042+ 4C7B C6 30        ADD301: add     A,$30           ; And make it full ASCII
7043+ 4C7D 47                   ld      B,A             ; Store high order byte
7044+ 4C7E C9                   ret
7045+ 4C7F
7046+ 4C7F              ; Convert "&Hnnnn" to FPREG
7047+ 4C7F              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
7048+ 4C7F              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
7049+ 4C7F EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
7050+ 4C80 21 00 00             ld      HL,$0000        ; Zero out the value
7051+ 4C83 CD 98 4C             call    GETHEX          ; Check the number for valid hex
7052+ 4C86 DA B8 4C             jp      C,HXERR         ; First value wasn't hex, HX error
7053+ 4C89 18 05                jr      HEXLP1          ; Convert first character
7054+ 4C8B CD 98 4C     HEXLP:  call    GETHEX          ; Get second and addtional characters
7055+ 4C8E 38 1F                jr      C,HEXIT         ; Exit if not a hex character
7056+ 4C90 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
7057+ 4C91 29                   add     HL,HL
7058+ 4C92 29                   add     HL,HL
7059+ 4C93 29                   add     HL,HL
7060+ 4C94 B5                   or      L               ; Add in D0-D3 into L
7061+ 4C95 6F                   ld      L,A             ; Save new value
7062+ 4C96 18 F3                jr      HEXLP           ; And continue until all hex characters are in
7063+ 4C98
7064+ 4C98 13           GETHEX: inc     DE              ; Next location
7065+ 4C99 1A                   ld      A,(DE)          ; Load character at pointer
7066+ 4C9A FE 20                cp      SPC
7067+ 4C9C CA 98 4C             jp      Z,GETHEX        ; Skip spaces
7068+ 4C9F D6 30                sub     $30             ; Get absolute value
7069+ 4CA1 D8                   ret     C               ; < "0", error
7070+ 4CA2 FE 0A                cp      $0A
7071+ 4CA4 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
7072+ 4CA6 D6 07                sub     $07             ; Reduce to A-F
7073+ 4CA8 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
7074+ 4CAA D8                   ret     C               ; CY set if was :            ; < = > ? @
7075+ 4CAB FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
7076+ 4CAD 3F                   ccf
7077+ 4CAE C9                   ret                     ; CY set if it wasn't valid hex
7078+ 4CAF
7079+ 4CAF EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
7080+ 4CB0 7A                   ld      A,D             ; Load DE into AC
7081+ 4CB1 4B                   ld      C,E             ; For prep to
7082+ 4CB2 E5                   push    HL
7083+ 4CB3 CD 85 2E             call    ACPASS          ; ACPASS to set AC as integer into FPREG
7084+ 4CB6 E1                   pop     HL
7085+ 4CB7 C9                   ret
7086+ 4CB8
7087+ 4CB8 DD 5C        HXERR:  ld      E,HX            ; ?HEX Error
7088+ 4CBA C3 DC 20             jp      ERROR
7089+ 4CBD
7090+ 4CBD              ; BIN$(NN) Convert integer to a 1-16 char binary string
7091+ 4CBD CD 9F 2A     BIN:    call    TSTNUM          ; Verify it's a number
7092+ 4CC0 CD C1 26             call    DEINT           ; Get integer -32768 to 32767
7093+ 4CC3 C5           BIN2:   push    BC              ; Save contents of BC
7094+ 4CC4 21 5F 82             ld      HL,PBUFF
7095+ 4CC7 06 11                ld      B,$11           ; One higher than max char count (16+1)
7096+ 4CC9              ZEROSUP:                        ; Suppress leading zeros
7097+ 4CC9 05                   dec     B               ; Max 16 chars
7098+ 4CCA 78                   ld      A,B
7099+ 4CCB FE 01                cp      $01
7100+ 4CCD 28 08                jr      Z,BITOUT        ; Always output at least one character
7101+ 4CCF CB 13                rl      E
7102+ 4CD1 CB 12                rl      D
7103+ 4CD3 30 F4                jr      NC,ZEROSUP
7104+ 4CD5 18 04                jr      BITOUT2
7105+ 4CD7 CB 13        BITOUT: rl      E
7106+ 4CD9 CB 12                rl      D               ; Top bit now in carry
7107+ 4CDB 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
7108+ 4CDD CE 00                adc     A,$00           ; If carry set then '0' --> '1'
7109+ 4CDF 77                   ld      (HL),A
7110+ 4CE0 23                   inc     HL
7111+ 4CE1 05                   dec     B
7112+ 4CE2 20 F3                jr      NZ,BITOUT
7113+ 4CE4 AF                   xor     A               ; Terminating character
7114+ 4CE5 77                   ld      (HL),A          ; Store zero to terminate
7115+ 4CE6 23                   inc     HL              ; Make sure PBUFF is terminated
7116+ 4CE7 77                   ld      (HL),A          ; Store the double zero there
7117+ 4CE8 C1                   pop     BC
7118+ 4CE9 21 5F 82             ld      HL,PBUFF
7119+ 4CEC C3 34 2F             jp      STR1
7120+ 4CEF
7121+ 4CEF              ; Convert "&Bnnnn" to FPREG
7122+ 4CEF              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
7123+ 4CEF EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
7124+ 4CF0 21 00 00             ld      HL,$0000        ; Zero out the value
7125+ 4CF3 CD 0C 4D             call    CHKBIN          ; Check the number for valid bin
7126+ 4CF6 DA 1A 4D             jp      C,BINERR        ; First value wasn't bin, HX error
7127+ 4CF9 D6 30        BINIT:  sub     '0'
7128+ 4CFB 29                   add     HL,HL           ; Rotate HL left
7129+ 4CFC B5                   or      L
7130+ 4CFD 6F                   ld      L,A
7131+ 4CFE CD 0C 4D             call    CHKBIN          ; Get second and addtional characters
7132+ 4D01 30 F6                jr      NC,BINIT        ; Process if a bin character
7133+ 4D03 EB                   ex      DE,HL           ; Value into DE, Code string into HL
7134+ 4D04 7A                   ld      A,D             ; Load DE into AC
7135+ 4D05 4B                   ld      C,E             ; For prep to
7136+ 4D06 E5                   push    HL
7137+ 4D07 CD 85 2E             call    ACPASS          ; ACPASS to set AC as integer into FPREG
7138+ 4D0A E1                   pop     HL
7139+ 4D0B C9                   ret
7140+ 4D0C
7141+ 4D0C              ; Char is in A, NC if char is 0 or 1
7142+ 4D0C 13           CHKBIN: inc     DE
7143+ 4D0D 1A                   ld      A,(DE)
7144+ 4D0E FE 20                cp      SPC
7145+ 4D10 CA 0C 4D             jp      Z,CHKBIN        ; Skip spaces
7146+ 4D13 FE 30                cp      '0'             ; Set C if < '0'
7147+ 4D15 D8                   ret     C
7148+ 4D16 FE 32                cp      '2'
7149+ 4D18 3F                   ccf                     ; Set C if > '1'
7150+ 4D19 C9                   ret
7151+ 4D1A
7152+ 4D1A 1E 28        BINERR: ld      E,BN            ; ?BIN Error
7153+ 4D1C C3 DC 20             jp      ERROR
7154+ 4D1F
7155+ 4D1F
7156+ 4D1F C3 08 00     MONOUT: jp      $0008           ; output a char
7157+ 4D22
7158+ 4D22
7159+ 4D22 CD 3D 33     RESET:  call    DISNMI          ; disable NMI vector
7160+ 4D25 3A 48 82             ld      A,(SERIALS_EN)  ; load status of serial lines
7161+ 4D28 E6 11                and     $11             ; are serial ports open?
7162+ 4D2A C4 34 45             call    NZ,RSTSERS      ; yes, reset serials
7163+ 4D2D 3A 4B 82             ld      A,(DOS_EN)      ; is DOS enabled
7164+ 4D30 A7                   and     A               ; if enabled, A<>0
7165+ 4D31 C4 A5 10             call    NZ,CF_STANDBY   ; put CF into standby mode
7166+ 4D34 F3                   di                      ; disable INTs
7167+ 4D35                  IFDEF LM80C64K
7168+ 4D35 ~                    jp      ROM2RAM         ; Restart
7169+ 4D35                  ELSE
7170+ 4D35 C3 00 00             jp      $0000           ; Restart
7171+ 4D38                  ENDIF
7172+ 4D38
7173+ 4D38
7174+ 4D38 3E 00        INITST: ld      A,$00           ; Clear break flag
7175+ 4D3A 32 A9 80             ld      (BRKFLG),A
7176+ 4D3D C3 B1 1B             jp      SYSINIT
7177+ 4D40
7178+ 4D40
7179+ 4D40 F5           TSTBIT: push    AF              ; Save bit mask
7180+ 4D41 A0                   and     B               ; Get common bits
7181+ 4D42 C1                   pop     BC              ; Restore bit mask
7182+ 4D43 B8                   cp      B               ; Same bit set?
7183+ 4D44 3E 00                ld      A,$00           ; Return 0 in A
7184+ 4D46 C9                   ret
7185+ 4D47
7186+ 4D47 CD CD 23     OUTNCR: call    OUTC            ; Output character in A
7187+ 4D4A C3 D8 28             jp      PRNTCRLF        ; Output CRLF
7188+ 4D4D
# file closed: ../include/basic/basic-1.08.asm
  87  4D4D
  88  4D4D              ; include utils
  89  4D4D                  INCLUDE "../include/utils/utils-r1.2.asm"
# file opened: ../include/utils/utils-r1.2.asm
   1+ 4D4D              ; ------------------------------------------------------------------------------
   2+ 4D4D              ; LM80C - UTILITY ROUTINES - R1.2
   3+ 4D4D              ; ------------------------------------------------------------------------------
   4+ 4D4D              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4D4D              ; designed by Leonardo Miliani. More info at
   6+ 4D4D              ; www DOT leonardomiliani DOT com
   7+ 4D4D              ;
   8+ 4D4D              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 4D4D              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 4D4D              ;
  11+ 4D4D              ; * WKT are routines from WikiTI:
  12+ 4D4D              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 4D4D              ;
  14+ 4D4D              ; * LAC are routines from Learn@Cemetch
  15+ 4D4D              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 4D4D              ;
  17+ 4D4D              ; ------------------------------------------------------------------------------
  18+ 4D4D              ; Code Revision:
  19+ 4D4D              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 4D4D              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 4D4D              ; R1.2 - 20200131 - Added 32/16 bit multiplication/division and converter to
  22+ 4D4D              ;                   transform a 32-bit value into ASCII representation
  23+ 4D4D              ;
  24+ 4D4D              ; ------------------------------------------------------------------------------
  25+ 4D4D
  26+ 4D4D              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  27+ 4D4D              ; values can be both signed or unsigned words
  28+ 4D4D              ; inputs: HL, DE
  29+ 4D4D              ; destroys: A,F,HL
  30+ 4D4D              ;
  31+ 4D4D              ; returns: Z=1 if HL = DE
  32+ 4D4D              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  33+ 4D4D              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  34+ 4D4D              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  35+ 4D4D              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  36+ 4D4D              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  37+ 4D4D              ; Source: ALS
  38+ 4D4D
  39+ 4D4D B7           CMP16:  or      A           ; clear CARRY
  40+ 4D4E ED 52                sbc     HL,DE       ; subtract DE from HL
  41+ 4D50 E0                   ret     PO          ; return if no overflow
  42+ 4D51 7C                   ld      A,H         ; overflow - invert SIGN flag
  43+ 4D52 1F                   rra                 ; save CARRY flag in bit 7
  44+ 4D53 EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  45+ 4D55 37                   scf                 ; ensure a Non-Zero result
  46+ 4D56 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  47+ 4D57                                          ; ZERO flag = 0 for sure
  48+ 4D57 C9                   ret                 ; return
  49+ 4D58
  50+ 4D58              ; ----------------------------------------------------------------------
  51+ 4D58
  52+ 4D58              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  53+ 4D58              ; signed/unsigned product
  54+ 4D58              ; inputs: HL (multiplicand); DE (multiplier)
  55+ 4D58              ; destroys: A,F
  56+ 4D58              ; returns: HL (product)
  57+ 4D58              ; Source: ALS
  58+ 4D58
  59+ 4D58              ; initialize partial product, bit count
  60+ 4D58 C5           MUL16:  push    BC
  61+ 4D59 4D                   ld      C,L         ; BC = multiplier
  62+ 4D5A 44                   ld      B,H
  63+ 4D5B 21 00 00             ld      HL,0        ; product = 0
  64+ 4D5E 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  65+ 4D60                      ; shift-and-add algorithm
  66+ 4D60                      ; if MSB of multiplier is 1, add multiplicand to partial product
  67+ 4D60                      ; shift partial product, multiplier left 1 bit
  68+ 4D60 CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  69+ 4D62 CB 12                rl      D
  70+ 4D64 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  71+ 4D66 09                   add     HL,BC       ; add multiplicand to partial product
  72+ 4D67 29           MLP1:   add     HL,HL       ; shift partial product left
  73+ 4D68 3D                   dec     A
  74+ 4D69 20 F5                jr      NZ,MLP      ; continue until count = 0
  75+ 4D6B                      ; add multiplicand one last time if MSB of multiplier is 1
  76+ 4D6B B2                   or      D           ; sign flag = MSB of multiplier
  77+ 4D6C F2 70 4D             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  78+ 4D6F 09                   add     HL,BC       ; add multiplicand to product
  79+ 4D70 C1           EXMUL16:pop     BC
  80+ 4D71 C9                   ret
  81+ 4D72
  82+ 4D72
  83+ 4D72              ; ----------------------------------------------------------------------
  84+ 4D72
  85+ 4D72              ; multiply 2 unsigned 16-bit words and return a 32-bit unsigned product
  86+ 4D72              ; inputs: BC (multiplicand); DE (multiplier)
  87+ 4D72              ; destroys: A,F
  88+ 4D72              ; operation: BC * DE
  89+ 4D72              ; returns: DEHL (product)
  90+ 4D72              ; Source: WKT
  91+ 4D72
  92+ 4D72 21 00 00     MUL_U32:ld      HL,$0000        ; reset HL
  93+ 4D75 CB 23                sla     E		; optimised 1st iteration
  94+ 4D77 CB 12                rl      D
  95+ 4D79 30 02                jr      NC,MU32_1       ; if no Carry then jump over
  96+ 4D7B 60                   ld      H,B
  97+ 4D7C 69                   ld      L,C
  98+ 4D7D 3E 0F        MU32_1: ld      A,$0F
  99+ 4D7F 29           MUL_32L:add     HL,HL           ; main loop
 100+ 4D80 CB 13                rl      E
 101+ 4D82 CB 12                rl      D
 102+ 4D84 30 04                jr      NC,MU32_2
 103+ 4D86 09                   add     HL,BC
 104+ 4D87 30 01                jr      NC,MU32_2
 105+ 4D89 13                   inc     DE
 106+ 4D8A 3D           MU32_2: dec     A
 107+ 4D8B 20 F2                jr      NZ,MUL_32L
 108+ 4D8D C9                   ret
 109+ 4D8E
 110+ 4D8E              ; ----------------------------------------------------------------------
 111+ 4D8E              ; absolute value of HL (same applies to other 16-bit register pairs)
 112+ 4D8E              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
 113+ 4D8E              ;
 114+ 4D8E              ; inputs: HL
 115+ 4D8E              ; destroys: A
 116+ 4D8E              ; operation: ABS(HL)
 117+ 4D8E              ; returns: HL with no sign or negated
 118+ 4D8E              ; Source: WKT
 119+ 4D8E
 120+ 4D8E CB 7C        absHL:  bit     7,H
 121+ 4D90 C8                   ret     Z
 122+ 4D91 AF           negHL:  xor     A
 123+ 4D92 95                   sub     L
 124+ 4D93 6F                   ld      L,A
 125+ 4D94 9F                   sbc     A,A
 126+ 4D95 94                   sub     H
 127+ 4D96 67                   ld      H,A
 128+ 4D97 C9                   ret
 129+ 4D98
 130+ 4D98              ; ------------------------------------------------------------------------------
 131+ 4D98
 132+ 4D98              ; 8/8 division
 133+ 4D98              ; INPUT: D (dividend), E (divisor)
 134+ 4D98              ; OPERATION: D/E
 135+ 4D98              ; OUTPUT: D (quotient), A (remainder)
 136+ 4D98 AF           DIV_8_8:    xor     A
 137+ 4D99 C5                       push    BC
 138+ 4D9A 06 08                    ld      B,08h
 139+ 4D9C CB 22        DIV_8_8LOOP:sla     D
 140+ 4D9E 17                       rla
 141+ 4D9F BB                       cp      E
 142+ 4DA0 38 02                    jr      C,$+4
 143+ 4DA2 93                       sub     E
 144+ 4DA3 14                       inc     D
 145+ 4DA4 10 F6                    djnz    DIV_8_8LOOP
 146+ 4DA6 C1                       pop     BC
 147+ 4DA7 C9                       ret
 148+ 4DA8
 149+ 4DA8              ; ----------------------------------------------------------------------
 150+ 4DA8              ; divide a 16-bit number by an 8-bit number
 151+ 4DA8              ; (16/8 division)
 152+ 4DA8              ;
 153+ 4DA8              ; inputs: HL (Dividend), C (divisor)
 154+ 4DA8              ; destroys: A, B
 155+ 4DA8              ; OPERATION: HL/C
 156+ 4DA8              ; returns: HL (quotient), A (remainder)
 157+ 4DA8              ; source: WKT
 158+ 4DA8
 159+ 4DA8 AF           DIV_16_8:   xor     A
 160+ 4DA9 06 10                    ld      B,16
 161+ 4DAB 29           DIV_16_8LP: add     HL,HL
 162+ 4DAC 17                       rla
 163+ 4DAD 38 03                    jr      C,$+5
 164+ 4DAF B9                       cp      C
 165+ 4DB0 38 02                    jr      C,$+4
 166+ 4DB2 91                       sub     C
 167+ 4DB3 2C                       inc     L
 168+ 4DB4 10 F5                    djnz    DIV_16_8LP
 169+ 4DB6 C9                       ret
 170+ 4DB7
 171+ 4DB7              ; ----------------------------------------------------------------------
 172+ 4DB7              ; divide a 16-bit number by a 16-bit number
 173+ 4DB7              ; (16/16 division)
 174+ 4DB7              ;
 175+ 4DB7              ; inputs: AC (Dividend), DE (divisor)
 176+ 4DB7              ; destroys: HL,A,C
 177+ 4DB7              ; OPERATION: AC/DE
 178+ 4DB7              ; returns: AC (quotient), HL (remainder)
 179+ 4DB7              ; source: WKT
 180+ 4DB7 21 00 00     DIV_16_16:  ld      HL, 0
 181+ 4DBA 06 10                    ld      B, 16
 182+ 4DBC CB 21        DV16_16_LP: sla     C
 183+ 4DBE CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 184+ 4DC0 17                       rla
 185+ 4DC1 ED 6A                    adc     HL,HL
 186+ 4DC3 ED 52                    sbc     HL,DE
 187+ 4DC5 30 02                    jr      NC, $+4
 188+ 4DC7 19                       add     HL,DE
 189+ 4DC8 0D                       dec     C
 190+ 4DC9 10 F1                    djnz    DV16_16_LP
 191+ 4DCB C9                       ret
 192+ 4DCC
 193+ 4DCC
 194+ 4DCC              ; ----------------------------------------------------------------------
 195+ 4DCC              ; divide a 32-bit number by a 16 bit-number
 196+ 4DCC              ; (32/16 division)
 197+ 4DCC              ;
 198+ 4DCC              ; inputs: ACIX (Dividend), DE (divisor)
 199+ 4DCC              ; destroys: HL,IX,BC
 200+ 4DCC              ; OPERATION: ACIX/DE
 201+ 4DCC              ; returns: ACIX (quotient), HL (remainder)
 202+ 4DCC              ; source: WKT
 203+ 4DCC
 204+ 4DCC 21 00 00     DIV_32_16:  ld      HL,0
 205+ 4DCF 06 20                    ld      B,32
 206+ 4DD1 DD 29        DIV_32_16LP:add     IX,IX
 207+ 4DD3 CB 11                    rl      C
 208+ 4DD5 17                       rla
 209+ 4DD6 ED 6A                    adc     HL,HL
 210+ 4DD8 38 08                    jr      C,DIV_32_16OF
 211+ 4DDA ED 52                    sbc     HL,DE
 212+ 4DDC 30 07                    jr      NC,DIV_32_16SB
 213+ 4DDE 19                       add     HL,DE
 214+ 4DDF 10 F0                    djnz    DIV_32_16LP
 215+ 4DE1 C9                       ret
 216+ 4DE2 B7           DIV_32_16OF:or      A                   ; overflow
 217+ 4DE3 ED 52                    sbc     HL,DE
 218+ 4DE5 DD 23        DIV_32_16SB:inc     IX                  ; set bit
 219+ 4DE7 10 E8                    djnz    DIV_32_16LP
 220+ 4DE9 C9                       ret
 221+ 4DEA
 222+ 4DEA
 223+ 4DEA              ; ----------------------------------------------------------------------
 224+ 4DEA              ; convert a 32-bit number in ASCII string (terminated by '0')
 225+ 4DEA              ;
 226+ 4DEA              ; inputs: DEIX (Value), IY (dest. address in memory)
 227+ 4DEA              ; destroys: AF, BC, DE, HL, IX
 228+ 4DEA              ; outputs: IY (last char in dest. string)
 229+ 4DEA              ; source: MSX Forum
 230+ 4DEA
 231+ 4DEA 01 00 00 00  CLCN32T:    defw    1,0,10,0,100,0,1000,0,10000,0
 231+ 4DEE 0A 00 00 00
 231+ 4DF2 64 00 00 00
 231+ 4DF6 E8 03 00 00
 231+ 4DFA 10 27 00 00
 232+ 4DFE A0 86 01 00              defw    $86A0,$1,$4240,$F,$9680,$98,$E100,$5F5,$CA00,$3B9A
 232+ 4E02 40 42 0F 00
 232+ 4E06 80 96 98 00
 232+ 4E0A 00 E1 F5 05
 232+ 4E0E 00 CA 9A 3B
 233+ 4E12 00 00 00 00  CLCN32Z:    defs    4
 234+ 4E16
 235+ 4E16 DD 22 12 4E  CLCN32:     ld      (CLCN32Z),IX
 236+ 4E1A ED 53 14 4E              ld      (CLCN32Z+$02),DE
 237+ 4E1E DD 21 0E 4E              ld      IX,CLCN32T+$24
 238+ 4E22 06 09                    ld      B,$09
 239+ 4E24 0E 00                    ld      C,$00
 240+ 4E26 3E 30        CLCN321:    ld      A,"0"
 241+ 4E28 B7                       or      A
 242+ 4E29 DD 5E 00     CLCN322:    ld      E,(IX+$00)
 243+ 4E2C DD 56 01                 ld      D,(IX+$01)
 244+ 4E2F 2A 12 4E                 ld      HL,(CLCN32Z)
 245+ 4E32 ED 52                    sbc     HL,DE
 246+ 4E34 22 12 4E                 ld      (CLCN32Z),HL
 247+ 4E37 DD 5E 02                 ld      E,(IX+$02)
 248+ 4E3A DD 56 03                 ld      D,(IX+$03)
 249+ 4E3D 2A 14 4E                 ld      HL,(CLCN32Z+$02)
 250+ 4E40 ED 52                    sbc     HL,DE
 251+ 4E42 22 14 4E                 ld      (CLCN32Z+$02),HL
 252+ 4E45 38 04                    jr      C,CLCN325
 253+ 4E47 0C                       inc     C
 254+ 4E48 3C                       inc     A
 255+ 4E49 18 DE                    jr      CLCN322
 256+ 4E4B DD 5E 00     CLCN325:    ld      E,(IX+$00)
 257+ 4E4E DD 56 01                 ld      D,(IX+$01)
 258+ 4E51 2A 12 4E                 ld      HL,(CLCN32Z)
 259+ 4E54 19                       add     HL,DE
 260+ 4E55 22 12 4E                 ld      (CLCN32Z),HL
 261+ 4E58 DD 5E 02                 ld      E,(IX+$02)
 262+ 4E5B DD 56 03                 ld      D,(IX+$03)
 263+ 4E5E 2A 14 4E                 ld      HL,(CLCN32Z+$02)
 264+ 4E61 ED 5A                    adc     HL,DE
 265+ 4E63 22 14 4E                 ld      (CLCN32Z+$02),HL
 266+ 4E66 11 FC FF                 ld      DE,-4
 267+ 4E69 DD 19                    add     IX,DE
 268+ 4E6B 0C                       inc     C
 269+ 4E6C 0D                       dec     C
 270+ 4E6D 28 05                    jr      Z,CLCN323
 271+ 4E6F FD 77 00                 ld      (IY+$00),A
 272+ 4E72 FD 23                    inc     IY
 273+ 4E74 10 B0        CLCN323:    djnz    CLCN321
 274+ 4E76 3A 12 4E                 ld      A,(CLCN32Z)
 275+ 4E79 C6 30                    add     "0"
 276+ 4E7B FD 77 00                 ld      (IY+$00),A
 277+ 4E7E FD 36 01 00              ld      (IY+$01),0
 278+ 4E82 C9                       ret
# file closed: ../include/utils/utils-r1.2.asm
  90  4E83
  91  4E83              ; include the latest version of the font sets
  92  4E83                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 4E83              ; ------------------------------------------------------------------------------
   2+ 4E83              ; LM80C - 6x8 CHARSET - R1.6
   3+ 4E83              ; ------------------------------------------------------------------------------
   4+ 4E83              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4E83              ; designed by Leonardo Miliani. More info at
   6+ 4E83              ; www DOT leonardomiliani DOT com
   7+ 4E83              ; ------------------------------------------------------------------------------
   8+ 4E83              ; Code Revision:
   9+ 4E83              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 4E83              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 4E83              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 4E83              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 4E83              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 4E83              ; R1.5 - 20200524 - New style for char #252
  15+ 4E83              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 4E83              ; ------------------------------------------------------------------------------
  17+ 4E83              ;
  18+ 4E83              ;-------------------------------------------------------------------------------
  19+ 4E83              ;
  20+ 4E83              ;               6 x 8    C  H  A  R  S  E  T
  21+ 4E83              ;
  22+ 4E83              ;-------------------------------------------------------------------------------
  23+ 4E83              ;
  24+ 4E83              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 4E83              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 4E83
  27+ 4E83              CHRST68 equ $
  28+ 4E83 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 4E87 00 00 00 00
  29+ 4E8B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 4E8F 00 00 00 00
  30+ 4E93 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 4E97 00 00 00 00
  31+ 4E9B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 4E9F 00 00 00 00
  32+ 4EA3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 4EA7 00 00 00 00
  33+ 4EAB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 4EAF 00 00 00 00
  34+ 4EB3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 4EB7 00 00 00 00
  35+ 4EBB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 4EBF 00 00 00 00
  36+ 4EC3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 4EC7 00 00 00 00
  37+ 4ECB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 4ECF 00 00 00 00
  38+ 4ED3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 4ED7 00 00 00 00
  39+ 4EDB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 4EDF 00 00 00 00
  40+ 4EE3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 4EE7 00 00 00 00
  41+ 4EEB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 4EEF 00 00 00 00
  42+ 4EF3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 4EF7 00 00 00 00
  43+ 4EFB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 4EFF 00 00 00 00
  44+ 4F03 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 4F07 00 00 00 00
  45+ 4F0B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 4F0F 00 00 00 00
  46+ 4F13 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 4F17 00 00 00 00
  47+ 4F1B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 4F1F 00 00 00 00
  48+ 4F23 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 4F27 00 00 00 00
  49+ 4F2B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 4F2F 00 00 00 00
  50+ 4F33 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 4F37 00 00 00 00
  51+ 4F3B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 4F3F 00 00 00 00
  52+ 4F43 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 4F47 00 00 00 00
  53+ 4F4B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 4F4F 00 00 00 00
  54+ 4F53 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 4F57 00 00 00 00
  55+ 4F5B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 4F5F 00 00 00 00
  56+ 4F63 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 4F67 00 00 00 00
  57+ 4F6B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 4F6F 00 00 00 00
  58+ 4F73 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 4F77 00 00 00 00
  59+ 4F7B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 4F7F 00 00 00 00
  60+ 4F83 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 4F87 00 00 00 00
  61+ 4F8B 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 4F8F 20 00 20 00
  62+ 4F93 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 4F97 00 00 00 00
  63+ 4F9B 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 4F9F F8 50 50 00
  64+ 4FA3 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 4FA7 28 F0 20 00
  65+ 4FAB C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 4FAF 40 98 18 00
  66+ 4FB3 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 4FB7 A8 90 68 00
  67+ 4FBB 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 4FBF 00 00 00 00
  68+ 4FC3 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 4FC7 40 20 10 00
  69+ 4FCB 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 4FCF 10 20 40 00
  70+ 4FD3 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 4FD7 A8 20 00 00
  71+ 4FDB 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 4FDF 20 20 00 00
  72+ 4FE3 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 4FE7 60 20 40 00
  73+ 4FEB 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 4FEF 00 00 00 00
  74+ 4FF3 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 4FF7 00 60 60 00
  75+ 4FFB 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 4FFF 40 80 00 00
  76+ 5003 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 5007 C8 88 70 00
  77+ 500B 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 500F 20 20 70 00
  78+ 5013 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 5017 20 40 F8 00
  79+ 501B F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 501F 08 88 70 00
  80+ 5023 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 5027 F8 10 10 00
  81+ 502B F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 502F 08 88 70 00
  82+ 5033 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 5037 88 88 70 00
  83+ 503B F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 503F 40 40 40 00
  84+ 5043 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 5047 88 88 70 00
  85+ 504B 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 504F 08 10 60 00
  86+ 5053 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 5057 30 30 00 00
  87+ 505B 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 505F 30 10 20 00
  88+ 5063 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 5067 40 20 10 00
  89+ 506B 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 506F F8 00 00 00
  90+ 5073 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 5077 10 20 40 00
  91+ 507B 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 507F 20 00 20 00
  92+ 5083 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 5087 A8 A8 70 00
  93+ 508B 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 508F F8 88 88 00
  94+ 5093 F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 5097 88 88 F0 00
  95+ 509B 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 509F 80 88 70 00
  96+ 50A3 E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 50A7 88 90 E0 00
  97+ 50AB F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 50AF 80 80 F8 00
  98+ 50B3 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 50B7 80 80 80 00
  99+ 50BB 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 50BF 88 88 78 00
 100+ 50C3 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 50C7 88 88 88 00
 101+ 50CB 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 50CF 20 20 70 00
 102+ 50D3 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 50D7 10 90 60 00
 103+ 50DB 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 50DF A0 90 88 00
 104+ 50E3 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 50E7 80 80 F8 00
 105+ 50EB 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 50EF 88 88 88 00
 106+ 50F3 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 50F7 88 88 88 00
 107+ 50FB 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 50FF 88 88 70 00
 108+ 5103 F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 5107 80 80 80 00
 109+ 510B 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 510F A8 90 68 00
 110+ 5113 F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 5117 A0 90 88 00
 111+ 511B 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 511F 08 08 F0 00
 112+ 5123 F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 5127 20 20 20 00
 113+ 512B 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 512F 88 88 70 00
 114+ 5133 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 5137 88 50 20 00
 115+ 513B 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 513F A8 A8 50 00
 116+ 5143 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 5147 50 88 88 00
 117+ 514B 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 514F 20 20 20 00
 118+ 5153 F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 5157 40 80 F8 00
 119+ 515B 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 515F 40 40 70 00
 120+ 5163 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 5167 10 08 00 00
 121+ 516B 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 516F 10 10 70 00
 122+ 5173 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 5177 00 00 00 00
 123+ 517B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 517F 00 00 00 FC
 124+ 5183 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 5187 00 00 00 00
 125+ 518B 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 518F 78 88 78 00
 126+ 5193 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 5197 C8 88 F0 00
 127+ 519B 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 519F 80 88 70 00
 128+ 51A3 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 51A7 98 88 78 00
 129+ 51AB 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 51AF F8 80 70 00
 130+ 51B3 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 51B7 40 40 40 00
 131+ 51BB 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 51BF 78 08 70 00
 132+ 51C3 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 51C7 88 88 88 00
 133+ 51CB 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 51CF 20 20 20 00
 134+ 51D3 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 51D7 08 88 70 00
 135+ 51DB 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 51DF C0 A0 90 00
 136+ 51E3 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 51E7 20 20 70 00
 137+ 51EB 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 51EF A8 88 88 00
 138+ 51F3 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 51F7 88 88 88 00
 139+ 51FB 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 51FF 88 88 70 00
 140+ 5203 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 5207 F0 80 80 00
 141+ 520B 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 520F 78 08 08 00
 142+ 5213 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 5217 80 80 80 00
 143+ 521B 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 521F 70 08 F0 00
 144+ 5223 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 5227 40 48 30 00
 145+ 522B 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 522F 88 98 68 00
 146+ 5233 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 5237 88 50 20 00
 147+ 523B 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 523F A8 A8 50 00
 148+ 5243 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 5247 20 50 88 00
 149+ 524B 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 524F 68 08 70 00
 150+ 5253 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 5257 20 40 F8 00
 151+ 525B 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 525F 20 20 10 00
 152+ 5263 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 5267 20 20 20 00
 153+ 526B 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 526F 10 10 20 00
 154+ 5273 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 5277 00 00 00 00
 155+ 527B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 527F 00 00 00 00
 156+ 5283 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 5287 B4 84 78 00
 157+ 528B 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 528F B4 CC 78 00
 158+ 5293 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 5297 FC 78 30 00
 159+ 529B 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 529F F8 70 20 00
 160+ 52A3 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 52A7 A8 20 70 00
 161+ 52AB 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 52AF A8 20 70 00
 162+ 52B3 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 52B7 FC 30 30 30
 163+ 52BB 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 52BF 3C 30 30 30
 164+ 52C3 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 52C7 F0 30 30 30
 165+ 52CB 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 52CF F0 00 00 00
 166+ 52D3 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 52D7 3C 00 00 00
 167+ 52DB 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 52DF FC 00 00 00
 168+ 52E3 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 52E7 3C 30 30 30
 169+ 52EB 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 52EF FC 30 30 30
 170+ 52F3 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 52F7 F0 30 30 30
 171+ 52FB 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 52FF FC 00 00 00
 172+ 5303 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 5307 30 30 30 30
 173+ 530B 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 530F 70 60 E0 C0
 174+ 5313 C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 5317 38 18 1C 0C
 175+ 531B CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 531F 30 78 CC CC
 176+ 5323 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 5327 20 20 20 20
 177+ 532B 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 532F 20 20 20 20
 178+ 5333 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 5337 20 20 20 20
 179+ 533B 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 533F 00 00 00 00
 180+ 5343 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 5347 00 00 00 00
 181+ 534B 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 534F 00 00 00 00
 182+ 5353 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 5357 20 20 20 20
 183+ 535B 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 535F 20 20 20 20
 184+ 5363 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 5367 20 20 20 20
 185+ 536B 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 536F 00 00 00 00
 186+ 5373 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 5377 20 20 20 20
 187+ 537B 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 537F 20 40 40 80
 188+ 5383 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 5387 10 08 08 04
 189+ 538B 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 538F 30 48 48 84
 190+ 5393 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 5397 00 00 FC FC
 191+ 539B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 539F FC FC FC FC
 192+ 53A3 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 53A7 FC FC FC FC
 193+ 53AB FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 53AF 00 00 00 00
 194+ 53B3 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 53B7 00 00 00 00
 195+ 53BB FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 53BF FC FC 00 00
 196+ 53C3 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 53C7 80 80 80 80
 197+ 53CB E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 53CF E0 E0 E0 E0
 198+ 53D3 F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 53D7 F8 F8 F8 F8
 199+ 53DB 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 53DF 04 04 04 04
 200+ 53E3 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 53E7 1C 1C 1C 1C
 201+ 53EB 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 53EF 7C 7C 7C 7C
 202+ 53F3 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 53F7 84 84 84 FC
 203+ 53FB 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 53FF E0 E0 E0 E0
 204+ 5403 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 5407 1C 1C 1C 1C
 205+ 540B 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 540F 00 00 00 00
 206+ 5413 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 5417 00 00 00 00
 207+ 541B E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 541F 1C 1C 1C 1C
 208+ 5423 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 5427 E0 E0 E0 E0
 209+ 542B 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 542F 78 78 78 78
 210+ 5433 CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 5437 CC CC CC CC
 211+ 543B FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 543F 00 00 FC FC
 212+ 5443 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 5447 FC FC 00 00
 213+ 544B 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 544F 30 30 CC CC
 214+ 5453 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 5457 54 A8 54 A8
 215+ 545B 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 545F 64 30 98 CC
 216+ 5463 CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 5467 CC 64 30 98
 217+ 546B 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 546F 30 98 CC 64
 218+ 5473 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 5477 64 CC 98 30
 219+ 547B 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 547F 20 00 F8 00
 220+ 5483 C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 5487 C0 00 F8 00
 221+ 548B 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 548F 18 00 F8 00
 222+ 5493 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 5497 A0 60 20 00
 223+ 549B 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 549F 00 00 00 00
 224+ 54A3 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 54A7 70 00 00 00
 225+ 54AB 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 54AF 00 FC 00 00
 226+ 54B3 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 54B7 54 A8 00 00
 227+ 54BB 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 54BF E0 C0 80 00
 228+ 54C3 FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 54C7 00 00 00 00
 229+ 54CB 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 54CF 1C 0C 04 00
 230+ 54D3 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 54D7 00 30 78 FC
 231+ 54DB 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 54DF 20 20 20 00
 232+ 54E3 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 54E7 40 80 00 00
 233+ 54EB 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 54EF 18 10 00 00
 234+ 54F3 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 54F7 24 1C 1C 3C
 235+ 54FB 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 54FF 20 F8 70 20
 236+ 5503 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 5507 90 E0 E0 F0
 237+ 550B 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 550F 60 20 00 00
 238+ 5513 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 5517 08 04 00 00
 239+ 551B 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 551F F0 44 38 00
 240+ 5523 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 5527 28 28 28 00
 241+ 552B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 552F 1C 20 20 20
 242+ 5533 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 5537 E0 10 10 10
 243+ 553B 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 553F 00 00 00 00
 244+ 5543 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 5547 00 00 00 00
 245+ 554B 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 554F 3C 30 30 30
 246+ 5553 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 5557 F0 30 30 30
 247+ 555B 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 555F E0 00 00 00
 248+ 5563 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 5567 1C 00 00 00
 249+ 556B 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 556F 48 30 00 00
 250+ 5573 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 5577 78 30 00 00
 251+ 557B 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 557F FC 78 30 00
 252+ 5583 FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 5587 E0 C0 80 80
 253+ 558B FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 558F 1C 0C 04 04
 254+ 5593 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 5597 1C 3C 7C FC
 255+ 559B 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 559F E0 F0 F8 FC
 256+ 55A3 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 55A7 F0 E0 C0 00
 257+ 55AB 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 55AF 78 CC 00 00
 258+ 55B3 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 55B7 70 20 70 20
 259+ 55BB 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 55BF 90 90 60 00
 260+ 55C3 F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 55C7 84 84 84 FC
 261+ 55CB 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 55CF 84 84 84 FC
 262+ 55D3 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 55D7 48 48 48 78
 263+ 55DB FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 55DF FC B4 B4 FC
 264+ 55E3 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 55E7 D4 D4 00 00
 265+ 55EB 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 55EF 78 48 48 48
 266+ 55F3 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 55F7 B4 84 78 00
 267+ 55FB 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 55FF A8 80 00 00
 268+ 5603 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 5607 A0 88 70 00
 269+ 560B 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 560F 84 84 FC 00
 270+ 5613 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 5617 F0 F0 F0 00
 271+ 561B 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 561F F0 F0 F0 00
 272+ 5623 FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 5627 94 94 84 FC
 273+ 562B 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 562F 68 70 80 00
 274+ 5633 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 5637 6C 18 08 00
 275+ 563B 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 563F 20 60 E0 40
 276+ 5643 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 5647 E4 68 20 00
 277+ 564B 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 564F E0 60 20 00
 278+ 5653 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 5657 F8 FC F0 90
 279+ 565B 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 565F B4 84 78 00
 280+ 5663 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 5667 40 48 B0 00
 281+ 566B 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 566F 48 3C 84 78
 282+ 5673 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 5677 F8 00 20 00
 283+ 567B FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 567F FC FC FC FC
 284+ 5683                      ; here ends the ASCII table
 285+ 5683
# file closed: ../include/vdp/6x8fonts-r16.asm
  93  5683                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 5683              ; ------------------------------------------------------------------------------
   2+ 5683              ; LM80C - 8x8 CHARSET - R1.8
   3+ 5683              ; ------------------------------------------------------------------------------
   4+ 5683              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5683              ; designed by Leonardo Miliani. More info at
   6+ 5683              ; www DOT leonardomiliani DOT com
   7+ 5683              ; ------------------------------------------------------------------------------
   8+ 5683              ; Code Revision:
   9+ 5683              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 5683              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 5683              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 5683              ; R1.3 - 20191015 - More graphic chars
  13+ 5683              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 5683              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 5683              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 5683              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 5683              ; R1.8 - 20200524 - New style for char #252
  18+ 5683              ; ------------------------------------------------------------------------------
  19+ 5683              ;
  20+ 5683              ;-------------------------------------------------------------------------------
  21+ 5683              ;
  22+ 5683              ;               8 x 8    C  H  A  R  S  E  T
  23+ 5683              ;
  24+ 5683              ;-------------------------------------------------------------------------------
  25+ 5683              ;
  26+ 5683              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 5683
  28+ 5683              CHRST88 equ $
  29+ 5683 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 5687 00 00 00 00
  30+ 568B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 568F 00 00 00 00
  31+ 5693 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 5697 00 00 00 00
  32+ 569B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 569F 00 00 00 00
  33+ 56A3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 56A7 00 00 00 00
  34+ 56AB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 56AF 00 00 00 00
  35+ 56B3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 56B7 00 00 00 00
  36+ 56BB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 56BF 00 00 00 00
  37+ 56C3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 56C7 00 00 00 00
  38+ 56CB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 56CF 00 00 00 00
  39+ 56D3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 56D7 00 00 00 00
  40+ 56DB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 56DF 00 00 00 00
  41+ 56E3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 56E7 00 00 00 00
  42+ 56EB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 56EF 00 00 00 00
  43+ 56F3 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 56F7 00 00 00 00
  44+ 56FB 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 56FF 00 00 00 00
  45+ 5703 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 5707 00 00 00 00
  46+ 570B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 570F 00 00 00 00
  47+ 5713 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 5717 00 00 00 00
  48+ 571B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 571F 00 00 00 00
  49+ 5723 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 5727 00 00 00 00
  50+ 572B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 572F 00 00 00 00
  51+ 5733 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 5737 00 00 00 00
  52+ 573B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 573F 00 00 00 00
  53+ 5743 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 5747 00 00 00 00
  54+ 574B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 574F 00 00 00 00
  55+ 5753 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 5757 00 00 00 00
  56+ 575B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 575F 00 00 00 00
  57+ 5763 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 5767 00 00 00 00
  58+ 576B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 576F 00 00 00 00
  59+ 5773 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 5777 00 00 00 00
  60+ 577B 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 577F 00 00 00 00
  61+ 5783 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 5787 00 00 00 00
  62+ 578B 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 578F 10 00 10 00
  63+ 5793 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 5797 00 00 00 00
  64+ 579B 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 579F FE 28 28 00
  65+ 57A3 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 57A7 14 78 10 00
  66+ 57AB 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 57AF 10 26 46 00
  67+ 57B3 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 57B7 4A 44 3A 00
  68+ 57BB 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 57BF 00 00 00 00
  69+ 57C3 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 57C7 20 10 08 00
  70+ 57CB 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 57CF 08 10 20 00
  71+ 57D3 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 57D7 38 54 10 00
  72+ 57DB 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 57DF 10 10 00 00
  73+ 57E3 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 57E7 00 18 08 10
  74+ 57EB 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 57EF 00 00 00 00
  75+ 57F3 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 57F7 00 18 18 00
  76+ 57FB 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 57FF 10 20 40 00
  77+ 5803 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 5807 64 44 38 00
  78+ 580B 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 580F 10 10 7C 00
  79+ 5813 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 5817 10 20 7C 00
  80+ 581B 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 581F 04 44 38 00
  81+ 5823 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 5827 7C 08 08 00
  82+ 582B 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 582F 04 44 38 00
  83+ 5833 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 5837 44 44 38 00
  84+ 583B 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 583F 20 20 20 00
  85+ 5843 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 5847 44 44 38 00
  86+ 584B 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 584F 04 44 38 00
  87+ 5853 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 5857 18 18 00 00
  88+ 585B 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 585F 18 08 10 00
  89+ 5863 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 5867 10 08 04 00
  90+ 586B 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 586F 7E 00 00 00
  91+ 5873 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 5877 08 10 20 00
  92+ 587B 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 587F 10 00 10 00
  93+ 5883 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 5887 B8 80 84 78
  94+ 588B 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 588F 7C 44 44 00
  95+ 5893 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 5897 44 44 78 00
  96+ 589B 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 589F 40 44 38 00
  97+ 58A3 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 58A7 44 44 78 00
  98+ 58AB 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 58AF 40 40 7C 00
  99+ 58B3 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 58B7 40 40 40 00
 100+ 58BB 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 58BF 5C 44 38 00
 101+ 58C3 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 58C7 44 44 44 00
 102+ 58CB 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 58CF 10 10 38 00
 103+ 58D3 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 58D7 04 44 38 00
 104+ 58DB 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 58DF 48 44 44 00
 105+ 58E3 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 58E7 40 40 7C 00
 106+ 58EB 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 58EF 42 42 42 00
 107+ 58F3 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 58F7 44 44 44 00
 108+ 58FB 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 58FF 44 44 38 00
 109+ 5903 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 5907 78 40 40 00
 110+ 590B 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 590F 54 48 34 00
 111+ 5913 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 5917 78 48 44 00
 112+ 591B 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 591F 04 04 78 00
 113+ 5923 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 5927 10 10 10 00
 114+ 592B 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 592F 44 44 38 00
 115+ 5933 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 5937 44 28 10 00
 116+ 593B 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 593F 5A 5A 24 00
 117+ 5943 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 5947 28 44 44 00
 118+ 594B 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 594F 10 10 10 00
 119+ 5953 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 5957 20 40 7C 00
 120+ 595B 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 595F 20 20 38 00
 121+ 5963 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 5967 08 04 02 00
 122+ 596B 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 596F 08 08 38 00
 123+ 5973 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 5977 00 00 00 00
 124+ 597B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 597F 00 00 7E 00
 125+ 5983 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 5987 00 00 00 00
 126+ 598B 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 598F 3C 44 3C 00
 127+ 5993 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 5997 44 44 78 00
 128+ 599B 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 599F 40 44 38 00
 129+ 59A3 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 59A7 44 44 3C 00
 130+ 59AB 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 59AF 7C 40 38 00
 131+ 59B3 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 59B7 20 20 20 00
 132+ 59BB 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 59BF 44 3C 04 38
 133+ 59C3 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 59C7 44 44 44 00
 134+ 59CB 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 59CF 10 10 10 00
 135+ 59D3 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 59D7 08 08 48 30
 136+ 59DB 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 59DF 60 50 48 00
 137+ 59E3 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 59E7 10 10 38 00
 138+ 59EB 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 59EF 4A 42 42 00
 139+ 59F3 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 59F7 44 44 44 00
 140+ 59FB 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 59FF 44 44 38 00
 141+ 5A03 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 5A07 44 78 40 40
 142+ 5A0B 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 5A0F 44 3C 04 04
 143+ 5A13 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 5A17 40 40 40 00
 144+ 5A1B 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 5A1F 38 04 78 00
 145+ 5A23 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 5A27 20 24 18 00
 146+ 5A2B 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 5A2F 44 4C 34 00
 147+ 5A33 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 5A37 44 28 10 00
 148+ 5A3B 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 5A3F 54 54 28 00
 149+ 5A43 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 5A47 10 28 44 00
 150+ 5A4B 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 5A4F 4C 34 04 38
 151+ 5A53 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 5A57 10 20 7C 00
 152+ 5A5B 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 5A5F 20 20 18 00
 153+ 5A63 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 5A67 10 10 10 00
 154+ 5A6B 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 5A6F 08 08 30 00
 155+ 5A73 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 5A77 00 00 00 00
 156+ 5A7B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 5A7F 00 00 00 00
 157+ 5A83 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 5A87 A5 99 42 3C
 158+ 5A8B 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 5A8F DB E7 7E 3C
 159+ 5A93 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 5A97 7C 38 10 00
 160+ 5A9B 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 5A9F 7C 38 10 00
 161+ 5AA3 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 5AA7 54 10 7C 00
 162+ 5AAB 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 5AAF D6 10 7C 00
 163+ 5AB3 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 5AB7 FF 18 18 18
 164+ 5ABB 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 5ABF 1F 18 18 18
 165+ 5AC3 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 5AC7 F8 18 18 18
 166+ 5ACB 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 5ACF F8 00 00 00
 167+ 5AD3 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 5AD7 1F 00 00 00
 168+ 5ADB 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 5ADF FF 00 00 00
 169+ 5AE3 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 5AE7 1F 18 18 18
 170+ 5AEB 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 5AEF FF 18 18 18
 171+ 5AF3 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 5AF7 F8 18 18 18
 172+ 5AFB 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 5AFF FF 00 00 00
 173+ 5B03 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 5B07 18 18 18 18
 174+ 5B0B 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 5B0F 38 70 E0 C0
 175+ 5B13 C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 5B17 1C 0E 07 03
 176+ 5B1B C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 5B1F 3C 7E E7 C3
 177+ 5B23 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 5B27 10 10 10 10
 178+ 5B2B 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 5B2F 10 10 10 10
 179+ 5B33 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 5B37 10 10 10 10
 180+ 5B3B 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 5B3F 00 00 00 00
 181+ 5B43 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 5B47 00 00 00 00
 182+ 5B4B 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 5B4F 00 00 00 00
 183+ 5B53 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 5B57 10 10 10 10
 184+ 5B5B 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 5B5F 10 10 10 10
 185+ 5B63 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 5B67 10 10 10 10
 186+ 5B6B 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 5B6F 00 00 00 00
 187+ 5B73 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 5B77 10 10 10 10
 188+ 5B7B 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 5B7F 10 20 40 80
 189+ 5B83 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 5B87 08 04 02 01
 190+ 5B8B 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 5B8F 18 24 42 81
 191+ 5B93 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 5B97 00 00 FF FF
 192+ 5B9B 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 5B9F FF FF FF FF
 193+ 5BA3 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 5BA7 FF FF FF FF
 194+ 5BAB FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 5BAF 00 00 00 00
 195+ 5BB3 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 5BB7 00 00 00 00
 196+ 5BBB FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 5BBF FF FF 00 00
 197+ 5BC3 C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 5BC7 C0 C0 C0 C0
 198+ 5BCB F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 5BCF F0 F0 F0 F0
 199+ 5BD3 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 5BD7 FC FC FC FC
 200+ 5BDB 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 5BDF 03 03 03 03
 201+ 5BE3 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 5BE7 0F 0F 0F 0F
 202+ 5BEB 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 5BEF 3F 3F 3F 3F
 203+ 5BF3 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 5BF7 81 81 81 FF
 204+ 5BFB 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 5BFF F0 F0 F0 F0
 205+ 5C03 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 5C07 0F 0F 0F 0F
 206+ 5C0B 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 5C0F 00 00 00 00
 207+ 5C13 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 5C17 00 00 00 00
 208+ 5C1B F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 5C1F 0F 0F 0F 0F
 209+ 5C23 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 5C27 F0 F0 F0 F0
 210+ 5C2B 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 5C2F 3C 3C 3C 3C
 211+ 5C33 C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 5C37 C3 C3 C3 C3
 212+ 5C3B FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 5C3F 00 00 FF FF
 213+ 5C43 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 5C47 FF FF 00 00
 214+ 5C4B 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 5C4F 33 33 CC CC
 215+ 5C53 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 5C57 55 AA 55 AA
 216+ 5C5B 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 5C5F 66 33 99 CC
 217+ 5C63 CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 5C67 CC 99 33 66
 218+ 5C6B 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 5C6F 33 99 CC 66
 219+ 5C73 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 5C77 66 CC 99 33
 220+ 5C7B 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 5C7F 10 00 7C 00
 221+ 5C83 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 5C87 60 00 7E 00
 222+ 5C8B 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 5C8F 06 00 7E 00
 223+ 5C93 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 5C97 A0 60 20 00
 224+ 5C9B 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 5C9F 00 00 00 00
 225+ 5CA3 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 5CA7 70 00 00 00
 226+ 5CAB 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 5CAF 00 7E 00 00
 227+ 5CB3 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 5CB7 54 A8 00 00
 228+ 5CBB 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 5CBF E0 C0 80 00
 229+ 5CC3 FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 5CC7 00 00 00 00
 230+ 5CCB 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 5CCF 07 03 01 00
 231+ 5CD3 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 5CD7 10 38 7C FE
 232+ 5CDB 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 5CDF 10 10 10 00
 233+ 5CE3 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 5CE7 20 40 00 00
 234+ 5CEB 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 5CEF 0C 08 00 00
 235+ 5CF3 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 5CF7 0E 0E 1E 00
 236+ 5CFB 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 5CFF 7C 38 10 00
 237+ 5D03 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 5D07 E0 E0 F0 00
 238+ 5D0B 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 5D0F 60 20 00 00
 239+ 5D13 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 5D17 08 04 00 00
 240+ 5D1B 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 5D1F F0 44 38 00
 241+ 5D23 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 5D27 28 28 28 00
 242+ 5D2B 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 5D2F 08 10 10 10
 243+ 5D33 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 5D37 20 10 10 10
 244+ 5D3B 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 5D3F 00 00 00 00
 245+ 5D43 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 5D47 00 00 00 00
 246+ 5D4B 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 5D4F 0F 1C 18 18
 247+ 5D53 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 5D57 F0 38 18 18
 248+ 5D5B 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 5D5F E0 00 00 00
 249+ 5D63 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 5D67 07 00 00 00
 250+ 5D6B 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 5D6F 42 42 3C 00
 251+ 5D73 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 5D77 7E 7E 3C 00
 252+ 5D7B 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 5D7F 7E 3C 18 00
 253+ 5D83 FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 5D87 F0 E0 C0 80
 254+ 5D8B FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 5D8F 0F 07 03 01
 255+ 5D93 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 5D97 1F 3F 7F FF
 256+ 5D9B 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 5D9F F8 FC FE FF
 257+ 5DA3 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 5DA7 78 70 60 00
 258+ 5DAB 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 5DAF 3C 66 00 00
 259+ 5DB3 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 5DB7 38 10 38 10
 260+ 5DBB 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 5DBF 44 44 38 00
 261+ 5DC3 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 5DC7 42 42 42 7E
 262+ 5DCB 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 5DCF 81 81 81 FF
 263+ 5DD3 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 5DD7 54 54 54 7C
 264+ 5DDB FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 5DDF BD AD AD FF
 265+ 5DE3 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 5DE7 AC AA EA 00
 266+ 5DEB 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 5DEF 7E 66 66 66
 267+ 5DF3 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 5DF7 9D 81 42 3C
 268+ 5DFB 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 5DFF A5 A2 00 00
 269+ 5E03 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 5E07 48 42 42 3C
 270+ 5E0B 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 5E0F 99 81 FF 00
 271+ 5E13 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 5E17 7C 7C 7C 00
 272+ 5E1B 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 5E1F F8 F8 F8 00
 273+ 5E23 FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 5E27 A5 A5 81 FF
 274+ 5E2B 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 5E2F 52 24 58 80
 275+ 5E33 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 5E37 81 76 0C 04
 276+ 5E3B 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 5E3F 08 18 38 10
 277+ 5E43 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 5E47 F5 F5 31 12
 278+ 5E4B 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 5E4F F0 F0 30 10
 279+ 5E53 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 5E57 7C 7E 78 48
 280+ 5E5B 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 5E5F A1 99 42 3C
 281+ 5E63 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 5E67 20 22 5C 00
 282+ 5E6B 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 5E6F 24 1E 42 3C
 283+ 5E73 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 5E77 7C 00 10 00
 284+ 5E7B FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 5E7F FF FF FF FF
 285+ 5E83
# file closed: ../include/vdp/8x8fonts-r18.asm
  94  5E83                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 5E83              ; ------------------------------------------------------------------------------
   2+ 5E83              ; LM80C - LOGO CHARSET - R1.1
   3+ 5E83              ; ------------------------------------------------------------------------------
   4+ 5E83              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5E83              ; designed by Leonardo Miliani. More info at
   6+ 5E83              ; www DOT leonardomiliani DOT com
   7+ 5E83              ; ------------------------------------------------------------------------------
   8+ 5E83              ; Code Revision:
   9+ 5E83              ; R1.0 - 20200124 - First revision: logo chars
  10+ 5E83              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 5E83              ; ------------------------------------------------------------------------------
  12+ 5E83
  13+ 5E83              LOGOFONT:   equ $
  14+ 5E83 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 5E87 00 00 00 00
  15+ 5E8B FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 5E8F FF FF FF FF
  16+ 5E93 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 5E97 00 00 00 00
  17+ 5E9B 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 5E9F 0F 0F 0F 0F
  18+ 5EA3 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 5EA7 FF FF FF FF
  19+ 5EAB F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 5EAF F0 F0 F0 F0
  20+ 5EB3 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 5EB7 0F 0F 0F 0F
  21+ 5EBB 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 5EBF F0 F0 F0 F0
  22+ 5EC3 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 5EC7 00 00 00 00
  23+ 5ECB 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 5ECF 00 00 00 00
  24+ 5ED3 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 5ED7 FF 07 03 00
  25+ 5EDB 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 5EDF FF E0 C0 00
  26+ 5EE3 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 5EE7 19 1F 18 18
  27+ 5EEB 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 5EEF 98 F8 18 18
  28+ 5EF3 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 5EF7 0F 00 00 00
  29+ 5EFB 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 5EFF 1F 1C 18 18
  30+ 5F03 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 5F07 F8 38 18 18
  31+ 5F0B 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 5F0F F0 00 00 00
  32+ 5F13 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 5F17 FF 00 00 00
  33+ 5F1B 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 5F1F FF FF FF FF
  34+ 5F23 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 5F27 FF FF FF FF
  35+ 5F2B FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 5F2F F0 F0 F0 F0
  36+ 5F33 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 5F37 0F 0F 0F 0F
  37+ 5F3B 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 5F3F 30 00 00 00
  38+ 5F43
# file closed: ../include/vdp/logo-fonts.asm
  95  5F43
  96  5F43              ; include workspace equates
  97  5F43                  INCLUDE "../include/workspace/workspace-r1.1.asm"
# file opened: ../include/workspace/workspace-r1.1.asm
   1+ 5F43              ; ------------------------------------------------------------------------------
   2+ 5F43              ; LM80C 64K - WORKSPACE EQUATES - R1.1
   3+ 5F43              ; ------------------------------------------------------------------------------
   4+ 5F43              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5F43              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 5F43              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 5F43              ; kind of warranty: you can use them at your own risk.
   8+ 5F43              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 5F43              ; maintain the copyright notices, include this advice and the note to the
  10+ 5F43              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 5F43              ; redistribuite them.
  12+ 5F43              ; https://www.leonardomiliani.com
  13+ 5F43              ;
  14+ 5F43              ; Please support me by visiting the following links:
  15+ 5F43              ; Main project page: https://www.leonardomiliani.com
  16+ 5F43              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 5F43              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 5F43              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 5F43              ; ------------------------------------------------------------------------------
  20+ 5F43
  21+ 5F43              ; set starting of RAM based on computer model
  22+ 5F43                  IFDEF LM80C64K
  23+ 5F43 ~            SERBUF_START    equ     END_OF_FW       ; RAM starts here
  24+ 5F43                  ELSE
  25+ 5F43              SERBUF_START    equ     $8000           ; RAM starts here
  26+ 5F43                  ENDIF
  27+ 5F43
  28+ 5F43              ;-------------------------------------------------------------------------------
  29+ 5F43              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  30+ 5F43              serRdPtr        equ     serInPtr+2
  31+ 5F43              serBufUsed      equ     serRdPtr+2
  32+ 5F43              basicStarted    equ     serBufUsed+1
  33+ 5F43              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  34+ 5F43              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  35+ 5F43
  36+ 5F43              ; BASIC WORK SPACE LOCATIONS
  37+ 5F43              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  38+ 5F43              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  39+ 5F43              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  40+ 5F43              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  41+ 5F43              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  42+ 5F43              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  43+ 5F43              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  44+ 5F43              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  45+ 5F43              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  46+ 5F43              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  47+ 5F43              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  48+ 5F43              DIV2            equ     DIV1+$04        ; (4) <-   to
  49+ 5F43              DIV3            equ     DIV2+$04        ; (3) <-   be
  50+ 5F43              DIV4            equ     DIV3+$03        ; (2) <-inserted
  51+ 5F43              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  52+ 5F43              LSTRND          equ     SEED+$23        ; (4) Last random number
  53+ 5F43              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  54+ 5F43              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  55+ 5F43              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  56+ 5F43              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  57+ 5F43              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  58+ 5F43              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  59+ 5F43              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  60+ 5F43              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  61+ 5F43              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  62+ 5F43              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  63+ 5F43              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  64+ 5F43              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  65+ 5F43              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  66+ 5F43              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  67+ 5F43              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  68+ 5F43              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  69+ 5F43              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  70+ 5F43              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  71+ 5F43              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  72+ 5F43              STACK           equ     BUFFER+$05      ; (85) Initial stack
  73+ 5F43              CURPOS          equ     STACK+$55       ; (1) Character position on line
  74+ 5F43              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  75+ 5F43              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  76+ 5F43              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  77+ 5F43              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location for BASIC
  78+ 5F43              DOSBFR          equ     LSTRAM+$02      ; (2) Start of temporary buffer used by DOS for load/save files (32 bytes below the I/O buffer)
  79+ 5F43              IOBUFF          equ     DOSBFR+$02      ; (2) Start of I/O buffer used by DOS to store/retrieve disk sectors
  80+ 5F43              DOSER           equ     IOBUFF+$02      ; (1) Error from DOS
  81+ 5F43              TMPDBF          equ     DOSER+$01       ; (36) Secondary buffer for DOS
  82+ 5F43              TMSTPT          equ     TMPDBF+$24      ; (2) Temporary string pointer
  83+ 5F43              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  84+ 5F43              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  85+ 5F43              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  86+ 5F43              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  87+ 5F43              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  88+ 5F43              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  89+ 5F43              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  90+ 5F43              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  91+ 5F43              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  92+ 5F43              BRKLIN          equ     READFG+$01      ; (2) Line of break
  93+ 5F43              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  94+ 5F43              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  95+ 5F43              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  96+ 5F43              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  97+ 5F43              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  98+ 5F43              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  99+ 5F43              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
 100+ 5F43              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
 101+ 5F43              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
 102+ 5F43              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
 103+ 5F43              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
 104+ 5F43              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
 105+ 5F43              SCR_NAM_TB      equ     SCR_MODE+$01    ; (2) video name table address
 106+ 5F43              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 107+ 5F43              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 108+ 5F43              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 109+ 5F43              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 110+ 5F43              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 111+ 5F43              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 112+ 5F43              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 113+ 5F43              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 114+ 5F43              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 115+ 5F43              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 116+ 5F43              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 117+ 5F43              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 118+ 5F43              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 119+ 5F43              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 120+ 5F43              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 121+ 5F43              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 122+ 5F43              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 123+ 5F43              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 124+ 5F43              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 125+ 5F43                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 126+ 5F43              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 127+ 5F43              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 128+ 5F43              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 129+ 5F43              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 130+ 5F43              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 131+ 5F43              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 132+ 5F43              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 133+ 5F43              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 134+ 5F43              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 135+ 5F43              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 136+ 5F43              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 137+ 5F43              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 138+ 5F43                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 139+ 5F43              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 140+ 5F43              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 141+ 5F43              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 142+ 5F43              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 143+ 5F43              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 144+ 5F43                                                      ; from here there are the RAM locations that
 145+ 5F43                                                      ; are saved during SAVE
 146+ 5F43              PROGND          equ     DOS_EN+$01      ; (2) End of program
 147+ 5F43              VAREND          equ     PROGND+$02      ; (2) End of variables
 148+ 5F43              ARREND          equ     VAREND+$02      ; (2) End of arrays
 149+ 5F43              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 150+ 5F43              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 151+ 5F43              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 152+ 5F43              FPREG           equ     FNARG+$04       ; (3) Floating point register
 153+ 5F43              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 154+ 5F43              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 155+ 5F43              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 156+ 5F43              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 157+ 5F43              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 158+ 5F43              STLOOK          equ     PROGST+$64      ; Start of memory test
 159+ 5F43
# file closed: ../include/workspace/workspace-r1.1.asm
  98  5F43
  99  5F43              ; END OF ASSEMBLY SOURCE
 100  5F43              ;-------------------------------------------------------------------------------
 101  5F43
# file closed: LM80C-firmware-r3.23.asm

Value    Label
------ - -----------------------------------------------------------
0x018F   A_RTS_OFF
0x01AD   A_RTS_ON
0x2E86   ABPASS
0x4ABF   ABRTDS
0x4ACD   ABRTXT
0x38CE   ABS_
0x4D8E   absHL
0x26A0 X ACCSUM
0x2E85   ACPASS
0x4C6B   ADD30
0x4C7B   ADD301
0x3867   ADDEXP
0x3A0D   ADDIG
0x0A54   ADDNEWLINE
0x3603   ADDPHL
0x8208   ADRS1
0x820C   ADRS2
0x12A2   ALFLSTXT
0x3154   ALLFOL
0x29C1   ANTVLU
0x3D5E X ARET
0x2D90   ARLDSV
0x8250   ARREND
0x301F   ARRLP
0x3125   ASC
0x39B0   ASCTFP
0x291A   ASPCS
0x069D   ATHOME
0x3D12   ATN
0x3D2F   ATN1
0x3D39   ATNTAB
0x26DB   ATOH
0x80B4   AUTOKE
0x1FB0   AUTORP
0x0197   B_RTS_OFF
0x01B5 X B_RTS_ON
0x0847   BACKSPACE
0x293D   BADINP
0x204B   BAKSTK
0x3105   BAKTMP
0x805D   basicStarted
0x8135   BASTXT
0x38F5   BCDEFP
0x05AB   BEEPOFF
0x1C83   BFREE
0x4CBD   BIN
0x4CC3 X BIN2
0x4D1A   BINERR
0x4CF9   BINIT
0x4CEF   BINTFP
0x4CD7   BITOUT
0x4CDB   BITOUT2
0x466B   BITS6
0x4675   BITS7
0x4680   BITS8
0x8205   BKGNDCLR
0x0008   BKSP
0x1C7A   BLNSPC
0x0028   BN
0x1A9F   BNMSG
0x3663   BNORM
0x1932 X BNPTR
0x3666   BNRMLP
0x820F   BPS
0x264E   BRK
0x80A9   BRKFLG
0x81DE   BRKLIN
0x2045   BRKMSG
0x1C6E   BRKRET
0x0010   BS
0x2DC3   BSERR
0x19C9   BSMSG
0x191A X BSPTR
0x8138   BUFFER
0x0058   bufWrap
0x4C62   BYT2ASC
0x81A5   BYT_SIZ
0x18C3   BYTEHEX
0x379B   BYTSFT
0x104C   CF_BUSY
0x0057   CF_CMD
0x1053   CF_CMDRDY
0x1062   CF_DAT_RDY
0x0050   CF_DATA
0x0051 X CF_ERR
0x0051   CF_FTR
0x102D   CF_INIT
0x0053   CF_LBA0
0x0054   CF_LBA1
0x0055   CF_LBA2
0x0056   CF_LBA3
0x1043   CF_NOP
0x10C4   CF_RD_CMD
0x10D5   CF_RD_EXIT
0x10B1   CF_RD_SEC
0x0052   CF_SECCNT
0x106F   CF_SETSTR
0x10A5   CF_STANDBY
0x0057   CF_STAT
0x10F9   CF_WR_EXIT
0x10D8   CF_WR_SEC
0x2D26   CFEVAL
0x4B25   CFINIT
0x1806   CH0TO9
0x180E   CH0TO9E
0x028B   CH3_TIMER
0x015D   CHABFREMPTY
0x0778   CHAR2VID
0x01FD   CHARINTOBFR
0x2CD4   CHARTY
0x823A   CHASNDDTN
0x1811   CHATOZ
0x1819   CHATOZE
0x823C   CHBSNDDTN
0x089D   CHCKYPOS
0x0908   CHCKYPOS2
0x823E   CHCSNDDTN
0x0D92   CHECKALT
0x0DA0   CHECKCTRL
0x0DAE   CHECKKBD
0x40C6   CHECKPA
0x40C7   CHECKPY
0x0312   CHECKWARM
0x2F1D   CHEKFN
0x4A5D   CHK1AR
0x18E7   CHK_C_CF
0x18D3   CHK_NAM
0x18E8 X CHK_NAM_LV
0x0E29   CHKALT
0x0E72   CHKAUTO
0x4D0C   CHKBIN
0x3EE6   CHKCLR0
0x3EE2   CHKCLR1
0x029A   CHKCRSR
0x0E20   CHKCTRL
0x48CA   CHKDOS
0x181C   CHKDSKVAL
0x183A   CHKDSKVAL1
0x1850   CHKDSKVAL2
0x184F   CHKDSKVALE
0x48B6   CHKEY1
0x48BB   CHKEY2
0x48BE   CHKEY3
0x48C4   CHKEY4
0x48C7   CHKEY5
0x1579   CHKFLEXT
0x4C05   CHKFLNM
0x4C0F   CHKFN1
0x0EAA   CHKFNK
0x3EEC   CHKG2M
0x0823   CHKHL
0x35E2   CHKINK
0x0E0C   CHKLN
0x26AD   CHKLTR
0x1854   CHKNMVAL
0x185F   CHKNMVAL1
0x1865   CHKNMVAL2
0x1875   CHKNMVAL3
0x3E29   CHKSCAR
0x0D17   CHKSNDCH
0x05D9 X CHKSPCK
0x207F   CHKSTK
0x16D4   CHKSTNM1
0x1705   CHKSTNM10
0x16D7   CHKSTNM2
0x16F0   CHKSTNM3
0x170A X CHKSTNM5
0x16FA   CHKSTNM6
0x80A6   CHKSUM
0x23C2   CHKSYN
0x2AA1   CHKTYP
0x08C4   CHKYPOS
0x4530   CHKZSER
0x1516   CHNGNAM
0x3136   CHR
0x8203   CHR4VID
0x8210   CHRPNT
0x4E83   CHRST68
0x5683   CHRST88
0x075A   CHRTBL
0x42F5   CIRCLE
0x461E   CKBPS
0x3FD3   CKCOL
0x179B   CKCREN
0x0278   CKINCHAR
0x17AF   CKLSTEN
0x17B5   CKLSTEN1
0x3DDC   CKMAGN
0x4E16   CLCN32
0x4E26   CLCN321
0x4E29   CLCN322
0x4E74   CLCN323
0x4E4B   CLCN325
0x4DEA   CLCN32T
0x4E12   CLCN32Z
0x2700   CLEAR
0x0690   CLEARVIDBUF
0x240E   CLOTST
0x0AFB   CLR_RAM_REG
0x18F2   CLRBUFF
0x18FE   CLRDOSBF
0x2224   CLREG
0x3EA0   CLREX2
0x3E8E   CLRG1
0x3E97   CLRG2
0x0630   CLRG2PTNTBL
0x18E9   CLRIOBF
0x3E87   CLRMC
0x44E2   CLRPRM
0x0CB5   CLRPSGREGS
0x21FF   CLRPTR
0x05D4   CLRTABLE
0x44C4   CLRTMBF
0x3E84   CLRTXT
0x44D3   CLRVDBF
0x3D61   CLS
0x485B   CLSQT
0x486B   CLSQT1
0x4D4D   CMP16
0x35BB   CMP_A
0x393E   CMPFP
0x2C3A   CMPLG1
0x2C38   CMPLOG
0x3924   CMPNUM
0x2C7C   CMPRES
0x2C64   CMPSTR
0x0020   CN
0x4BE0   CNFREQ
0x4C03   CNFRQN
0x1A5F   CNMSG
0x192A X CNPTR
0x322E   CNT1INS
0x0D52   CNTCHKSND
0x3E56   CNTCKCL
0x43B7   CNTCL1
0x43DB   CNTCL2
0x43FF   CNTCL3
0x4425   CNTCL4
0x4447   CNTCL5
0x446B   CNTCL6
0x448F   CNTCL7
0x4298   CNTDRW
0x28E2   CNTEND
0x0F05   CNTFNK
0x3F52   CNTGPT2
0x0EA4   CNTKBCK
0x2BF9   CNTLGC
0x4821   CNTLTK
0x0A08   CNTNULL
0x0A86 X CNTNULL2
0x4144   CNTPLOT
0x4165   CNTPLT1
0x459D   CNTRX2
0x0120   CNTRXCHA
0x456E   CNTSER
0x45A8   CNTSER2
0x45BA   CNTSER3
0x44BF   CNTVALY
0x254B   CNTWTSP
0x3265   CNTZIN
0x39BC   CNVNUM
0x1B9D   COLD
0x0307   COLDSTART
0x3E39   COLOR
0x80A3   COMMAN
0x36C3   COMPL
0x309A   CONCAT
0x39EC   CONEXP
0x3660   CONPOS
0x2687   CONT
0x073B   CONT_POS_CURS
0x81E4   CONTAD
0x08AE   CONTCRSLFT
0x091B   CONTCRSRGT
0x8247   CONTROLKEYS
0x2B8C   CONVAR
0x02FB   CORW
0x3C96   COS
0x0349   COUNTER
0x23BC   CPDEHL
0x47B8   CPKEY
0x47D7   CPKEY1
0x47C8   CPKEY2
0x47CF   CPKEY3
0x47DF   CPKYEND
0x2301   CPYLIT
0x000D   CR
0x1091   CR_DEV_RDY
0x10A2 X CR_DV_ERR
0x1096   CR_DV_RD_1
0x10A3   CR_DV_RD_E
0x2DE3   CRARLP
0x2DC8   CREARY
0x280D   CRESTR
0x09DA   CRGRETURN
0x2262   CRNCLP
0x001F   CRSDN
0x001C   CRSLFT
0x8200   CRSR_STATE
0x001D   CRSRGT
0x001E   CRSUP
0x2F56   CRTMST
0x2F62   CRTST
0x2F78   CRTSTE
0x2259   CRUNCH
0x000C   CS
0x1BAA   CSTART
0x81EA   CTC0IV
0x81ED   CTC1IV
0x81F0   CTC2IV
0x81F3   CTC3IV
0x471A   CTC_CFG
0x0010   CTC_CH0
0x0011   CTC_CH1
0x0012   CTC_CH2
0x0013   CTC_CH3
0x0388   CTCCONF
0x80A5   CTLOFG
0x410A   CTPOINT
0x0003   CTRLC
0x0007   CTRLG
0x000F   CTRLO
0x0011   CTRLQ
0x0012   CTRLR
0x0013   CTRLS
0x0015   CTRLU
0x348F   CTSNDC
0x8206   CUR_POS
0x81D5   CUROPR
0x8192   CURPOS
0x0959   CURSOR_OFF
0x0944   CURSOR_ON
0x0924   CURSORDOWN
0x088A   CURSORLEFT
0x08EF   CURSORRIGHT
0x08D6   CURSORUP
0x0038   D0
0x1B30   D0MSG
0x1942 X D0PTR
0x003A   D1
0x1281   D1ERR
0x1B40   D1MSG
0x1944 X D1PRT
0x003C   D2
0x1264   D2ERR
0x1B4C   D2MSG
0x1946 X D2PRT
0x003E   D3
0x1B5A   D3MSG
0x1948 X D3PRT
0x0040   D4
0x1B5F   D4MSG
0x194A X D4PTR
0x0042   D5
0x1B64   D5MSG
0x194C X D5PTR
0x0044   D6
0x1B6E   D6MSG
0x194E X D6PTR
0x0046   D7
0x1B82   D7MSG
0x1950 X D7PRT
0x0048   D8
0x1B8E   D8MSG
0x1952 X D8PTR
0x819F   DAT_STRT
0x27B4   DATA
0x8211   DATABT
0x8195   DATFLG
0x81D9   DATLIN
0x20BC   DATSNR
0x8218   DC
0x3975   DCBCDE
0x0012   DD
0x20CB   DDERR
0x19D7   DDMSG
0x191C X DDPTR
0x187C   DE2HL
0x056B   DEC_D
0x0347   DEC_E
0x47AA   DECLN1
0x3D7D   DEEK
0x2E9A   DEF
0x1FB2 X DEFFNKS
0x4605   DEFSER
0x2DEB   DEFSIZ
0x26C1   DEINT
0x007F   DEL
0x2331   DELCHR
0x26BB   DEPINT
0x3904   DETHL4
0x3906   DETHLB
0x10FC   DFSCT0
0x3AB6   DIGTXT
0x2CA6   DIM
0x2C9D   DIMRET
0x23F1   DINPOS
0x37A0   DINT
0x3DA8 X DIR_PAU
0x81A1   DIR_SCT
0x819D   DIR_STRT
0x4736   DIRMOD
0x4AD6   DISK
0x333D   DISNMI
0x37FD   DIV
0x806B   DIV1
0x37F1   DIV10
0x806F   DIV2
0x8073   DIV3
0x8076   DIV4
0x4DB7   DIV_16_16
0x4DA8   DIV_16_8
0x4DAB   DIV_16_8LP
0x4DCC   DIV_32_16
0x4DD1   DIV_32_16LP
0x4DE2   DIV_32_16OF
0x4DE5   DIV_32_16SB
0x4D98   DIV_8_8
0x4D9C   DIV_8_8LOOP
0x3824   DIVLP
0x806A   DIVSUP
0x820A   DKLNPT
0x8208   DKNMPT
0x4379   DLSZ
0x223D   DOAGN
0x05EE   DOCOLDRESET
0x28E7   DOCOM
0x2311   DODEL
0x3AF6   DOEBIT
0x2EC7   DOFN
0x3D88   DOKE
0x824B   DOS_EN
0x4A56   DOS_ERR
0x1182 X DOS_FT0
0x1183   DOS_FT1
0x1235   DOS_FT10
0x119D   DOS_FT2
0x11C5 X DOS_FT5
0x1239   DOS_FT7
0x123B   DOS_FT8
0x1228   DOS_FT9
0x120E   DOS_FTA
0x1175   DOS_FTC
0x8198   DOSBFR
0x819C   DOSER
0x1CD2   DOSMSG
0x2915   DOSPC
0x127C   DOSVERSERR
0x2900   DOTAB
0x39E8   DPOINT
0x41BC   DRAW
0x4395   DRWCRL
0x110D   DSK_INIT
0x1241   DSK_RNM
0x110B   DSKDIRADR
0x4B12   DSKFRM
0x1268   DSKFULL
0x128B   DSKNMTX
0x4BAE   DSKRNM
0x4BA1   DSKUND
0x1713   DSKUNDFL
0x171F   DSKUNDFL1
0x1750   DSKUNDFL2
0x173B   DSKUNDPR
0x1755   DSKUNDTXT
0x2F66   DTSTR
0x126C   DUPLERR
0x4DBC   DV16_16_LP
0x37FF   DVBCDE
0x821A   DX
0x42C8   DXGR
0x821C   DY
0x0014   DZ
0x20C5   DZERR
0x19EC   DZMSG
0x191E X DZPTR
0x8214   E2
0x2325   ECHDEL
0x031F   ECHO_CHAR
0x3A2F   EDIGIT
0x31CD   EMPTINS
0x0CB1   EMPTSNDBFR
0x0AF2   EMPTVRM
0x0AE7   EMPTY_VRAM
0x014F   EMPTYCHABFR
0x0181   EMPTYCHBBFR
0x061E   EMPTYG2
0x064F   EMPTYMC
0x05F5   EMPTYVIDBUF
0x46EF   ENCHB
0x2308   ENDBUF
0x39FB   ENDCON
0x4391   ENDCRL
0x0DF4   ENDCTRLCK
0x2E4A   ENDDIM
0x42F1   ENDDRAW
0x35F4   ENDINK
0x35FD X ENDINK2
0x28CE   ENDINP
0x0839 X ENDINSRT
0x81B8   ENDMEM
0x2CC8   ENDNAM
0x0A61   ENDOFLN
0x265D   ENDPRG
0x2E5F   ENDTMR
0x820A   ENDTXT
0x0505   ENDVDPSET
0x2088   ENFMEM
0x8212   ER
0x426C   ER2
0x4A76   ERASE
0x0587   ERASECLRTBL
0x4AB1   ERASED
0x2100   ERRIN
0x2681   ERRINT
0x81E2   ERRLIN
0x2034   ERRMSG
0x20DC   ERROR
0x1954 X ERRORS
0x190A   ERRTBL
0x4AA3   ERSTX
0x001B   ESC
0x2AAE   EVAL
0x2AB1   EVAL1
0x2ABA   EVAL2
0x2ABD   EVAL3
0x2B73   EVLPAR
0x2C86   EVNOT
0x25EB   EXCUTE
0x04C2   EXG2MD
0x07D4   EXITCHAR2VID
0x0957   EXITCURSOR_ON
0x0941   EXITCURSORDOWN
0x08B1   EXITCURSORLEFT
0x0921   EXITCURSORRGHT
0x08ED   EXITCURSORUP
0x13D4 X EXITFLS
0x209C   EXITGM
0x40C2   EXITPA2
0x40BE   EXITPAI
0x4D70   EXMUL16
0x46FD   EXNRM
0x3B90   EXP
0x39DA   EXPLP
0x3BD0   EXPTAB
0x3B08   EXPTEN
0x2A1D   EXTIG
0x2A46   FANDT
0x0008   FC
0x26D6   FCERR
0x198D   FCMSG
0x1912 X FCPTR
0x2A2D   FDTLP
0x16B5   FIL_ERA1
0x16C0   FIL_ERA2
0x16C3   FIL_ERA3
0x1694   FIL_ERA5
0x168D   FIL_ERA6
0x1656   FIL_ERASE
0x16CD   FILE_EXIST
0x4A3F   FILES
0x13D9   FILETP
0x2E26   FINDEL
0x0E0A   FINDKEY
0x07E2   FLASHCURSOR
0x1711   FLEXST
0x38B4   FLGDIF
0x38BB   FLGREL
0x170F X FLNTEXS
0x1274   FLNTFND
0x00EC   FMVEREND
0x8256   FNARG
0x1CFA   FNCTAB
0x2D96   FNDARY
0x2E2B   FNDELP
0x21D2   FNDEND
0x1760   FNDFRENTR
0x176C   FNDFRENTR1
0x176F   FNDFRENTR2
0x177F   FNDFRENTR3
0x1774   FNDFRENTR4
0x331F   FNDNUM
0x24FF   FNDTOK
0x2D0D   FNDVAR
0x228C   FNDWRD
0x80B5   FNKEYS
0x0F25   FNKEYSORD
0x2B9D   FNOFST
0x8254   FNRGNM
0x2D1B   FNTHR
0x2BCE   FNVAL
0x2AE6   FOPRND
0x2552   FOR
0x81DB   FORFLG
0x2582   FORFND
0x2566   FORSLP
0x3612   FPADD
0x38EA   FPBCDE
0x825D   FPEXP
0x3951   FPINT
0x374D   FPMULT
0x825A   FPREG
0x36AA   FPROND
0x26B5   FPSINT
0x3901   FPTHL
0x2E64   FRE
0x2E80   FRENUM
0x8204   FRGNDCLR
0x2B8F   FRMEVL
0x4B74   FRMTXT
0x00D0 X FWVER
0x043C   G1MD
0x047D   G2MD
0x2FE7   GARBGE
0x2FEA   GARBLP
0x493F   GET3AR
0x260B   GETCHR
0x212F   GETCMD
0x4C98   GETHEX
0x3D5F   GETINP
0x3322   GETINT
0x311A   GETLEN
0x2342   GETLIN
0x26DC   GETLN
0x2A9C   GETNUM
0x22A7   GETNXT
0x30E4   GETSTR
0x2CAB   GETVAR
0x002A   GM
0x44FB   GMERR
0x1AAA   GMMSG
0x2399   GMNCR
0x1934 X GMPRT
0x301E   GNXARY
0x2BD6   GOFUNC
0x2760   GOSUB
0x2771   GOTO
0x3FB6   GPCPCH1
0x3FAB X GPCPCHR
0x3F67   GPNT
0x3F91   GPNTCO1
0x3F87 X GPNTCOL
0x3EF5   GPRINT
0x303E   GRBARY
0x2FBF   GRBDON
0x2FF8   GRBLP
0x30E7   GSTRCU
0x30EB   GSTRDE
0x30EA   GSTRHL
0x3129 X GTFLNM
0x2CB0   GTFNAM
0x26DF   GTLNLP
0x17A3   GTNXTEN
0x3A80   GTSIXD
0x2999   GTVLUS
0x820A   GX
0x820C   GY
0x3B27   HALF
0x3CE0   HALFPI
0x0339   HELLOWRLD
0x473F   HELP
0x4C2C   HEX
0x4C44   HEX1
0x4C46   HEX2
0x4C53   HEX3
0x4C55   HEX4
0x4CAF   HEXIT
0x4C8B   HEXLP
0x4C90   HEXLP1
0x4C7F   HEXTFP
0x1881   HL2DE
0x0749   HL2XY
0x4758   HLPERR
0x80B1   HLPLN
0x0019   HOME
0x0032   HP
0x1AFF   HPMSG
0x193C X HPPTR
0x0026 X HX
0x4CB8   HXERR
0x1A94   HXMSG
0x1930 X HXPTR
0x0016   ID
0x19FD   IDMSG
0x1920 X IDPTR
0x2F0F   IDTEST
0x2843   IF
0x285A   IF0
0x2863   IF1
0x2851   IFGO
0x25F2   IFJMP
0x0034   IM
0x20D7   IMERR
0x1B09   IMMSG
0x193E X IMPRT
0x38FF   INCHL
0x23ED   INCLEN
0x0294   INCTMR3
0x2065   INDFND
0x219A   INEWLN
0x02AE   INIT_HW
0x02B1 X INIT_HW2
0x1F5B   INITAB
0x2034   INITBE
0x035E   initCTC
0x4B32 X INITDSK
0x4B40 X INITFN
0x0CAB   initPSG
0x4D38   INITST
0x03ED   initVDP
0x35B0   INKEY
0x35CA   INKEY2
0x203B   INMSG
0x32DF   INP
0x29EB   INPBIN
0x265A   INPBRK
0x80A0   INPORT
0x12D6   INPR1
0x809F   INPSUB
0x294E   INPUT
0x3A89   INRNG
0x0805   INSERTKEY
0x001A   INSRT
0x3176   INSTR
0x397C   INT
0x220E   INTVAR
0x38D2   INVSGN
0x819A   IOBUFF
0x29DC   ITMSEP
0x3B12   JSTZER
0x8240   KBDNPT
0x0F2D   KBMAP
0x0FAD   KBMAP_ALT
0x0FED   KBMAP_CTRL
0x0F6D   KBMAP_SFT
0x8241   KBTMP
0x475D   KEY
0x0D72   KEYBOARD
0x477A   KEYCH
0x80B3   KEYDEL
0x8245   KEYTMR
0x2A8C   KILFOR
0x233C   KILIN
0x8243   LASTKEYPRSD
0x8193   LCRFLG
0x04FC   LDCLRTBEX2
0x0474   LDCLRTBMD1
0x060F   LDCOLSTOEMPTY
0x490D   LDEND
0x17C1   LDENTRIES
0x4914   LDERR
0x15EF   LDFL1
0x15F3   LDFL2
0x1613   LDFL3
0x15D3   LDFL4
0x164A   LDFL5
0x1651   LDFLEX
0x0EF1   LDFNKEYCHR
0x20A9   LDG1
0x20BA   LDG1ND
0x480C   LDKEY
0x17D0   LDMSCT
0x17D3 X LDMSCT1
0x0B18   LDREGVLS
0x492A   LDSVPT
0x0343   LEDLIGHT
0x3146   LEFT
0x3116   LEN
0x27CB   LET
0x281E   LETNUM
0x27E6   LETSTR
0x000A   LF
0x32D5   LFRGNM
0x80AF   LINEAT
0x3A3B   LINEIN
0x2183   LINFND
0x2429   LIST
0x24BC   LISTLP
0x1596   LK4FILE
0x1599   LK4FILE1
0x0B6B   LM80CLOGO
0x8206   LNS1
0x820A   LNS2
0x48D4   LOAD
0x0726   LOAD_CRSR_POS
0x0B22   LOADCHARSET
0x3EA7   LOADCLR
0x38F8   LOADFP
0x05B3   LOADLOGOCHRS
0x0E30   LOADMAP
0x098A   LOADNEXTCOL
0x48F8   LOADST
0x33F5   LOCATE
0x1278   LODERR
0x15AC   LODFILE
0x370C   LOG
0x5E83   LOGOFONT
0x36FF   LOGTAB
0x204F   LOKFOR
0x81D7   LOOPST
0x001C   LS
0x1A34   LSMSG
0x1926 X LSPTR
0x2455   LST01
0x2458   LST01H
0x24B3   LST02
0x249C   LST03
0x24B0   LST05
0x2473   LST06
0x24E1   LST07
0x24DE   LST08
0x12BD   LST_FILES
0x2484   LSTALL
0x81DC   LSTBIN
0x8201   LSTCSRSTA
0x130B   LSTFILES1
0x130E   LSTFILES2
0x1338   LSTFILES20
0x1340   LSTFILES21
0x131C   LSTFILES3
0x137A X LSTFILES5
0x136F   LSTFILES6
0x1343   LSTFILESPR
0x47E1   LSTKEYS
0x24ED   LSTLP2
0x24F0   LSTLP3
0x2477   LSTNOT
0x8196   LSTRAM
0x809B   LSTRND
0x81AA   LSW_SCT
0x29F6   LTSTND
0x0881   LVBKSP
0x05EC   LVCKSPLK
0x325B   LVINSTR
0x0ED8 X LVKBRDCHK
0x0ED4   LVKBRDCHK2
0x0131   LVRXCHA
0x2537   LVSRLN
0x80A2   LWIDTH
0x3325   MAKINT
0x3AA5   MAKNUM
0x39C4   MANLP
0x22D9   MATCH
0x049F   MCMD
0x1CEF   MEMMSG
0x3276   MID
0x314C   MID1
0x32DA   MIDNUM
0x3652   MINCDE
0x2B7B   MINUS
0x3ED5   MIXCLRS
0x8206   MIXCOL
0x2F53   MKTMST
0x399D   MLDBLP
0x3995   MLDEBC
0x1BE2   MLOOP
0x4D60   MLP
0x4D67   MLP1
0x3892   MLSP10
0x0D0D   MNGSNDS
0x1BDF   MNOASK
0x4043   MNPAINT
0x0024   MO
0x37A8   MOD
0x1A84   MOMSG
0x4D1F   MONOUT
0x192E X MOPTR
0x2A02   MORDT
0x234B   MORINP
0x21B9   MOVBUF
0x06ED   MOVCRS
0x22E1   MOVDIR
0x2074   MOVLP
0x06F3   MOVSHOWCRS
0x2071   MOVSTR
0x206E   MOVUP
0x2871   MRPRNT
0x0394   MSGTXT1
0x03D0   MSGTXT2
0x1BCC   MSIZE
0x4B54   MSPTOK
0x4B5C   MSTTXT
0x81A8   MSW_SCT
0x4D7D   MU32_1
0x4D8A   MU32_2
0x4D58   MUL16
0x3778   MUL8LP
0x4D7F   MUL_32L
0x4D72   MUL_U32
0x3744   MULLN2
0x374B   MULT
0x376F   MULT8
0x3A06   MULTEN
0x826C   MULVAL
0x086E   MVBKSP
0x08B3   MVCRS2LFT
0x2815   MVSTPT
0x1270   NAMERR
0x2995   NEDMOR
0x3B3D   NEGAFT
0x4D91   negHL
0x21FE   NEW
0x0708   NEWCRSRCOORD
0x0E84   NEWKEY
0x2924   NEXITM
0x2A51   NEXT
0x2A54   NEXT1
0x0000   NF
0x20C8   NFERR
0x1954   NFMSG
0x190A X NFPTR
0x0000   NLLCR
0x334E   NM1
0x3333   NMI
0x335F   NMI2
0x336A   NMIDINT
0x3363   NMIEINT
0x80A8   NMIFLG
0x336D   NMIINT
0x8061   NMIUSR
0x3379   NMIVR1
0x0CDF   NOBEEP
0x0CFB   NOBPDAT
0x22D1   NOCHNG
0x1C2B   NODOS
0x3B15   NOENED
0x4185   NOGD
0x3513   NOISUP
0x0DF8   NOKEYPRSD
0x2670   NOLIN
0x3789   NOMADD
0x39AB   NOMLAD
0x2968   NOPMPT
0x367D   NORMAL
0x353D   NOS1
0x3550   NOS2
0x3569   NOS3
0x22C8   NOSPC
0x4CAB   NOSUB7
0x362C   NOSWAP
0x33AB   NOSYSPR
0x2B50   NOTAMP
0x0208   NOTFULL
0x023F   NOTRDWRAP
0x2CE3   NOTSTR
0x0214   NOTWRAP
0x3305   NOXOR
0x0036   NR
0x20DA   NRERR
0x1B1F   NRMSG
0x1940 X NRPRT
0x2CF3   NSCFOR
0x81A3   NTR_NBR
0x80A4   NULFLG
0x3A4E   NUMASC
0x8212   NUMCHR
0x2DAA   NXTARY
0x22B7   NXTBYT
0x0B37   NXTCHAR
0x22F8   NXTCHR
0x0798   NXTCPCK
0x8252   NXTDAT
0x27B3   NXTDTA
0x0834   NXTINST
0x298D   NXTITM
0x2517   NXTLN
0x4024   NXTLOOP
0x81E0   NXTOPR
0x27BA   NXTSTL
0x27BD   NXTSTT
0x0006   OD
0x1981   ODMSG
0x1910 X ODPTR
0x2040   OKMSG
0x000C   OM
0x2097   OMERR
0x19AC   OMMSG
0x1916 X OMPTR
0x2825   ON
0x2834   ONGO
0x2835   ONGOLP
0x25F3   ONJMP
0x2AAA   OPNPAR
0x486D   OPNQT
0x4883   OPNQT1
0x4B8C   OPRCMP
0x2B25   OPRND
0x8212   ORGSP
0x001A   OS
0x1A20   OSMSG
0x1924 X OSPTR
0x2339   OTKLN
0x8068   OTPORT
0x23CD   OUTC
0x3B06   OUTEXP
0x23B3   OUTIT
0x23B6   OUTNBS
0x4D47   OUTNCR
0x8067   OUTSUB
0x2509   OUTWRD
0x000A   OV
0x20D1   OVERR
0x19A3   OVMSG
0x1914 X OVPTR
0x3885   OVTST1
0x388A   OVTST2
0x388B   OVTST3
0x3A2A   PADD
0x3FE6   PAINT
0x4031   PAINT0
0x4040   PAINT1
0x403F   PAINT11
0x4073   PAINT2
0x4086   PAINT3
0x40A5   PAINT4
0x40B7   PAINT5
0x2BEF   PAND
0x2C14 X PAND1
0x8212   PARBT
0x2E95   PASSA
0x3D9F   PAUSE
0x825F   PBUFF
0x33BB   PEEK
0x2655   PEND
0x38E7   PHLTFP
0x0002 X PIO_CA
0x0003   PIO_CB
0x0000 X PIO_DA
0x0001   PIO_DB
0x33CF   PKEPRMS
0x07E1   PLACEHOLDER
0x4129   PLOT
0x4388   PLTCRL
0x36B7   PLUCDE
0x3685   PNORM
0x820E   PNT
0x0ED1   PNT2VD
0x4100   PNTEND
0x411E   PNTRTN
0x1395   PNTSTATS
0x40D6   POINT
0x33E5   POKE
0x2FD9   POPAF
0x3103   POPHL
0x3799   POPHRT
0x2121   POPNOK
0x2BF2   POR
0x2C19   POR1
0x2E92   POS
0x06E3   POS_CURSOR
0x0A87   POS_TB_CRS_32
0x0AB7   POS_TB_CRS_40
0x26B8 X POSINT
0x32EB   POUT
0x3B4B   POWER
0x3B5B   POWER1
0x3B78   POWER2
0x3B2B   POWERS
0x2875   PRINT
0x1F3D   PRITAB
0x1889   PRN16ASCII
0x188F   PRN16ASCIX
0x1886   PRN32ASCII
0x18A2 X PRN_HEX
0x18A3   PRN_HEX1
0x18AC X PRN_WHEX
0x18AE   PRN_WHEX1
0x28D8   PRNTCRLF
0x0F18   PRNTFNK
0x0ED9   PRNTFNKEY
0x3A43   PRNTHL
0x2878   PRNTLP
0x28BB   PRNTNB
0x2122   PRNTOK
0x0A40   PRNTRETURN
0x1899   PRNTSIZ
0x28BF   PRNTST
0x8202   PRNTVIDEO
0x2FA3   PRNUMS
0x2364   PROCES
0x824C   PROGND
0x826F   PROGST
0x2241   PROMPT
0x2FA4   PRS
0x2FA7   PRS1
0x2FAE   PRSLP
0x4836   PRTCHR
0x4885   PRTCKEY
0x4892   PRTEND
0x4886   PRTK1
0x47F5 X PRTK2
0x481E   PRTK3
0x47F3   PRTK4
0x820E   PRTNUM
0x0041   PSG_DAT
0x0040   PSG_REG
0x360D   PSUB
0x820E   PT
0x8210   PT1
0x8212   PT2
0x1790   PT2FSEN
0x4853   PTCHR1
0x211D   PTLN
0x21C6   PTRLP
0x239F   PUTBUF
0x0EC4   PUTCHRBUF
0x0F0B   PUTCHRBUF1
0x0801   PUTCRSCHR
0x23A4   PUTCTL
0x25C7   PUTFID
0x4189   PXLSET
0x2BF7   PXOR
0x2C21   PXOR1
0x2F69   QTSTLP
0x2F63   QTSTR
0x3CE4   QUARTR
0x8212   RADIUS
0x81AC   RAM_PTR
0x027D   RAWPRINT
0x2988   READ
0x06A7   READ_VIDEO_LOC
0x06DC   READ_VSTAT
0x81DD   READFG
0x0D5D   READKBLN
0x3D82 X RECWRD
0x292B   REDO
0x27B6   REM
0x49FC   RENFIL
0x3837   RESDIV
0x3C82   RESEED
0x4D22   RESET
0x476A   RESFN
0x0383   RESTMR
0x2630   RESTNL
0x261B   RESTOR
0x3678   RESZER
0x1283   RET_ERR
0x2D5A   RETADR
0x1060   RETERR
0x38C0   RETINT
0x27AE   RETLIN
0x22DD   RETNAD
0x2D5D   RETNUL
0x2B87   RETNUM
0x38B2   RETREL
0x278F   RETURN
0x0004   RG
0x196C   RGMSG
0x190E X RGPTR
0x326C   RIGHT
0x314A   RIGHT1
0x80AA   RINPUT
0x2ACA   RLTLP
0x3C21   RND
0x3C5D   RND1
0x3C79   RND2
0x17F3   RND8
0x17DC   RND_ID
0x17DF   RND_ID1
0x4BD2   RNDKTX
0x3C8A   RNDTAB
0x3B18   RNGTST
0x3699   RONDB
0x3698   RONDUP
0x3600   ROUND
0x3205   RP2INST
0x44CC   RPCLTMB
0x3F7C   RPGPNT
0x0595   RPT100
0x0539   RPT101
0x053C   RPT102
0x0552   RPT103
0x055A   RPT104
0x434C   RPTCL1
0x078B   RPTCPCK
0x4339   RPTCRL
0x44DB   RPTCVBF
0x427C   RPTDRW
0x0615   RPTEMPTYBUF
0x09CE   RPTEMPTYROW
0x067D   RPTFLL1
0x31DE   RPTINST
0x0DB2   RPTKBDRD
0x3EB1   RPTLDCL
0x09F8   RPTNLLSRC
0x0A79   RPTNLLSRC2
0x3DAD   RPTPS
0x4541   RPTRSSR
0x0CE5   RPTWLCMBP
0x346A   RPVOLCG
0x3A24   RSCALE
0x0000 X RST00
0x0008 X RST08
0x0010 X RST10
0x0018 X RST18
0x071D   RSTCHRCRS
0x18F3   RSTIOBF
0x0CBC   RSTPSG
0x4534   RSTSERS
0x328F   RSTSTR
0x0B01   RSTVDPRAMREG
0x274C   RUN
0x25CB   RUNCNT
0x220A   RUNFST
0x2770   RUNLIN
0x0100   RX_CHA_AVAIL
0x0165   RX_CHB_AVAIL
0x022A   RXA
0x0255   RXA_EXIT
0x45A4   RXEND
0x3250   RZINSTR
0x002E   SA
0x1AD0   SAMSG
0x1938 X SAPTR
0x4971   SAVE
0x49CE   SAVE1
0x49E3   SAVESCT
0x3679   SAVEXP
0x13E8   SAVFILE
0x1410   SAVFL1
0x14B3   SAVFL10
0x14E5 X SAVFL11
0x150A   SAVFL12
0x1497   SAVFL2
0x1408   SAVFL3
0x14C5   SAVFL4
0x1423   SAVFL6
0x1427 X SAVFL7
0x146F   SAVFL9
0x1511   SAVFLEXT
0x25BE   SAVSTP
0x2F3E   SAVSTR
0x2D68   SBSCPT
0x002C   SC
0x36D7   SCALE
0x36D9   SCALLP
0x39EF   SCALMI
0x3A05   SCALPL
0x4729   SCERR
0x4725   SCERR1
0x1ABB   SCMSG
0x3075   SCNEND
0x2D6E   SCPTLP
0x1936 X SCPTR
0x81FD   SCR_CUR_NX
0x81FE   SCR_CUR_NY
0x81FB   SCR_CURS_X
0x81FC   SCR_CURS_Y
0x81F8   SCR_MODE
0x81F9   SCR_NAM_TB
0x81FF   SCR_ORG_CHR
0x81F7   SCR_SIZE_H
0x81F6   SCR_SIZE_W
0x3DBE   SCREEN
0x0978   SCROLLNXTRW
0x0960   SCROLLUP
0x81A7   SCT_SIZ
0x3DEA   SCVDP
0x22A5   SEARCH
0x8078   SEED
0x0B39   SENDCHRPTRNS
0x0E91   SENDKEY
0x0CE2   SENDSND
0x0058   SER_BUFSIZE
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x8249   SERABITS
0x824A   SERBBITS
0x8000   SERBUF_START
0x805C   serBufUsed
0x4500   SERIAL
0x8248   SERIALS_EN
0x8058   serInPtr
0x456A   SERLED
0x805A   serRdPtr
0x4521   SERVAR
0x4648   SET_CTC
0x0B06   SET_GFX_MODE
0x0B0E   SET_GFX_MODE2
0x4637   SET_PT
0x059F   SETBEEP
0x3EBC   SETBRCL
0x07C1   SETCRSRY
0x07C2   SETCSRCOORDS
0x330F   SETIO
0x22EF   SETLIT
0x0674   SETNAMETABLE
0x0E62   SETNEWAUTO
0x4684   SETPAR
0x468F   SETPAR2
0x1788   SETPTEN
0x21C1   SETPTR
0x4894   SETREP
0x4612   SETSER
0x0D03   SETSNDREG
0x1C06   SETTOP
0x1C5B   SETTP1
0x3DD1 X SETVDP
0x0687   SETVDPADRS
0x218B   SFTPRG
0x38B8   SGN
0x2BDF   SGNEXP
0x825E   SGNRES
0x0510   SHOW_LOGO
0x36E6   SHRITE
0x36E9   SHRLP
0x36ED   SHRT1
0x1C91   SIGNON
0x390F   SIGNS
0x3C9C   SIN
0x3CCC   SIN1
0x3CE8   SINTAB
0x01CB   SIO_A_DI
0x01E3   SIO_A_EI
0x0354   SIO_A_SETS
0x01D3   SIO_B_DI
0x01EB   SIO_B_EI
0x035A X SIO_B_SETS
0x0022   SIO_CA
0x0023   SIO_CB
0x0020   SIO_DA
0x0021   SIO_DB
0x019D   SIO_RTS_OFF
0x01BB   SIO_RTS_ON
0x01D9   SIO_RXDI
0x01F1   SIO_RXEN
0x8214   SIOBFR
0x3A6B   SIXDIG
0x3009   SMPVAR
0x3C00   SMSER1
0x0002   SN
0x34D8   SND1
0x2400   SND2VID
0x0A21   SNDCHRTOBFR
0x066A   SNDCLRSET
0x0EB2   SNDKEYTOBFR
0x05CA   SNDLOGPT
0x350D   SNDOVR
0x0CC9   SNDREGCFG
0x20C2   SNERR
0x1965   SNMSG
0x190C X SNPTR
0x0030   SO
0x472E   SOERR
0x1AE9   SOMSG
0x193A X SOPTR
0x3481   SOUND
0x8210 X SPA
0x8211 X SPB
0x0020   SPC
0x3A5C   SPCFST
0x291C   SPCLP
0x0136   SPEC_RXA_CNDT
0x0168   SPEC_RXB_CNDT
0x3B42   SQR
0x2525   SRCHLIN
0x21DE   SRCHLN
0x21E1   SRCHLP
0x252B   SRCLN
0x252C   SRCLN1
0x3427   SREG
0x46C4   SRLCNT
0x4564   SRPT2
0x35DE   SRTINK
0x81B6   SRTMEM
0x8208   SRTTXT
0x359C   SSTAT
0x30D1   SSTSA
0x001E   ST
0x813D   STACK
0x38DA   STAKFP
0x2644   STALL
0x1BA3   STARTB
0x0666   STARTEMPTY
0x8244   STATUSKEY
0x2B0E   STKTHS
0x82D3   STLOOK
0x1A44   STMSG
0x2653   STOP
0x2729   STORED
0x8213   STPBT
0x304C   STPOOL
0x1928 X STPTR
0x2F2E   STR
0x2F34   STR1
0x304F   STRADD
0x81D3   STRBOT
0x4279   STRE2
0x29DF   STRENT
0x46AC   STRPAR
0x80AD   STRSPC
0x28C6   STTLIN
0x360F   SUBCDE
0x3609   SUBPHL
0x3C09   SUMLP
0x3BF1   SUMSER
0x4704   SUP_BPS
0x3AEA   SUPTLZ
0x49F5   SVEND
0x4A2A   SVERR
0x2CC7   SVNAM2
0x2F5C   SVSTAD
0x8216   SX
0x8218   SY
0x338D   SYS
0x1BB1   SYSINIT
0x33B9   SYSRET
0x3CFD   TAN
0x818F   TEMPSTACK
0x0DE1   TESTALT
0x0DEE   TESTCTRL
0x2FDB   TESTOS
0x2FBD   TESTR
0x8216   TF
0x12B3   TLFLSTX
0x1297   TLSCTTX
0x0018   TM
0x20D4   TMERR
0x1A11   TMMSG
0x820E   TMPADR
0x8206   TMPBFR1
0x8208   TMPBFR2
0x820A   TMPBFR3
0x820C   TMPBFR4
0x8208   TMPCLR
0x819D   TMPDBF
0x8214   TMPHL
0x8242   TMPKEYBFR
0x81CF   TMPSTR
0x1922 X TMPTR
0x2E4E   TMR
0x81E6   TMRCNT
0x81C3   TMSTPL
0x81C1   TMSTPT
0x3142   TOPOOL
0x30DA   TOSTRA
0x8214   TP
0x81AE   TPBF1
0x81B0   TPBF2
0x81B2   TPBF3
0x81B4   TPBF4
0x819D   TPHL
0x3AC5   TRYAGN
0x30DB   TSALP
0x4D40 X TSTBIT
0x2636   TSTBRK
0x1BF4   TSTMEM
0x2A9F   TSTNUM
0x2F84   TSTOPL
0x2C26   TSTRED
0x22F2   TSTREM
0x38A9   TSTSGN
0x2539   TSTSPC
0x2AA0   TSTSTR
0x2342   TTYLIN
0x026C   TX_EMP
0x0259   TXA
0x0269   TXA_EXIT
0x4919   TXTLDG
0x0412 X TXTMD
0x4A19   TXTRNM
0x4A2F   TXTSVG
0x8194   TYPE
0x0022   UF
0x20CE   UFERR
0x1A6E   UFMSG
0x192C X UFPTR
0x000E   UL
0x278A   ULERR
0x19BA   ULMSG
0x1918 X ULPTR
0x36FB   UNITY
0x2631   UPDATA
0x8064   USR
0x32A6   VAL
0x32C4   VAL1
0x32CE   VAL2
0x32D1   VAL3
0x44B4   VALIDX
0x44B9   VALIDY
0x824E   VAREND
0x0030   VDP_DAT
0x0032   VDP_SET
0x0B43   VDPMODESET
0x0B4B X VDPMODESET1
0x0B53 X VDPMODESET2
0x0B63 X VDPMODESETEX2
0x0B5B X VDPMODESETMC
0x820E   VIDEOBUFF
0x8236   VIDTMP1
0x8238   VIDTMP2
0x3476   VOLCH
0x3448   VOLUME
0x33C2   VPEEK
0x33EA   VPOKE
0x3575   VREG
0x3591   VSTAT
0x32F1   WAIT
0x3306   WAITLP
0x1BA0   WARM
0x1C6B   WARMST
0x3D75   WIDTH
0x0CF3   WLCBPDAT
0x0CD9   WLCMBEEP
0x1D3E   WORDS
0x1ECF   WORDTB
0x06BC   WRITE_VIDEO_LOC
0x06D1   WRITE_VREG
0x09B3   WRITEBUF
0x805E   WRKSPC
0x16C8   WRT_ERR
0x3560   WRTSND
0x0D08   WRTSNDREG
0x253F   WTSPC
0x8206   X1
0x421F   X1GR
0x820E   X2
0x820E   XC
0x8214   XI
0x4191   XY2HL
0x8208   Y1
0x4249   Y1GR
0x8210   Y2
0x8210   YC
0x8216   YI
0x0083   ZDATA
0x00C3 X ZDINT
0x00C1 X ZDIV
0x00AF   ZELSE
0x0080   ZEND
0x00C9   ZEQUAL
0x2E09   ZERARY
0x203F   ZERBYT
0x2D4C   ZEROLP
0x4CC9   ZEROSUP
0x00B9   ZFN
0x0081   ZFOR
0x008C   ZGOSUB
0x0088   ZGOTO
0x00C8   ZGTR
0x00E2   ZINSTR
0x00EA   ZLEFT
0x00CA   ZLTH
0x00BF   ZMINUS
0x00C2 X ZMOD
0x00B6   ZNEW
0x00BC   ZNOT
0x28F5   ZONELP
0x00C7   ZOR
0x00BE   ZPLUS
0x00E1   ZPOINT
0x00B0   ZPRINT
0x008E   ZREM
0x00CB   ZSGN
0x00BA   ZSPC
0x00BD   ZSTEP
0x00B7   ZTAB
0x00BB   ZTHEN
0x00C0 X ZTIMES
0x00B8   ZTO
